{"version":3,"file":"server.js","mappings":";;;;;;;;AAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC7DA,eAAe,mBAAO,CAAC,IAAgB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;;;AAGA;AACA;AACA,wCAAwC,GAAG,IAAI;AAC/C;AACA;AACA;;AAEA;AACA,qBAAqB,KAAK;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,uCAAuC,GAAG;AAC1C,YAAY,GAAG,yBAAyB;AACxC;AACA;AACA,8BAA8B;AAC9B,cAAc,GAAG;AACjB;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC,6BAA6B,eAAe;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ,6BAA6B;AAC7B,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,cAAc,KAAK,QAAQ,EAAE,IAAI,EAAE;AACnC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA,QAAQ,qBAAM,oBAAoB,qBAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,UAAU;AACV;AACA,UAAU;AACV,8EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,qBAAqB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B,eAAe;AACxE;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,IAAI;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf,aAAa,mCAAmC,OAAO;AACvD,eAAe;AACf,eAAe;AACf,gBAAgB;AAChB;;;;;;;;ACtoBA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,cAAc,mBAAO,CAAC,IAAS;;AAE/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;;;AC1blC;AACP;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACO;;;AC5BP;AACA;AACA;AACA;AACa;AAC6B;AACgD;AACnF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA,sBAAsB,YAAY,iCAAiC,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAqE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;ACpQA;AACA;AACA;AACA;AACa;AAC6B;AAC1C;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,0EAA0E;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAyE;AAC/G,SAAS;AACT;AACA,sCAAsC,2EAA2E;AACjH,0CAA0C,oEAAoE;AAC9G,SAAS;AACT;AACA,qDAAqD;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,wEAAwE;AAC9G,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,wEAAwE;AAC9F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvnBA;AACA;AACA;AACA;AACa;AAC4B;AACgB;AAClD;AACP;AACA;AACO;AACP;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,sCAAsC,gGAAgG;AACtI;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAmE;AACjH;AACA;AACA;AACA,8CAA8C,kFAAkF;AAChI;AACA;AACA;AACA,oCAAoC;AACpC,2BAA2B;AAC3B;AACA,mCAAmC,4BAA4B,IAAI,sBAAsB;AACzF;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,uCAAuC,gFAAgF,cAAc,aAAa;AAClJ;AACA;AACA;AACA,uCAAuC,wDAAwD,oBAAoB,YAAY;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,6BAA6B,KAAK;AAClC;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA,kBAAkB,MAAM,YAAY,oCAAoC,IAAI,gDAAgD;AAC5H;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAA2E;AACzF;AACO;AACP;AACA;AACO;AACP;AACA;;;ACxLA;AACA;AACA;AACA;AACa;AAC8B;AACP;AACM;AACF;AACxC;AACA;AACA;AACA;AACO,MAAM,kBAAa,GAAG,aAAqB;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACO,MAAM,gBAAW,GAAG,WAAkB;AAC7C;AACA;AACA;AACA;AACO,MAAM,UAAK,GAAG,KAAY;AACjC;AACA;AACA;AACO,MAAM,cAAS,GAAG,SAAgB;AACzC;AACA;AACA;AACO,MAAM,uBAAkB,GAAG,kBAAyB;AAC3D;AACA;AACA;AACO,MAAM,qBAAgB,GAAG,gBAAuB;AACvD;AACA;AACA;AACO,MAAM,gBAAW,GAAG,WAAkB;AAC7C;AACA;AACA;AACO,MAAM,iBAAY,GAAG,YAAmB;AAC/C;AACA;AACA;AACO,MAAM,UAAK,GAAG,KAAY;AACjC;AACA;AACA;AACA;AACA;AACO,MAAM,kBAAa,GAAG,aAAoB;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8HAA8H,qBAAqB;AACnJ,mDAAmD,qBAAqB;AACxE;AACO,SAAS,WAAM;AACtB,WAAW,MAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,qBAAqB;AACzI,mDAAmD,qBAAqB;AACxE;AACO;AACP,WAAW,WAAgB;AAC3B;AACA;AACA;AACA;AACA,mEAAmE,qBAAqB;AACxF;AACA,gFAAgF,qBAAqB;AACrG;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,mBAAmB,SAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACa;;AAEb,eAAe,mBAAO,CAAC,IAAS;AAChC,eAAe,mBAAO,CAAC,IAAU;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,mCAAmC,iBAAiB;AACpD;AACA,YAAY,QAAQ;AACpB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B,kBAAkB,UAAU;AAC5B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1JA,gBAAgB,mBAAO,CAAC,IAAc;AACtC,iBAAiB,mBAAO,CAAC,IAAe;AACxC,cAAc,mBAAO,CAAC,IAAY;AAClC,cAAc,mBAAO,CAAC,IAAY;AAClC,cAAc,mBAAO,CAAC,IAAY;;AAElC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA,qBAAqB,mBAAO,CAAC,IAAmB;AAChD,sBAAsB,mBAAO,CAAC,IAAoB;AAClD,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,IAAc;AACtC,WAAW,mBAAO,CAAC,IAAS;;AAE5B;AACA;;AAEA;;;;;;;;ACNA,oBAAoB,mBAAO,CAAC,IAAkB;AAC9C,qBAAqB,mBAAO,CAAC,IAAmB;AAChD,kBAAkB,mBAAO,CAAC,EAAgB;AAC1C,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,kBAAkB,mBAAO,CAAC,IAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA,WAAW,mBAAO,CAAC,IAAS;;AAE5B;AACA;;AAEA;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;ACXA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA,sBAAsB,mBAAO,CAAC,IAAoB;AAClD,SAAS,mBAAO,CAAC,IAAM;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,SAAS,mBAAO,CAAC,IAAM;;AAEvB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,IAAa;AACpC,YAAY,mBAAO,CAAC,IAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,GAAG;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvBA,aAAa,mBAAO,CAAC,IAAW;AAChC,gBAAgB,mBAAO,CAAC,IAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,iBAAiB,mBAAO,CAAC,IAAc;AACvC,eAAe,mBAAO,CAAC,IAAa;AACpC,eAAe,mBAAO,CAAC,IAAY;AACnC,eAAe,mBAAO,CAAC,IAAa;;AAEpC;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9CA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,eAAe,mBAAO,CAAC,IAAa;AACpC,cAAc,mBAAO,CAAC,IAAY;AAClC,eAAe,mBAAO,CAAC,IAAY;AACnC,YAAY,mBAAO,CAAC,IAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClDA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9BA,aAAa,mBAAO,CAAC,IAAW;AAChC,eAAe,mBAAO,CAAC,IAAa;AACpC,cAAc,mBAAO,CAAC,IAAW;AACjC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpCA,eAAe,mBAAO,CAAC,IAAa;AACpC,WAAW,mBAAO,CAAC,IAAQ;AAC3B,aAAa,mBAAO,CAAC,IAAW;AAChC,YAAY,mBAAO,CAAC,IAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA,cAAc,mBAAO,CAAC,IAAW;AACjC,YAAY,mBAAO,CAAC,IAAU;AAC9B,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjBA,WAAW,mBAAO,CAAC,IAAS;;AAE5B;AACA;;AAEA;;;;;;;;ACLA,gBAAgB,mBAAO,CAAC,IAAc;AACtC,iBAAiB,mBAAO,CAAC,IAAe;AACxC,oBAAoB,mBAAO,CAAC,IAAkB;AAC9C,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AChCA,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,aAAa,mBAAO,CAAC,IAAU;AAC/B,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvBA,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;;AAEA;;;;;;;;ACtEA,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,IAAI;AACJ,CAAC;;AAED;;;;;;;;ACVA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;;;;;;;;ACHA,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjBA,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,eAAe,mBAAO,CAAC,GAAa;;AAEpC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChBA,aAAa,mBAAO,CAAC,IAAW;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA;AACA,yCAAyC,EAAE;;AAE3C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,cAAc,mBAAO,CAAC,IAAW;AACjC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AClBA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA,WAAW,mBAAO,CAAC,IAAS;AAC5B,gBAAgB,mBAAO,CAAC,IAAc;AACtC,UAAU,mBAAO,CAAC,IAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA,cAAc,mBAAO,CAAC,IAAW;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;;;;;;;ACzBA,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;;AAEA;;;;;;;;ACLA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA,cAAc,mBAAO,CAAC,IAAY;AAClC,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,IAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACRA,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,iBAAiB,mBAAO,CAAC,IAAe;AACxC,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjBA,oBAAoB,mBAAO,CAAC,IAAkB;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;;;;;;;AC1BA,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;ACpEA,iBAAiB,mBAAO,CAAC,IAAc;AACvC,uBAAuB,mBAAO,CAAC,IAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC5BA,eAAe,mBAAO,CAAC,IAAY;AACnC,iBAAiB,mBAAO,CAAC,IAAc;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA,iBAAiB,mBAAO,CAAC,IAAe;AACxC,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,iBAAiB,mBAAO,CAAC,IAAe;AACxC,mBAAmB,mBAAO,CAAC,GAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,uBAAuB,mBAAO,CAAC,IAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA,eAAe,mBAAO,CAAC,IAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACxEA,cAAc,mBAAO,CAAC,IAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA,uBAAuB,mBAAO,CAAC,IAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC3BA,mBAAmB,mBAAO,CAAC,IAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,gBAAgB,mBAAO,CAAC,IAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;;;;;;;;ACjCA,sBAAsB,mBAAO,CAAC,IAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA,iBAAiB,mBAAO,CAAC,IAAe;AACxC,qBAAqB,mBAAO,CAAC,IAAmB;AAChD,eAAe,mBAAO,CAAC,IAAY;AACnC,mBAAmB,mBAAO,CAAC,GAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;AClCA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4CAA4C;AAC5C,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,OAAO,kBAAkB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,SAAS,OAAO,MAAM,GAAG,KAAK,IAAI,SAAS;AAC/E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,QAAQ;AACjB,SAAS,WAAW;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD,CAAC;;AAED;AACA;AACA;;AAEA,OAAO,uBAAuB;AAC9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,OAAO,kBAAkB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,kBAAkB;AACzB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,8BAA8B;AACrC,OAAO,iBAAiB;AACxB,OAAO,gCAAgC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,qBAAqB;;AAEhF;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,aAAa;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA,SAAS,MAAM;AACf,SAAS,aAAa;;AAEtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,aAAa;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO,uBAAuB;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,cAAc,sBAAsB;AACpC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,cAAc;AACrB,OAAO,kBAAkB;AACzB,OAAO,iBAAiB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,sCAAsC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,sBAAsB,sCAAsC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,eAAe;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,0CAA0C;AAC1C,KAAK;AACL,GAAG;AACH,WAAW,KAAK;;AAEhB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB,0BAA0B;AAC1B,QAAQ,EAAE;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,MAAM;AACf,SAAS,SAAS;;AAElB;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,EAAE,wCAAwC,UAAU;AAC9E;AACA;AACA;AACA,0BAA0B,EAAE,oDAAoD,UAAU;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE,gBAAgB;AACxE;AACA,UAAU;AACV,gCAAgC,SAAS,QAAQ,OAAO;AACxD;AACA,0CAA0C,EAAE,yBAAyB,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK,IAAI,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK,0BAA0B;AAC/B,4CAA4C,wBAAwB,+uBAA+uB,EAAE,2BAA2B,mBAAmB,yBAAyB,yCAAyC,yBAAyB,SAAS,yBAAyB,sBAAsB,yBAAyB,mCAAmC,0BAA0B,uBAAuB,2BAA2B,SAAS,2BAA2B,qBAAqB,2BAA2B,qBAAqB,2BAA2B,wCAAwC,2BAA2B,wBAAwB,2BAA2B,iCAAiC,2BAA2B,kCAAkC,2BAA2B,SAAS,2BAA2B,uBAAuB,2BAA2B,oBAAoB,2BAA2B,gCAAgC,2BAA2B,6BAA6B,2BAA2B,SAAS,2BAA2B,6BAA6B,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,0BAA0B,2BAA2B,cAAc,2BAA2B,oCAAoC,2BAA2B,6BAA6B,2BAA2B,WAAW,2BAA2B,aAAa,2BAA2B,SAAS,2BAA2B,WAAW,2BAA2B,cAAc,2BAA2B,iCAAiC,2BAA2B,6BAA6B,2BAA2B,uBAAuB,2BAA2B,6BAA6B,2BAA2B,SAAS,2BAA2B,6BAA6B,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,0BAA0B,2BAA2B,cAAc,2BAA2B,oCAAoC,2BAA2B,6BAA6B,2BAA2B,WAAW,2BAA2B,aAAa,2BAA2B,SAAS,2BAA2B,WAAW,2BAA2B,cAAc,2BAA2B,iCAAiC,2BAA2B,6BAA6B,2BAA2B,+BAA+B,2BAA2B,wBAAwB,2BAA2B,KAAK;;AAErzG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK,0BAA0B;AAC/B,uDAAuD,mCAAmC,2QAA2Q,EAAE,sDAAsD,gCAAgC,yBAAyB,iBAAiB,yBAAyB,6CAA6C,0BAA0B,iBAAiB,0BAA0B,SAAS,yBAAyB,oBAAoB,0BAA0B,SAAS,yBAAyB,uCAAuC,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,mBAAmB,2BAA2B,yBAAyB,2BAA2B,qBAAqB,2BAA2B,0BAA0B,2BAA2B,qBAAqB,2BAA2B,SAAS,2BAA2B,0BAA0B,2BAA2B,SAAS,2BAA2B,0CAA0C,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,sCAAsC,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,eAAe;;AAEzqD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA,KAAK,0BAA0B;AAC/B,4CAA4C,eAAe,0EAA0E,YAAY,i3CAAi3C,6WAA6W,EAAE,UAAU,OAAO,ohBAAohB,+EAA+E,8iBAA8iB,EAAE,wBAAwB,sBAAsB,wBAAwB,kBAAkB,yBAAyB,SAAS,yBAAyB,sCAAsC,yBAAyB,iBAAiB,yBAAyB,SAAS,yBAAyB,qBAAqB,yBAAyB,SAAS,yBAAyB,kCAAkC,yBAAyB,GAAG,YAAY,yBAAyB,SAAS,yBAAyB,0BAA0B,yBAAyB,GAAG,+BAA+B,0BAA0B,iBAAiB,2BAA2B,cAAc,2BAA2B,eAAe,2BAA2B,wCAAwC,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,qBAAqB,2BAA2B,SAAS,2BAA2B,wBAAwB,2BAA2B,SAAS,2BAA2B,+BAA+B,2BAA2B,cAAc,2BAA2B,6CAA6C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,qBAAqB,2BAA2B,SAAS,2BAA2B,6BAA6B,2BAA2B,eAAe,2BAA2B,mDAAmD,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,qBAAqB,2BAA2B,SAAS,2BAA2B,6BAA6B,2BAA2B,eAAe,2BAA2B,oCAAoC,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,2BAA2B,2BAA2B,6BAA6B,2BAA2B,2CAA2C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,cAAc,2BAA2B,eAAe,2BAA2B,2BAA2B,2BAA2B,iCAAiC,2BAA2B,2CAA2C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,mBAAmB,2BAA2B,4CAA4C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,mCAAmC,2BAA2B,2CAA2C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,cAAc,2BAA2B,eAAe,2BAA2B,2BAA2B,2BAA2B,yCAAyC,2BAA2B,wDAAwD,2BAA2B,sBAAsB,2BAA2B,2CAA2C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,gDAAgD,2BAA2B,2CAA2C,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,mBAAmB,2BAA2B,0BAA0B,2BAA2B,qBAAqB,2BAA2B,4BAA4B,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,mBAAmB,2BAA2B,wBAAwB,2BAA2B,qBAAqB,2BAA2B,yBAAyB,2BAA2B,iBAAiB,2BAA2B,2BAA2B,2BAA2B,wBAAwB,2BAA2B,0BAA0B,2BAA2B,kBAAkB,2BAA2B,SAAS,2BAA2B,qCAAqC,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,yBAAyB,2BAA2B,+BAA+B,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,yBAAyB,2BAA2B,8BAA8B,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,yBAAyB,2BAA2B,0BAA0B,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,yBAAyB,2BAA2B,yBAAyB,2BAA2B,wBAAwB,2BAA2B,oCAAoC,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,yCAAyC,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,+BAA+B,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,wBAAwB,2BAA2B,8BAA8B,2BAA2B,kCAAkC,2BAA2B,iBAAiB,2BAA2B,cAAc,2BAA2B,cAAc,2BAA2B,+BAA+B,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,uBAAuB,2BAA2B,4CAA4C,2BAA2B,iBAAiB,2BAA2B,SAAS,2BAA2B,qBAAqB,2BAA2B,SAAS,2BAA2B,uBAAuB,2BAA2B,SAAS,2BAA2B,SAAS,2BAA2B,SAAS,2BAA2B,SAAS,2BAA2B,+BAA+B,2BAA2B,oBAAoB,2BAA2B,oBAAoB,2BAA2B,mCAAmC,4BAA4B,iBAAiB,4BAA4B,SAAS,4BAA4B,oCAAoC,6BAA6B,eAAe,6BAA6B,oDAAoD,6BAA6B,iBAAiB,6BAA6B,yCAAyC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,cAAc,6BAA6B,wBAAwB,6BAA6B,0BAA0B,4BAA4B,iBAAiB,4BAA4B,SAAS,2BAA2B,gCAAgC,4BAA4B,0BAA0B,6BAA6B,6BAA6B,6BAA6B,2CAA2C,6BAA6B,iCAAiC,6BAA6B,cAAc,6BAA6B,cAAc,6BAA6B,kCAAkC,6BAA6B,mCAAmC,6BAA6B,kBAAkB,6BAA6B,SAAS,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,eAAe,6BAA6B,oCAAoC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,SAAS,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,uBAAuB,6BAA6B,qBAAqB,6BAA6B,SAAS,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,uBAAuB,6BAA6B,cAAc,6BAA6B,qBAAqB,6BAA6B,cAAc,6BAA6B,GAAG,yBAAyB,6BAA6B,qBAAqB,6BAA6B,SAAS,6BAA6B,0BAA0B,6BAA6B,SAAS,6BAA6B,0CAA0C,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,cAAc,6BAA6B,sCAAsC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,cAAc,6BAA6B,kCAAkC,6BAA6B,4BAA4B,6BAA6B,mCAAmC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,SAAS,6BAA6B,kCAAkC,6BAA6B,sCAAsC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,eAAe,6BAA6B,iCAAiC,6BAA6B,mCAAmC,6BAA6B,iBAAiB,6BAA6B,SAAS,6BAA6B,0BAA0B,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,cAAc,6BAA6B,kBAAkB,6BAA6B,qDAAqD,6BAA6B,sBAAsB,6BAA6B,8CAA8C,6BAA6B,sBAAsB,6BAA6B,8CAA8C,6BAA6B,sBAAsB,6BAA6B,2CAA2C,6BAA6B,sBAAsB,6BAA6B,0CAA0C,6BAA6B,sBAAsB,6BAA6B,gDAAgD,6BAA6B,sBAAsB,6BAA6B,qCAAqC,6BAA6B,sBAAsB,6BAA6B,kDAAkD,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,MAAM,WAAW,6BAA6B,wBAAwB,6BAA6B,SAAS,6BAA6B,yBAAyB,6BAA6B,SAAS,6BAA6B,yBAAyB,6BAA6B,SAAS,6BAA6B,yBAAyB,6BAA6B,SAAS,6BAA6B,yBAAyB,6BAA6B,SAAS,6BAA6B,8BAA8B,6BAA6B,GAAG,2CAA2C,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,wBAAwB,6BAA6B,wBAAwB,6BAA6B,wBAAwB,6BAA6B,oDAAoD,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,wBAAwB,6BAA6B,0CAA0C,6BAA6B,iCAAiC,6BAA6B,SAAS,6BAA6B,oCAAoC,6BAA6B,sCAAsC,6BAA6B,sCAAsC,6BAA6B,oCAAoC,6BAA6B,mCAAmC,6BAA6B,yCAAyC,6BAA6B,8BAA8B,6BAA6B,2CAA2C,6BAA6B,wCAAwC,6BAA6B,iDAAiD,6BAA6B,iBAAiB,6BAA6B,gDAAgD,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,SAAS,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,2BAA2B,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,eAAe,6BAA6B,8CAA8C,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,SAAS,6BAA6B,SAAS,6BAA6B,cAAc,6BAA6B,gBAAgB,6BAA6B,0BAA0B,6BAA6B,8BAA8B,6BAA6B,iBAAiB,6BAA6B,SAAS,6BAA6B,kCAAkC,6BAA6B,+CAA+C,6BAA6B,kBAAkB,6BAA6B,SAAS,6BAA6B,kCAAkC,6BAA6B,iBAAiB,6BAA6B,SAAS,6BAA6B,wBAAwB,6BAA6B,uBAAuB,6BAA6B,qBAAqB,6BAA6B,wBAAwB,6BAA6B,2BAA2B,6BAA6B,wBAAwB,6BAA6B,mCAAmC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,oBAAoB,6BAA6B,mBAAmB,6BAA6B,oBAAoB,6BAA6B,oBAAoB,6BAA6B,mBAAmB,6BAA6B,mBAAmB,6BAA6B,mBAAmB,6BAA6B,mBAAmB,6BAA6B,iCAAiC,6BAA6B,iBAAiB,6BAA6B,cAAc,6BAA6B,mBAAmB,6BAA6B,mBAAmB,6BAA6B,mBAAmB,6BAA6B,SAAS;;AAEnknB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL,sBAAsB;AACtB,qBAAqB;;AAErB;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,mBAAmB;AACnB;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,OAAO,QAAQ;;AAEf;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;AC7tMrB;;AAEb;AACA;AACA;;AAEA,OAAO,QAAQ,EAAE,mBAAO,CAAC,IAAe;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC1Ka;;AAEb;AACA,iBAAiB,mBAAO,CAAC,IAAiB;AAC1C,qBAAqB,qCAAsC;AAC3D,SAAS,kCAAmC;AAC5C;;;;;;;;;ACNa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACjIa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA,aAAa;AACb;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA,cAAc;AACd;AACA;;AAEA,qBAAqB;AACrB;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA,uCAAuC;AACvC;AACA;;AAEA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4CAA4C;AAC5C,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;ACzLA,+CAAiC;AAiBjC,MAAa,gBAAgB;IAC3B,YACU,UAAsB,EACtB,WAAkD;QADlD,eAAU,GAAV,UAAU,CAAY;QACtB,gBAAW,GAAX,WAAW,CAAuC;IACzD,CAAC;IAEJ,aAAa,CAAC,SAAiB;QAC7B,MAAM,GAAG,GAAG,gBAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACjC,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,EAAE;YAAE,OAAO,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;QAC3C,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,kBAAkB,EAAE,SAAS,CAAC,CAAC;IACpE,CAAC;IAED,QAAQ,CAAC,SAAiB;QACxB,MAAM,GAAG,GAAG,gBAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACjC,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,EAAE;YAAE,OAAO,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtC,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;IAC/D,CAAC;IAED,IAAI,CAAC,SAAiB;QACpB,MAAM,GAAG,GAAG,gBAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACjC,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,EAAE;YAAE,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAClC,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;IAC3D,CAAC;CACF;AA1BD,4CA0BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;ACnEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mCAAmC,EAAE;AACrC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9EA;AACA;AACA;AACA;AACa;AACN;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0EAA0E,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,KAAK;AACzG;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,oCAAoC;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oCAAoC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,IAAI,kBAAkB;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,eAAe;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8BAA8B;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA,IAAI,uCAAuC;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,uCAAuC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA,IAAI,+CAA+C;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,+CAA+C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F;AAC3F;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB,IAAI;AAC5D;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,wBAAwB;AACxC;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA,IAAI,0BAA0B;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AAC1C;AACP;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oDAAoD;AACrD;AACA,qBAAqB,+DAA+D;AACpF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AAC5D;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wDAAwD;AAClD;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,0DAA0D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC,YAAY,oEAAoB;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;;;;;AC7qEjB;AACA;AACA;AACA;AACqkB;AACngB;AAC8e;AAChjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU,WAAW,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;;ACxDjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,eAAe,EAAE,OAAO;AACxB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,iBAAiB,+EAA+E;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIE;;;ACtGF;AACA;AACA;AACA;AACqC;AACyD;AAC9B;AACqC;AAChE;AACrC;AACA,mBAAmB,cAAc,CAAM,2FAA2F,IAAI,cAAc,EAAE,EAAE,IAAI,KAAK;AACjK,mBAAmB,cAAc,CAAM,uDAAuD,EAAE,mJAAmJ;AACnP,cAAc,cAAc,CAAM,kDAAkD,EAAE,+CAA+C;AACrI,cAAc,cAAc,CAAM,sJAAsJ;AACxL,eAAe,cAAc,CAAM,kEAAkE,yBAAyB,6BAA6B,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI,+BAA+B,GAAG,MAAM;AAC3O,kBAAkB,cAAc,CAAM,+CAA+C,MAAM,0BAA0B,KAAK,oCAAoC,KAAK,oBAAoB;AACvL,cAAc,cAAc,CAAM,yFAAyF,EAAE,uCAAuC;AACpK,cAAc,cAAc,CAAM,2DAA2D,IAAI,GAAG,EAAE,UAAU,IAAI,gBAAgB,IAAI,GAAG,EAAE,WAAW,IAAI,yEAAyE,EAAE,iBAAiB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,2EAA2E,EAAE,iBAAiB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,2EAA2E,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,kBAAkB,IAAI,GAAG,EAAE,aAAa,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,sBAAsB,IAAI,EAAE,IAAI,cAAc,IAAI,EAAE,IAAI,yEAAyE,EAAE,YAAY;AACnkC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,+BAA+B;AAC9I;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,SAAS;AACjB,2BAA2B,IAAI;AAC/B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA,+CAA+C,WAAW;AAC1D,+CAA+C,WAAW;AAC1D,+CAA+C,WAAW;AAC1D,+CAA+C,WAAW;AAC1D,oDAAoD,WAAW;AAC/D,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,qBAAqB;AACrB,eAAe;AACf;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C,oCAAoC,CAAM,wCAAwC,EAAE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,WAAW,iBAAiB;AAC5B;AACO;AACP,WAAW,gBAAgB;AAC3B;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC,uBAAuB,UAAU;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,oDAAoD,CAAM,mCAAmC,EAAE;AAC/F,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,oDAAoD,CAAM,6BAA6B,EAAE;AACzF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,oDAAoD,CAAM;AAC1D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE,6BAA6B,CAAM;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,0BAA0B,SAAS;AACnC,oDAAoD,CAAM,wCAAwC,EAAE;AACpG,iBAAiB;AACjB;AACA;AACA,YAAY,SAAS;AACrB;AACA,iBAAiB,MAAM;AACvB;AACA,gCAAgC,0CAA0C;AAC1E,0BAA0B,SAAS;AACnC,oDAAoD,CAAM,iBAAiB,EAAE;AAC7E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,CAAM;AAC7D;AACA;AACA,4BAA4B,sDAAsD;AAClF,0BAA0B,kBAAkB;AAC5C;AACA,sBAAsB,SAAS;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM,6BAA6B,EAAE;AAClE,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,2CAA2C,EAAE;AAC5E,aAAa;AACb;AACA;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,2CAA2C,EAAE;AAC5E,aAAa;AACb;AACA;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,iCAAiC,EAAE;AAClE,aAAa;AACb;AACA;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,iCAAiC,EAAE;AAClE,aAAa;AACb;AACA;AACA;AACA,YAAY,QAAQ,sBAAsB,YAAY;AACtD;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,gDAAgD,EAAE;AACjF,aAAa;AACb;AACA,YAAY,QAAQ,sBAAsB,YAAY;AACtD;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,+CAA+C,EAAE;AAChF,aAAa;AACb;AACA,YAAY,QAAQ;AACpB,0BAA0B,cAAc;AACxC;AACA;AACA,gCAAgC,0CAA0C;AAC1E,kFAAkF,CAAM,yCAAyC,EAAE;AACnI,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,CAAM;AACjD;AACA;AACA;AACA;AACA,+CAA+C,CAAM;AACrD;AACA;AACA,+CAA+C,CAAM;AACrD;AACA;AACA;AACA;AACA,4CAA4C,0CAA0C;AACtF,8FAA8F,CAAM,wBAAwB,EAAE;AAC9H,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAA0C;AAC9E,iCAAiC,CAAM,0DAA0D,GAAG;AACpG,qBAAqB;AACrB;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA,gCAAgC,0CAA0C;AAC1E,oDAAoD,CAAM;AAC1D,iBAAiB;AACjB;AACA,gBAAgB,QAAQ;AACxB;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM,uEAAuE,GAAG;AAC7G,iBAAiB;AACjB;AACA,gBAAgB,QAAQ;AACxB;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM,wEAAwE,GAAG;AAC9G,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF,qCAAqC,CAAM;AAC3C,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,qCAAqC,GAAG;AACvE,aAAa;AACb;AACA,YAAY,QAAQ;AACpB;AACA,4BAA4B,0CAA0C;AACtE,yBAAyB,CAAM,sCAAsC,GAAG;AACxE,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,wCAAwC,mBAAmB;AAC3D,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAiD,IAAI;AACtG;AACA;AACA,iCAAiC,CAAM,qBAAqB,EAAE;AAC9D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,4CAA4C,0EAA0E;AACtH,gEAAgE,CAAM,YAAY,GAAG;AACrF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA,wDAAwD,0EAA0E;AAClI,4EAA4E,CAAM,YAAY,GAAG;AACjG,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0EAA0E;AAClH,4DAA4D,CAAM,YAAY,GAAG;AACjF,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0EAA0E;AACtH,gEAAgE,CAAM,YAAY,GAAG;AACrF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM,4CAA4C,EAAE;AACjF,iBAAiB;AACjB;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,gCAAgC,0CAA0C;AAC1E,6BAA6B,CAAM,2DAA2D,EAAE;AAChG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF,qCAAqC,CAAM,8BAA8B,GAAG,sBAAsB,EAAE;AACpG,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,kBAAkB;AAC/F;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAM,yCAAyC,SAAS;AAC/E;AACA;AACA,uBAAuB,CAAM,yCAAyC,SAAS;AAC/E;AACA;AACA,uBAAuB,CAAM,+BAA+B,SAAS;AACrE;AACA;AACA,uBAAuB,CAAM,gCAAgC,SAAS;AACtE;AACA;AACA,uBAAuB,CAAM,+BAA+B,SAAS;AACrE;AACA;AACA,uBAAuB,CAAM,uEAAuE,SAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,CAAM,oBAAoB,SAAS;AAC9D;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,sCAAsC,CAAM,oBAAoB,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAM,oBAAoB,SAAS;AAC1D;AACA;AACA;AACA,uBAAuB,CAAM,oBAAoB,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAM,uCAAuC,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAM,wCAAwC,SAAS;AAC9E;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,CAAM,0BAA0B,SAAS,+EAA+E,kBAAkB;AACxK,oBAAoB,QAAQ;AAC5B,kCAAkC,CAAM,0BAA0B,SAAS,+EAA+E,kBAAkB;AAC5K;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mBAAmB,CAAM,oBAAoB,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAM,oBAAoB,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,2BAA2B,CAAM,uBAAuB,SAAS;AACjE;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,sCAAsC,CAAM,oBAAoB,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA,uBAAuB,CAAM,oBAAoB,SAAS;AAC1D;AACA;AACA;AACA,uBAAuB,CAAM,uBAAuB,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAM,qCAAqC,SAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,kCAAkC,CAAM,4BAA4B,SAAS;AAC7E;AACA;AACA;AACA;AACA,8BAA8B,CAAM,4BAA4B,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,CAAM,+CAA+C,SAAS;AACjF;AACA;AACA,mBAAmB,CAAM,2BAA2B,SAAS;AAC7D;AACA;AACA;AACA;;;AC3tCA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2BAA2B;AAC3B,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AAC+C;AACV;AACW;AACY;AACf;AAC4E;AACpF;AACrC,sCAAsC;AACtC;AACO;AACP,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC;AACA,gDAAgD,uCAAuC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA,0EAA0E,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAkB;AACnD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA,0CAA0C,gBAAgB;AAC1D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ,2BAA2B,eAAe;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ,2BAA2B,eAAe;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qCAAqC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,kCAAkC,gBAAgB;AAClD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iCAAiC,QAAe;AAChD;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,YAAmB;AAChG;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAkB;AACvD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,gDAAgD,aAAa,CAAM;AACnE;AACA;AACA,wCAAwC,CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA,aAAa;AACb;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gEAAgE;AAChE,kCAAkC,gBAAgB;AAClD,wBAAwB,CAAM;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,wBAAwB,CAAM;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,KAAK;AAC/D;AACA;AACA;AACA,kCAAkC,QAAQ,KAAK;AAC/C;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,wBAAwB;AACxB,qBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA,gFAAgF;AAChF,6EAA6E;AAC7E,2BAA2B,uBAAuB;AAClD;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,kCAAkC,kBAAkB;AACpD,kCAAkC,kBAAkB;AACpD,oCAAoC,kBAAkB;AACtD,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,sGAAsG,UAAU;AAChH;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;;AC57BA;AACA;AACA;AACA;AAC+C;AACF;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAkB;AAC3C,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B,MAAM,6BAA6B;AACrG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5GA;AACA;AACA;AACA;AACwF;AACnD;AACQ;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kBAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI,kBAAkB;AACrJ;AACA,kIAAkI,kBAAkB;AACpJ,yHAAyH,kBAAkB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C,uCAAuC,UAAU;AACjD;AACA;AACA,0CAA0C,KAAK;AAC/C,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,CAAM;AACtC;AACA,+BAA+B,UAAU,qCAAqC,SAAS;AACvF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2EAA2E,aAAa;AACxF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY,SAAS,2CAA2C;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AAC+C;AACH;AACG;AACV;AACwC;AACtE;AACP;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,QAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD,8CAA8C,yCAAyC,UAAU,+BAA+B;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA,0CAA0C,8HAA8H;AACxK,2CAA2C,oDAAoD;AAC/F;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,QAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yCAAyC,UAAU,kCAAkC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,2CAA2C,mCAAmC;AAC9E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY,CAAC,YAAmB;AAC1E;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB,EAAE,wBAAwB,EAAE,uBAAuB;AACjG;AACA;AACA,wBAAwB,sBAAsB,EAAE,wBAAwB,EAAE,uBAAuB,EAAE,6CAA6C;AAChJ;AACA,sBAAsB,wBAAwB,QAAQ,wCAAwC;AAC9F;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA,WAAW,YAAmB,UAAU,CAAM;AAC9C;;;AC9QA;AACA;AACA;AACA;AACqC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,4CAA4C;AACtE,0BAA0B;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,+BAA+B,4CAA4C;AAC3E,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA,iBAAiB;AACjB,qCAAqC,aAAa;AAClD;AACA;AACA,0BAA0B,aAAa;AACvC,0BAA0B;AAC1B;AACA;AACA,iBAAiB;AACjB,8BAA8B,4CAA4C;AAC1E,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA,iBAAiB;AACjB,8BAA8B,aAAa;AAC3C,mCAAmC,4CAA4C;AAC/E,mCAAmC,oDAAoD;AACvF,8BAA8B,qCAAqC;AACnE,0CAA0C,aAAa;AACvD;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA,iBAAiB;AACjB;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA,iBAAiB;AACjB;AACA;AACA,8CAA8C,aAAa;AAC3D,uCAAuC,mBAAmB;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,8BAA8B;AAC9B;AACA;AACA,iBAAiB;AACjB,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,qCAAqC;AAC/D;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kBAAkB;AAC9C,sCAAsC,kBAAkB;AACxD,qCAAqC,kBAAkB;AACvD,wBAAwB,aAAa;AACrC,0BAA0B,aAAa;AACvC,0BAA0B,aAAa;AACvC,2BAA2B,qCAAqC;AAChE,2BAA2B,qCAAqC;AAChE,2BAA2B,qCAAqC;AAChE,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAM;AACd,aAAa,CAAM;AACnB,WAAW,CAAM;AACjB,iBAAiB,CAAM;AACvB,aAAa,CAAM;AACnB,gBAAgB,CAAM;AACtB,aAAa,CAAM;AACnB,sBAAsB,CAAM;AAC5B,aAAa,CAAM;AACnB,sBAAsB,CAAM;AAC5B,eAAe,CAAM;AACrB,eAAe,CAAM;AACrB,aAAa,CAAM;AACnB,qBAAqB,CAAM;AAC3B,WAAW,CAAM;AACjB,cAAc,CAAM;AACpB,cAAc,CAAM;AACpB,iBAAiB,CAAM;AACvB,mBAAmB,CAAM;AACzB,mBAAmB,CAAM;AACzB,cAAc,CAAM;AACpB,0BAA0B,CAAM;AAChC,iBAAiB,CAAM;AACvB,gBAAgB,CAAM;AACtB,uBAAuB,CAAM;AAC7B,kBAAkB,CAAM;AACxB,UAAU,CAAM;AAChB,UAAU,CAAM;AAChB,YAAY,CAAM;AAClB,WAAW,CAAM;AACjB,WAAW,CAAM;AACjB,WAAW,CAAM;AACjB,SAAS,CAAM;AACf,SAAS,CAAM;AACf,UAAU,CAAM;AAChB,cAAc,CAAM;AACpB,cAAc,CAAM;AACpB,cAAc,CAAM;AACpB,cAAc,CAAM;AACpB,mBAAmB,CAAM;AACzB,WAAW,CAAM;AACjB,sBAAsB,CAAM;AAC5B,qBAAqB,CAAM;AAC3B,QAAQ,CAAM;AACd,UAAU,CAAM;AAChB,UAAU,CAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvgBA,QAAQ,MAAM,aAAa,OAAO,QAAQ,cAAc,gGAAgG,gBAAgB,gCAAgC,YAAY,KAAK,gCAAgC,KAAK,gBAAgB,KAAK,WAAW,mBAAmB,wBAAwB,kGAAkG,yBAAyB,mBAAmB,yEAAyE,UAAU,oCAAoC,iBAAiB,SAAS,oCAAoC,+DAA+D,QAAQ,6BAA6B,SAAS,OAAO,mBAAmB,yCAAyC,UAAU,KAAK,MAAM,8GAA8G,yDAAyD,uBAAuB,+BAA+B,2DAA2D,4EAA4E,wBAAwB,6CAA6C,iBAAiB,kCAAkC,cAAc,mBAAmB,KAAK,mBAAmB,2CAA2C,qCAAqC,wBAAwB,4BAA4B,gDAAgD,YAAY,iCAAiC,KAAK,6BAA6B,iCAAiC,KAAK,wCAAwC,KAAK,KAAK,UAAU,QAAQ,gDAAgD,6BAA6B,oDAAoD,MAAM,wBAAwB,+BAA+B,cAAc,SAAS,YAAY,KAAK,iEAAiE,6EAA6E,uBAAuB,SAAS,qBAAqB,+BAA+B,0DAA0D,KAAK,iCAAiC,OAAO,IAAI,OAAO,UAAU,kDAAkD,wBAAwB,yFAAyF,KAAK,oBAAoB,+CAA+C,uCAAuC,sBAAsB,iBAAiB,KAAK,KAAK,sBAAsB,WAAW,OAAO,MAAM,OAAO,+EAA+E,mDAAmD,iBAAiB,KAAK,6BAA6B,OAAO,MAAM,OAAO,yBAAyB,6BAA6B,qBAAqB,KAAK,4CAA4C,KAAK,KAAK,sBAAsB,6EAA6E,YAAY,MAAM,OAAO,qEAAqE,oBAAoB,iIAAiI,qBAAqB,uDAAuD,kCAAkC,MAAM,mBAAmB,KAAK,OAAO,uCAAuC,yBAAyB,iCAAiC,uBAAuB,4CAA4C,KAAK,mGAAmG,YAAY,MAAM,MAAM,4QAA4Q,8CAA8C,uBAAuB,MAAM,cAAc,WAAW,+BAA+B,YAAY,YAAY,qCAAqC,YAAY,+DAA+D,uBAAuB,EAAE,8DAA8D,4FAA4F,eAAe,wCAAwC,SAAS,GAAG,SAAS,MAAM,MAAM,iBAAiB,sBAAsB,wDAAwD,oCAAoC,0BAA0B,0BAA0B,2CAA2C,gBAAgB,iEAAiE,0BAA0B,YAAY,YAAY,OAAO,aAAa,QAAQ,gBAAgB,WAAW,EAAE,GAAG,kGAAkG,0BAA0B,+KAA+K,oKAAoK,kFAAkF,QAAQ,gBAAgB,yPAAyP,OAAO,UAAU,KAAK,MAAM,SAAS,4BAA4B,4KAA4K,qBAAqB,kDAAkD,UAAU,0DAA0D,SAAS,iEAAiE,aAAa,kBAAkB,QAAQ,kBAAkB,IAAI,+CAA+C,GAAG,kUAAkU,qBAAqB,kBAAkB,uFAAuF,eAAe,QAAQ,iDAAiD,uBAAuB,uEAAuE,6BAA6B,eAAe,8DAA8D,iBAAiB,eAAe,iBAAiB,SAAS,YAAY,iBAAiB,MAAM,4BAA4B,iBAAiB,qEAAqE,UAAU,mBAAmB,kBAAkB,gBAAgB,aAAa,aAAa,4DAA4D,eAAe,oFAAoF,SAAS,SAAS,QAAQ,iSAAiS,SAAS,4KAA4K,kBAAkB,WAAW,YAAY,WAAW,KAAK,wBAAwB,8MAA8M,KAAK,8BAA8B,aAAa,wFAAwF,qEAAqE,cAAc,MAAM,YAAY,WAAW,KAAK,wBAAwB,6EAA6E,sBAAsB,gBAAgB,MAAM,8DAA8D,YAAY,EAAE,OAAO,oQAAoQ,gBAAgB,cAAc,UAAU,+CAA+C,GAAG,oDAAoD,qBAAqB,WAAW,sBAAsB,8HAA8H,uGAAuG,MAAM,4DAA4D,wBAAwB,qBAAqB,0BAA0B,GAAG,YAAY,GAAG,2CAA2C,wBAAwB,oBAAoB,0BAA0B,GAAG,YAAY,GAAG,cAAc,iEAAiE,cAAc,IAAI,6BAA6B,MAAM,kDAAkD,sCAAsC,cAAc,2CAA2C,aAAa,yBAAyB,MAAM,aAAa,4BAA4B,eAAe,yBAAyB,EAAE,gCAAgC,kBAAkB,uBAAuB,wBAAwB,6DAA6D,OAAO,EAAE,uBAAuB,0CAA0C,wBAAwB,0DAA0D,OAAO,EAAE,wBAAwB,0BAA0B,uBAAuB,0BAA0B,SAAS,GAAG,UAAU,IAAW,MAAM,GAAG,gBAAO;AAC98U;;ACDA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF,6GAA6G,IAAI;AACjH;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3HA;AACA;AACA;AACA;AACqC;AACJ;AACW;AACG;AACV;AACO;AACU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,0BAA0B,gCAAgC;AACrG;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAG;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,CAAM,gCAAgC,EAAE;AACzE,+DAA+D;AAC/D;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,qCAAqC,CAAM,gCAAgC,EAAE;AAC7E,8CAA8C;AAC9C;AACA;AACA;AACA,4BAA4B,CAAM,kCAAkC,EAAE;AACtE;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA,4BAA4B,CAAM,kCAAkC,EAAE,2BAA2B,EAAE;AACnG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAgB;AAChC;AACA;AACA,0CAA0C,GAAG,CAAM,gCAAgC,EAAE,KAAK,EAAE;AAC5F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG,CAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,CAAM,UAAU,EAAE,SAAS,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,CAAM,gCAAgC,EAAE,KAAK,EAAE;AACtF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA,2CAA2C,CAAM,mCAAmC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC,CAAM,yCAAyC,EAAE;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,2BAAS;AAC5F;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,2BAAS;AACb;AACA;AACA;AACA,eAAe,OAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAG,wBAAwB,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7lBA;AACA;AACA;AACA;AAC6C;AACqB;AAC3D;AACP;AACA;AACA;AACA;AACA,oBAAoB,sBAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA,mCAAmC,0BAA0B,gBAAgB,UAAU;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wCAAwC,sCAAsC,gBAAgB;AAC9F;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvHA;AACA;AACA;AACA;AAC6D;AAChB;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD,sBAAsB,cAAc;AACpC;AACA;AACA,sBAAsB,cAAc,QAAQ,KAAK;AACjD;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,oBAAoB,sBAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5DoD;AACG;AAChD,SAAS,aAAM;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAU;AACrB,eAAe,QAAQ,SAAS,KAAK;AACrC,KAAK;AACL;;;ACnBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3EA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACuB;AACkC;AAC7C;AACuB;AAClD;AACP;AACA;AACA;AACA;AACA,gCAAgC,qBAAY,4BAA4B,aAAM;AAC9E,kCAAkC,qBAAY;AAC9C;AACA;AACA,kBAAkB,aAAM;AACxB,2CAA2C,qBAAY;AACvD,YAAY,QAAQ,SAAS,KAAK,QAAQ,QAAQ;AAClD;AACA;AACA;AACA,oBAAoB,sBAAa;AACjC;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE,+DAA+D,KAAK,QAAQ,QAAQ,eAAe,QAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS;AAChG;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,gFAAgF,SAAS;AACzF;AACA;AACA;AACA;AACA;AACA,qFAAqF,SAAS;AAC9F,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,uBAAuB,IAAI;AACpF;AACA,+DAA+D,IAAI;AACnE,qFAAqF,SAAS;AAC9F,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F,wFAAwF,SAAS;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA,uFAAuF,SAAS;AAChG,oFAAoF,SAAS,wOAAwO,SAAS;AAC9U;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA,0BAA0B,KAAK,QAAQ,QAAQ,8CAA8C,QAAQ;AACrG;AACA,0CAA0C,qBAAY;AACtD;AACA;AACA;AACA;AACA,2BAA2B,KAAK,QAAQ,QAAQ,oDAAoD,QAAQ;AAC5G;AACA;AACA,gBAAgB,qBAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK,QAAQ,QAAQ,6CAA6C,QAAQ;AACrG;AACA;AACA,gBAAgB,qBAAY;AAC5B;AACA;AACA;AACA,uBAAuB,KAAK,QAAQ,QAAQ,iCAAiC,QAAQ;AACrF;AACA;AACA,YAAY,qBAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/WA;AACA;AACA;AACA;AAC6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,GAAG,mBAAmB,GAAG,wBAAwB;AAC7F;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAQ;AACrD;AACA,SAAS,kBAAQ;AACjB;AACA;;;ACvEA;AACA;AACA;AACA;AAC2D;AACV;AACU;AACU;AACK;AACX;AACE;AACP;AACU;AAChC;AACI;AACS;AACb;AAC7B;AACP;AACA,kCAAkC,iBAAiB;AACnD,6CAA6C,mBAAmB;AAChE,+BAA+B,cAAc;AAC7C,0BAA0B,SAAS;AACnC,oCAAoC,mBAAmB;AACvD,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,KAAS,aAAa,uBAAuB;AACtF,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B;AACA,iBAAiB;AACjB,8CAA8C,aAAM;AACpD,qCAAqC,IAAI;AACzC;AACA;;;;;;;;;ACnDA;AACA;AACA;AACA;AACa;;AAEb,0CAA8C;;;;;;;;ACNjC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,4BAA4B,GAAG,4BAA4B;AAC7F,cAAc,mBAAO,CAAC,GAAO;AAC7B;AACA;AACA,cAAc,mBAAO,CAAC,IAAe;AACrC,aAAa,mBAAO,CAAC,IAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,+BAA+B;;;;;;;;;AC3ElB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,IAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,SAAS;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0HAA0H,gBAAgB;AAC1I;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;;AC3JF;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,+BAA+B,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,iCAAiC,GAAG,yBAAyB,GAAG,+BAA+B,GAAG,eAAe,GAAG,aAAa,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,aAAa,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,eAAe,GAAG,WAAW;AACzwC,uBAAuB,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,oCAAoC,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa;AACjT,mBAAmB,mBAAO,CAAC,IAAY;AACvC,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,gDAA+C,EAAE,qCAAqC,mCAAmC,EAAC;AAC1H,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,oDAAmD,EAAE,qCAAqC,uCAAuC,EAAC;AAClI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,uDAAsD,EAAE,qCAAqC,0CAA0C,EAAC;AACxI,oBAAoB,mBAAO,CAAC,IAAa;AACzC,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,4CAA2C,EAAE,qCAAqC,gCAAgC,EAAC;AACnH,yCAAwC,EAAE,qCAAqC,6BAA6B,EAAC;AAC7G,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,iBAAiB,mBAAO,CAAC,IAAU;AACnC,yCAAwC,EAAE,qCAAqC,0BAA0B,EAAC;AAC1G,2CAA0C,EAAE,qCAAqC,4BAA4B,EAAC;AAC9G,uBAAuB,mBAAO,CAAC,IAAgB;AAC/C,2DAA0D,EAAE,qCAAqC,kDAAkD,EAAC;AACpJ,qDAAoD,EAAE,qCAAqC,4CAA4C,EAAC;AACxI,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,6DAA4D,EAAE,qCAAqC,+DAA+D,EAAC;AACnK,+DAA8D,EAAE,qCAAqC,iEAAiE,EAAC;AACvK,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,+DAA8D,EAAE,qCAAqC,uDAAuD,EAAC;AAC7J,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,gEAA+D,EAAE,qCAAqC,wDAAwD,EAAC;AAC/J,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,yDAAwD,EAAE,qCAAqC,iDAAiD,EAAC;AACjJ,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,sDAAqD,EAAE,qCAAqC,2CAA2C,EAAC;AACxI,qDAAoD,EAAE,qCAAqC,0CAA0C,EAAC;AACtI,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,2DAA0D,EAAE,qCAAqC,gDAAgD,EAAC;AAClJ,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,gDAA+C,EAAE,qCAAqC,qCAAqC,EAAC;AAC5H,yCAAwC,EAAE,qCAAqC,8BAA8B,EAAC;AAC9G,+CAA8C,EAAE,qCAAqC,oCAAoC,EAAC;AAC1H,+CAA8C,EAAE,qCAAqC,oCAAoC,EAAC;AAC1H,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,oDAAmD,EAAE,qCAAqC,yCAAyC,EAAC;AACpI,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,gEAA+D,EAAE,qCAAqC,qDAAqD,EAAC;AAC5J,8DAA6D,EAAE,qCAAqC,mDAAmD,EAAC;AACxJ,wDAAuD,EAAE,qCAAqC,6CAA6C,EAAC;AAC5I,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,cAAc,mBAAO,CAAC,IAAO;AAC7B,WAAW;;;;;;;;;AChFE;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB;AAC3D,cAAc,mBAAO,CAAC,IAAO;AAC7B,WAAW,mBAAO,CAAC,IAAM;AACzB,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA,aAAa,YAAY;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;AC/FlB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,oCAAoC,GAAG,2CAA2C,GAAG,sCAAsC,GAAG,0BAA0B,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,qBAAqB;AACviB,cAAc,mBAAO,CAAC,IAAO;AAC7B,WAAW,mBAAO,CAAC,IAAM;AACzB,mBAAmB,mBAAO,CAAC,IAAY;AACvC,oBAAoB,mBAAO,CAAC,IAAa;AACzC,iBAAiB,mBAAO,CAAC,IAAU;AACnC,uBAAuB,mBAAO,CAAC,IAAgB;AAC/C;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF,2CAA2C,KAAK;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0EAA0E,oCAAoC,KAAK;AACpH;AACA;AACA;AACA;AACA,oEAAoE,IAAI;AACxE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,UAAU,qBAAqB;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,uBAAuB,cAAc;AAChL;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,uBAAuB,uBAAuB,cAAc;AACxK;AACA;AACA,4GAA4G,uBAAuB;AACnI;AACA;AACA;AACA;AACA,8GAA8G,sBAAsB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,oDAAoD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB,yBAAyB,cAAc;AACxH;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB,UAAU,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA,iEAAiE,gBAAgB,UAAU,qBAAqB,sBAAsB,eAAe;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe,yBAAyB,cAAc;AAChH;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iCAAiC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,2CAA2C,gBAAgB,KAAK,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,KAAK,WAAW,8BAA8B,uBAAuB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,4CAA4C,gBAAgB,KAAK,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,uBAAuB,GAAG,mBAAmB;AAC/G,iDAAiD,wBAAwB,KAAK,WAAW,QAAQ,wCAAwC,KAAK,MAAM;AACpJ;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,GAAG;AAC3G;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,+BAA+B;AAC9G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;;;;;;;;;AC3rClB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;;;;;;;;;ACfjD;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,aAAa;AAC/B,cAAc,mBAAO,CAAC,IAAO;AAC7B;AACA;AACA,0BAA0B;AAC1B,+BAA+B;AAC/B,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;AC/Ha;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACtH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;;;;;;;;;AClCN;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,iBAAiB,GAAG,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;AC7YH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;ACvJhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB;AAC3F,cAAc,mBAAO,CAAC,IAAO;AAC7B,WAAW,mBAAO,CAAC,IAAM;AACzB,iBAAiB,mBAAO,CAAC,IAAU;AACnC,oBAAoB,mBAAO,CAAC,GAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;;;;;;;;;AC/LtB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB;AAC5F,cAAc,mBAAO,CAAC,IAAO;AAC7B,WAAW,mBAAO,CAAC,IAAM;AACzB,oBAAoB,mBAAO,CAAC,GAAa;AACzC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;AClHvB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,gCAAgC,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,kBAAkB;AAC5qB,WAAW,mBAAO,CAAC,IAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,eAAe,KAAK;;;;;;;;;ACjTxC;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;;ACtBF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,cAAc,mBAAO,CAAC,IAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;ACnEJ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,iCAAiC;AACvE,uBAAuB,mBAAO,CAAC,IAAgB;AAC/C;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;;AC3EnC;AACA;AACA;AACA;AACa;;AAEb,0CAA8C;;;;;;;;ACNjC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,kBAAkB,mBAAO,CAAC,IAAwB;AAClD,aAAa,mBAAO,CAAC,IAAwB;AAC7C,aAAa,mBAAO,CAAC,IAAe;AACpC;AACA;AACA;AACA,gCAAgC;;;;;;;;;AC3BnB;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,gCAAgC;AACxD,aAAa,mBAAO,CAAC,IAAgB;AACrC,aAAa,mBAAO,CAAC,IAA6B;AAClD,aAAa,mBAAO,CAAC,IAAY;AACjC,aAAa,mBAAO,CAAC,IAAY;AACjC,mBAAmB,mBAAO,CAAC,GAAc;AACzC,4DAA2D,EAAE,qCAAqC,iDAAiD,EAAC;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;;;;;;;;;AC5E1D;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,yBAAyB,mBAAO,CAAC,IAAgB;AACjD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gCAAgC;;;;;;;;;ACdnB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,4BAA4B,GAAG,wBAAwB,GAAG,wBAAwB;AACvL,yBAAyB,mBAAO,CAAC,IAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,gCAAgC;;;;;;;;;AC3CnB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yCAAyC,GAAG,yCAAyC,GAAG,mCAAmC;AAC3H,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE,mCAAmC,KAAK;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oFAAoF,yCAAyC,KAAK;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oFAAoF,yCAAyC,KAAK;;;;;;;;;ACzCtH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,4BAA4B;AAC/D,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,yBAAyB,2BAA2B;AACpD,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA,yBAAyB,+BAA+B;AACxD,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;;;;;;;;;AC/B3F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;;;;;;;;;ACvB/E;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;;;;;;;;;ACtBzE;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,kCAAkC,GAAG,iCAAiC,GAAG,oCAAoC,GAAG,wCAAwC;AAC3L,yBAAyB,mBAAO,CAAC,IAAgB;AACjD,WAAW,mBAAO,CAAC,IAAY;AAC/B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF,wCAAwC,KAAK;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E,oCAAoC,KAAK;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;;;;;;;;;ACzE3F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,kCAAkC,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,gCAAgC;AAClP,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;;;;;;;;;ACpGrF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,yBAAyB,yBAAyB;AAClD,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;;;;;;;;;ACnB5E;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;;;;;;;;;ACrBlF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,+BAA+B,GAAG,wBAAwB;AAC5F,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,SAAS,uBAAuB;AAChC,IAAI,6BAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA,uCAAuC,gBAAgB;AACvD,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;;;;;;;;;AC1CxF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,0BAA0B;AAC9D,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,SAAS,wBAAwB;AACjC,IAAI,iCAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;;;;;;;;;AC7B9F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,gCAAgC,GAAG,yBAAyB,GAAG,6BAA6B,GAAG,gCAAgC,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,4BAA4B,GAAG,gCAAgC,GAAG,oBAAoB,GAAG,gCAAgC,GAAG,yBAAyB,GAAG,6BAA6B,GAAG,sCAAsC,GAAG,iBAAiB,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,yCAAyC,GAAG,4CAA4C,GAAG,wCAAwC,GAAG,8BAA8B,GAAG,uCAAuC,GAAG,wCAAwC,GAAG,yCAAyC,GAAG,sCAAsC,GAAG,uCAAuC,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,0BAA0B,GAAG,+BAA+B,GAAG,mBAAmB,GAAG,0CAA0C,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,+BAA+B,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,+BAA+B,GAAG,uCAAuC,GAAG,iCAAiC,GAAG,4BAA4B,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,sCAAsC,GAAG,8BAA8B,GAAG,0BAA0B;AACjoD,oCAAoC,GAAG,mCAAmC,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,kCAAkC,GAAG,gCAAgC,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,sCAAsC,GAAG,oCAAoC,GAAG,kCAAkC,GAAG,kCAAkC,GAAG,6BAA6B,GAAG,mBAAmB,GAAG,mCAAmC,GAAG,yCAAyC,GAAG,yCAAyC,GAAG,0CAA0C,GAAG,qCAAqC,GAAG,wBAAwB,GAAG,6BAA6B,GAAG,0BAA0B,GAAG,2BAA2B,GAAG,gCAAgC,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,6CAA6C,GAAG,+BAA+B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,iCAAiC,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,qBAAqB,GAAG,qCAAqC,GAAG,uCAAuC,GAAG,sCAAsC,GAAG,iCAAiC,GAAG,kCAAkC,GAAG,2BAA2B,GAAG,8BAA8B,GAAG,8BAA8B,GAAG,uBAAuB,GAAG,qCAAqC;AACvrD,4CAA4C,GAAG,2CAA2C,GAAG,6CAA6C,GAAG,+BAA+B,GAAG,2CAA2C,GAAG,4CAA4C,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,gCAAgC,GAAG,kCAAkC,GAAG,iCAAiC,GAAG,oCAAoC,GAAG,wCAAwC,GAAG,+BAA+B,GAAG,+BAA+B,GAAG,wBAAwB,GAAG,iCAAiC,GAAG,0BAA0B,GAAG,sCAAsC;AACxvB,mBAAmB,mBAAO,CAAC,IAAY;AACvC,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,WAAW,mBAAO,CAAC,IAAY;AAC/B,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,yDAAwD,EAAE,qCAAqC,2DAA2D,EAAC;AAC3J,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,yDAAwD,EAAE,qCAAqC,2DAA2D,EAAC;AAC3J,mCAAmC,mBAAO,CAAC,IAA4B;AACvE,2DAA0D,EAAE,qCAAqC,8DAA8D,EAAC;AAChK,yEAAwE,EAAE,qCAAqC,4EAA4E,EAAC;AAC5L,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,wDAAuD,EAAE,qCAAqC,yDAAyD,EAAC;AACxJ,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,wDAAuD,EAAE,qCAAqC,yDAAyD,EAAC;AACxJ,4DAA2D,EAAE,qCAAqC,6DAA6D,EAAC;AAChK,gCAAgC,mBAAO,CAAC,IAAyB;AACjE,uDAAsD,EAAE,qCAAqC,uDAAuD,EAAC;AACrJ,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,sDAAqD,EAAE,qCAAqC,qDAAqD,EAAC;AAClJ,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,yDAAwD,EAAE,qCAAqC,2DAA2D,EAAC;AAC3J,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,oDAAmD,EAAE,qCAAqC,gDAAgD,EAAC;AAC3I,iEAAgE,EAAE,qCAAqC,6DAA6D,EAAC;AACrK,sEAAqE,EAAE,qCAAqC,kEAAkE,EAAC;AAC/K,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,qEAAoE,EAAE,qCAAqC,sEAAsE,EAAC;AAClL,qEAAoE,EAAE,qCAAqC,sEAAsE,EAAC;AAClL,+DAA8D,EAAE,qCAAqC,gEAAgE,EAAC;AACtK,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,+CAA8C,EAAE,qCAAqC,iDAAiD,EAAC;AACvI,yDAAwD,EAAE,qCAAqC,2DAA2D,EAAC;AAC3J,8DAA6D,EAAE,qCAAqC,gEAAgE,EAAC;AACrK,8DAA6D,EAAE,qCAAqC,gEAAgE,EAAC;AACrK,gEAA+D,EAAE,qCAAqC,kEAAkE,EAAC;AACzK,kEAAiE,EAAE,qCAAqC,oEAAoE,EAAC;AAC7K,gCAAgC,mBAAO,CAAC,IAAyB;AACjE,uDAAsD,EAAE,qCAAqC,uDAAuD,EAAC;AACrJ,sCAAsC,mBAAO,CAAC,IAA+B;AAC7E,6DAA4D,EAAE,qCAAqC,mEAAmE,EAAC;AACvK,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,4DAA2D,EAAE,qCAAqC,8DAA8D,EAAC;AACjK,8DAA6D,EAAE,qCAAqC,gEAAgE,EAAC;AACrK,0DAAyD,EAAE,qCAAqC,4DAA4D,EAAC;AAC7J,8DAA6D,EAAE,qCAAqC,gEAAgE,EAAC;AACrK,0DAAyD,EAAE,qCAAqC,4DAA4D,EAAC;AAC7J,8DAA6D,EAAE,qCAAqC,gEAAgE,EAAC;AACrK,0DAAyD,EAAE,qCAAqC,4DAA4D,EAAC;AAC7J,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,mDAAkD,EAAE,qCAAqC,8CAA8C,EAAC;AACxI,+CAA8C,EAAE,qCAAqC,0CAA0C,EAAC;AAChI,kDAAiD,EAAE,qCAAqC,6CAA6C,EAAC;AACtI,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,+DAA8D,EAAE,qCAAqC,gEAAgE,EAAC;AACtK,gEAA+D,EAAE,qCAAqC,iEAAiE,EAAC;AACxK,kEAAiE,EAAE,qCAAqC,mEAAmE,EAAC;AAC5K,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,sDAAqD,EAAE,qCAAqC,qDAAqD,EAAC;AAClJ,6DAA4D,EAAE,qCAAqC,4DAA4D,EAAC;AAChK,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,oDAAmD,EAAE,qCAAqC,iDAAiD,EAAC;AAC5I,2DAA0D,EAAE,qCAAqC,wDAAwD,EAAC;AAC1J,2DAA0D,EAAE,qCAAqC,wDAAwD,EAAC;AAC1J,8BAA8B,mBAAO,CAAC,IAAuB;AAC7D,oEAAmE,EAAE,qCAAqC,kEAAkE,EAAC;AAC7K,gEAA+D,EAAE,qCAAqC,8DAA8D,EAAC;AACrK,6DAA4D,EAAE,qCAAqC,2DAA2D,EAAC;AAC/J,8DAA6D,EAAE,qCAAqC,4DAA4D,EAAC;AACjK,4DAA2D,EAAE,qCAAqC,0DAA0D,EAAC;AAC7J,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,oDAAmD,EAAE,qCAAqC,gDAAgD,EAAC;AAC3I,oDAAmD,EAAE,qCAAqC,gDAAgD,EAAC;AAC3I,gDAA+C,EAAE,qCAAqC,4CAA4C,EAAC;AACnI,oDAAmD,EAAE,qCAAqC,gDAAgD,EAAC;AAC3I,wEAAuE,EAAE,qCAAqC,oEAAoE,EAAC;AACnL,uEAAsE,EAAE,qCAAqC,mEAAmE,EAAC;AACjL,2DAA0D,EAAE,qCAAqC,uDAAuD,EAAC;AACzJ,yEAAwE,EAAE,qCAAqC,qEAAqE,EAAC;AACrL,uEAAsE,EAAE,qCAAqC,mEAAmE,EAAC;AACjL,wEAAuE,EAAE,qCAAqC,oEAAoE,EAAC;AACnL;AACA;AACA;AACA;AACA,IAAI,0BAA0B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA,IAAI,8BAA8B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA,IAAI,sCAAsC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA,IAAI,uBAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA,IAAI,iCAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;AAC3G;AACA;AACA,IAAI,uCAAuC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gFAAgF,uCAAuC,KAAK;AAC7H;AACA;AACA,IAAI,+BAA+B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sFAAsF,0CAA0C,KAAK;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gFAAgF,uCAAuC,KAAK;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oFAAoF,yCAAyC,KAAK;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF,wCAAwC,KAAK;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gFAAgF,uCAAuC,KAAK;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF,wCAAwC,KAAK;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F,4CAA4C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oFAAoF,yCAAyC,KAAK;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA,yBAAyB,4BAA4B;AACrD,eAAe,uCAAuC,IAAI;AAC1D;AACA;AACA,iDAAiD;AACjD,QAAQ,oDAAoD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA,yBAAyB,sBAAsB;AAC/C,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;AACxG;AACA;AACA,yBAAyB,4BAA4B;AACrD,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA,2DAA2D;AAC3D,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA,SAAS,uBAAuB;AAChC,IAAI,2BAA2B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;AACxG;AACA;AACA,yBAAyB,8BAA8B;AACvD,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA,yBAAyB,kBAAkB;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE,gCAAgC,KAAK;AACxG;AACA;AACA,WAAW,4BAA4B;AACvC,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E,qCAAqC,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gFAAgF,uCAAuC,KAAK;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E,qCAAqC,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;;;;;;;;;AC15B9F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE,iCAAiC,KAAK;;;;;;;;;AClB9F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,mBAAmB,GAAG,uBAAuB;AACtE,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA,qCAAqC,iCAAiC;AACtE,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;;;;;;;;;ACnE7D;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C,GAAG,2CAA2C,GAAG,6CAA6C,GAAG,+BAA+B,GAAG,2CAA2C,GAAG,4CAA4C,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,wBAAwB;AACjX,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,WAAW,mBAAO,CAAC,IAAY;AAC/B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F,4CAA4C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF,2CAA2C,KAAK;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4FAA4F,6CAA6C,KAAK;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF,2CAA2C,KAAK;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F,4CAA4C,KAAK;;;;;;;;;ACrN/H;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C,GAAG,qCAAqC,GAAG,wBAAwB;AAC7G,yBAAyB,mBAAO,CAAC,IAAgB;AACjD,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E,qCAAqC,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sFAAsF,0CAA0C,KAAK;;;;;;;;;ACpCzH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,yBAAyB,2BAA2B;AACpD,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;;;;;;;;;ACnBlF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,kCAAkC,GAAG,kCAAkC,GAAG,6BAA6B,GAAG,sCAAsC,GAAG,mBAAmB;AAC7M,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE,kCAAkC,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E,oCAAoC,KAAK;;;;;;;;;ACxDvG;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;;;;;;;;;ACrB5E;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;;;;;;;;;ACrBlF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,sCAAsC,GAAG,mCAAmC;AACnH,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE,mCAAmC,KAAK;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8EAA8E,sCAAsC,KAAK;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E,oCAAoC,KAAK;;;;;;;;;ACzCvG;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C,GAAG,+BAA+B;AAC/E,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4FAA4F,6CAA6C,KAAK;;;;;;;;;AC1B/I;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACnK;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CrB;AACA;AACA;AACA;AACa;AACN;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,oCAAoC;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oCAAoC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,IAAI,kBAAkB;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,eAAe;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC0B;AAC3B;AACA;AACA,IAAI,8BAA8B;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA,IAAI,uCAAuC;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,uCAAuC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA,IAAI,+CAA+C;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,+CAA+C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F;AAC3F;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAA6C,IAAI;AAClF;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD,gBAAgB,oCAAoC;AACpD;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA,IAAI,0BAA0B;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AAC1C;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;;;;;;;;;AC/pEjB;AACA;AACA;AACA;AACa;;AAEb,0CAA8C;;;;;;;;ACNjC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,cAAc,mBAAO,CAAC,IAAe;AACrC,aAAa,mBAAO,CAAC,IAAwC;AAC7D,aAAa,mBAAO,CAAC,IAAe;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;AC7DX;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,6BAA6B;AAC5G,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,yDAAwD,EAAE,qCAAqC,kDAAkD,EAAC;AAClJ,aAAa,mBAAO,CAAC,IAAiC;AACtD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,mBAAmB,mBAAO,CAAC,IAAY;AACvC,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,aAAa,mBAAO,CAAC,GAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;;;;;;;;;AClChF;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;ACjCf;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,WAAW,mBAAO,CAAC,IAAY;AAC/B;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;;;;;;;;;ACrCf;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;AC7BZ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B;;;;;;;;;AC1C7B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;AC7BxB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;ACxBb;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;;;;;;;;;ACjBjC;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;ACtBtB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,2BAA2B;AACvD,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,wBAAwB,mBAAO,CAAC,IAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0EAA0E,+BAA+B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,+BAA+B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gCAAgC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oBAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,qBAAqB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mFAAmF;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0EAA0E,0DAA0D;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;AC3PZ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,uBAAuB,GAAG,sBAAsB;AAC9E,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,eAAe,mBAAO,CAAC,IAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,OAAO;AACjI;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;AC9Jd;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,0BAA0B,GAAG,6BAA6B;AAC1F,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;ACzJhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,uBAAuB,GAAG,gCAAgC,GAAG,gCAAgC,GAAG,gCAAgC,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,gCAAgC,GAAG,8BAA8B,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,2BAA2B;AACvc,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,WAAW,mBAAO,CAAC,IAAY;AAC/B,aAAa,mBAAO,CAAC,IAAc;AACnC,mBAAmB,mBAAO,CAAC,IAAY;AACvC,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,0BAA0B,mBAAO,CAAC,IAAmB;AACrD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,uBAAuB,mBAAO,CAAC,GAAgB;AAC/C,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,wBAAwB,mBAAO,CAAC,GAAiB;AACjD,sBAAsB,mBAAO,CAAC,IAAe;AAC7C,oBAAoB,mBAAO,CAAC,GAAa;AACzC,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,mBAAmB,mBAAO,CAAC,IAAY;AACvC,kBAAkB,mBAAO,CAAC,IAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,eAAe;AAChI;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gFAAgF,mBAAmB;AACnG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA,SAAS;AACT,4EAA4E,QAAQ;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA,gEAAgE,kEAAkE,IAAI,YAAY;AAClJ,aAAa;AACb,SAAS;AACT,4EAA4E,QAAQ;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA,+EAA+E,IAAI;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA,2GAA2G,SAAS,qDAAqD;AACzK,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,gBAAgB;AACxC,0BAA0B,mBAAmB;AAC7C,uBAAuB,gBAAgB;AACvC,uBAAuB,gBAAgB;AACvC,uBAAuB,sBAAsB;AAC7C,0BAA0B,mBAAmB;AAC7C,0BAA0B,mBAAmB;AAC7C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;;;;;;;;;AC5uBX;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;ACfd;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA,8DAA8D,0BAA0B;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,gDAAgD;AACtG;AACA,SAAS;AACT;AACA;AACA;AACA,+DAA+D,gDAAgD;AAC/G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA,SAAS;AACT,0EAA0E,0DAA0D;AACpI;AACA;AACA,qBAAqB;;;;;;;;;AC3KrB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;ACjCf;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AAC9J;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;;;;;;;;;AC1CH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,aAAa,GAAG,cAAc,GAAG,UAAU,GAAG,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV,gCAAgC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AACnF;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB;;;;;;;;;AChGpB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;AC3C/B,eAAe,GAAG,IAAiD,oBAAoB,KAAK,aAAiI,CAAC,iBAAiB,aAAa,OAAO,QAAQ,cAAc,gGAAgG,gBAAgB,gCAAgC,YAAY,KAAK,gCAAgC,KAAK,gBAAgB,KAAK,WAAW,mBAAmB,wBAAwB,kGAAkG,yBAAyB,mBAAmB,yEAAyE,UAAU,oCAAoC,iBAAiB,SAAS,oCAAoC,+DAA+D,QAAQ,6BAA6B,SAAS,OAAO,mBAAmB,yCAAyC,UAAU,KAAK,MAAM,8GAA8G,yDAAyD,uBAAuB,+BAA+B,2DAA2D,4EAA4E,wBAAwB,6CAA6C,iBAAiB,kCAAkC,cAAc,mBAAmB,KAAK,mBAAmB,2CAA2C,qCAAqC,wBAAwB,4BAA4B,gDAAgD,YAAY,iCAAiC,KAAK,6BAA6B,iCAAiC,KAAK,wCAAwC,KAAK,KAAK,UAAU,QAAQ,gDAAgD,6BAA6B,oDAAoD,MAAM,wBAAwB,+BAA+B,cAAc,SAAS,YAAY,KAAK,iEAAiE,6EAA6E,uBAAuB,SAAS,qBAAqB,+BAA+B,0DAA0D,KAAK,iCAAiC,OAAO,IAAI,OAAO,UAAU,kDAAkD,wBAAwB,yFAAyF,KAAK,oBAAoB,+CAA+C,uCAAuC,sBAAsB,iBAAiB,KAAK,KAAK,sBAAsB,WAAW,OAAO,MAAM,OAAO,+EAA+E,mDAAmD,iBAAiB,KAAK,6BAA6B,OAAO,MAAM,OAAO,yBAAyB,6BAA6B,qBAAqB,KAAK,4CAA4C,KAAK,KAAK,sBAAsB,6EAA6E,YAAY,MAAM,OAAO,qEAAqE,oBAAoB,iIAAiI,qBAAqB,uDAAuD,kCAAkC,MAAM,mBAAmB,KAAK,OAAO,uCAAuC,yBAAyB,iCAAiC,uBAAuB,4CAA4C,KAAK,mGAAmG,YAAY,MAAM,MAAM,4QAA4Q,8CAA8C,sBAAsB,aAAa,yCAAyC,SAAS,qFAAqF,oCAAoC,0BAA0B,qCAAqC,eAAe,sCAAsC,SAAS,6BAA6B,oDAAoD,gBAAgB,iEAAiE,0BAA0B,YAAY,YAAY,OAAO,aAAa,QAAQ,gBAAgB,WAAW,EAAE,GAAG,kGAAkG,0BAA0B,+KAA+K,oKAAoK,kFAAkF,QAAQ,gBAAgB,yPAAyP,OAAO,UAAU,KAAK,MAAM,SAAS,4BAA4B,4KAA4K,qBAAqB,kDAAkD,UAAU,0DAA0D,SAAS,iEAAiE,aAAa,kBAAkB,QAAQ,kBAAkB,IAAI,+CAA+C,GAAG,kUAAkU,qBAAqB,kBAAkB,uFAAuF,eAAe,QAAQ,2DAA2D,uBAAuB,uEAAuE,6BAA6B,eAAe,8DAA8D,iBAAiB,eAAe,iBAAiB,SAAS,YAAY,iBAAiB,MAAM,4BAA4B,iBAAiB,qEAAqE,UAAU,QAAQ,6BAA6B,kBAAkB,gBAAgB,aAAa,aAAa,4DAA4D,eAAe,oFAAoF,SAAS,SAAS,QAAQ,iSAAiS,SAAS,4KAA4K,kBAAkB,WAAW,YAAY,WAAW,KAAK,wBAAwB,8MAA8M,KAAK,8BAA8B,aAAa,wFAAwF,qEAAqE,cAAc,MAAM,YAAY,WAAW,KAAK,wBAAwB,6EAA6E,sBAAsB,gBAAgB,MAAM,8DAA8D,YAAY,EAAE,OAAO,8QAA8Q,gBAAgB,cAAc,UAAU,+CAA+C,GAAG,oDAAoD,qBAAqB,WAAW,sBAAsB,8HAA8H,uGAAuG,MAAM,4DAA4D,wBAAwB,qBAAqB,0BAA0B,GAAG,YAAY,GAAG,2CAA2C,wBAAwB,oBAAoB,0BAA0B,GAAG,YAAY,GAAG,cAAc,iEAAiE,cAAc,IAAI,6BAA6B,MAAM,kDAAkD,gBAAgB,sCAAsC,cAAc,4CAA4C,qBAAqB,mEAAmE,kBAAkB,2CAA2C,8DAA8D,6BAA6B,aAAa,+BAA+B,mBAAmB,4BAA4B,gEAAgE,mCAAmC,sBAAsB,EAAE,eAAe,YAAY,yCAAyC,4BAA4B,SAAS,6FAA6F,iBAAiB,sCAAsC,SAAS,iBAAiB,qCAAqC,MAAM,aAAa,4BAA4B,eAAe,yBAAyB,EAAE,gCAAgC,kBAAkB,uBAAuB,wBAAwB,6DAA6D,OAAO,EAAE,uBAAuB,0CAA0C,wBAAwB,0DAA0D,OAAO,EAAE,wBAAwB,0BAA0B,uBAAuB,0BAA0B,iBAAiB,IAAI,MAAM,cAAc,WAAW,+BAA+B,YAAY,YAAY,oDAAoD,SAAS,YAAY,QAAQ,sCAAsC,SAAS,uBAAuB,eAAe,+BAA+B,6BAA6B,cAAc,EAAE,eAAe,iCAAiC,6BAA6B,gBAAgB,EAAE,MAAM;AACriX;;;;;;;;ACDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;ACfa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,iCAAiC;AACrE,sCAAsC,mBAAO,CAAC,IAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;ACxDa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,cAAc,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,0BAA0B;AAC3P,iCAAiC,mBAAO,CAAC,GAAQ;AACjD,0BAA0B,6BAA6B,mBAAO,CAAC,IAA+B;AAC9F,uBAAuB;AACvB,wBAAwB;AACxB,sBAAsB;AACtB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB;AAChB;AACA;AACA;AACA,qBAAqB;AACrB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5Ca;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,cAAc,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,2BAA2B;AACvH,aAAa,mBAAO,CAAC,IAAe;AACpC,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,IAAU;AAC/B,gBAAgB,mBAAO,CAAC,IAAW;AACnC,uDAAsD,EAAE,qCAAqC,yCAAyC,EAAC;AACvI,4CAA2C,EAAE,qCAAqC,8BAA8B,EAAC;AACjH,iDAAgD,EAAE,qCAAqC,mCAAmC,EAAC;AAC3H,0CAAyC,EAAE,qCAAqC,4BAA4B,EAAC;AAC7G,4BAA4B,mBAAO,CAAC,IAAuB;AAC3D,yDAAwD,EAAE,qCAAqC,uDAAuD,EAAC;AACvJ;;;;;;;;AC3Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAY,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,yBAAyB;AACvG,iBAAiB,mBAAO,CAAC,IAAe;AACxC,kBAAkB,mBAAO,CAAC,IAAW;AACrC,iBAAiB,mBAAO,CAAC,IAAU;AACnC,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,wBAAwB,eAAe,GAAG;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oDAAoD,QAAQ,mGAAmG;AAC/J,kDAAkD,QAAQ,mGAAmG;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC12Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,YAAY,GAAG,gBAAgB,GAAG,eAAe,GAAG,uBAAuB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,sBAAsB;AAC7K,sBAAsB,mBAAO,CAAC,IAAe;AAC7C,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,iBAAiB,mBAAO,CAAC,IAAU;AACnC,kBAAkB,mBAAO,CAAC,IAAW;AACrC,sBAAsB,mBAAO,CAAC,IAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;AAC1E;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,CAAC;AACD,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,gFAAgF,UAAU,GAAG,cAAc;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,oFAAoF,UAAU,GAAG,cAAc,WAAW,kBAAkB,GAAG,qBAAqB;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,UAAU,WAAW,aAAa,GAAG,gBAAgB;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,qBAAqB;AACrD;AACA;AACA,8BAA8B,EAAE,wBAAwB;AACxD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,oEAAoE,GAAG,wBAAwB;AACxL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8BAA8B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+BAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA,8BAA8B,wCAAwC;AACtE,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAA8D;AAClF,8BAA8B,8DAA8D;AAC5F,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACroCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,iBAAiB;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,eAAe,GAAG,cAAc,GAAG,gBAAgB,GAAG,mBAAmB;AAC5F;AACA,0CAA0C,OAAO;AACjD;AACA,mBAAmB;AACnB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;AC/BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,KAAK,OAAO,KAAK;AAClC,sBAAsB,KAAK,OAAO,KAAK;AACvC;AACA;;AAEA;AACA;AACA,oBAAoB,MAAM;AAC1B,uBAAuB,QAAQ,OAAO,OAAO;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wDAAwD;;AAE7E;AACA;AACA,MAAM,4DAA4D;AAClE;AACA,MAAM,4DAA4D;;AAElE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;AAC5E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,sCAAsC;AACxD;AACA;AACA,0BAA0B,4CAA4C;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAA+D;AACrE;AACA,MAAM,2DAA2D;AACjE;AACA,MAAM,2DAA2D;;AAEjE;AACA;AACA;AACA;AACA,wBAAwB,uEAAuE;AAC/F,wBAAwB,uEAAuE;;AAE/F;AACA;AACA;AACA;;AAEA,qBAAqB,gEAAgE;AACrF,mBAAmB,mEAAmE;AACtF;;AAEA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB,gBAAgB,OAAO;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,+CAA+C;AAC/D,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2EAA2E,MAAM;AACjF;AACA;AACA;;AAEA,8EAA8E,IAAI,OAAO,MAAM;AAC/F,6DAA6D,MAAM;AACnE,6DAA6D,MAAM;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtlBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,gBAAgB,mBAAO,CAAC,IAAS;AACjC,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,wBAAwB,yBAAyB;AACjD,CAAC;AACD;AACA,wGAAwG,0CAA0C;AAClJ,MAAM,0BAA0B;AAChC;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;;;;;;;;AC/Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,qBAAqB;AACvC,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe;AACf;;;;;;;;AC5Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,gBAAgB,mBAAO,CAAC,IAAa;AACrC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,oBAAoB;AAChD,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,iFAAiF,IAAI;AACrF,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACxDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,eAAe,mBAAO,CAAC,IAAY;AACnC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW,KAAK,UAAU,uCAAuC,kBAAkB;AAC1I;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC/Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC;AACnC,eAAe,mBAAO,CAAC,IAAY;AACnC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW,KAAK,UAAU,uCAAuC,kBAAkB;AAC1I;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC/Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,kBAAkB;AAC7F;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8FAA8F,SAAS;AACvG;AACA,2EAA2E,kBAAkB;AAC7F;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC5Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,kBAAkB;AACnH;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8FAA8F,SAAS;AACvG;AACA,iGAAiG,kBAAkB;AACnH;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,4CAA4C,WAAW;AACvD,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC3Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC3Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,oBAAoB;AACvG,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,gEAAgE,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,0BAA0B,uBAAuB;AAC7E,YAAY,aAAa;AACzB,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,GAAG,eAAe;AACpE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA,gCAAgC,OAAO;AACvC;AACA,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B,0CAA0C,yBAAyB;AACnE;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,IAAI,MAAM;AAChD;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,eAAe,OAAO,IAAI,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7Ma;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,qBAAqB,iBAAiB;AAC3F;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC9Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC,EAAE,eAAe;AAClG;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,iBAAiB;AACvC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,mCAAmC,mBAAO,CAAC,IAA4B;AACvE,0CAA0C,mBAAO,CAAC,IAAmC;AACrF,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,gCAAgC,mBAAO,CAAC,IAAyB;AACjE,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,uCAAuC,mBAAO,CAAC,IAAgC;AAC/E,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,0CAA0C,mBAAO,CAAC,IAAmC;AACrF,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,8BAA8B,mBAAO,CAAC,IAAuB;AAC7D,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,8BAA8B,mBAAO,CAAC,IAAuB;AAC7D,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,mCAAmC,mBAAO,CAAC,IAA4B;AACvE,gCAAgC,mBAAO,CAAC,IAAyB;AACjE,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,0BAA0B,mBAAO,CAAC,IAAmB;AACrD,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,qCAAqC,mBAAO,CAAC,IAA8B;AAC3E,uCAAuC,mBAAO,CAAC,GAAgC;AAC/E,uBAAuB,mBAAO,CAAC,IAAgB;AAC/C,uCAAuC,mBAAO,CAAC,IAAgC;AAC/E,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,gCAAgC,mBAAO,CAAC,IAAyB;AACjE,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,sCAAsC,mBAAO,CAAC,IAA+B;AAC7E,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,iCAAiC,mBAAO,CAAC,IAA0B;AACnE,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,sCAAsC,mBAAO,CAAC,IAA+B;AAC7E,uBAAuB,mBAAO,CAAC,IAAgB;AAC/C,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,kCAAkC,mBAAO,CAAC,GAA2B;AACrE,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,mCAAmC,mBAAO,CAAC,IAA4B;AACvE,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;ACrHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,8BAA8B,mBAAO,CAAC,IAAuB;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,sBAAsB;AAC7C,eAAe,mBAAO,CAAC,IAAY;AACnC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,uBAAuB,SAAS,GAAG,aAAa;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,gBAAgB,mBAAO,CAAC,IAAmB;AAC3C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC,kBAAkB,mBAAO,CAAC,IAAe;AACzC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AChEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACzDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,IAAI,GAAG,KAAK;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AClJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD,gBAAgB,mBAAO,CAAC,IAAU;AAClC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACvDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAW;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,eAAe,mBAAO,CAAC,IAAY;AACnC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oHAAoH,SAAS,MAAM,QAAQ;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6HAA6H,SAAS,MAAM,SAAS,mBAAmB,gBAAgB;AACxL,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACxFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,sBAAsB,mBAAO,CAAC,IAAe;AAC7C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,8BAA8B;AAC5D,gBAAgB,mBAAO,CAAC,IAAa;AACrC,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,cAAc;AACxC,wGAAwG,IAAI,IAAI,KAAK;AACrH,KAAK;AACL,CAAC;AACD,8BAA8B;AAC9B;AACA;AACA;AACA,8DAA8D,KAAK;AACnE,KAAK;AACL,CAAC;AACD,2BAA2B;AAC3B;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,iCAAiC;AACjC;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB,OAAO,sBAAsB;AAC5G;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iEAAiE,EAAE,kBAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,EAAE,kBAAkB;AAC7G;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,SAAS;AACzF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,SAAS;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0HAA0H;AAC1H;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC3Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAoB;AAC7C,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,iCAAiC;AACjC;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,eAAe,mBAAO,CAAC,IAAY;AACnC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iJAAiJ;AACjJ;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe,+CAA+C,cAAc;AAClH;AACA,2CAA2C,yCAAyC;AACpF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACxFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAU;AAClC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,WAAW,QAAQ,kBAAkB,GAAG,qBAAqB;AAC9K;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iHAAiH,WAAW,QAAQ,kBAAkB,GAAG,qBAAqB;AAC9K;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAA+C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAgD,KAAK,mDAAmD;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAA0D,EAAE,0CAA0C,4CAA4C,IAAI;AAC5K;AACA,uBAAuB,iDAAiD,IAAI,+CAA+C;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7Pa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB,wBAAwB;AACxB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB,wBAAwB;AACxB,wBAAwB;AACxB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,GAAG;AAC5E;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACpEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAoB;AAC7C,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACvDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,6BAA6B,GAAG,uBAAuB,GAAG,cAAc,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,oBAAoB;AAC3N,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;ACvDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF;AACA;AACA;AACA,oEAAoE,YAAY;AAChF;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA,kFAAkF,UAAU;AAC5F;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AClFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB,cAAc,qBAAqB;AACnG;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACpGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,gBAAgB,mBAAO,CAAC,IAAa;AACrC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACnCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,4BAA4B,mBAAO,CAAC,IAAqB;AACzD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qHAAqH;AAC7I;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACrEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,iBAAiB;AACzC,eAAe,mBAAO,CAAC,IAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAA+C;AAC3F;AACA;AACA,wCAAwC,+CAA+C;AACvF;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;;;;;;;;AC/Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAA4B;AACxD,gBAAgB,mBAAO,CAAC,IAAU;AAClC,gBAAgB,mBAAO,CAAC,IAAwB;AAChD,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW,+BAA+B,YAAY;AAClH;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA,wDAAwD,WAAW,IAAI,gDAAgD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,YAAY;AAChK;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW,+BAA+B,YAAY;AACzG;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C;AACvE;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACrIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,+CAA+C,cAAc;AAC3G;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qDAAqD,YAAY,kBAAkB,cAAc;AACjG;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACzEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,mBAAmB;AACnB;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACvCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAa;AACrC,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wBAAwB,0CAA0C;AAClE;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB,8BAA8B,eAAe;AAC7F,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;;;;;;;;AC7Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,qBAAqB,mBAAO,CAAC,IAAwB;AACrD,iBAAiB,mBAAO,CAAC,IAAoB;AAC7C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,sBAAsB;AAC7D,gBAAgB,mBAAO,CAAC,IAAa;AACrC,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,2BAA2B,mBAAO,CAAC,IAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA,sBAAsB;AACtB,YAAY,kDAAkD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,qCAAqC;AACrC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,oCAAoC;AACpC,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC3Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,sBAAsB,GAAG,sCAAsC,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,iCAAiC;AACxM,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,eAAe,mBAAO,CAAC,IAAY;AACnC,eAAe,mBAAO,CAAC,IAAY;AACnC,kBAAkB,mBAAO,CAAC,IAAe;AACzC,iCAAiC,MAAM,OAAO;AAC9C,sBAAsB,KAAK;AAC3B,sBAAsB,QAAQ,UAAU;AACxC,oBAAoB,MAAM;AAC1B;AACA;AACA,yBAAyB,YAAY;AACrC;AACA,8BAA8B,qBAAqB,UAAU;AAC7D;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA,iFAAiF,eAAe;AAChG;AACA;AACA;AACA,kCAAkC,uBAAuB,EAAE,oBAAoB,EAAE,uBAAuB;AACxG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oEAAoE,uBAAuB;AAC3F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;;;;;;;ACnHa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,oCAAoC,mBAAO,CAAC,IAAkB;AAC9D,oCAAoC,mBAAO,CAAC,GAAkB;AAC9D,oCAAoC,mBAAO,CAAC,IAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA,qDAAqD,iBAAiB,QAAQ,2BAA2B;AACzG;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;AC7Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,oCAAoC,GAAG,mBAAmB,GAAG,8BAA8B,GAAG,wCAAwC,GAAG,kCAAkC,GAAG,kCAAkC,GAAG,4BAA4B,GAAG,oBAAoB,GAAG,sBAAsB;AACrU,qBAAqB,mBAAO,CAAC,IAAY;AACzC,6BAA6B,mBAAO,CAAC,IAAsB;AAC3D,eAAe,mBAAO,CAAC,IAAQ;AAC/B,eAAe,mBAAO,CAAC,IAAQ;AAC/B,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,4BAA4B;AAC5B,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;;;;;;;ACpLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,YAAY;AAC5B,mBAAmB,MAAM;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;AC3Ea;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,0BAA0B,mBAAO,CAAC,IAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;AC1Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,uBAAuB,GAAG,qBAAqB;AACzE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,iDAAgD,EAAE,qCAAqC,0CAA0C,EAAC;AAClI,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,mDAAkD,EAAE,qCAAqC,8CAA8C,EAAC;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,qDAAqD,EAAE;AACvD;AACA;;;;;;;;ACzBa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,8BAA8B,mBAAO,CAAC,IAAY;AAClD,gCAAgC,mBAAO,CAAC,IAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;;;;;;;;AC7Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,eAAe,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,oBAAoB;AAC7I,cAAc,mBAAO,CAAC,IAAS;AAC/B,gDAA+C,EAAE,qCAAqC,gCAAgC,EAAC;AACvH,mBAAmB,mBAAO,CAAC,IAAc;AACzC,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,iDAAgD,EAAE,qCAAqC,sCAAsC,EAAC;AAC9H,mDAAkD,EAAE,qCAAqC,wCAAwC,EAAC;AAClI,gBAAgB,mBAAO,CAAC,IAAW;AACnC,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G,4BAA4B,mBAAO,CAAC,GAAuB;AAC3D,oDAAmD,EAAE,qCAAqC,kDAAkD,EAAC;AAC7I;;;;;;;;ACba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,oBAAoB,mBAAO,CAAC,IAAW;AACvC;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,YAAY;AAC5B,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,0BAA0B,mBAAO,CAAC,IAAmB;AACrD,iBAAiB,mBAAO,CAAC,IAAU;AACnC,0BAA0B,mBAAO,CAAC,IAAQ;AAC1C,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,mBAAmB,mBAAO,CAAC,IAAY;AACvC,aAAa,mBAAO,CAAC,IAAsB;AAC3C,aAAa,mBAAO,CAAC,IAAwB;AAC7C,aAAa,mBAAO,CAAC,IAAU;AAC/B,aAAa,mBAAO,CAAC,IAAiB;AACtC,aAAa,mBAAO,CAAC,IAAa;AAClC,aAAa,mBAAO,CAAC,GAAS;AAC9B,aAAa,mBAAO,CAAC,IAAU;AAC/B,aAAa,mBAAO,CAAC,IAAQ;AAC7B,aAAa,mBAAO,CAAC,IAAiB;AACtC,YAAY,gBAAgB,mBAAO,CAAC,IAAQ;AAC5C,aAAa,mBAAO,CAAC,IAAa;AAClC,aAAa,mBAAO,CAAC,IAAkB;AACvC,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,IAAe;AACpC,aAAa,mBAAO,CAAC,IAAiB;AACtC,aAAa,mBAAO,CAAC,IAAc;AACnC,aAAa,mBAAO,CAAC,IAAe;AACpC,aAAa,mBAAO,CAAC,IAAgB;AACrC,aAAa,mBAAO,CAAC,IAAW;AAChC,aAAa,mBAAO,CAAC,IAAwB;AAC7C,aAAa,mBAAO,CAAC,IAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,iBAAiB;AAChF,uBAAuB,mBAAO,CAAC,IAAc;AAC7C,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;ACjFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB,GAAG,wBAAwB;AAChE,gBAAgB,mBAAO,CAAC,IAAU;AAClC,uBAAuB,mBAAO,CAAC,IAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB,gCAAgC,QAAQ;AACxC;;;;;;;;ACrGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;;;;;;;;ACFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,kBAAkB,mBAAO,CAAC,IAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,8BAA8B;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uCAAuC,YAAY;AACnD,qCAAqC,UAAU;AAC/C,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,4BAA4B,GAAG,2BAA2B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D,4BAA4B,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,gBAAgB,GAAG,eAAe,GAAG,iBAAiB,GAAG,eAAe,GAAG,YAAY,GAAG,gBAAgB,GAAG,aAAa,GAAG,WAAW;AACzJ,qBAAqB,mBAAO,CAAC,IAAY;AACzC,uCAAsC,EAAE,qCAAqC,4BAA4B,EAAC;AAC1G,yCAAwC,EAAE,qCAAqC,8BAA8B,EAAC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,4CAA4C,IAAI;AAChD;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;;;;;;;ACzCa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,iBAAiB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,eAAe,GAAG,gBAAgB;AACrO,eAAe,mBAAO,CAAC,IAAQ;AAC/B,0BAA0B,mBAAO,CAAC,IAAQ;AAC1C,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,gBAAgB,mBAAO,CAAC,IAAS;AACjC,kBAAkB,mBAAO,CAAC,IAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7Ka;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,iBAAiB,GAAG,uBAAuB;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAe;AACvC,0BAA0B,mBAAO,CAAC,IAAQ;AAC1C,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,IAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;ACvEa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,gBAAgB,GAAG,2BAA2B,GAAG,sBAAsB,GAAG,aAAa,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,oBAAoB;AAClO,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uDAAsD,EAAE,qCAAqC,0CAA0C,EAAC;AACxI,aAAa,mBAAO,CAAC,IAAe;AACpC,aAAa,mBAAO,CAAC,IAA6B;AAClD,aAAa,mBAAO,CAAC,IAA2B;AAChD,aAAa,mBAAO,CAAC,IAAuB;AAC5C;AACA,oBAAoB;AACpB;AACA,mBAAmB;AACnB;AACA,sBAAsB;AACtB;AACA,mBAAmB;AACnB;AACA,qBAAqB;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uCAAuC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;ACnFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,gBAAgB,mBAAO,CAAC,GAAW;AACnC,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;;;;;;;;ACFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;;;;;;;;ACFa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,aAAa,mBAAO,CAAC,IAAW;AAChC;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,YAAY,GAAG,aAAa;AAClG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;AC5Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,GAAG,qBAAqB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,iBAAiB;AAC5I,eAAe,mBAAO,CAAC,IAAS;AAChC,qBAAqB,mBAAO,CAAC,IAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB,uBAAuB,gBAAgB;AAC7F,6BAA6B,iBAAiB,uBAAuB,gBAAgB,+BAA+B,6BAA6B;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA,kCAAkC;AAClC;;;;;;;;AC/Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C,GAAG,2CAA2C,GAAG,mBAAmB,GAAG,+BAA+B,GAAG,qBAAqB;AACxK,sBAAsB,mBAAO,CAAC,GAAa;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;;;;;;;;AC9Ca;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,IAAU;AAC/B,aAAa,mBAAO,CAAC,GAAS;AAC9B,aAAa,mBAAO,CAAC,IAAY;AACjC,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,IAAQ;AAC7B,aAAa,mBAAO,CAAC,IAAW;AAChC,aAAa,mBAAO,CAAC,GAAS;AAC9B;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;AC1Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;;;;;;;;ACPa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB;AACvC,sCAAsC,mBAAO,CAAC,IAAa;AAC3D;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,gDAAgD,WAAW;AAC3D;AACA,iBAAiB;AACjB;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,EAAE;AACrF;AACA,mBAAmB;AACnB;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,yBAAyB,GAAG,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,sDAAsD,eAAe;AACrE;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB;AACvC,eAAe,mBAAO,CAAC,IAAU;AACjC,+CAA8C,EAAE,qCAAqC,gCAAgC,EAAC;AACtH,aAAa,mBAAO,CAAC,IAAQ;AAC7B,6CAA4C,EAAE,qCAAqC,4BAA4B,EAAC;AAChH;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;ACvCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;ACvCa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,qBAAqB;AAC3C,uCAAuC,mBAAO,CAAC,IAAuC;AACtF,kBAAkB,mBAAO,CAAC,IAA+B;AACzD,aAAa,mBAAO,CAAC,IAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,6BAA6B,GAAG,kBAAkB;AACxE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,mBAAmB,mBAAO,CAAC,IAAY;AACvC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS,SAAS,wBAAwB;AAC9F;AACA,8FAA8F;AAC9F;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,0CAA0C,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4DAA4D,SAAS,aAAa,UAAU;AAC5F;AACA;AACA;AACA;AACA,oCAAoC,kDAAkD;AACtF;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,iBAAiB,iBAAiB,IAAI,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA,sBAAsB,wBAAwB;AAC9C;AACA,sBAAsB,8BAA8B;AACpD;AACA,sBAAsB,0CAA0C;AAChE;AACA,sBAAsB,yBAAyB;AAC/C;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,yBAAyB;AAC/C;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,4BAA4B;AAClD;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,wBAAwB;AAC9C;AACA,sBAAsB,2BAA2B;AACjD;AACA,sBAAsB,uCAAuC;AAC7D;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,0BAA0B;AAChD;AACA,sBAAsB,yBAAyB;AAC/C;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,KAAK,mBAAmB;AACnD;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,2BAA2B;AACxF;AACA;AACA,6DAA6D,4CAA4C;AACzG;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC;AACpC,yBAAyB,gBAAgB;AACzC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACryBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;;;;;;;ACba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,uBAAuB;AACrD,oBAAoB,mBAAO,CAAC,GAAa;AACzC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,2BAA2B;AACrD,4BAA4B,mBAAO,CAAC,IAAuB;AAC3D,uDAAsD,EAAE,qCAAqC,qDAAqD,EAAC;AACnJ,mDAAkD,EAAE,qCAAqC,iDAAiD,EAAC;AAC3I;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,kCAAkC,mBAAO,CAAC,IAA4B;AACtE,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,kCAAkC,mBAAO,CAAC,IAA4B;AACtE,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE,qDAAqD,eAAe,WAAW,gBAAgB;AAC/F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,oBAAoB,mBAAO,CAAC,IAA0B;AACtD,kCAAkC,mBAAO,CAAC,IAA4B;AACtE,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;AACpE,0GAA0G,mBAAmB;AAC7H,KAAK;AACL;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;;;;;;;;ACxCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,sBAAsB,GAAG,mBAAmB;AACzE,oBAAoB,mBAAO,CAAC,IAAe;AAC3C,+CAA8C,EAAE,qCAAqC,qCAAqC,EAAC;AAC3H,uBAAuB,mBAAO,CAAC,IAAkB;AACjD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,2BAA2B,mBAAO,CAAC,IAAsB;AACzD,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,iBAAiB,GAAG,oBAAoB;AAC5D,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,YAAY,UAAU;AACtB;AACA;AACA,iBAAiB;AACjB;;;;;;;;AC7Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;ACZa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,gBAAgB;AACjD,oBAAoB,mBAAO,CAAC,IAAa;AACzC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,gBAAgB,GAAG,8BAA8B;AAC3E,+BAA+B,mBAAO,CAAC,IAA0B;AACjE,0DAAyD,EAAE,qCAAqC,2DAA2D,EAAC;AAC5J,4CAA2C,EAAE,qCAAqC,6CAA6C,EAAC;AAChI,kBAAkB,mBAAO,CAAC,IAAa;AACvC,mDAAkD,EAAE,qCAAqC,uCAAuC,EAAC;AACjI;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,0BAA0B;AACpD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qCAAqC,mBAAO,CAAC,IAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,mFAAmF,sDAAsD;AACzI;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,+BAA+B;AAChE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qCAAqC,mBAAO,CAAC,IAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,mFAAmF,sDAAsD;AACzI;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;ACzEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,qCAAqC,mBAAO,CAAC,IAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;;;;;;;AC/Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,+BAA+B,GAAG,8BAA8B,GAAG,0BAA0B,GAAG,uBAAuB;AACnJ,2BAA2B,mBAAO,CAAC,IAAsB;AACzD,mDAAkD,EAAE,qCAAqC,gDAAgD,EAAC;AAC1I,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ,gCAAgC,mBAAO,CAAC,IAA2B;AACnE,0DAAyD,EAAE,qCAAqC,4DAA4D,EAAC;AAC7J,2DAA0D,EAAE,qCAAqC,6DAA6D,EAAC;AAC/J,0BAA0B,mBAAO,CAAC,IAAqB;AACvD,qDAAoD,EAAE,qCAAqC,iDAAiD,EAAC;AAC7I;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,qBAAqB,mBAAO,CAAC,IAAe;AAC5C,iBAAiB,mBAAO,CAAC,IAAU;AACnC,oBAAoB,mBAAO,CAAC,IAAa;AACzC,mDAAmD,mBAAO,CAAC,GAAsD;AACjH,yCAAyC,mBAAO,CAAC,GAA4C;AAC7F,+CAA+C,mBAAO,CAAC,IAAkD;AACzG;AACA,kBAAkB,8FAA8F;AAChH;AACA,KAAK,gFAAgF,GAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;AC1Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,4BAA4B,mBAAO,CAAC,IAAuB;AAC3D,uDAAsD,EAAE,qCAAqC,qDAAqD,EAAC;AACnJ;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,cAAc,mBAAO,CAAC,IAAO;AAC7B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,2GAA2G,aAAa,WAAW;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,EAAE;AACnF;AACA;;;;;;;;AC5Ya;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW,GAAG,cAAc;AAC5B,cAAc;AACd;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA,OAAO,MAAM;AACb,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC,aAAa;AAChD,mCAAmC,SAAS;AAC5C,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,yCAAyC;AACzC;AACA,8CAA8C;AAC9C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,yCAAyC;AACzC,0CAA0C;AAC1C;AACA;AACA;AACA,uBAAuB;AACvB,yCAAyC;AACzC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9Oa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,oCAAoC;AACrD,+BAA+B,mBAAO,CAAC,IAA0B;AACjE,gEAA+D,EAAE,qCAAqC,iEAAiE,EAAC;AACxK,YAAY,mBAAO,CAAC,IAAO;AAC3B,0CAAyC,EAAE,qCAAqC,wBAAwB,EAAC;AACzG;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C;AAC7C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6CAA6C;AAC7C;;;;;;;;ACnCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C;AAC7C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAW;AACpC,+CAA+C,mBAAO,CAAC,IAA6C;AACpG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,EAAE,OAAO;AACzE;AACA;AACA;AACA;AACA,8CAA8C,KAAK,QAAQ,KAAK;AAChE;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;;;;;;;;ACjGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qBAAqB,mBAAO,CAAC,IAAkB;AAC/C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,2FAA2F;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,2BAA2B,qBAAqB;AAChD,sEAAsE;AACtE;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,EAAE,OAAO;AAClF;AACA;AACA;AACA,wDAAwD,UAAU,MAAM,QAAQ;AAChF;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE,UAAU,GAAG,eAAe,EAAE;AAC7D;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA,sDAAsD,eAAe,IAAI,eAAe;AACxF;AACA;;;;;;;;ACzJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8CAA8C;AAC9C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,EAAE,OAAO;AACzE;AACA;AACA;AACA;AACA,6CAA6C,KAAK,aAAa,KAAK;AACpE;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;;;;;;;ACtFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC;AACvC,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,IAAI,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,SAAS;AAC1G;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C;AAC5C,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;ACpDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C;AAC5C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iCAAiC,gDAAgD;AACjF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C;AAC5C;;;;;;;;ACxCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sCAAsC;AACtC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,oBAAoB,mBAAO,CAAC,IAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;;;;;;;;ACvCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,gBAAgB,mBAAO,CAAC,IAAa;AACrC,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA,6BAA6B,iBAAiB;AAC9C;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa,qBAAqB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,cAAc;AAClB,IAAI;AACJ;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,qCAAqC,qCAAqC;AAC1E;AACA;AACA,wEAAwE;AACxE;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA;AACA,uDAAuD,EAAE,EAAE,GAAG,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA,qBAAqB,uBAAuB;AAC5C;AACA,qBAAqB,uBAAuB;AAC5C;AACA,qBAAqB,kBAAkB;AACvC;AACA,qBAAqB,UAAU,aAAa,EAAE;AAC9C;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,SAAS,KAAK,SAAS,OAAO,UAAU,EAAE;AAC/D;AACA;AACA,iBAAiB,IAAI,SAAS,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,SAAS,IAAI,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,oBAAoB;AACpB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,KAAK;AACL,qBAAqB;AACrB;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qCAAqC;AACrC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,uBAAuB;AACnC;AACA;AACA,uBAAuB;AACvB;AACA;AACA,IAAI;AACJ,IAAI;AACJ,IAAI,cAAc;AAClB,IAAI,cAAc;AAClB,IAAI,cAAc;AAClB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7Wa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yCAAyC;AACzC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qBAAqB,mBAAO,CAAC,IAAkB;AAC/C,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA,yEAAyE,MAAM;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA,wDAAwD,2DAA2D;AACnH;AACA;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAW;AACpC,iBAAiB,mBAAO,CAAC,IAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa,iDAAiD,2DAA2D;AACvJ;AACA;AACA,gCAAgC;AAChC;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC;AACvC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C,aAAa;AACb,SAAS;AACT;AACA;AACA,uCAAuC;AACvC;;;;;;;;ACnCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gDAAgD;AAChD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAW;AACpC,oBAAoB,mBAAO,CAAC,IAAuB;AACnD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,IAAI,mBAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wHAAwH,oBAAoB,IAAI,mBAAmB;AACnK;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;;;;;;;;AC1Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC;AACrC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,uBAAuB,mBAAO,CAAC,IAAoB;AACnD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,QAAQ,iIAAiI;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,qCAAqC;AACrC;;;;;;;;AC9Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,iBAAiB,mBAAO,CAAC,IAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,iDAAiD;AACjD,CAAC,gCAAgC;AACjC,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,EAAE,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,4BAA4B;AACjD,iCAAiC,mBAAO,CAAC,IAA4B;AACrE,wDAAuD,EAAE,qCAAqC,2DAA2D,EAAC;AAC1J,sBAAsB,aAAa,IAAI,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;AChBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;ACZa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC,GAAG,qCAAqC,GAAG,gCAAgC,GAAG,yCAAyC,GAAG,oCAAoC,GAAG,8CAA8C,GAAG,gCAAgC,GAAG,4CAA4C,GAAG,uCAAuC,GAAG,iCAAiC,GAAG,6CAA6C,GAAG,6CAA6C,GAAG,oCAAoC;AAC7hB,qCAAqC,mBAAO,CAAC,IAAgC;AAC7E,gEAA+D,EAAE,qCAAqC,uEAAuE,EAAC;AAC9K,8CAA8C,mBAAO,CAAC,IAAyC;AAC/F,yEAAwE,EAAE,qCAAqC,yFAAyF,EAAC;AACzM,8CAA8C,mBAAO,CAAC,IAAyC;AAC/F,yEAAwE,EAAE,qCAAqC,yFAAyF,EAAC;AACzM,kCAAkC,mBAAO,CAAC,GAA6B;AACvE,6DAA4D,EAAE,qCAAqC,iEAAiE,EAAC;AACrK,wCAAwC,mBAAO,CAAC,IAAmC;AACnF,mEAAkE,EAAE,qCAAqC,6EAA6E,EAAC;AACvL,6CAA6C,mBAAO,CAAC,IAAwC;AAC7F,wEAAuE,EAAE,qCAAqC,uFAAuF,EAAC;AACtM,iCAAiC,mBAAO,CAAC,IAA4B;AACrE,4DAA2D,EAAE,qCAAqC,+DAA+D,EAAC;AAClK,+CAA+C,mBAAO,CAAC,IAA0C;AACjG,0EAAyE,EAAE,qCAAqC,2FAA2F,EAAC;AAC5M,qCAAqC,mBAAO,CAAC,IAAgC;AAC7E,gEAA+D,EAAE,qCAAqC,uEAAuE,EAAC;AAC9K,0CAA0C,mBAAO,CAAC,IAAqC;AACvF,qEAAoE,EAAE,qCAAqC,iFAAiF,EAAC;AAC7L,iCAAiC,mBAAO,CAAC,IAA4B;AACrE,4DAA2D,EAAE,qCAAqC,+DAA+D,EAAC;AAClK,sCAAsC,mBAAO,CAAC,IAAiC;AAC/E,iEAAgE,EAAE,qCAAqC,yEAAyE,EAAC;AACjL,wCAAwC,mBAAO,CAAC,IAAmC;AACnF,mEAAkE,EAAE,qCAAqC,6EAA6E,EAAC;AACvL;;;;;;;;AC7Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,8BAA8B,mBAAO,CAAC,EAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;;;;;;;;ACvCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,0BAA0B;AAClD,2BAA2B,mBAAO,CAAC,IAAsB;AACzD,sDAAqD,EAAE,qCAAqC,mDAAmD,EAAC;AAChJ,kBAAkB,mBAAO,CAAC,EAAa;AACvC,iDAAgD,EAAE,qCAAqC,qCAAqC,EAAC;AAC7H;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,8DAA8D,0EAA0E;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8FAA8F,KAAK;AACnG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;AC3Da;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,8BAA8B,mBAAO,CAAC,IAAsD;AAC5F,gBAAgB;AAChB;;;;;;;;AC5Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,cAAc;AACxC,qBAAqB,mBAAO,CAAC,IAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,sBAAsB,WAAW,MAAM,qBAAqB;AAC5D;AACA;AACA,sBAAsB,WAAW,MAAM,WAAW;AAClD;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,uEAAuE,sBAAsB,sBAAsB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,6BAA6B,EAAE,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,QAAQ,eAAe,GAAG,WAAW;AAClG;AACA;AACA,8CAA8C,eAAe,QAAQ,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,WAAW,WAAW;AACnF;AACA;AACA,8CAA8C,eAAe,WAAW,qBAAqB;AAC7F;AACA;AACA,8CAA8C,eAAe,WAAW,WAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,WAAW,WAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS,IAAI,QAAQ;AACxC;AACA,mEAAmE,SAAS,IAAI,QAAQ;AACxF;AACA;;;;;;;;ACnHa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,cAAc;AACxC,yBAAyB,mBAAO,CAAC,IAAoB;AACrD,0CAAyC,EAAE,qCAAqC,qCAAqC,EAAC;AACtH,mDAAkD,EAAE,qCAAqC,8CAA8C,EAAC;AACxI,aAAa,mBAAO,CAAC,IAAc;AACnC;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,GAAG,uBAAuB;AAC5D,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;ACzCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C;AAC7C,uBAAuB,mBAAO,CAAC,IAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA,6CAA6C;AAC7C;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gDAAgD;AAChD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gDAAgD,GAAG,6CAA6C;AAChG,8CAA8C,mBAAO,CAAC,IAAyC;AAC/F,yEAAwE,EAAE,qCAAqC,yFAAyF,EAAC;AACzM,iDAAiD,mBAAO,CAAC,IAA4C;AACrG,4EAA2E,EAAE,qCAAqC,+FAA+F,EAAC;AAClN;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qBAAqB,mBAAO,CAAC,IAAY;AACzC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,8BAA8B,mBAAO,CAAC,IAAyB;AAC/D,yDAAwD,EAAE,qCAAqC,yDAAyD,EAAC;AACzJ;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6CAA6C,mBAAO,CAAC,IAAoC;AACzF,mBAAmB,mBAAO,CAAC,IAAa;AACxC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD,mGAAmG,QAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,EAAE,GAAG,EAAE;AAChE;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;;;;;;;;AC5Ja;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,wBAAwB,mBAAO,CAAC,IAAmB;AACnD,mDAAkD,EAAE,qCAAqC,6CAA6C,EAAC;AACvI,aAAa,mBAAO,CAAC,IAAS;AAC9B;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,0BAA0B;AACrD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA,0BAA0B;AAC1B;AACA,wBAAwB;AACxB;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,sDAAsD,mBAAO,CAAC,IAAyD;AACvH,yDAAyD,mBAAO,CAAC,IAA4D;AAC7H;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,iCAAiC,mBAAO,CAAC,IAA4B;AACrE,4DAA2D,EAAE,qCAAqC,+DAA+D,EAAC;AAClK;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mDAAmD;AACnD,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,GAAG;AACpC;AACA,yBAAyB,KAAK;AAC9B,2BAA2B,UAAU,GAAG;AACxC,yBAAyB;AACzB,wBAAwB,QAAQ;AAChC;AACA,oCAAoC,SAAS;AAC7C,wBAAwB;AACxB;AACA;AACA;AACA,mFAAmF,OAAO;AAC1F;AACA;AACA,wCAAwC,EAAE,IAAI,GAAG,KAAK;AACtD,4CAA4C,SAAS;AACrD,+BAA+B;AAC/B;AACA,4BAA4B,WAAW,8CAA8C,OAAO;AAC5F;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,aAAa;AACb;AACA,cAAc,OAAO,QAAQ;AAC7B,eAAe,MAAM,OAAO;AAC5B,aAAa,QAAQ,MAAM;AAC3B,aAAa,QAAQ,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,QAAQ;AAC1C,4BAA4B,MAAM,MAAM;AACxC,mBAAmB;AACnB;AACA;AACA,oCAAoC,iBAAiB,IAAI;AACzD;AACA;AACA;AACA,8BAA8B,MAAM,KAAK;AACzC,4BAA4B,QAAQ,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,iBAAiB,MAAM;AAC7D,+DAA+D,MAAM;AACrE;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,gCAAgC;AAChC,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;;;;;;;ACxGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD;AACtD,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qJAAqJ,kBAAkB;AACvK;AACA;AACA,qEAAqE,iBAAiB;AACtF;AACA;AACA;AACA,yJAAyJ,wCAAwC;AACjM;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,qBAAqB,mBAAO,CAAC,IAAe;AAC5C,oBAAoB,mBAAO,CAAC,IAAa;AACzC,0CAA0C,mBAAO,CAAC,GAA6C;AAC/F,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oCAAoC,mBAAO,CAAC,IAAuC;AACnF;AACA,8GAA8G;AAC9G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,sBAAsB,mBAAO,CAAC,IAAiB;AAC/C,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC;AACvC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC;AACvC;;;;;;;;ACzCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,iBAAiB,mBAAO,CAAC,IAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;AAC5B;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,oBAAoB,mBAAO,CAAC,IAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;ACxCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,iBAAiB,mBAAO,CAAC,IAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;AC5Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C;AAC1C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,qBAAqB,mBAAO,CAAC,IAAkB;AAC/C,iBAAiB,mBAAO,CAAC,IAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C;AAC1C;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,qBAAqB,mBAAO,CAAC,IAAkB;AAC/C,iBAAiB,mBAAO,CAAC,IAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,iBAAiB,mBAAO,CAAC,IAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD,iBAAiB;AACjB;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA,sGAAsG,SAAS,oBAAoB,QAAQ;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;ACpDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2CAA2C;AAC3C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2CAA2C;AAC3C;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uBAAuB,mBAAO,CAAC,IAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC;AAChC;;;;;;;;ACxCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2CAA2C,GAAG,kCAAkC,GAAG,gCAAgC,GAAG,uCAAuC,GAAG,kCAAkC,GAAG,4BAA4B,GAAG,0CAA0C,GAAG,iCAAiC,GAAG,iCAAiC,GAAG,8BAA8B;AACvX,+BAA+B,mBAAO,CAAC,IAA0B;AACjE,0DAAyD,EAAE,qCAAqC,2DAA2D,EAAC;AAC5J,kCAAkC,mBAAO,CAAC,IAA6B;AACvE,6DAA4D,EAAE,qCAAqC,iEAAiE,EAAC;AACrK,kCAAkC,mBAAO,CAAC,IAA6B;AACvE,6DAA4D,EAAE,qCAAqC,iEAAiE,EAAC;AACrK,2CAA2C,mBAAO,CAAC,IAAsC;AACzF,sEAAqE,EAAE,qCAAqC,mFAAmF,EAAC;AAChM,6BAA6B,mBAAO,CAAC,IAAwB;AAC7D,wDAAuD,EAAE,qCAAqC,uDAAuD,EAAC;AACtJ,mCAAmC,mBAAO,CAAC,IAA8B;AACzE,8DAA6D,EAAE,qCAAqC,mEAAmE,EAAC;AACxK,wCAAwC,mBAAO,CAAC,GAAmC;AACnF,mEAAkE,EAAE,qCAAqC,6EAA6E,EAAC;AACvL,iCAAiC,mBAAO,CAAC,IAA4B;AACrE,4DAA2D,EAAE,qCAAqC,+DAA+D,EAAC;AAClK,mCAAmC,mBAAO,CAAC,IAA8B;AACzE,8DAA6D,EAAE,qCAAqC,mEAAmE,EAAC;AACxK,4CAA4C,mBAAO,CAAC,IAAuC;AAC3F,uEAAsE,EAAE,qCAAqC,qFAAqF,EAAC;AACnM;;;;;;;;ACvBa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,iBAAiB,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,YAAY,GAAG,gBAAgB,GAAG,aAAa;AAC5J,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6CAA4C,EAAE,qCAAqC,0CAA0C,EAAC;AAC9H,qDAAoD,EAAE,qCAAqC,4CAA4C,EAAC;AACxI,4CAA2C,EAAE,qCAAqC,yCAAyC,EAAC;AAC5H,aAAa,mBAAO,CAAC,IAAS;AAC9B,2BAA2B,mBAAO,CAAC,IAA6B;AAChE,yCAAwC,EAAE,qCAAqC,sCAAsC,EAAC;AACtH,cAAc,mBAAO,CAAC,IAAS;AAC/B,4CAA2C,EAAE,qCAAqC,4BAA4B,EAAC;AAC/G,wCAAuC,EAAE,qCAAqC,wBAAwB,EAAC;AACvG,6CAA4C,EAAE,qCAAqC,6BAA6B,EAAC;AACjH,eAAe,mBAAO,CAAC,IAAU;AACjC,+CAA8C,EAAE,qCAAqC,gCAAgC,EAAC;AACtH;;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,sCAAsC,mBAAO,CAAC,GAAqD;AACnG,gDAAgD,mBAAO,CAAC,IAA+D;AACvH,8CAA8C,mBAAO,CAAC,IAA6D;AACnH,yCAAyC,mBAAO,CAAC,IAAkD;AACnG,uCAAuC,mBAAO,CAAC,GAAgD;AAC/F,gBAAgB,mBAAO,CAAC,IAAS;AACjC,6CAA6C,mBAAO,CAAC,IAA4D;AACjH,gCAAgC,mBAAO,CAAC,IAAyC;AACjF,kDAAkD,mBAAO,CAAC,IAAiE;AAC3H,qCAAqC,mBAAO,CAAC,IAA8C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;;;;;;;AC5Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,6CAA6C,mBAAO,CAAC,IAAoC;AACzF,4BAA4B,mBAAO,CAAC,IAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;AC7Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,8BAA8B;AAC7D,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA,YAAY,sBAAsB;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA,YAAY,MAAM;AAClB;AACA;AACA,4BAA4B;AAC5B;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+CAA+C;AAC/C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,sCAAsC,mBAAO,CAAC,GAA+B;AAC7E,yBAAyB,mBAAO,CAAC,IAA0B;AAC3D;AACA;AACA;AACA,KAAK,WAAW;AAChB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,mDAAmD,aAAa,cAAc,OAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,8BAA8B,GAAG,gCAAgC,GAAG,uBAAuB,GAAG,yBAAyB,GAAG,6BAA6B,GAAG,sCAAsC,GAAG,mCAAmC;AACvQ,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA,IAAI;AACJ;AACA;AACA,SAAS,aAAa;AACtB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,wBAAwB,KAAK;AAC7B,KAAK;AACL;AACA,sCAAsC;AACtC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;AChGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C;AAC7C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC,sCAAsC,mBAAO,CAAC,GAA+B;AAC7E;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA,QAAQ;AACR;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,mDAAmD,aAAa,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C;AAC5C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,uBAAuB,mBAAO,CAAC,IAAuB;AACtD,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,4CAA4C;AAC5C;;;;;;;;AC9Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C;AAC1C,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gBAAgB,mBAAO,CAAC,IAAa;AACrC,sCAAsC,mBAAO,CAAC,GAA+B;AAC7E,yBAAyB,mBAAO,CAAC,IAA0B;AAC3D;AACA;AACA,+CAA+C,WAAW;AAC1D,wCAAwC,WAAW;AACnD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6CAA6C;AAC7C,sCAAsC,mBAAO,CAAC,IAA6B;AAC3E,uBAAuB,mBAAO,CAAC,IAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,6CAA6C;AAC7C;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uBAAuB,mBAAO,CAAC,IAAuB;AACtD,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC,sCAAsC,mBAAO,CAAC,GAAyD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sCAAsC;AACtC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uBAAuB,mBAAO,CAAC,IAAuB;AACtD,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;;;;;;;;ACnCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uBAAuB,mBAAO,CAAC,IAAuB;AACtD,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC,sCAAsC,mBAAO,CAAC,GAAyD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,oCAAoC;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,uBAAuB,mBAAO,CAAC,IAAuB;AACtD,yBAAyB,mBAAO,CAAC,IAAsB;AACvD,gBAAgB,mBAAO,CAAC,IAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,0BAA0B,GAAG,cAAc,OAAO,4CAA4C;AAC9F;AACA;AACA,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;;;;;;;;AChEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,iBAAiB;AACvH,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;;;;;;;;AC/Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC;AACnC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;;;;;;;AC/Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC;AACxC,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,sBAAsB,mBAAO,CAAC,IAAgB;AAC9C;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB,KAAK,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC;AACvC,uBAAuB,mBAAO,CAAC,IAA0B;AACzD,sBAAsB,mBAAO,CAAC,IAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC,GAAG,wCAAwC;AAClF,yCAAyC,mBAAO,CAAC,IAAoC;AACrF,oEAAmE,EAAE,qCAAqC,+EAA+E,EAAC;AAC1L,wCAAwC,mBAAO,CAAC,IAAmC;AACnF,mEAAkE,EAAE,qCAAqC,6EAA6E,EAAC;AACvL;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC;AACA;AACA,kCAAkC,MAAM,cAAc,EAAE,SAAS;AACjE;;;;;;;;ACNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,gBAAgB;AAClC,yCAAyC,mBAAO,CAAC,IAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,uCAAuC;AACvC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;ACzEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oCAAoC,mBAAO,CAAC,IAAuC;AACnF,uCAAuC,mBAAO,CAAC,IAA0C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;AC3Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,uBAAuB,mBAAO,CAAC,IAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,sDAAsD;AAClJ;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;;;;;;;ACxCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4FAA4F,sDAAsD;AAClJ;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,6BAA6B,mBAAO,CAAC,IAA+B;AACpE,6BAA6B,mBAAO,CAAC,IAA+B;AACpE,+BAA+B,mBAAO,CAAC,IAAiC;AACxE,+BAA+B,mBAAO,CAAC,IAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAiB;AACvC;AACA;AACA;AACA;AACA,QAAQ,4BAA4B,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,QAAQ,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;;;;;;;;ACjGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAiB;AACvC,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA,uBAAuB,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,QAAQ,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;AC9Sa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAiB;AACvC,gBAAgB,mBAAO,CAAC,IAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,QAAQ,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;AC9Ka;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,yCAAyC,mBAAO,CAAC,IAAgC;AACjF,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sBAAsB,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,QAAQ,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;;;;;;;;ACjGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5Ba;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,qBAAqB;AACrJ,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,qBAAqB;AACrB,qBAAqB;AACrB,uBAAuB;AACvB,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,cAAc;AACrI,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;;;;;;;AC5Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,oBAAoB,mBAAO,CAAC,IAAe;AAC3C,+CAA8C,EAAE,qCAAqC,qCAAqC,EAAC;AAC3H;;;;;;;;ACLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,6BAA6B,mBAAO,CAAC,IAAuB;AAC5D,sBAAsB,mBAAO,CAAC,IAAgB;AAC9C,mBAAmB,mBAAO,CAAC,IAAa;AACxC,sBAAsB,mBAAO,CAAC,IAAgB;AAC9C,sBAAsB,mBAAO,CAAC,IAAgB;AAC9C,qCAAqC,mBAAO,CAAC,IAAkD;AAC/F,wBAAwB,mBAAO,CAAC,GAAkB;AAClD,oBAAoB,mBAAO,CAAC,IAAc;AAC1C,qBAAqB,mBAAO,CAAC,IAAe;AAC5C,gBAAgB,mBAAO,CAAC,IAAU;AAClC,8BAA8B,mBAAO,CAAC,IAA6B;AACnE,sCAAsC,mBAAO,CAAC,IAAoD;AAClG,yBAAyB,mBAAO,CAAC,IAA0B;AAC3D,wBAAwB,mBAAO,CAAC,IAA0B;AAC1D,gBAAgB,mBAAO,CAAC,IAAU;AAClC,cAAc,mBAAO,CAAC,IAAc;AACpC,kBAAkB,mBAAO,CAAC,GAAY;AACtC,2BAA2B,mBAAO,CAAC,IAAoB;AACvD,wBAAwB,mBAAO,CAAC,IAAiB;AACjD,eAAe,mBAAO,CAAC,IAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sIAAsI;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,YAAY;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,iDAAiD,KAAK;AACtD,iBAAiB;AACjB;AACA;AACA,6CAA6C;AAC7C,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,sCAAsC,qCAAqC;AAC3E,iBAAiB;AACjB;AACA,sDAAsD,YAAY;AAClE,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,cAAc,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB;AACnB;;;;;;;;ACnea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,0BAA0B;AACnD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,0BAA0B,GAAG,iBAAiB,GAAG,+BAA+B,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,iBAAiB,GAAG,iCAAiC;AAC9O,iCAAiC;AACjC;AACA;AACA,oBAAoB,IAAI,MAAM,iBAAiB;AAC/C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,sBAAsB,wCAAwC;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,qBAAqB,EAAE,IAAI,MAAM,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,2CAA2C,MAAM,IAAI,MAAM;AAC3D;AACA,oBAAoB;AACpB;;;;;;;;ACxEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;;;;;;;;ACFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,gCAAgC;AACpE,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,gCAAgC,mBAAO,CAAC,IAAuB;AAC/D,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;AC1Ca;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,eAAe,GAAG,YAAY;AAClD,2BAA2B,mBAAO,CAAC,IAA6B;AAChE,wCAAuC,EAAE,qCAAqC,qCAAqC,EAAC;AACpH,2CAA0C,EAAE,qCAAqC,wCAAwC,EAAC;AAC1H,6CAA4C,EAAE,qCAAqC,0CAA0C,EAAC;AAC9H,aAAa,mBAAO,CAAC,IAAY;AACjC,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,IAAQ;AAC7B,aAAa,mBAAO,CAAC,IAAa;AAClC;;;;;;;;ACzBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC,GAAG,gCAAgC,GAAG,gCAAgC;AAC9G,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,oCAAoC,mCAAmC;AACvE,oCAAoC,KAAK,WAAW,KAAK;AACzD,gCAAgC,KAAK;AACrC;AACA,6CAA6C,YAAY;AACzD,sBAAsB,QAAQ,EAAE,QAAQ,EAAE,QAAQ;AAClD;AACA,wCAAwC,YAAY;AACpD,gBAAgB,QAAQ,EAAE,QAAQ,EAAE,QAAQ;AAC5C;AACA,gCAAgC;AAChC;AACA,mBAAmB,MAAM,MAAM,YAAY,wCAAwC,QAAQ;AAC3F;AACA,gCAAgC;AAChC,wCAAwC;AACxC;AACA;AACA,8DAA8D;AAC9D,oCAAoC,KAAK;AACzC,4BAA4B;AAC5B;AACA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,cAAc,WAAW;AACzB,0BAA0B,IAAI;AAC9B,KAAK;AACL;AACA;AACA,mBAAmB,QAAQ,mBAAmB,yCAAyC,QAAQ,WAAW;AAC1G;AACA,KAAK;AACL;AACA;AACA,mBAAmB,QAAQ,mEAAmE,WAAW;AACzG;AACA,KAAK;AACL;AACA;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,0BAA0B,GAAG,wBAAwB;AACjP,6BAA6B,mBAAO,CAAC,IAA6B;AAClE,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,eAAe,GAAG,iBAAiB,GAAG,eAAe,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,mBAAmB;AAC7P,6BAA6B,mBAAO,CAAC,IAA6B;AAClE;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,wBAAwB;AACxB;AACA,sBAAsB;AACtB;AACA,oBAAoB;AACpB;AACA,kBAAkB;AAClB;;;;;;;;AC7Ba;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,uCAAuC,mBAAO,CAAC,IAAiB;AAChE,eAAe;AACf;;;;;;;;ACRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;ACba;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW;AACX,+BAA+B,mBAAO,CAAC,IAAwB;AAC/D,sBAAsB,mBAAO,CAAC,IAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK,MAAM,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;;;;;;;AC5kBa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,KAAK;AACL;AACA,uBAAuB,EAAE,IAAI,GAAG,IAAI,GAAG;AACvC,uBAAuB,EAAE,IAAI,GAAG;AAChC;AACA,uBAAuB,GAAG;AAC1B,uBAAuB,GAAG;AAC1B,uBAAuB,GAAG;AAC1B,uBAAuB,EAAE,IAAI,EAAE;AAC/B,uBAAuB,GAAG;AAC1B,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,GAAG;AAC1B,sBAAsB,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;ACvJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,qBAAqB,gCAAgC,IAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;;;;;;ACrBa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,cAAc,GAAG,WAAW,GAAG,iBAAiB,GAAG,aAAa,GAAG,cAAc,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,cAAc,GAAG,gBAAgB,GAAG,WAAW,GAAG,iBAAiB;AACnN,0CAA0C,mBAAO,CAAC,GAAiB;AACnE,kCAAkC,mBAAO,CAAC,IAA2B;AACrE,iBAAiB,mBAAO,CAAC,IAAU;AACnC,oBAAoB,mBAAO,CAAC,IAAa;AACzC,sBAAsB,mBAAO,CAAC,IAAe;AAC7C,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,UAAU;AACvB;AACA;AACA,WAAW;AACX,qBAAqB;AACrB,gBAAgB;AAChB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA,qCAAqC;AACrC,cAAc;AACd,wBAAwB;AACxB,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,SAAS;AACT,kCAAkC;AAClC,gCAAgC;AAChC,sCAAsC;AACtC;AACA,sCAAsC;AACtC,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,0BAA0B;AAC1B;AACA,KAAK,IAAI;AACT,KAAK,GAAG;AACR,KAAK,KAAK;AACV,KAAK,IAAI,IAAI,EAAE;AACf,KAAK,IAAI,EAAE,IAAI;AACf;AACA;AACA,KAAK,IAAI,OAAO,IAAI;AACpB,KAAK,EAAE,OAAO,EAAE;AAChB,0CAA0C;AAC1C;AACA;AACA;AACA,+BAA+B,QAAQ,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,cAAc;AACd,wBAAwB;AACxB,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB;AACvB;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ,iCAAiC;AACzC,QAAQ,2BAA2B;AACnC,QAAQ,8BAA8B;AACtC;AACA,QAAQ,qCAAqC;AAC7C;AACA;AACA,wBAAwB,0BAA0B;AAClD,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA,wEAAwE,oBAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe,mBAAO,CAAC,IAAU;AACjC,uCAAsC,EAAE,qCAAqC,wBAAwB,EAAC;AACtG,kBAAkB,mBAAO,CAAC,IAAa;AACvC,0CAAyC,EAAE,qCAAqC,8BAA8B,EAAC;AAC/G,oBAAoB,mBAAO,CAAC,IAAe;AAC3C,4CAA2C,EAAE,qCAAqC,kCAAkC,EAAC;AACrH;AACA,qBAAqB;AACrB,2BAA2B;AAC3B,wBAAwB;AACxB,0BAA0B;AAC1B;;;;;;;;ACl/Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA,kDAAkD,aAAa;AAC/D;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC,IAAI;AAC3D;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,oGAAoG,SAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;UCzPA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;ACNA,uDAAuE;AACvE,kEAKgD;AAChD,qDAA8D;AAc9D,MAAM,IAAI,GAAG,qrkDAAY,CAAC;AAC1B,MAAM,OAAO,GAAG,ogpKAAe,CAAC;AAChC,MAAM,OAAO,GAAG,ovqaAAe,CAAC;AAChC,MAAM,kBAAkB,GAAG,m2nMAA2B,CAAC;AACvD,MAAM,OAAO,GAAG,inkGAAe,CAAC;AAEhC,MAAM,MAAM,GAAG,IAAqB,CAAC;AACrC,MAAM,UAAU,GAAG,iDAAa,EAAC,MAAM,CAAC,CAAC;AACzC,MAAM,UAAU,GAAG,IAAI,mCAAgB,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;AACxD,MAAM,YAAY,GAAiB;IACjC,EAAE,EAAE,UAAU;IACd,GAAG,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;IAC/B,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE;QAC5B,MAAM,UAAU,GAAG,uCAAc,EAAC,EAAE,CAAC,CAAC;QACtC,MAAM,OAAO,GAAG,MAAM,iCAAQ,EAAC,GAAG,EAAE,UAAU,CAAC,CAAC;QAChD,OAAO;YACL,OAAO,EAAE,OAAO;YAChB,QAAQ,EAAE,EAAE;YACZ,MAAM,EAAE,iDAAiB;YACzB,OAAO;SACR,CAAC;IACJ,CAAC;IACD,WAAW,EAAE;QACX,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC,OAAO;QAC5B,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC,OAAO;QAC5B,IAAI,EAAE,KAAK,IAAI,EAAE,CAAC,IAAI;QACtB,kBAAkB,EAAE,KAAK,IAAI,EAAE,CAAC,kBAAkB;KACnD;IACD,iBAAiB,EAAE;QACjB,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC,OAAO;KAC7B;CACF,CAAC;AAEF,+CAAW,EAAC,MAAM,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC","sources":["../../../../node_modules/balanced-match/index.js","../../../../node_modules/brace-expansion/index.js","../../../../node_modules/cross-fetch/dist/browser-ponyfill.js","../../../../node_modules/isarray/index.js","../../../../node_modules/isobject/index.js","../../../../node_modules/jsonc-parser/lib/esm/impl/scanner.js","../../../../node_modules/jsonc-parser/lib/esm/impl/string-intern.js","../../../../node_modules/jsonc-parser/lib/esm/impl/format.js","../../../../node_modules/jsonc-parser/lib/esm/impl/parser.js","../../../../node_modules/jsonc-parser/lib/esm/impl/edit.js","../../../../node_modules/jsonc-parser/lib/esm/main.js","../../../../node_modules/line-column/lib/line-column.js","../../../../node_modules/lodash/_Hash.js","../../../../node_modules/lodash/_ListCache.js","../../../../node_modules/lodash/_Map.js","../../../../node_modules/lodash/_MapCache.js","../../../../node_modules/lodash/_Symbol.js","../../../../node_modules/lodash/_arrayMap.js","../../../../node_modules/lodash/_arrayReduce.js","../../../../node_modules/lodash/_asciiToArray.js","../../../../node_modules/lodash/_asciiWords.js","../../../../node_modules/lodash/_assignValue.js","../../../../node_modules/lodash/_assocIndexOf.js","../../../../node_modules/lodash/_baseAssignValue.js","../../../../node_modules/lodash/_baseGet.js","../../../../node_modules/lodash/_baseGetTag.js","../../../../node_modules/lodash/_baseIsNative.js","../../../../node_modules/lodash/_basePropertyOf.js","../../../../node_modules/lodash/_baseSet.js","../../../../node_modules/lodash/_baseSlice.js","../../../../node_modules/lodash/_baseToString.js","../../../../node_modules/lodash/_baseUnset.js","../../../../node_modules/lodash/_castPath.js","../../../../node_modules/lodash/_castSlice.js","../../../../node_modules/lodash/_coreJsData.js","../../../../node_modules/lodash/_createCaseFirst.js","../../../../node_modules/lodash/_createCompounder.js","../../../../node_modules/lodash/_deburrLetter.js","../../../../node_modules/lodash/_defineProperty.js","../../../../node_modules/lodash/_freeGlobal.js","../../../../node_modules/lodash/_getMapData.js","../../../../node_modules/lodash/_getNative.js","../../../../node_modules/lodash/_getRawTag.js","../../../../node_modules/lodash/_getValue.js","../../../../node_modules/lodash/_hasUnicode.js","../../../../node_modules/lodash/_hasUnicodeWord.js","../../../../node_modules/lodash/_hashClear.js","../../../../node_modules/lodash/_hashDelete.js","../../../../node_modules/lodash/_hashGet.js","../../../../node_modules/lodash/_hashHas.js","../../../../node_modules/lodash/_hashSet.js","../../../../node_modules/lodash/_isIndex.js","../../../../node_modules/lodash/_isKey.js","../../../../node_modules/lodash/_isKeyable.js","../../../../node_modules/lodash/_isMasked.js","../../../../node_modules/lodash/_listCacheClear.js","../../../../node_modules/lodash/_listCacheDelete.js","../../../../node_modules/lodash/_listCacheGet.js","../../../../node_modules/lodash/_listCacheHas.js","../../../../node_modules/lodash/_listCacheSet.js","../../../../node_modules/lodash/_mapCacheClear.js","../../../../node_modules/lodash/_mapCacheDelete.js","../../../../node_modules/lodash/_mapCacheGet.js","../../../../node_modules/lodash/_mapCacheHas.js","../../../../node_modules/lodash/_mapCacheSet.js","../../../../node_modules/lodash/_memoizeCapped.js","../../../../node_modules/lodash/_nativeCreate.js","../../../../node_modules/lodash/_objectToString.js","../../../../node_modules/lodash/_parent.js","../../../../node_modules/lodash/_root.js","../../../../node_modules/lodash/_stringToArray.js","../../../../node_modules/lodash/_stringToPath.js","../../../../node_modules/lodash/_toKey.js","../../../../node_modules/lodash/_toSource.js","../../../../node_modules/lodash/_unicodeToArray.js","../../../../node_modules/lodash/_unicodeWords.js","../../../../node_modules/lodash/camelCase.js","../../../../node_modules/lodash/capitalize.js","../../../../node_modules/lodash/deburr.js","../../../../node_modules/lodash/eq.js","../../../../node_modules/lodash/isArray.js","../../../../node_modules/lodash/isFunction.js","../../../../node_modules/lodash/isObject.js","../../../../node_modules/lodash/isObjectLike.js","../../../../node_modules/lodash/isSymbol.js","../../../../node_modules/lodash/kebabCase.js","../../../../node_modules/lodash/last.js","../../../../node_modules/lodash/memoize.js","../../../../node_modules/lodash/set.js","../../../../node_modules/lodash/snakeCase.js","../../../../node_modules/lodash/toString.js","../../../../node_modules/lodash/unset.js","../../../../node_modules/lodash/upperFirst.js","../../../../node_modules/lodash/words.js","../../../../node_modules/ohm-js/dist/ohm.esm.js","../../../../node_modules/ohm-js/extras/VisitorFamily.js","../../../../node_modules/ohm-js/extras/index.js","../../../../node_modules/ohm-js/extras/semantics-toAST.js","../../../../node_modules/ohm-js/src/common.js","../.././src/common/VsCodeFileSystem.ts","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/objects.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/strings.js","../../../../node_modules/vscode-json-languageservice/node_modules/vscode-languageserver-types/lib/esm/main.js","../../../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js","../../../../node_modules/@vscode/l10n/dist/browser.js","../../../../node_modules/vscode-json-languageservice/lib/esm/parser/jsonParser.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/json.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonCompletion.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonHover.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonValidation.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/colors.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/configuration.js","../../../../node_modules/vscode-uri/lib/esm/index.mjs","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/glob.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonFolding.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/format.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/propertyTree.js","../../../../node_modules/vscode-json-languageservice/lib/esm/utils/sort.js","../../../../node_modules/vscode-json-languageservice/lib/esm/services/jsonLinks.js","../../../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js","../../../../node_modules/vscode-jsonrpc/browser.js","../../../../node_modules/vscode-jsonrpc/lib/browser/main.js","../../../../node_modules/vscode-jsonrpc/lib/browser/ril.js","../../../../node_modules/vscode-jsonrpc/lib/common/api.js","../../../../node_modules/vscode-jsonrpc/lib/common/cancellation.js","../../../../node_modules/vscode-jsonrpc/lib/common/connection.js","../../../../node_modules/vscode-jsonrpc/lib/common/disposable.js","../../../../node_modules/vscode-jsonrpc/lib/common/events.js","../../../../node_modules/vscode-jsonrpc/lib/common/is.js","../../../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js","../../../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js","../../../../node_modules/vscode-jsonrpc/lib/common/messageReader.js","../../../../node_modules/vscode-jsonrpc/lib/common/messageWriter.js","../../../../node_modules/vscode-jsonrpc/lib/common/messages.js","../../../../node_modules/vscode-jsonrpc/lib/common/ral.js","../../../../node_modules/vscode-jsonrpc/lib/common/semaphore.js","../../../../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js","../../../../node_modules/vscode-languageserver-protocol/browser.js","../../../../node_modules/vscode-languageserver-protocol/lib/browser/main.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/api.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/connection.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/messages.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js","../../../../node_modules/vscode-languageserver-protocol/lib/common/utils/is.js","../../../../node_modules/vscode-languageserver-types/lib/esm/main.js","../../../../node_modules/vscode-languageserver/browser.js","../../../../node_modules/vscode-languageserver/lib/browser/main.js","../../../../node_modules/vscode-languageserver/lib/common/api.js","../../../../node_modules/vscode-languageserver/lib/common/callHierarchy.js","../../../../node_modules/vscode-languageserver/lib/common/configuration.js","../../../../node_modules/vscode-languageserver/lib/common/diagnostic.js","../../../../node_modules/vscode-languageserver/lib/common/fileOperations.js","../../../../node_modules/vscode-languageserver/lib/common/inlayHint.js","../../../../node_modules/vscode-languageserver/lib/common/inlineValue.js","../../../../node_modules/vscode-languageserver/lib/common/linkedEditingRange.js","../../../../node_modules/vscode-languageserver/lib/common/moniker.js","../../../../node_modules/vscode-languageserver/lib/common/notebook.js","../../../../node_modules/vscode-languageserver/lib/common/progress.js","../../../../node_modules/vscode-languageserver/lib/common/semanticTokens.js","../../../../node_modules/vscode-languageserver/lib/common/server.js","../../../../node_modules/vscode-languageserver/lib/common/showDocument.js","../../../../node_modules/vscode-languageserver/lib/common/textDocuments.js","../../../../node_modules/vscode-languageserver/lib/common/typeHierarchy.js","../../../../node_modules/vscode-languageserver/lib/common/utils/is.js","../../../../node_modules/vscode-languageserver/lib/common/utils/uuid.js","../../../../node_modules/vscode-languageserver/lib/common/workspaceFolder.js","../../../../node_modules/vscode-uri/lib/umd/index.js","../../../liquid-html-parser/dist/conditional-comment.js","../../../liquid-html-parser/dist/errors.js","../../../liquid-html-parser/dist/grammar.js","../../../liquid-html-parser/dist/index.js","../../../liquid-html-parser/dist/stage-1-cst.js","../../../liquid-html-parser/dist/stage-2-ast.js","../../../liquid-html-parser/dist/types.js","../../../liquid-html-parser/dist/utils.js","../../../liquid-html-parser/grammar/liquid-html.ohm.js","../../../theme-check-common/dist/AbstractFileSystem.js","../../../theme-check-common/dist/AugmentedThemeDocset.js","../../../theme-check-common/dist/JSONValidator.js","../../../theme-check-common/dist/checks/app-block-missing-schema/index.js","../../../theme-check-common/dist/checks/app-block-valid-tags/index.js","../../../theme-check-common/dist/checks/asset-preload/index.js","../../../theme-check-common/dist/checks/asset-size-app-block-css/index.js","../../../theme-check-common/dist/checks/asset-size-app-block-javascript/index.js","../../../theme-check-common/dist/checks/asset-size-css/index.js","../../../theme-check-common/dist/checks/asset-size-javascript/index.js","../../../theme-check-common/dist/checks/block-id-usage/index.js","../../../theme-check-common/dist/checks/capture-on-content-for-block/index.js","../../../theme-check-common/dist/checks/cdn-preconnect/index.js","../../../theme-check-common/dist/checks/content-for-header-modification/index.js","../../../theme-check-common/dist/checks/deprecate-bgsizes/index.js","../../../theme-check-common/dist/checks/deprecate-lazysizes/index.js","../../../theme-check-common/dist/checks/deprecated-filter/fixes.js","../../../theme-check-common/dist/checks/deprecated-filter/index.js","../../../theme-check-common/dist/checks/deprecated-tag/index.js","../../../theme-check-common/dist/checks/empty-block-content/index.js","../../../theme-check-common/dist/checks/img-width-and-height/index.js","../../../theme-check-common/dist/checks/index.js","../../../theme-check-common/dist/checks/json-missing-block/index.js","../../../theme-check-common/dist/checks/json-missing-block/missing-block-utils.js","../../../theme-check-common/dist/checks/json-syntax-error/index.js","../../../theme-check-common/dist/checks/liquid-free-settings/index.js","../../../theme-check-common/dist/checks/liquid-html-syntax-error/index.js","../../../theme-check-common/dist/checks/matching-translations/index.js","../../../theme-check-common/dist/checks/missing-asset/index.js","../../../theme-check-common/dist/checks/missing-template/index.js","../../../theme-check-common/dist/checks/pagination-size/index.js","../../../theme-check-common/dist/checks/parser-blocking-script/index.js","../../../theme-check-common/dist/checks/parser-blocking-script/suggestions.js","../../../theme-check-common/dist/checks/remote-asset/index.js","../../../theme-check-common/dist/checks/required-layout-theme-object/index.js","../../../theme-check-common/dist/checks/schema-presets-block-order/index.js","../../../theme-check-common/dist/checks/schema-presets-static-blocks/index.js","../../../theme-check-common/dist/checks/translation-key-exists/index.js","../../../theme-check-common/dist/checks/unclosed-html-element/index.js","../../../theme-check-common/dist/checks/undefined-object/index.js","../../../theme-check-common/dist/checks/unique-settings-id/index.js","../../../theme-check-common/dist/checks/unique-static-block-id/index.js","../../../theme-check-common/dist/checks/unknown-filter/index.js","../../../theme-check-common/dist/checks/unused-assign/index.js","../../../theme-check-common/dist/checks/utils.js","../../../theme-check-common/dist/checks/valid-block-target/index.js","../../../theme-check-common/dist/checks/valid-content-for-arguments/index.js","../../../theme-check-common/dist/checks/valid-html-translation/index.js","../../../theme-check-common/dist/checks/valid-json/index.js","../../../theme-check-common/dist/checks/valid-local-blocks/index.js","../../../theme-check-common/dist/checks/valid-local-blocks/valid-block-utils.js","../../../theme-check-common/dist/checks/valid-render-snippet-params/index.js","../../../theme-check-common/dist/checks/valid-schema-name/index.js","../../../theme-check-common/dist/checks/valid-schema/index.js","../../../theme-check-common/dist/checks/valid-settings-key/index.js","../../../theme-check-common/dist/checks/valid-static-block-type/index.js","../../../theme-check-common/dist/checks/valid-visible-if/index.js","../../../theme-check-common/dist/checks/valid-visible-if/visible-if-utils.js","../../../theme-check-common/dist/checks/variable-name/index.js","../../../theme-check-common/dist/context-utils.js","../../../theme-check-common/dist/disabled-checks/index.js","../../../theme-check-common/dist/find-root.js","../../../theme-check-common/dist/fixes/apply-fix-to-string.js","../../../theme-check-common/dist/fixes/autofix.js","../../../theme-check-common/dist/fixes/correctors/index.js","../../../theme-check-common/dist/fixes/correctors/json-corrector.js","../../../theme-check-common/dist/fixes/correctors/string-corrector.js","../../../theme-check-common/dist/fixes/index.js","../../../theme-check-common/dist/fixes/utils.js","../../../theme-check-common/dist/ignore.js","../../../theme-check-common/dist/index.js","../../../theme-check-common/dist/json.js","../../../theme-check-common/dist/jsonc/parse.js","../../../theme-check-common/dist/jsonc/types.js","../../../theme-check-common/dist/liquid-doc/liquidDoc.js","../../../theme-check-common/dist/liquid-doc/utils.js","../../../theme-check-common/dist/path.js","../../../theme-check-common/dist/to-schema.js","../../../theme-check-common/dist/to-source-code.js","../../../theme-check-common/dist/types.js","../../../theme-check-common/dist/types/schema-prop-factory.js","../../../theme-check-common/dist/types/schemas/index.js","../../../theme-check-common/dist/types/schemas/setting.js","../../../theme-check-common/dist/types/theme-liquid-docs.js","../../../theme-check-common/dist/types/theme-schemas.js","../../../theme-check-common/dist/utils/array.js","../../../theme-check-common/dist/utils/block.js","../../../theme-check-common/dist/utils/error.js","../../../theme-check-common/dist/utils/file-utils.js","../../../theme-check-common/dist/utils/index.js","../../../theme-check-common/dist/utils/indexBy.js","../../../theme-check-common/dist/utils/markup.js","../../../theme-check-common/dist/utils/memo.js","../../../theme-check-common/dist/utils/object.js","../../../theme-check-common/dist/utils/position.js","../../../theme-check-common/dist/utils/types.js","../../../theme-check-common/dist/visitor.js","../../../theme-check-common/dist/visitors/index.js","../../../theme-check-common/dist/visitors/json.js","../../../theme-check-common/dist/visitors/liquid.js","../../../theme-language-server-browser/dist/index.js","../../../theme-language-server-common/dist/ClientCapabilities.js","../../../theme-language-server-common/dist/TypeSystem.js","../../../theme-language-server-common/dist/codeActions/BaseCodeActionsProvider.js","../../../theme-language-server-common/dist/codeActions/CodeActionsProvider.js","../../../theme-language-server-common/dist/codeActions/index.js","../../../theme-language-server-common/dist/codeActions/providers/FixAllProvider.js","../../../theme-language-server-common/dist/codeActions/providers/FixProvider.js","../../../theme-language-server-common/dist/codeActions/providers/SuggestionProvider.js","../../../theme-language-server-common/dist/codeActions/providers/index.js","../../../theme-language-server-common/dist/codeActions/providers/utils.js","../../../theme-language-server-common/dist/commands/BaseExecuteCommandProvider.js","../../../theme-language-server-common/dist/commands/ExecuteCommandProvider.js","../../../theme-language-server-common/dist/commands/index.js","../../../theme-language-server-common/dist/commands/providers/ApplyFixesProvider.js","../../../theme-language-server-common/dist/commands/providers/ApplySuggestionProvider.js","../../../theme-language-server-common/dist/commands/providers/RunChecksProvider.js","../../../theme-language-server-common/dist/commands/providers/index.js","../../../theme-language-server-common/dist/completions/CompletionsProvider.js","../../../theme-language-server-common/dist/completions/index.js","../../../theme-language-server-common/dist/completions/params/LiquidCompletionParams.js","../../../theme-language-server-common/dist/completions/params/fix.js","../../../theme-language-server-common/dist/completions/params/index.js","../../../theme-language-server-common/dist/completions/providers/ContentForBlockTypeCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/ContentForCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/ContentForParameterCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/FilterCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/FilterNamedParameterCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/HtmlAttributeCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/HtmlAttributeValueCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/HtmlTagCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/LiquidDocParamTypeCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/LiquidDocTagCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/LiquidTagsCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/ObjectAttributeCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/ObjectCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/RenderSnippetCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/RenderSnippetParameterCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/TranslationCompletionProvider.js","../../../theme-language-server-common/dist/completions/providers/common/CompletionItemProperties.js","../../../theme-language-server-common/dist/completions/providers/common/index.js","../../../theme-language-server-common/dist/completions/providers/data/contentForParameterCompletionOptions.js","../../../theme-language-server-common/dist/completions/providers/index.js","../../../theme-language-server-common/dist/diagnostics/DiagnosticsManager.js","../../../theme-language-server-common/dist/diagnostics/index.js","../../../theme-language-server-common/dist/diagnostics/offenseToDiagnostic.js","../../../theme-language-server-common/dist/diagnostics/runChecks.js","../../../theme-language-server-common/dist/docset/HtmlDocset.js","../../../theme-language-server-common/dist/docset/MarkdownRenderer.js","../../../theme-language-server-common/dist/docset/index.js","../../../theme-language-server-common/dist/documentHighlights/DocumentHighlightsProvider.js","../../../theme-language-server-common/dist/documentHighlights/providers/HtmlTagNameDocumentHighlightsProvider.js","../../../theme-language-server-common/dist/documentHighlights/providers/LiquidBlockTagDocumentHighlightsProvider.js","../../../theme-language-server-common/dist/documentHighlights/providers/index.js","../../../theme-language-server-common/dist/documentLinks/DocumentLinksProvider.js","../../../theme-language-server-common/dist/documentLinks/index.js","../../../theme-language-server-common/dist/documents/DocumentManager.js","../../../theme-language-server-common/dist/documents/index.js","../../../theme-language-server-common/dist/documents/types.js","../../../theme-language-server-common/dist/formatting/OnTypeFormattingProvider.js","../../../theme-language-server-common/dist/formatting/index.js","../../../theme-language-server-common/dist/formatting/providers/BracketsAutoclosingOnTypeFormattingProvider.js","../../../theme-language-server-common/dist/formatting/providers/HtmlElementAutoclosingOnTypeFormattingProvider.js","../../../theme-language-server-common/dist/hover/HoverProvider.js","../../../theme-language-server-common/dist/hover/index.js","../../../theme-language-server-common/dist/hover/providers/HtmlAttributeHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/HtmlAttributeValueHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/HtmlTagHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/LiquidDocTagHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/LiquidFilterHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/LiquidObjectAttributeHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/LiquidObjectHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/LiquidTagHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/RenderSnippetHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/RenderSnippetParameterHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/TranslationHoverProvider.js","../../../theme-language-server-common/dist/hover/providers/index.js","../../../theme-language-server-common/dist/index.js","../../../theme-language-server-common/dist/json/JSONContributions.js","../../../theme-language-server-common/dist/json/JSONLanguageService.js","../../../theme-language-server-common/dist/json/RequestContext.js","../../../theme-language-server-common/dist/json/completions/providers/BlockSettingsPropertyCompletionProvider.js","../../../theme-language-server-common/dist/json/completions/providers/BlockTypeCompletionProvider.js","../../../theme-language-server-common/dist/json/completions/providers/ReferencedBlockTypeCompletionProvider.js","../../../theme-language-server-common/dist/json/completions/providers/SchemaTranslationCompletionProvider.js","../../../theme-language-server-common/dist/json/completions/providers/SettingsPropertyCompletionProvider.js","../../../theme-language-server-common/dist/json/completions/providers/helpers/schemaSettings.js","../../../theme-language-server-common/dist/json/hover/providers/BlockSettingsHoverProvider.js","../../../theme-language-server-common/dist/json/hover/providers/SchemaTranslationHoverProvider.js","../../../theme-language-server-common/dist/json/hover/providers/SettingsHoverProvider.js","../../../theme-language-server-common/dist/json/hover/providers/TranslationPathHoverProvider.js","../../../theme-language-server-common/dist/json/utils.js","../../../theme-language-server-common/dist/linkedEditingRanges/LinkedEditingRangesProvider.js","../../../theme-language-server-common/dist/linkedEditingRanges/providers/EmptyHtmlTagLinkedRangesProvider.js","../../../theme-language-server-common/dist/linkedEditingRanges/providers/HtmlTagNameLinkedRangesProvider.js","../../../theme-language-server-common/dist/linkedEditingRanges/providers/index.js","../../../theme-language-server-common/dist/linkedEditingRanges/wordPattern.js","../../../theme-language-server-common/dist/progress.js","../../../theme-language-server-common/dist/rename/RenameProvider.js","../../../theme-language-server-common/dist/rename/providers/HtmlTagNameRenameProvider.js","../../../theme-language-server-common/dist/rename/providers/LiquidVariableRenameProvider.js","../../../theme-language-server-common/dist/renamed/RenameHandler.js","../../../theme-language-server-common/dist/renamed/handlers/AssetRenameHandler.js","../../../theme-language-server-common/dist/renamed/handlers/BlockRenameHandler.js","../../../theme-language-server-common/dist/renamed/handlers/SectionRenameHandler.js","../../../theme-language-server-common/dist/renamed/handlers/SnippetRenameHandler.js","../../../theme-language-server-common/dist/renamed/handlers/utils.js","../../../theme-language-server-common/dist/server/CachedFileSystem.js","../../../theme-language-server-common/dist/server/Configuration.js","../../../theme-language-server-common/dist/server/index.js","../../../theme-language-server-common/dist/server/safe.js","../../../theme-language-server-common/dist/server/startServer.js","../../../theme-language-server-common/dist/settings/index.js","../../../theme-language-server-common/dist/translations.js","../../../theme-language-server-common/dist/types.js","../../../theme-language-server-common/dist/utils/array.js","../../../theme-language-server-common/dist/utils/debounce.js","../../../theme-language-server-common/dist/utils/htmlTagNames.js","../../../theme-language-server-common/dist/utils/index.js","../../../theme-language-server-common/dist/utils/isCovered.js","../../../theme-language-server-common/dist/utils/liquidDoc.js","../../../theme-language-server-common/dist/utils/node.js","../../../theme-language-server-common/dist/utils/uri.js","../../../theme-language-server-common/dist/version.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/assert-valid-pattern.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/ast.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/brace-expressions.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/escape.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/index.js","../../../theme-check-common/node_modules/minimatch/dist/cjs/unescape.js","../../../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js","../../webpack/bootstrap","../../webpack/runtime/define property getters","../../webpack/runtime/global","../../webpack/runtime/hasOwnProperty shorthand","../../webpack/runtime/make namespace object","../.././src/browser/server.ts"],"sourcesContent":["'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n","// Save global object in a variable\nvar __global__ =\n(typeof globalThis !== 'undefined' && globalThis) ||\n(typeof self !== 'undefined' && self) ||\n(typeof global !== 'undefined' && global);\n// Create an object that extends from __global__ without the fetch function\nvar __globalThis__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = __global__.DOMException\n}\nF.prototype = __global__; // Needed for feature detection on whatwg-fetch's code\nreturn new F();\n})();\n// Wraps whatwg-fetch with a function scope to hijack the global object\n// \"globalThis\" that's going to be patched\n(function(globalThis) {\n\nvar irrelevant = (function (exports) {\n\n  var global =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global);\n\n  var support = {\n    searchParams: 'URLSearchParams' in global,\n    iterable: 'Symbol' in global && 'iterator' in Symbol,\n    blob:\n      'FileReader' in global &&\n      'Blob' in global &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in global,\n    arrayBuffer: 'ArrayBuffer' in global\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n      throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      /*\n        fetch-mock wraps the Response object in an ES6 Proxy to\n        provide useful test harness features such as flush. However, on\n        ES5 browsers without fetch or Proxy support pollyfills must be used;\n        the proxy-pollyfill is unable to proxy an attribute unless it exists\n        on the object before the Proxy is created. This change ensures\n        Response.bodyUsed exists on the instance, while maintaining the\n        semantic of setting Request.bodyUsed in the constructor before\n        _initBody is called.\n      */\n      this.bodyUsed = this.bodyUsed;\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          var isConsumed = consumed(this);\n          if (isConsumed) {\n            return isConsumed\n          }\n          if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n            return Promise.resolve(\n              this._bodyArrayBuffer.buffer.slice(\n                this._bodyArrayBuffer.byteOffset,\n                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n              )\n            )\n          } else {\n            return Promise.resolve(this._bodyArrayBuffer)\n          }\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n\n    if (this.method === 'GET' || this.method === 'HEAD') {\n      if (options.cache === 'no-store' || options.cache === 'no-cache') {\n        // Search for a '_' parameter in the query string\n        var reParamSearch = /([?&])_=[^&]*/;\n        if (reParamSearch.test(this.url)) {\n          // If it already exists then set the value with the current time\n          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());\n        } else {\n          // Otherwise add a new '_' parameter to the end with the current time\n          var reQueryString = /\\?/;\n          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();\n        }\n      }\n    }\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n    // https://github.com/github/fetch/issues/748\n    // https://github.com/zloirock/core-js/issues/751\n    preProcessedHeaders\n      .split('\\r')\n      .map(function(header) {\n        return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n      })\n      .forEach(function(line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n        if (key) {\n          var value = parts.join(':').trim();\n          headers.append(key, value);\n        }\n      });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = global.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        setTimeout(function() {\n          resolve(new Response(body, options));\n        }, 0);\n      };\n\n      xhr.onerror = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request failed'));\n        }, 0);\n      };\n\n      xhr.ontimeout = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request failed'));\n        }, 0);\n      };\n\n      xhr.onabort = function() {\n        setTimeout(function() {\n          reject(new exports.DOMException('Aborted', 'AbortError'));\n        }, 0);\n      };\n\n      function fixUrl(url) {\n        try {\n          return url === '' && global.location.href ? global.location.href : url\n        } catch (e) {\n          return url\n        }\n      }\n\n      xhr.open(request.method, fixUrl(request.url), true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr) {\n        if (support.blob) {\n          xhr.responseType = 'blob';\n        } else if (\n          support.arrayBuffer &&\n          request.headers.get('Content-Type') &&\n          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n        ) {\n          xhr.responseType = 'arraybuffer';\n        }\n      }\n\n      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n        Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n        });\n      } else {\n        request.headers.forEach(function(value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n      }\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!global.fetch) {\n    global.fetch = fetch;\n    global.Headers = Headers;\n    global.Request = Request;\n    global.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n})({});\n})(__globalThis__);\n// This is a ponyfill, so...\n__globalThis__.fetch.ponyfill = true;\ndelete __globalThis__.fetch.polyfill;\n// Choose between native implementation (__global__) or custom implementation (__globalThis__)\nvar ctx = __global__.fetch ? __global__ : __globalThis__;\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isArray = require('isarray');\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && isArray(val) === false;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text, ignoreTrivia = false) {\n    const len = text.length;\n    let pos = 0, value = '', tokenOffset = 0, token = 16 /* SyntaxKind.Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* ScanError.None */;\n    function scanHexDigits(count, exact) {\n        let digits = 0;\n        let value = 0;\n        while (digits < count || !exact) {\n            let ch = text.charCodeAt(pos);\n            if (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) {\n                value = value * 16 + ch - 48 /* CharacterCodes._0 */;\n            }\n            else if (ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */) {\n                value = value * 16 + ch - 65 /* CharacterCodes.A */ + 10;\n            }\n            else if (ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */) {\n                value = value * 16 + ch - 97 /* CharacterCodes.a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* SyntaxKind.Unknown */;\n        scanError = 0 /* ScanError.None */;\n    }\n    function scanNumber() {\n        let start = pos;\n        if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        let end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */ || text.charCodeAt(pos) === 101 /* CharacterCodes.e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */ || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* ScanError.UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        let result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                break;\n            }\n            const ch = text.charCodeAt(pos);\n            if (ch === 34 /* CharacterCodes.doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* CharacterCodes.backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                    break;\n                }\n                const ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* CharacterCodes.doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* CharacterCodes.backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* CharacterCodes.slash */:\n                        result += '/';\n                        break;\n                    case 98 /* CharacterCodes.b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* CharacterCodes.f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* CharacterCodes.n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* CharacterCodes.r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* CharacterCodes.t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* CharacterCodes.u */:\n                        const ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* ScanError.InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* ScanError.InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* ScanError.UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* ScanError.InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* ScanError.None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* SyntaxKind.EOF */;\n        }\n        let code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* SyntaxKind.Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* SyntaxKind.LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* CharacterCodes.openBrace */:\n                pos++;\n                return token = 1 /* SyntaxKind.OpenBraceToken */;\n            case 125 /* CharacterCodes.closeBrace */:\n                pos++;\n                return token = 2 /* SyntaxKind.CloseBraceToken */;\n            case 91 /* CharacterCodes.openBracket */:\n                pos++;\n                return token = 3 /* SyntaxKind.OpenBracketToken */;\n            case 93 /* CharacterCodes.closeBracket */:\n                pos++;\n                return token = 4 /* SyntaxKind.CloseBracketToken */;\n            case 58 /* CharacterCodes.colon */:\n                pos++;\n                return token = 6 /* SyntaxKind.ColonToken */;\n            case 44 /* CharacterCodes.comma */:\n                pos++;\n                return token = 5 /* SyntaxKind.CommaToken */;\n            // strings\n            case 34 /* CharacterCodes.doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* SyntaxKind.StringLiteral */;\n            // comments\n            case 47 /* CharacterCodes.slash */:\n                const start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* SyntaxKind.LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {\n                    pos += 2;\n                    const safeLength = len - 1; // For lookahead.\n                    let commentClosed = false;\n                    while (pos < safeLength) {\n                        const ch = text.charCodeAt(pos);\n                        if (ch === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* CharacterCodes.carriageReturn */ && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* ScanError.UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* SyntaxKind.BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* SyntaxKind.Unknown */;\n            // numbers\n            case 45 /* CharacterCodes.minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* SyntaxKind.Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* CharacterCodes._0 */:\n            case 49 /* CharacterCodes._1 */:\n            case 50 /* CharacterCodes._2 */:\n            case 51 /* CharacterCodes._3 */:\n            case 52 /* CharacterCodes._4 */:\n            case 53 /* CharacterCodes._5 */:\n            case 54 /* CharacterCodes._6 */:\n            case 55 /* CharacterCodes._7 */:\n            case 56 /* CharacterCodes._8 */:\n            case 57 /* CharacterCodes._9 */:\n                value += scanNumber();\n                return token = 11 /* SyntaxKind.NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* SyntaxKind.TrueKeyword */;\n                        case 'false': return token = 9 /* SyntaxKind.FalseKeyword */;\n                        case 'null': return token = 7 /* SyntaxKind.NullKeyword */;\n                    }\n                    return token = 16 /* SyntaxKind.Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* SyntaxKind.Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* CharacterCodes.closeBrace */:\n            case 93 /* CharacterCodes.closeBracket */:\n            case 123 /* CharacterCodes.openBrace */:\n            case 91 /* CharacterCodes.openBracket */:\n            case 34 /* CharacterCodes.doubleQuote */:\n            case 58 /* CharacterCodes.colon */:\n            case 44 /* CharacterCodes.comma */:\n            case 47 /* CharacterCodes.slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        let result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* SyntaxKind.LineCommentTrivia */ && result <= 15 /* SyntaxKind.Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: () => pos,\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: () => token,\n        getTokenValue: () => value,\n        getTokenOffset: () => tokenOffset,\n        getTokenLength: () => pos - tokenOffset,\n        getTokenStartLine: () => lineStartOffset,\n        getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,\n        getTokenError: () => scanError,\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* CharacterCodes.space */ || ch === 9 /* CharacterCodes.tab */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* CharacterCodes.lineFeed */ || ch === 13 /* CharacterCodes.carriageReturn */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;\n}\nvar CharacterCodes;\n(function (CharacterCodes) {\n    CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\n    CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\n    CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\n    CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\n    CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\n    CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\n    CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\n    CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\n    CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\n    CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\n    CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\n    CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\n    CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\n    CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\n    CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\n    CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\n    CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\n    CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\n    CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\n    CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\n    CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\n    CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\n    CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\n    CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\n    CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\n    CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\n    CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\n    CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\n    CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\n    CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\n    CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\n    CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\n    CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\n    CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\n    CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\n    CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\n    CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\n    CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\n    CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\n    CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\n    CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\n    CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\n    CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\n    CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\n    CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\n    CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\n    CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\n    CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\n    CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\n    CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\n    CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\n    CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\n    CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\n    CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\n    CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\n    CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\n    CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\n    CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\n    CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\n    CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\n    CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\n    CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\n    CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\n    CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\n    CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\n    CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\n    CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\n    CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\n    CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\n    CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\n    CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\n    CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\n    CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\n    CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\n    CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\n    CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\n    CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\n    CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\n    CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\n    CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\n})(CharacterCodes || (CharacterCodes = {}));\n","export const cachedSpaces = new Array(20).fill(0).map((_, index) => {\n    return ' '.repeat(index);\n});\nconst maxCachedValues = 200;\nexport const cachedBreakLinesWithSpaces = {\n    ' ': {\n        '\\n': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\n' + ' '.repeat(index);\n        }),\n        '\\r': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\r' + ' '.repeat(index);\n        }),\n        '\\r\\n': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\r\\n' + ' '.repeat(index);\n        }),\n    },\n    '\\t': {\n        '\\n': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\n' + '\\t'.repeat(index);\n        }),\n        '\\r': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\r' + '\\t'.repeat(index);\n        }),\n        '\\r\\n': new Array(maxCachedValues).fill(0).map((_, index) => {\n            return '\\r\\n' + '\\t'.repeat(index);\n        }),\n    }\n};\nexport const supportedEols = ['\\n', '\\r', '\\r\\n'];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nimport { cachedSpaces, cachedBreakLinesWithSpaces, supportedEols } from './string-intern';\nexport function format(documentText, range, options) {\n    let initialIndentLevel;\n    let formatText;\n    let formatTextStart;\n    let rangeStart;\n    let rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        let endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    const eol = getEOL(options, documentText);\n    const eolFastPathSupported = supportedEols.includes(eol);\n    let numberLineBreaks = 0;\n    let indentLevel = 0;\n    let indentValue;\n    if (options.insertSpaces) {\n        indentValue = cachedSpaces[options.tabSize || 4] ?? repeat(cachedSpaces[1], options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    const indentType = indentValue === '\\t' ? '\\t' : ' ';\n    let scanner = createScanner(formatText, false);\n    let hasError = false;\n    function newLinesAndIndent() {\n        if (numberLineBreaks > 1) {\n            return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n        const amountOfSpaces = indentValue.length * (initialIndentLevel + indentLevel);\n        if (!eolFastPathSupported || amountOfSpaces > cachedBreakLinesWithSpaces[indentType][eol].length) {\n            return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n        if (amountOfSpaces <= 0) {\n            return eol;\n        }\n        return cachedBreakLinesWithSpaces[indentType][eol][amountOfSpaces];\n    }\n    function scanNext() {\n        let token = scanner.scan();\n        numberLineBreaks = 0;\n        while (token === 15 /* SyntaxKind.Trivia */ || token === 14 /* SyntaxKind.LineBreakTrivia */) {\n            if (token === 14 /* SyntaxKind.LineBreakTrivia */ && options.keepLines) {\n                numberLineBreaks += 1;\n            }\n            else if (token === 14 /* SyntaxKind.LineBreakTrivia */) {\n                numberLineBreaks = 1;\n            }\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* SyntaxKind.Unknown */ || scanner.getTokenError() !== 0 /* ScanError.None */;\n        return token;\n    }\n    const editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && (!range || (startOffset < rangeEnd && endOffset > rangeStart)) && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    let firstToken = scanNext();\n    if (options.keepLines && numberLineBreaks > 0) {\n        addEdit(repeat(eol, numberLineBreaks), 0, 0);\n    }\n    if (firstToken !== 17 /* SyntaxKind.EOF */) {\n        let firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        let initialIndent = (indentValue.length * initialIndentLevel < 20) && options.insertSpaces\n            ? cachedSpaces[indentValue.length * initialIndentLevel]\n            : repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* SyntaxKind.EOF */) {\n        let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        let secondToken = scanNext();\n        let replaceContent = '';\n        let needsLineBreak = false;\n        while (numberLineBreaks === 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */)) {\n            let commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(cachedSpaces[1], firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            needsLineBreak = secondToken === 12 /* SyntaxKind.LineCommentTrivia */;\n            replaceContent = needsLineBreak ? newLinesAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* SyntaxKind.CloseBraceToken */) {\n            if (firstToken !== 1 /* SyntaxKind.OpenBraceToken */) {\n                indentLevel--;\n            }\n            ;\n            if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1 /* SyntaxKind.OpenBraceToken */) {\n                replaceContent = newLinesAndIndent();\n            }\n            else if (options.keepLines) {\n                replaceContent = cachedSpaces[1];\n            }\n        }\n        else if (secondToken === 4 /* SyntaxKind.CloseBracketToken */) {\n            if (firstToken !== 3 /* SyntaxKind.OpenBracketToken */) {\n                indentLevel--;\n            }\n            ;\n            if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3 /* SyntaxKind.OpenBracketToken */) {\n                replaceContent = newLinesAndIndent();\n            }\n            else if (options.keepLines) {\n                replaceContent = cachedSpaces[1];\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* SyntaxKind.OpenBracketToken */:\n                case 1 /* SyntaxKind.OpenBraceToken */:\n                    indentLevel++;\n                    if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        replaceContent = cachedSpaces[1];\n                    }\n                    break;\n                case 5 /* SyntaxKind.CommaToken */:\n                    if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        replaceContent = cachedSpaces[1];\n                    }\n                    break;\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                    replaceContent = newLinesAndIndent();\n                    break;\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (!needsLineBreak) {\n                        replaceContent = cachedSpaces[1];\n                    }\n                    break;\n                case 6 /* SyntaxKind.ColonToken */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (!needsLineBreak) {\n                        replaceContent = cachedSpaces[1];\n                    }\n                    break;\n                case 10 /* SyntaxKind.StringLiteral */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else if (secondToken === 6 /* SyntaxKind.ColonToken */ && !needsLineBreak) {\n                        replaceContent = '';\n                    }\n                    break;\n                case 7 /* SyntaxKind.NullKeyword */:\n                case 8 /* SyntaxKind.TrueKeyword */:\n                case 9 /* SyntaxKind.FalseKeyword */:\n                case 11 /* SyntaxKind.NumericLiteral */:\n                case 2 /* SyntaxKind.CloseBraceToken */:\n                case 4 /* SyntaxKind.CloseBracketToken */:\n                    if (options.keepLines && numberLineBreaks > 0) {\n                        replaceContent = newLinesAndIndent();\n                    }\n                    else {\n                        if ((secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */) && !needsLineBreak) {\n                            replaceContent = cachedSpaces[1];\n                        }\n                        else if (secondToken !== 5 /* SyntaxKind.CommaToken */ && secondToken !== 17 /* SyntaxKind.EOF */) {\n                            hasError = true;\n                        }\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (numberLineBreaks > 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */ || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */)) {\n                replaceContent = newLinesAndIndent();\n            }\n        }\n        if (secondToken === 17 /* SyntaxKind.EOF */) {\n            if (options.keepLines && numberLineBreaks > 0) {\n                replaceContent = newLinesAndIndent();\n            }\n            else {\n                replaceContent = options.insertFinalNewline ? eol : '';\n            }\n        }\n        const secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    let result = '';\n    for (let i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    let i = 0;\n    let nChars = 0;\n    const tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        let ch = content.charAt(i);\n        if (ch === cachedSpaces[1]) {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    const segments = []; // strings or numbers\n    const earlyReturnException = new Object();\n    let previousNode = undefined;\n    const previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    let isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: (name, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: (value, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: (sep, offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    const last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode,\n        isAtPropertyKey,\n        matches: (pattern) => {\n            let k = 0;\n            for (let i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentProperty = null;\n    let currentParent = [];\n    const previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    const visitor = {\n        onObjectBegin: () => {\n            const object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: (name) => {\n            currentProperty = name;\n        },\n        onObjectEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: () => {\n            const array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    const visitor = {\n        onObjectBegin: (offset) => {\n            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: (name, offset, length) => {\n            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });\n        },\n        onObjectEnd: (offset, length) => {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: (offset, length) => {\n            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: (offset, length) => {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: (value, offset, length) => {\n            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: (sep, offset, length) => {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    const result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    let node = root;\n    for (let segment of path) {\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            let found = false;\n            for (const propertyNode of node.children) {\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            const index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    const path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        const key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        const index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            const obj = Object.create(null);\n            for (let prop of node.children) {\n                const valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound = false) {\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound = false) {\n    if (contains(node, offset, includeRightBound)) {\n        const children = node.children;\n        if (Array.isArray(children)) {\n            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                const item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options = ParseOptions.DEFAULT) {\n    const _scanner = createScanner(text, false);\n    // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n    // to not affect visitor functions which stored a reference to a previous JSONPath\n    const _jsonPath = [];\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toNoArgVisitWithPath(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toOneArgVisitWithPath(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    const disallowComments = options && options.disallowComments;\n    const allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            const token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* ScanError.InvalidUnicode */:\n                    handleError(14 /* ParseErrorCode.InvalidUnicode */);\n                    break;\n                case 5 /* ScanError.InvalidEscapeCharacter */:\n                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);\n                    break;\n                case 3 /* ScanError.UnexpectedEndOfNumber */:\n                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* ScanError.UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* ScanError.UnexpectedEndOfString */:\n                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);\n                    break;\n                case 6 /* ScanError.InvalidCharacter */:\n                    handleError(16 /* ParseErrorCode.InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    handleError(1 /* ParseErrorCode.InvalidSymbol */);\n                    break;\n                case 15 /* SyntaxKind.Trivia */:\n                case 14 /* SyntaxKind.LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter = [], skipUntil = []) {\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            let token = _scanner.getToken();\n            while (token !== 17 /* SyntaxKind.EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        const value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n            // add property name afterwards\n            _jsonPath.push(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* SyntaxKind.NumericLiteral */:\n                const tokenValue = _scanner.getTokenValue();\n                let value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* SyntaxKind.NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* SyntaxKind.TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* SyntaxKind.FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {\n            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n        }\n        _jsonPath.pop(); // remove processed property name\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        let needsComma = false;\n        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {\n            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        let isFirstElement = true;\n        let needsComma = false;\n        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (isFirstElement) {\n                _jsonPath.push(0);\n                isFirstElement = false;\n            }\n            else {\n                _jsonPath[_jsonPath.length - 1]++;\n            }\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (!isFirstElement) {\n            _jsonPath.pop(); // remove array index\n        }\n        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {\n            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* SyntaxKind.OpenBracketToken */:\n                return parseArray();\n            case 1 /* SyntaxKind.OpenBraceToken */:\n                return parseObject();\n            case 10 /* SyntaxKind.StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* SyntaxKind.LineCommentTrivia */:\n            case 13 /* SyntaxKind.BlockCommentTrivia */:\n            case 17 /* SyntaxKind.EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* SyntaxKind.EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n    const path = originalPath.slice();\n    const errors = [];\n    const root = parseTree(text, errors);\n    let parent = void 0;\n    let lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = { [lastSegment]: value };\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        const existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                const propertyIndex = parent.children.indexOf(existing.parent);\n                let removeBegin;\n                let removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    let previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        let next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n            const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(p => p.children[0].value)) : parent.children.length;\n            let edit;\n            if (index > 0) {\n                let previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        const insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            const newProperty = `${JSON.stringify(value)}`;\n            let edit;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                const previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            const removalIndex = lastSegment;\n            const toRemove = parent.children[removalIndex];\n            let edit;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                let previous = parent.children[removalIndex - 1];\n                let offset = previous.offset + previous.length;\n                let parentEndOffset = parent.offset + parent.length;\n                edit = { offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            let edit;\n            const newProperty = `${JSON.stringify(value)}`;\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                const toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                const previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(`Can not ${value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')} Array index ${insertIndex} as length is not sufficient`);\n        }\n    }\n    else {\n        throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    let newText = applyEdit(text, edit);\n    // format the new text\n    let begin = edit.offset;\n    let end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    const edits = format(newText, { offset: begin, length: end - begin }, { ...options.formattingOptions, keepLines: false });\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (let i = edits.length - 1; i >= 0; i--) {\n        const edit = edits[i];\n        newText = applyEdit(newText, edit);\n        begin = Math.min(begin, edit.offset);\n        end = Math.max(end, edit.offset + edit.length);\n        end += edit.content.length - edit.length;\n    }\n    // create a single edit with all changes\n    const editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport const createScanner = scanner.createScanner;\nexport var ScanError;\n(function (ScanError) {\n    ScanError[ScanError[\"None\"] = 0] = \"None\";\n    ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n    ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n    ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n    ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n    ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError || (ScanError = {}));\nexport var SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n    SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n    SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n    SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n    SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n    SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n    SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n    SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n    SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n    SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n    SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n    SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n    SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n    SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n    SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n})(SyntaxKind || (SyntaxKind = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport const getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport const parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport const parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport const findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport const findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport const getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport const getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport const visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport const stripComments = parser.stripComments;\nexport var ParseErrorCode;\n(function (ParseErrorCode) {\n    ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n    ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n    ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n    ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n    ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n    ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n    ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n    ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n    ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n})(ParseErrorCode || (ParseErrorCode = {}));\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* ParseErrorCode.InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* ParseErrorCode.InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* ParseErrorCode.PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ParseErrorCode.ValueExpected */: return 'ValueExpected';\n        case 5 /* ParseErrorCode.ColonExpected */: return 'ColonExpected';\n        case 6 /* ParseErrorCode.CommaExpected */: return 'CommaExpected';\n        case 7 /* ParseErrorCode.CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* ParseErrorCode.CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* ParseErrorCode.EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* ParseErrorCode.InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* ParseErrorCode.UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* ParseErrorCode.UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* ParseErrorCode.UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* ParseErrorCode.InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* ParseErrorCode.InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* ParseErrorCode.InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edit operations needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edit operations needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to an input string.\n * @param text The input text\n * @param edits Edit operations following the format described in {@linkcode EditResult}.\n * @returns The text with the applied edits.\n * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.\n */\nexport function applyEdits(text, edits) {\n    let sortedEdits = edits.slice(0).sort((a, b) => {\n        const diff = a.offset - b.offset;\n        if (diff === 0) {\n            return a.length - b.length;\n        }\n        return diff;\n    });\n    let lastModifiedOffset = text.length;\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\n        let e = sortedEdits[i];\n        if (e.offset + e.length <= lastModifiedOffset) {\n            text = edit.applyEdit(text, e);\n        }\n        else {\n            throw new Error('Overlapping edit');\n        }\n        lastModifiedOffset = e.offset;\n    }\n    return text;\n}\n","/**\n * line-column - Convert efficiently index to/from line-column in a string\n * @module  lineColumn\n * @license MIT\n */\n\"use strict\";\n\nvar isArray  = require(\"isarray\");\nvar isObject = require(\"isobject\");\nvar slice = Array.prototype.slice;\n\nmodule.exports = LineColumnFinder;\n\n/**\n * Finder for index and line-column from given string.\n *\n * You can call this without `new` operator as it returns an instance anyway.\n *\n * @class\n * @param {string} str - A string to be parsed.\n * @param {Object|number} [options] - Options.\n *     This can be an index in the string for shorthand of `lineColumn(str, index)`.\n * @param {number} [options.origin=1] - The origin value of line and column.\n */\nfunction LineColumnFinder(str, options) {\n  if (!(this instanceof LineColumnFinder)) {\n    if (typeof options === \"number\") {\n      return (new LineColumnFinder(str)).fromIndex(options);\n    }\n    return new LineColumnFinder(str, options);\n  }\n\n  this.str = str || \"\";\n  this.lineToIndex = buildLineToIndex(this.str);\n\n  options = options || {};\n  this.origin = typeof options.origin === \"undefined\" ? 1 : options.origin;\n}\n\n/**\n * Find line and column from index in the string.\n *\n * @param  {number} index - Index in the string. (0-origin)\n * @return {Object|null}\n *     Found line number and column number in object `{ line: X, col: Y }`.\n *     If the given index is out of range, it returns `null`.\n */\nLineColumnFinder.prototype.fromIndex = function (index) {\n  if (index < 0 || index >= this.str.length || isNaN(index)) {\n    return null;\n  }\n\n  var line = findLowerIndexInRangeArray(index, this.lineToIndex);\n  return {\n    line: line + this.origin,\n    col:  index - this.lineToIndex[line] + this.origin\n  };\n}\n\n/**\n * Find index from line and column in the string.\n *\n * @param  {number|Object|Array} line - Line number in the string.\n *     This can be an Object of `{ line: X, col: Y }`, or\n *     an Array of `[line, col]`.\n * @param  {number} [column] - Column number in the string.\n *     This must be omitted or undefined when Object or Array is given\n *     to the first argument.\n * @return {number}\n *     Found index in the string. (always 0-origin)\n *     If the given line or column is out of range, it returns `-1`.\n */\nLineColumnFinder.prototype.toIndex = function (line, column) {\n  if (typeof column === \"undefined\") {\n    if (isArray(line) && line.length >= 2) {\n      return this.toIndex(line[0], line[1]);\n    }\n    if (isObject(line) && \"line\" in line && (\"col\" in line || \"column\" in line)) {\n      return this.toIndex(line.line, (\"col\" in line ? line.col : line.column));\n    }\n    return -1;\n  }\n  if (isNaN(line) || isNaN(column)) {\n    return -1;\n  }\n\n  line -= this.origin;\n  column -= this.origin;\n\n  if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {\n    var lineIndex = this.lineToIndex[line];\n    var nextIndex = (\n      line === this.lineToIndex.length - 1\n        ? this.str.length\n        : this.lineToIndex[line + 1]\n    );\n\n    if (column < nextIndex - lineIndex) {\n      return lineIndex + column;\n    }\n  }\n  return -1;\n}\n\n/**\n * Build an array of indexes of each line from a string.\n *\n * @private\n * @param   str {string}  An input string.\n * @return  {number[]}    Built array of indexes. The key is line number.\n */\nfunction buildLineToIndex(str) {\n  var lines = str.split(\"\\n\"),\n      lineToIndex = new Array(lines.length),\n      index = 0;\n\n  for (var i = 0, l = lines.length; i < l; i++) {\n    lineToIndex[i] = index;\n    index += lines[i].length + /* \"\\n\".length */ 1;\n  }\n  return lineToIndex;\n}\n\n/**\n * Find a lower-bound index of a value in a sorted array of ranges.\n *\n * Assume `arr = [0, 5, 10, 15, 20]` and\n * this returns `1` for `value = 7` (5 <= value < 10),\n * and returns `3` for `value = 18` (15 <= value < 20).\n *\n * @private\n * @param  arr   {number[]} An array of values representing ranges.\n * @param  value {number}   A value to be searched.\n * @return {number} Found index. If not found `-1`.\n */\nfunction findLowerIndexInRangeArray(value, arr) {\n  if (value >= arr[arr.length - 1]) {\n    return arr.length - 1;\n  }\n\n  var min = 0, max = arr.length - 2, mid;\n  while (min < max) {\n    mid = min + ((max - min) >> 1);\n\n    if (value < arr[mid]) {\n      max = mid - 1;\n    } else if (value >= arr[mid + 1]) {\n      min = mid + 1;\n    } else { // value >= arr[mid] && value < arr[mid + 1]\n      min = mid;\n      break;\n    }\n  }\n  return min;\n}\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\nmodule.exports = asciiToArray;\n","/** Used to match words composed of alphanumeric characters. */\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n\nmodule.exports = asciiWords;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = basePropertyOf;\n","var assignValue = require('./_assignValue'),\n    castPath = require('./_castPath'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var baseSlice = require('./_baseSlice');\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\nmodule.exports = castSlice;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var castSlice = require('./_castSlice'),\n    hasUnicode = require('./_hasUnicode'),\n    stringToArray = require('./_stringToArray'),\n    toString = require('./toString');\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\nmodule.exports = createCaseFirst;\n","var arrayReduce = require('./_arrayReduce'),\n    deburr = require('./deburr'),\n    words = require('./words');\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\";\n\n/** Used to match apostrophes. */\nvar reApos = RegExp(rsApos, 'g');\n\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\nfunction createCompounder(callback) {\n  return function(string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n\nmodule.exports = createCompounder;\n","var basePropertyOf = require('./_basePropertyOf');\n\n/** Used to map Latin Unicode letters to basic Latin letters. */\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n  '\\xc7': 'C',  '\\xe7': 'c',\n  '\\xd0': 'D',  '\\xf0': 'd',\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n  '\\xd1': 'N',  '\\xf1': 'n',\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n  '\\xc6': 'Ae', '\\xe6': 'ae',\n  '\\xde': 'Th', '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n  '\\u0134': 'J',  '\\u0135': 'j',\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n  '\\u0174': 'W',  '\\u0175': 'w',\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n  '\\u0132': 'IJ', '\\u0133': 'ij',\n  '\\u0152': 'Oe', '\\u0153': 'oe',\n  '\\u0149': \"'n\", '\\u017f': 's'\n};\n\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\nvar deburrLetter = basePropertyOf(deburredLetters);\n\nmodule.exports = deburrLetter;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n","/** Used to detect strings that need a more robust regexp to match words. */\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n\nmodule.exports = hasUnicodeWord;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var asciiToArray = require('./_asciiToArray'),\n    hasUnicode = require('./_hasUnicode'),\n    unicodeToArray = require('./_unicodeToArray');\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\nmodule.exports = stringToArray;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\nmodule.exports = unicodeToArray;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\",\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n    rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;\n\n/** Used to match complex or compound words. */\nvar reUnicodeWord = RegExp([\n  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n  rsUpper + '+' + rsOptContrUpper,\n  rsOrdUpper,\n  rsOrdLower,\n  rsDigits,\n  rsEmoji\n].join('|'), 'g');\n\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n\nmodule.exports = unicodeWords;\n","var capitalize = require('./capitalize'),\n    createCompounder = require('./_createCompounder');\n\n/**\n * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the camel cased string.\n * @example\n *\n * _.camelCase('Foo Bar');\n * // => 'fooBar'\n *\n * _.camelCase('--foo-bar--');\n * // => 'fooBar'\n *\n * _.camelCase('__FOO_BAR__');\n * // => 'fooBar'\n */\nvar camelCase = createCompounder(function(result, word, index) {\n  word = word.toLowerCase();\n  return result + (index ? capitalize(word) : word);\n});\n\nmodule.exports = camelCase;\n","var toString = require('./toString'),\n    upperFirst = require('./upperFirst');\n\n/**\n * Converts the first character of `string` to upper case and the remaining\n * to lower case.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to capitalize.\n * @returns {string} Returns the capitalized string.\n * @example\n *\n * _.capitalize('FRED');\n * // => 'Fred'\n */\nfunction capitalize(string) {\n  return upperFirst(toString(string).toLowerCase());\n}\n\nmodule.exports = capitalize;\n","var deburrLetter = require('./_deburrLetter'),\n    toString = require('./toString');\n\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n/** Used to compose unicode character classes. */\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\n\n/** Used to compose unicode capture groups. */\nvar rsCombo = '[' + rsComboRange + ']';\n\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\nvar reComboMark = RegExp(rsCombo, 'g');\n\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('dj vu');\n * // => 'deja vu'\n */\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n}\n\nmodule.exports = deburr;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var createCompounder = require('./_createCompounder');\n\n/**\n * Converts `string` to\n * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the kebab cased string.\n * @example\n *\n * _.kebabCase('Foo Bar');\n * // => 'foo-bar'\n *\n * _.kebabCase('fooBar');\n * // => 'foo-bar'\n *\n * _.kebabCase('__FOO_BAR__');\n * // => 'foo-bar'\n */\nvar kebabCase = createCompounder(function(result, word, index) {\n  return result + (index ? '-' : '') + word.toLowerCase();\n});\n\nmodule.exports = kebabCase;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseSet = require('./_baseSet');\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n","var createCompounder = require('./_createCompounder');\n\n/**\n * Converts `string` to\n * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the snake cased string.\n * @example\n *\n * _.snakeCase('Foo Bar');\n * // => 'foo_bar'\n *\n * _.snakeCase('fooBar');\n * // => 'foo_bar'\n *\n * _.snakeCase('--FOO-BAR--');\n * // => 'foo_bar'\n */\nvar snakeCase = createCompounder(function(result, word, index) {\n  return result + (index ? '_' : '') + word.toLowerCase();\n});\n\nmodule.exports = snakeCase;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var baseUnset = require('./_baseUnset');\n\n/**\n * Removes the property at `path` of `object`.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n * _.unset(object, 'a[0].b.c');\n * // => true\n *\n * console.log(object);\n * // => { 'a': [{ 'b': {} }] };\n *\n * _.unset(object, ['a', '0', 'b', 'c']);\n * // => true\n *\n * console.log(object);\n * // => { 'a': [{ 'b': {} }] };\n */\nfunction unset(object, path) {\n  return object == null ? true : baseUnset(object, path);\n}\n\nmodule.exports = unset;\n","var createCaseFirst = require('./_createCaseFirst');\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\nmodule.exports = upperFirst;\n","var asciiWords = require('./_asciiWords'),\n    hasUnicodeWord = require('./_hasUnicodeWord'),\n    toString = require('./toString'),\n    unicodeWords = require('./_unicodeWords');\n\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = guard ? undefined : pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n  return string.match(pattern) || [];\n}\n\nmodule.exports = words;\n","/// <reference types=\"../index.d.ts\" />\nvar main$1 = {exports: {}};\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n/*\n  `Failure`s represent expressions that weren't matched while parsing. They are used to generate\n  error messages automatically. The interface of `Failure`s includes the collowing methods:\n\n  - getText() : String\n  - getType() : String  (one of {\"description\", \"string\", \"code\"})\n  - isDescription() : bool\n  - isStringTerminal() : bool\n  - isCode() : bool\n  - isFluffy() : bool\n  - makeFluffy() : void\n  - subsumes(Failure) : bool\n*/\n\nfunction isValidType(type) {\n  return type === 'description' || type === 'string' || type === 'code';\n}\n\nfunction Failure$2(pexpr, text, type) {\n  if (!isValidType(type)) {\n    throw new Error('invalid Failure type: ' + type);\n  }\n  this.pexpr = pexpr;\n  this.text = text;\n  this.type = type;\n  this.fluffy = false;\n}\n\nFailure$2.prototype.getPExpr = function() {\n  return this.pexpr;\n};\n\nFailure$2.prototype.getText = function() {\n  return this.text;\n};\n\nFailure$2.prototype.getType = function() {\n  return this.type;\n};\n\nFailure$2.prototype.isDescription = function() {\n  return this.type === 'description';\n};\n\nFailure$2.prototype.isStringTerminal = function() {\n  return this.type === 'string';\n};\n\nFailure$2.prototype.isCode = function() {\n  return this.type === 'code';\n};\n\nFailure$2.prototype.isFluffy = function() {\n  return this.fluffy;\n};\n\nFailure$2.prototype.makeFluffy = function() {\n  this.fluffy = true;\n};\n\nFailure$2.prototype.clearFluffy = function() {\n  this.fluffy = false;\n};\n\nFailure$2.prototype.subsumes = function(that) {\n  return (\n    this.getText() === that.getText() &&\n    this.type === that.type &&\n    (!this.isFluffy() || (this.isFluffy() && that.isFluffy()))\n  );\n};\n\nFailure$2.prototype.toString = function() {\n  return this.type === 'string' ? JSON.stringify(this.getText()) : this.getText();\n};\n\nFailure$2.prototype.clone = function() {\n  const failure = new Failure$2(this.pexpr, this.text, this.type);\n  if (this.isFluffy()) {\n    failure.makeFluffy();\n  }\n  return failure;\n};\n\nFailure$2.prototype.toKey = function() {\n  return this.toString() + '#' + this.type;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Failure_1 = Failure$2;\n\nvar common$l = {};\n\n(function (exports) {\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nconst escapeStringFor = {};\nfor (let c = 0; c < 128; c++) {\n  escapeStringFor[c] = String.fromCharCode(c);\n}\nescapeStringFor[\"'\".charCodeAt(0)] = \"\\\\'\";\nescapeStringFor['\"'.charCodeAt(0)] = '\\\\\"';\nescapeStringFor['\\\\'.charCodeAt(0)] = '\\\\\\\\';\nescapeStringFor['\\b'.charCodeAt(0)] = '\\\\b';\nescapeStringFor['\\f'.charCodeAt(0)] = '\\\\f';\nescapeStringFor['\\n'.charCodeAt(0)] = '\\\\n';\nescapeStringFor['\\r'.charCodeAt(0)] = '\\\\r';\nescapeStringFor['\\t'.charCodeAt(0)] = '\\\\t';\nescapeStringFor['\\u000b'.charCodeAt(0)] = '\\\\v';\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexports.abstract = function(optMethodName) {\n  const methodName = optMethodName || '';\n  return function() {\n    throw new Error(\n        'this method ' +\n        methodName +\n        ' is abstract! ' +\n        '(it has no implementation in class ' +\n        this.constructor.name +\n        ')'\n    );\n  };\n};\n\nexports.assert = function(cond, message) {\n  if (!cond) {\n    throw new Error(message || 'Assertion failed');\n  }\n};\n\n// Define a lazily-computed, non-enumerable property named `propName`\n// on the object `obj`. `getterFn` will be called to compute the value the\n// first time the property is accessed.\nexports.defineLazyProperty = function(obj, propName, getterFn) {\n  let memo;\n  Object.defineProperty(obj, propName, {\n    get() {\n      if (!memo) {\n        memo = getterFn.call(this);\n      }\n      return memo;\n    },\n  });\n};\n\nexports.clone = function(obj) {\n  if (obj) {\n    return Object.assign({}, obj);\n  }\n  return obj;\n};\n\nexports.repeatFn = function(fn, n) {\n  const arr = [];\n  while (n-- > 0) {\n    arr.push(fn());\n  }\n  return arr;\n};\n\nexports.repeatStr = function(str, n) {\n  return new Array(n + 1).join(str);\n};\n\nexports.repeat = function(x, n) {\n  return exports.repeatFn(() => x, n);\n};\n\nexports.getDuplicates = function(array) {\n  const duplicates = [];\n  for (let idx = 0; idx < array.length; idx++) {\n    const x = array[idx];\n    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {\n      duplicates.push(x);\n    }\n  }\n  return duplicates;\n};\n\nexports.copyWithoutDuplicates = function(array) {\n  const noDuplicates = [];\n  array.forEach(entry => {\n    if (noDuplicates.indexOf(entry) < 0) {\n      noDuplicates.push(entry);\n    }\n  });\n  return noDuplicates;\n};\n\nexports.isSyntactic = function(ruleName) {\n  const firstChar = ruleName[0];\n  return firstChar === firstChar.toUpperCase();\n};\n\nexports.isLexical = function(ruleName) {\n  return !exports.isSyntactic(ruleName);\n};\n\nexports.padLeft = function(str, len, optChar) {\n  const ch = optChar || ' ';\n  if (str.length < len) {\n    return exports.repeatStr(ch, len - str.length) + str;\n  }\n  return str;\n};\n\n// StringBuffer\n\nexports.StringBuffer = function() {\n  this.strings = [];\n};\n\nexports.StringBuffer.prototype.append = function(str) {\n  this.strings.push(str);\n};\n\nexports.StringBuffer.prototype.contents = function() {\n  return this.strings.join('');\n};\n\nconst escapeUnicode = str => String.fromCodePoint(parseInt(str, 16));\n\nexports.unescapeCodePoint = function(s) {\n  if (s.charAt(0) === '\\\\') {\n    switch (s.charAt(1)) {\n      case 'b':\n        return '\\b';\n      case 'f':\n        return '\\f';\n      case 'n':\n        return '\\n';\n      case 'r':\n        return '\\r';\n      case 't':\n        return '\\t';\n      case 'v':\n        return '\\v';\n      case 'x':\n        return escapeUnicode(s.slice(2, 4));\n      case 'u':\n        return s.charAt(2) === '{' ?\n          escapeUnicode(s.slice(3, -1)) :\n          escapeUnicode(s.slice(2, 6));\n      default:\n        return s.charAt(1);\n    }\n  } else {\n    return s;\n  }\n};\n\n// Helper for producing a description of an unknown object in a safe way.\n// Especially useful for error messages where an unexpected type of object was encountered.\nexports.unexpectedObjToString = function(obj) {\n  if (obj == null) {\n    return String(obj);\n  }\n  const baseToString = Object.prototype.toString.call(obj);\n  try {\n    let typeName;\n    if (obj.constructor && obj.constructor.name) {\n      typeName = obj.constructor.name;\n    } else if (baseToString.indexOf('[object ') === 0) {\n      typeName = baseToString.slice(8, -1); // Extract e.g. \"Array\" from \"[object Array]\".\n    } else {\n      typeName = typeof obj;\n    }\n    return typeName + ': ' + JSON.stringify(String(obj));\n  } catch (e) {\n    return baseToString;\n  }\n};\n}(common$l));\n\nconst common$k = common$l;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nclass Node {\n  constructor(matchLength) {\n    this.matchLength = matchLength;\n  }\n\n  get ctorName() {\n    throw new Error('subclass responsibility');\n  }\n\n  numChildren() {\n    return this.children ? this.children.length : 0;\n  }\n\n  childAt(idx) {\n    if (this.children) {\n      return this.children[idx];\n    }\n  }\n\n  indexOfChild(arg) {\n    return this.children.indexOf(arg);\n  }\n\n  hasChildren() {\n    return this.numChildren() > 0;\n  }\n\n  hasNoChildren() {\n    return !this.hasChildren();\n  }\n\n  onlyChild() {\n    if (this.numChildren() !== 1) {\n      throw new Error(\n          'cannot get only child of a node of type ' +\n          this.ctorName +\n          ' (it has ' +\n          this.numChildren() +\n          ' children)'\n      );\n    } else {\n      return this.firstChild();\n    }\n  }\n\n  firstChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get first child of a ' + this.ctorName + ' node, which has no children'\n      );\n    } else {\n      return this.childAt(0);\n    }\n  }\n\n  lastChild() {\n    if (this.hasNoChildren()) {\n      throw new Error(\n          'cannot get last child of a ' + this.ctorName + ' node, which has no children'\n      );\n    } else {\n      return this.childAt(this.numChildren() - 1);\n    }\n  }\n\n  childBefore(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childBefore() called w/ an argument that is not a child');\n    } else if (childIdx === 0) {\n      throw new Error('cannot get child before first child');\n    } else {\n      return this.childAt(childIdx - 1);\n    }\n  }\n\n  childAfter(child) {\n    const childIdx = this.indexOfChild(child);\n    if (childIdx < 0) {\n      throw new Error('Node.childAfter() called w/ an argument that is not a child');\n    } else if (childIdx === this.numChildren() - 1) {\n      throw new Error('cannot get child after last child');\n    } else {\n      return this.childAt(childIdx + 1);\n    }\n  }\n\n  isTerminal() {\n    return false;\n  }\n\n  isNonterminal() {\n    return false;\n  }\n\n  isIteration() {\n    return false;\n  }\n\n  isOptional() {\n    return false;\n  }\n}\n\n// Terminals\n\nclass TerminalNode$2 extends Node {\n  get ctorName() {\n    return '_terminal';\n  }\n\n  isTerminal() {\n    return true;\n  }\n\n  get primitiveValue() {\n    throw new Error('The `primitiveValue` property was removed in Ohm v17.');\n  }\n}\n\n// Nonterminals\n\nclass NonterminalNode$1 extends Node {\n  constructor(ruleName, children, childOffsets, matchLength) {\n    super(matchLength);\n    this.ruleName = ruleName;\n    this.children = children;\n    this.childOffsets = childOffsets;\n  }\n\n  get ctorName() {\n    return this.ruleName;\n  }\n\n  isNonterminal() {\n    return true;\n  }\n\n  isLexical() {\n    return common$k.isLexical(this.ctorName);\n  }\n\n  isSyntactic() {\n    return common$k.isSyntactic(this.ctorName);\n  }\n}\n\n// Iterations\n\nclass IterationNode$2 extends Node {\n  constructor(children, childOffsets, matchLength, isOptional) {\n    super(matchLength);\n    this.children = children;\n    this.childOffsets = childOffsets;\n    this.optional = isOptional;\n  }\n\n  get ctorName() {\n    return '_iter';\n  }\n\n  isIteration() {\n    return true;\n  }\n\n  isOptional() {\n    return this.optional;\n  }\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar nodes$1 = {\n  Node,\n  TerminalNode: TerminalNode$2,\n  NonterminalNode: NonterminalNode$1,\n  IterationNode: IterationNode$2,\n};\n\nvar pexprsMain = {};\n\n// Based on https://github.com/mathiasbynens/unicode-9.0.0.\n// These are just categories that are used in ES5/ES2015.\n// The full list of Unicode categories is here: http://www.fileformat.info/info/unicode/category/index.htm.\nvar UnicodeCategories$1 = {\n  // Letters\n  Lu: /[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AE\\uA7B0-\\uA7B4\\uA7B6\\uFF21-\\uFF3A]|\\uD801[\\uDC00-\\uDC27\\uDCB0-\\uDCD3]|\\uD803[\\uDC80-\\uDCB2]|\\uD806[\\uDCA0-\\uDCBF]|\\uD835[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA]|\\uD83A[\\uDD00-\\uDD21]/,\n  Ll: /[a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0561-\\u0587\\u13F8-\\u13FD\\u1C80-\\u1C88\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7B5\\uA7B7\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB65\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]|\\uD801[\\uDC28-\\uDC4F\\uDCD8-\\uDCFB]|\\uD803[\\uDCC0-\\uDCF2]|\\uD806[\\uDCC0-\\uDCDF]|\\uD835[\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]|\\uD83A[\\uDD22-\\uDD43]/,\n  Lt: /[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]/,\n  Lm: /[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E\\uFF9F]|\\uD81A[\\uDF40-\\uDF43]|\\uD81B[\\uDF93-\\uDF9F\\uDFE0]/,\n  Lo: /[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC50-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n\n  // Numbers\n  Nl: /[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]|\\uD800[\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]|\\uD809[\\uDC00-\\uDC6E]/,\n  Nd: /[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]|\\uD801[\\uDCA0-\\uDCA9]|\\uD804[\\uDC66-\\uDC6F\\uDCF0-\\uDCF9\\uDD36-\\uDD3F\\uDDD0-\\uDDD9\\uDEF0-\\uDEF9]|[\\uD805\\uD807][\\uDC50-\\uDC59\\uDCD0-\\uDCD9\\uDE50-\\uDE59\\uDEC0-\\uDEC9\\uDF30-\\uDF39]|\\uD806[\\uDCE0-\\uDCE9]|\\uD81A[\\uDE60-\\uDE69\\uDF50-\\uDF59]|\\uD835[\\uDFCE-\\uDFFF]|\\uD83A[\\uDD50-\\uDD59]/,\n\n  // Marks\n  Mn: /[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D01\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFB-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDCA-\\uDDCC\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3C\\uDF40\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDCB3-\\uDCB8\\uDCBA\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uDB40[\\uDD00-\\uDDEF]/,\n  Mc: /[\\u0903-\\u0903]|[\\u093E-\\u0940]|[\\u0949-\\u094C]|[\\u0982-\\u0983]|[\\u09BE-\\u09C0]|[\\u09C7-\\u09C8]|[\\u09CB-\\u09CC]|[\\u09D7-\\u09D7]|[\\u0A3E-\\u0A40]|[\\u0A83-\\u0A83]|[\\u0ABE-\\u0AC0]|[\\u0AC9-\\u0AC9]|[\\u0ACB-\\u0ACC]|[\\u0B02-\\u0B03]|[\\u0B3E-\\u0B3E]|[\\u0B40-\\u0B40]|[\\u0B47-\\u0B48]|[\\u0B4B-\\u0B4C]|[\\u0B57-\\u0B57]|[\\u0B83-\\u0B83]|[\\u0BBE-\\u0BBF]|[\\u0BC1-\\u0BC2]|[\\u0BC6-\\u0BC8]|[\\u0BCA-\\u0BCC]|[\\u0BD7-\\u0BD7]|[\\u0C01-\\u0C03]|[\\u0C41-\\u0C44]|[\\u0C82-\\u0C83]|[\\u0CBE-\\u0CBE]|[\\u0CC0-\\u0CC4]|[\\u0CC7-\\u0CC8]|[\\u0CCA-\\u0CCB]|[\\u0CD5-\\u0CD6]|[\\u0D02-\\u0D03]|[\\u0D3E-\\u0D40]|[\\u0D46-\\u0D48]|[\\u0D4A-\\u0D4C]|[\\u0D57-\\u0D57]|[\\u0F3E-\\u0F3F]|[\\u0F7F-\\u0F7F]/,\n\n  // Punctuation, Connector\n  Pc: /[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]/,\n\n  // Separator, Space\n  Zs: /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/,\n\n  // These two are not real Unicode categories, but our useful for Ohm.\n  // L is a combination of all the letter categories.\n  // Ltmo is a combination of Lt, Lm, and Lo.\n  L: /[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n  Ltmo: /[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]|[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E\\uFF9F]|\\uD81A[\\uDF40-\\uDF43]|\\uD81B[\\uDF93-\\uDF9F\\uDFE0]|[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC50-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst UnicodeCategories = UnicodeCategories$1;\nconst common$j = common$l;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// General stuff\n\nclass PExpr$1 {\n  constructor() {\n    if (this.constructor === PExpr$1) {\n      throw new Error(\"PExpr cannot be instantiated -- it's abstract\");\n    }\n  }\n\n  // Set the `source` property to the interval containing the source for this expression.\n  withSource(interval) {\n    if (interval) {\n      this.source = interval.trimmed();\n    }\n    return this;\n  }\n}\n\n// Any\n\nconst any = Object.create(PExpr$1.prototype);\n\n// End\n\nconst end = Object.create(PExpr$1.prototype);\n\n// Terminals\n\nclass Terminal$1 extends PExpr$1 {\n  constructor(obj) {\n    super();\n    this.obj = obj;\n  }\n}\n\n// Ranges\n\nclass Range extends PExpr$1 {\n  constructor(from, to) {\n    super();\n    this.from = from;\n    this.to = to;\n    // If either `from` or `to` is made up of multiple code units, then\n    // the range should consume a full code point, not a single code unit.\n    this.matchCodePoint = from.length > 1 || to.length > 1;\n  }\n}\n\n// Parameters\n\nclass Param extends PExpr$1 {\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n}\n\n// Alternation\n\nclass Alt extends PExpr$1 {\n  constructor(terms) {\n    super();\n    this.terms = terms;\n  }\n}\n\n// Extend is an implementation detail of rule extension\n\nclass Extend extends Alt {\n  constructor(superGrammar, name, body) {\n    const origBody = superGrammar.rules[name].body;\n    super([body, origBody]);\n\n    this.superGrammar = superGrammar;\n    this.name = name;\n    this.body = body;\n  }\n}\n\n// Splice is an implementation detail of rule overriding with the `...` operator.\nclass Splice extends Alt {\n  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {\n    const origBody = superGrammar.rules[ruleName].body;\n    super([...beforeTerms, origBody, ...afterTerms]);\n\n    this.superGrammar = superGrammar;\n    this.ruleName = ruleName;\n    this.expansionPos = beforeTerms.length;\n  }\n}\n\n// Sequences\n\nclass Seq extends PExpr$1 {\n  constructor(factors) {\n    super();\n    this.factors = factors;\n  }\n}\n\n// Iterators and optionals\n\nclass Iter extends PExpr$1 {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nclass Star extends Iter {}\nclass Plus extends Iter {}\nclass Opt extends Iter {}\n\nStar.prototype.operator = '*';\nPlus.prototype.operator = '+';\nOpt.prototype.operator = '?';\n\nStar.prototype.minNumMatches = 0;\nPlus.prototype.minNumMatches = 1;\nOpt.prototype.minNumMatches = 0;\n\nStar.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nPlus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;\nOpt.prototype.maxNumMatches = 1;\n\n// Predicates\n\nclass Not extends PExpr$1 {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\nclass Lookahead extends PExpr$1 {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// \"Lexification\"\n\nclass Lex extends PExpr$1 {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n}\n\n// Rule application\n\nclass Apply extends PExpr$1 {\n  constructor(ruleName, args = []) {\n    super();\n    this.ruleName = ruleName;\n    this.args = args;\n  }\n\n  isSyntactic() {\n    return common$j.isSyntactic(this.ruleName);\n  }\n\n  // This method just caches the result of `this.toString()` in a non-enumerable property.\n  toMemoKey() {\n    if (!this._memoKey) {\n      Object.defineProperty(this, '_memoKey', {value: this.toString()});\n    }\n    return this._memoKey;\n  }\n}\n\n// Unicode character\n\nclass UnicodeChar extends PExpr$1 {\n  constructor(category) {\n    super();\n    this.category = category;\n    this.pattern = UnicodeCategories[category];\n  }\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\npexprsMain.PExpr = PExpr$1;\npexprsMain.any = any;\npexprsMain.end = end;\npexprsMain.Terminal = Terminal$1;\npexprsMain.Range = Range;\npexprsMain.Param = Param;\npexprsMain.Alt = Alt;\npexprsMain.Extend = Extend;\npexprsMain.Splice = Splice;\npexprsMain.Seq = Seq;\npexprsMain.Iter = Iter;\npexprsMain.Star = Star;\npexprsMain.Plus = Plus;\npexprsMain.Opt = Opt;\npexprsMain.Not = Not;\npexprsMain.Lookahead = Lookahead;\npexprsMain.Lex = Lex;\npexprsMain.Apply = Apply;\npexprsMain.UnicodeChar = UnicodeChar;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$i = common$l;\nconst pexprs$l = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Return true if we should skip spaces preceding this expression in a syntactic context.\n*/\npexprs$l.PExpr.prototype.allowsSkippingPrecedingSpace = common$i.abstract(\n    'allowsSkippingPrecedingSpace'\n);\n\n/*\n  Generally, these are all first-order expressions and (with the exception of Apply)\n  directly read from the input stream.\n*/\npexprs$l.any.allowsSkippingPrecedingSpace =\n  pexprs$l.end.allowsSkippingPrecedingSpace =\n  pexprs$l.Apply.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Terminal.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Range.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.UnicodeChar.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return true;\n    };\n\n/*\n  Higher-order expressions that don't directly consume input.\n*/\npexprs$l.Alt.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Iter.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Lex.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Lookahead.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Not.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Param.prototype.allowsSkippingPrecedingSpace =\n  pexprs$l.Seq.prototype.allowsSkippingPrecedingSpace =\n    function() {\n      return false;\n    };\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Namespace$2() {}\nNamespace$2.prototype = Object.create(null);\n\nNamespace$2.asNamespace = function(objOrNamespace) {\n  if (objOrNamespace instanceof Namespace$2) {\n    return objOrNamespace;\n  }\n  return Namespace$2.createNamespace(objOrNamespace);\n};\n\n// Create a new namespace. If `optProps` is specified, all of its properties\n// will be copied to the new namespace.\nNamespace$2.createNamespace = function(optProps) {\n  return Namespace$2.extend(Namespace$2.prototype, optProps);\n};\n\n// Create a new namespace which extends another namespace. If `optProps` is\n// specified, all of its properties will be copied to the new namespace.\nNamespace$2.extend = function(namespace, optProps) {\n  if (namespace !== Namespace$2.prototype && !(namespace instanceof Namespace$2)) {\n    throw new TypeError('not a Namespace object: ' + namespace);\n  }\n  const ns = Object.create(namespace, {\n    constructor: {\n      value: Namespace$2,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    },\n  });\n  return Object.assign(ns, optProps);\n};\n\n// TODO: Should this be a regular method?\nNamespace$2.toString = function(ns) {\n  return Object.prototype.toString.call(ns);\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Namespace_1 = Namespace$2;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst {assert: assert$3} = common$l;\nconst Namespace$1 = Namespace_1;\nconst pexprs$k = pexprsMain;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction createError(message, optInterval) {\n  let e;\n  if (optInterval) {\n    e = new Error(optInterval.getLineAndColumnMessage() + message);\n    e.shortMessage = message;\n    e.interval = optInterval;\n  } else {\n    e = new Error(message);\n  }\n  return e;\n}\n\n// ----------------- errors about intervals -----------------\n\nfunction intervalSourcesDontMatch() {\n  return createError(\"Interval sources don't match\");\n}\n\n// ----------------- errors about grammars -----------------\n\n// Grammar syntax error\n\nfunction grammarSyntaxError(matchFailure) {\n  const e = new Error();\n  Object.defineProperty(e, 'message', {\n    enumerable: true,\n    get() {\n      return matchFailure.message;\n    },\n  });\n  Object.defineProperty(e, 'shortMessage', {\n    enumerable: true,\n    get() {\n      return 'Expected ' + matchFailure.getExpectedText();\n    },\n  });\n  e.interval = matchFailure.getInterval();\n  return e;\n}\n\n// Undeclared grammar\n\nfunction undeclaredGrammar(grammarName, namespace, interval) {\n  const message = namespace ?\n    'Grammar ' +\n      grammarName +\n      ' is not declared in namespace ' +\n      Namespace$1.toString(namespace) :\n    'Undeclared grammar ' + grammarName;\n  return createError(message, interval);\n}\n\n// Duplicate grammar declaration\n\nfunction duplicateGrammarDeclaration(grammar, namespace) {\n  return createError('Grammar ' + grammar.name + ' is already declared in this namespace');\n}\n\n// ----------------- rules -----------------\n\n// Undeclared rule\n\nfunction undeclaredRule(ruleName, grammarName, optInterval) {\n  return createError(\n      'Rule ' + ruleName + ' is not declared in grammar ' + grammarName,\n      optInterval\n  );\n}\n\n// Cannot override undeclared rule\n\nfunction cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot override rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource\n  );\n}\n\n// Cannot extend undeclared rule\n\nfunction cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {\n  return createError(\n      'Cannot extend rule ' + ruleName + ' because it is not declared in ' + grammarName,\n      optSource\n  );\n}\n\n// Duplicate rule declaration\n\nfunction duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {\n  let message =\n    \"Duplicate declaration for rule '\" + ruleName + \"' in grammar '\" + grammarName + \"'\";\n  if (grammarName !== declGrammarName) {\n    message += \" (originally declared in '\" + declGrammarName + \"')\";\n  }\n  return createError(message, optSource);\n}\n\n// Wrong number of parameters\n\nfunction wrongNumberOfParameters(ruleName, expected, actual, source) {\n  return createError(\n      'Wrong number of parameters for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      source\n  );\n}\n\n// Wrong number of arguments\n\nfunction wrongNumberOfArguments(ruleName, expected, actual, expr) {\n  return createError(\n      'Wrong number of arguments for rule ' +\n      ruleName +\n      ' (expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr\n  );\n}\n\n// Duplicate parameter names\n\nfunction duplicateParameterNames(ruleName, duplicates, source) {\n  return createError(\n      'Duplicate parameter names in rule ' + ruleName + ': ' + duplicates.join(', '),\n      source\n  );\n}\n\n// Invalid parameter expression\n\nfunction invalidParameter(ruleName, expr) {\n  return createError(\n      'Invalid parameter to rule ' +\n      ruleName +\n      ': ' +\n      expr +\n      ' has arity ' +\n      expr.getArity() +\n      ', but parameter expressions must have arity 1',\n      expr.source\n  );\n}\n\n// Application of syntactic rule from lexical rule\n\nconst syntacticVsLexicalNote =\n  'NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. ' +\n  'See https://ohmjs.org/d/svl for more details.';\n\nfunction applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {\n  return createError(\n      'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',\n      applyExpr.source\n  );\n}\n\n// Lexical rule application used with applySyntactic\n\nfunction applySyntacticWithLexicalRuleApplication(applyExpr) {\n  const {ruleName} = applyExpr;\n  return createError(\n      `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` +\n      syntacticVsLexicalNote,\n      applyExpr.source\n  );\n}\n\n// Application of applySyntactic in a syntactic context\n\nfunction unnecessaryExperimentalApplySyntactic(applyExpr) {\n  return createError(\n      'applySyntactic is not required here (in a syntactic context)',\n      applyExpr.source\n  );\n}\n\n// Incorrect argument type\n\nfunction incorrectArgumentType(expectedType, expr) {\n  return createError('Incorrect argument type: expected ' + expectedType, expr.source);\n}\n\n// Multiple instances of the super-splice operator (`...`) in the rule body.\n\nfunction multipleSuperSplices(expr) {\n  return createError(\"'...' can appear at most once in a rule body\", expr.source);\n}\n\n// Unicode code point escapes\n\nfunction invalidCodePoint(applyWrapper) {\n  const node = applyWrapper._node;\n  assert$3(node && node.isNonterminal() && node.ctorName === 'escapeChar_unicodeCodePoint');\n\n  // Get an interval that covers all of the hex digits.\n  const digitIntervals = applyWrapper.children.slice(1, -1).map(d => d.source);\n  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));\n  return createError(\n      `U+${fullInterval.contents} is not a valid Unicode code point`,\n      fullInterval\n  );\n}\n\n// ----------------- Kleene operators -----------------\n\nfunction kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {\n  const actuals =\n    applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];\n  const expr = kleeneExpr.expr.substituteParams(actuals);\n  let message =\n    'Nullable expression ' +\n    expr +\n    \" is not allowed inside '\" +\n    kleeneExpr.operator +\n    \"' (possible infinite loop)\";\n  if (applicationStack.length > 0) {\n    const stackTrace = applicationStack\n        .map(app => new pexprs$k.Apply(app.ruleName, app.args))\n        .join('\\n');\n    message += '\\nApplication stack (most recent application last):\\n' + stackTrace;\n  }\n  return createError(message, kleeneExpr.expr.source);\n}\n\n// ----------------- arity -----------------\n\nfunction inconsistentArity(ruleName, expected, actual, expr) {\n  return createError(\n      'Rule ' +\n      ruleName +\n      ' involves an alternation which has inconsistent arity ' +\n      '(expected ' +\n      expected +\n      ', got ' +\n      actual +\n      ')',\n      expr.source\n  );\n}\n\n// ----------------- properties -----------------\n\nfunction duplicatePropertyNames(duplicates) {\n  return createError('Object pattern has duplicate property names: ' + duplicates.join(', '));\n}\n\n// ----------------- constructors -----------------\n\nfunction invalidConstructorCall(grammar, ctorName, children) {\n  return createError(\n      'Attempt to invoke constructor ' + ctorName + ' with invalid or unexpected arguments'\n  );\n}\n\n// ----------------- convenience -----------------\n\nfunction multipleErrors(errors) {\n  const messages = errors.map(e => e.message);\n  return createError(['Errors:'].concat(messages).join('\\n- '), errors[0].interval);\n}\n\n// ----------------- semantic -----------------\n\nfunction missingSemanticAction(ctorName, name, type, stack) {\n  let stackTrace = stack\n      .slice(0, -1)\n      .map(info => {\n        const ans = '  ' + info[0].name + ' > ' + info[1];\n        return info.length === 3 ? ans + \" for '\" + info[2] + \"'\" : ans;\n      })\n      .join('\\n');\n  stackTrace += '\\n  ' + name + ' > ' + ctorName;\n\n  let moreInfo = '';\n  if (ctorName === '_iter') {\n    moreInfo = [\n      '\\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ',\n      '  https://ohmjs.org/d/dsa for details.',\n    ].join('\\n');\n  }\n\n  const message = [\n    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,\n    'Action stack (most recent call last):',\n    stackTrace,\n  ].join('\\n');\n\n  const e = createError(message);\n  e.name = 'missingSemanticAction';\n  return e;\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar errors$9 = {\n  applicationOfSyntacticRuleFromLexicalContext,\n  applySyntacticWithLexicalRuleApplication,\n  cannotExtendUndeclaredRule,\n  cannotOverrideUndeclaredRule,\n  duplicateGrammarDeclaration,\n  duplicateParameterNames,\n  duplicatePropertyNames,\n  duplicateRuleDeclaration,\n  inconsistentArity,\n  incorrectArgumentType,\n  intervalSourcesDontMatch,\n  invalidCodePoint,\n  invalidConstructorCall,\n  invalidParameter,\n  grammarSyntaxError,\n  kleeneExprHasNullableOperand,\n  missingSemanticAction,\n  multipleSuperSplices,\n  undeclaredGrammar,\n  undeclaredRule,\n  unnecessaryExperimentalApplySyntactic,\n  wrongNumberOfArguments,\n  wrongNumberOfParameters,\n\n  throwErrors(errors) {\n    if (errors.length === 1) {\n      throw errors[0];\n    }\n    if (errors.length > 1) {\n      throw multipleErrors(errors);\n    }\n  },\n};\n\nvar util$7 = {};\n\n(function (exports) {\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common = common$l;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Given an array of numbers `arr`, return an array of the numbers as strings,\n// right-justified and padded to the same length.\nfunction padNumbersToEqualLength(arr) {\n  let maxLen = 0;\n  const strings = arr.map(n => {\n    const str = n.toString();\n    maxLen = Math.max(maxLen, str.length);\n    return str;\n  });\n  return strings.map(s => common.padLeft(s, maxLen));\n}\n\n// Produce a new string that would be the result of copying the contents\n// of the string `src` onto `dest` at offset `offest`.\nfunction strcpy(dest, src, offset) {\n  const origDestLen = dest.length;\n  const start = dest.slice(0, offset);\n  const end = dest.slice(offset + src.length);\n  return (start + src + end).substr(0, origDestLen);\n}\n\n// Casts the underlying lineAndCol object to a formatted message string,\n// highlighting `ranges`.\nfunction lineAndColumnToMessage(...ranges) {\n  const lineAndCol = this;\n  const {offset} = lineAndCol;\n  const {repeatStr} = common;\n\n  const sb = new common.StringBuffer();\n  sb.append('Line ' + lineAndCol.lineNum + ', col ' + lineAndCol.colNum + ':\\n');\n\n  // An array of the previous, current, and next line numbers as strings of equal length.\n  const lineNumbers = padNumbersToEqualLength([\n    lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,\n    lineAndCol.lineNum,\n    lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1,\n  ]);\n\n  // Helper for appending formatting input lines to the buffer.\n  const appendLine = (num, content, prefix) => {\n    sb.append(prefix + lineNumbers[num] + ' | ' + content + '\\n');\n  };\n\n  // Include the previous line for context if possible.\n  if (lineAndCol.prevLine != null) {\n    appendLine(0, lineAndCol.prevLine, '  ');\n  }\n  // Line that the error occurred on.\n  appendLine(1, lineAndCol.line, '> ');\n\n  // Build up the line that points to the offset and possible indicates one or more ranges.\n  // Start with a blank line, and indicate each range by overlaying a string of `~` chars.\n  const lineLen = lineAndCol.line.length;\n  let indicationLine = repeatStr(' ', lineLen + 1);\n  for (let i = 0; i < ranges.length; ++i) {\n    let startIdx = ranges[i][0];\n    let endIdx = ranges[i][1];\n    common.assert(startIdx >= 0 && startIdx <= endIdx, 'range start must be >= 0 and <= end');\n\n    const lineStartOffset = offset - lineAndCol.colNum + 1;\n    startIdx = Math.max(0, startIdx - lineStartOffset);\n    endIdx = Math.min(endIdx - lineStartOffset, lineLen);\n\n    indicationLine = strcpy(indicationLine, repeatStr('~', endIdx - startIdx), startIdx);\n  }\n  const gutterWidth = 2 + lineNumbers[1].length + 3;\n  sb.append(repeatStr(' ', gutterWidth));\n  indicationLine = strcpy(indicationLine, '^', lineAndCol.colNum - 1);\n  sb.append(indicationLine.replace(/ +$/, '') + '\\n');\n\n  // Include the next line for context if possible.\n  if (lineAndCol.nextLine != null) {\n    appendLine(2, lineAndCol.nextLine, '  ');\n  }\n  return sb.contents();\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nlet builtInRulesCallbacks = [];\n\n// Since Grammar.BuiltInRules is bootstrapped, most of Ohm can't directly depend it.\n// This function allows modules that do depend on the built-in rules to register a callback\n// that will be called later in the initialization process.\nexports.awaitBuiltInRules = cb => {\n  builtInRulesCallbacks.push(cb);\n};\n\nexports.announceBuiltInRules = grammar => {\n  builtInRulesCallbacks.forEach(cb => {\n    cb(grammar);\n  });\n  builtInRulesCallbacks = null;\n};\n\n// Return an object with the line and column information for the given\n// offset in `str`.\nexports.getLineAndColumn = (str, offset) => {\n  let lineNum = 1;\n  let colNum = 1;\n\n  let currOffset = 0;\n  let lineStartOffset = 0;\n\n  let nextLine = null;\n  let prevLine = null;\n  let prevLineStartOffset = -1;\n\n  while (currOffset < offset) {\n    const c = str.charAt(currOffset++);\n    if (c === '\\n') {\n      lineNum++;\n      colNum = 1;\n      prevLineStartOffset = lineStartOffset;\n      lineStartOffset = currOffset;\n    } else if (c !== '\\r') {\n      colNum++;\n    }\n  }\n\n  // Find the end of the target line.\n  let lineEndOffset = str.indexOf('\\n', lineStartOffset);\n  if (lineEndOffset === -1) {\n    lineEndOffset = str.length;\n  } else {\n    // Get the next line.\n    const nextLineEndOffset = str.indexOf('\\n', lineEndOffset + 1);\n    nextLine =\n      nextLineEndOffset === -1 ?\n        str.slice(lineEndOffset) :\n        str.slice(lineEndOffset, nextLineEndOffset);\n    // Strip leading and trailing EOL char(s).\n    nextLine = nextLine.replace(/^\\r?\\n/, '').replace(/\\r$/, '');\n  }\n\n  // Get the previous line.\n  if (prevLineStartOffset >= 0) {\n    // Strip trailing EOL char(s).\n    prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\\r?\\n$/, '');\n  }\n\n  // Get the target line, stripping a trailing carriage return if necessary.\n  const line = str.slice(lineStartOffset, lineEndOffset).replace(/\\r$/, '');\n\n  return {\n    offset,\n    lineNum,\n    colNum,\n    line,\n    prevLine,\n    nextLine,\n    toString: lineAndColumnToMessage,\n  };\n};\n\n// Return a nicely-formatted string describing the line and column for the\n// given offset in `str` highlighting `ranges`.\nexports.getLineAndColumnMessage = function(str, offset, ...ranges) {\n  return exports.getLineAndColumn(str, offset).toString(...ranges);\n};\n\nexports.uniqueId = (() => {\n  let idCounter = 0;\n  return prefix => '' + prefix + idCounter++;\n})();\n}(util$7));\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst {abstract, isSyntactic} = common$l;\nconst errors$8 = errors$9;\nconst pexprs$j = pexprsMain;\nconst util$6 = util$7;\n\nlet BuiltInRules;\n\nutil$6.awaitBuiltInRules(g => {\n  BuiltInRules = g;\n});\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nlet lexifyCount;\n\npexprs$j.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount = 0;\n  this._assertAllApplicationsAreValid(ruleName, grammar);\n};\n\npexprs$j.PExpr.prototype._assertAllApplicationsAreValid = abstract(\n    '_assertAllApplicationsAreValid'\n);\n\npexprs$j.any._assertAllApplicationsAreValid =\n  pexprs$j.end._assertAllApplicationsAreValid =\n  pexprs$j.Terminal.prototype._assertAllApplicationsAreValid =\n  pexprs$j.Range.prototype._assertAllApplicationsAreValid =\n  pexprs$j.Param.prototype._assertAllApplicationsAreValid =\n  pexprs$j.UnicodeChar.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      // no-op\n    };\n\npexprs$j.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  lexifyCount++;\n  this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n  lexifyCount--;\n};\n\npexprs$j.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs$j.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);\n  }\n};\n\npexprs$j.Iter.prototype._assertAllApplicationsAreValid =\n  pexprs$j.Not.prototype._assertAllApplicationsAreValid =\n  pexprs$j.Lookahead.prototype._assertAllApplicationsAreValid =\n    function(ruleName, grammar) {\n      this.expr._assertAllApplicationsAreValid(ruleName, grammar);\n    };\n\npexprs$j.Apply.prototype._assertAllApplicationsAreValid = function(\n    ruleName,\n    grammar,\n    skipSyntacticCheck = false\n) {\n  const ruleInfo = grammar.rules[this.ruleName];\n  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;\n\n  // Make sure that the rule exists...\n  if (!ruleInfo) {\n    throw errors$8.undeclaredRule(this.ruleName, grammar.name, this.source);\n  }\n\n  // ...and that this application is allowed\n  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {\n    throw errors$8.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);\n  }\n\n  // ...and that this application has the correct number of arguments.\n  const actual = this.args.length;\n  const expected = ruleInfo.formals.length;\n  if (actual !== expected) {\n    throw errors$8.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);\n  }\n\n  const isBuiltInApplySyntactic =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;\n  const isBuiltInCaseInsensitive =\n    BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;\n\n  // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.\n  if (isBuiltInCaseInsensitive) {\n    if (!(this.args[0] instanceof pexprs$j.Terminal)) {\n      throw errors$8.incorrectArgumentType('a Terminal (e.g. \"abc\")', this.args[0]);\n    }\n  }\n\n  if (isBuiltInApplySyntactic) {\n    const arg = this.args[0];\n    if (!(arg instanceof pexprs$j.Apply)) {\n      throw errors$8.incorrectArgumentType('a syntactic rule application', arg);\n    }\n    if (!isSyntactic(arg.ruleName)) {\n      throw errors$8.applySyntacticWithLexicalRuleApplication(arg);\n    }\n    if (isContextSyntactic) {\n      throw errors$8.unnecessaryExperimentalApplySyntactic(this);\n    }\n  }\n\n  // ...and that all of the argument expressions only have valid applications and have arity 1.\n  // If `this` is an application of the built-in applySyntactic rule, then its arg is\n  // allowed (and expected) to be a syntactic rule, even if we're in a lexical context.\n  this.args.forEach(arg => {\n    arg._assertAllApplicationsAreValid(ruleName, grammar, isBuiltInApplySyntactic);\n    if (arg.getArity() !== 1) {\n      throw errors$8.invalidParameter(this.ruleName, arg);\n    }\n  });\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$h = common$l;\nconst errors$7 = errors$9;\nconst pexprs$i = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs$i.PExpr.prototype.assertChoicesHaveUniformArity = common$h.abstract(\n    'assertChoicesHaveUniformArity'\n);\n\npexprs$i.any.assertChoicesHaveUniformArity =\n  pexprs$i.end.assertChoicesHaveUniformArity =\n  pexprs$i.Terminal.prototype.assertChoicesHaveUniformArity =\n  pexprs$i.Range.prototype.assertChoicesHaveUniformArity =\n  pexprs$i.Param.prototype.assertChoicesHaveUniformArity =\n  pexprs$i.Lex.prototype.assertChoicesHaveUniformArity =\n  pexprs$i.UnicodeChar.prototype.assertChoicesHaveUniformArity =\n    function(ruleName) {\n      // no-op\n    };\n\npexprs$i.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  if (this.terms.length === 0) {\n    return;\n  }\n  const arity = this.terms[0].getArity();\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    const term = this.terms[idx];\n    term.assertChoicesHaveUniformArity();\n    const otherArity = term.getArity();\n    if (arity !== otherArity) {\n      throw errors$7.inconsistentArity(ruleName, arity, otherArity, term);\n    }\n  }\n};\n\npexprs$i.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // Extend is a special case of Alt that's guaranteed to have exactly two\n  // cases: [extensions, origBody].\n  const actualArity = this.terms[0].getArity();\n  const expectedArity = this.terms[1].getArity();\n  if (actualArity !== expectedArity) {\n    throw errors$7.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);\n  }\n};\n\npexprs$i.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertChoicesHaveUniformArity(ruleName);\n  }\n};\n\npexprs$i.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs$i.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // no-op (not required b/c the nested expr doesn't show up in the CST)\n};\n\npexprs$i.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  this.expr.assertChoicesHaveUniformArity(ruleName);\n};\n\npexprs$i.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {\n  // The arities of the parameter expressions is required to be 1 by\n  // `assertAllApplicationsAreValid()`.\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$g = common$l;\nconst errors$6 = errors$9;\nconst pexprs$h = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs$h.PExpr.prototype.assertIteratedExprsAreNotNullable = common$g.abstract(\n    'assertIteratedExprsAreNotNullable'\n);\n\npexprs$h.any.assertIteratedExprsAreNotNullable =\n  pexprs$h.end.assertIteratedExprsAreNotNullable =\n  pexprs$h.Terminal.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.Range.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.Param.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.UnicodeChar.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      // no-op\n    };\n\npexprs$h.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    this.terms[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\npexprs$h.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    this.factors[idx].assertIteratedExprsAreNotNullable(grammar);\n  }\n};\n\npexprs$h.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  // Note: this is the implementation of this method for `Star` and `Plus` expressions.\n  // It is overridden for `Opt` below.\n  this.expr.assertIteratedExprsAreNotNullable(grammar);\n  if (this.expr.isNullable(grammar)) {\n    throw errors$6.kleeneExprHasNullableOperand(this, []);\n  }\n};\n\npexprs$h.Opt.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.Not.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.Lookahead.prototype.assertIteratedExprsAreNotNullable =\n  pexprs$h.Lex.prototype.assertIteratedExprsAreNotNullable =\n    function(grammar) {\n      this.expr.assertIteratedExprsAreNotNullable(grammar);\n    };\n\npexprs$h.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {\n  this.args.forEach(arg => {\n    arg.assertIteratedExprsAreNotNullable(grammar);\n  });\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst {assert: assert$2} = common$l;\nconst errors$5 = errors$9;\nconst util$5 = util$7;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Interval$3(sourceString, startIdx, endIdx) {\n  this.sourceString = sourceString;\n  this.startIdx = startIdx;\n  this.endIdx = endIdx;\n}\n\nInterval$3.coverage = function(firstInterval, ...intervals) {\n  let {startIdx, endIdx} = firstInterval;\n  for (const interval of intervals) {\n    if (interval.sourceString !== firstInterval.sourceString) {\n      throw errors$5.intervalSourcesDontMatch();\n    } else {\n      startIdx = Math.min(startIdx, interval.startIdx);\n      endIdx = Math.max(endIdx, interval.endIdx);\n    }\n  }\n  return new Interval$3(firstInterval.sourceString, startIdx, endIdx);\n};\n\nInterval$3.prototype = {\n  coverageWith(...intervals) {\n    return Interval$3.coverage(...intervals, this);\n  },\n\n  collapsedLeft() {\n    return new Interval$3(this.sourceString, this.startIdx, this.startIdx);\n  },\n\n  collapsedRight() {\n    return new Interval$3(this.sourceString, this.endIdx, this.endIdx);\n  },\n\n  getLineAndColumn() {\n    return util$5.getLineAndColumn(this.sourceString, this.startIdx);\n  },\n\n  getLineAndColumnMessage() {\n    const range = [this.startIdx, this.endIdx];\n    return util$5.getLineAndColumnMessage(this.sourceString, this.startIdx, range);\n  },\n\n  // Returns an array of 0, 1, or 2 intervals that represents the result of the\n  // interval difference operation.\n  minus(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw errors$5.intervalSourcesDontMatch();\n    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {\n      // `this` and `that` are the same interval!\n      return [];\n    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {\n      // `that` splits `this` into two intervals\n      return [\n        new Interval$3(this.sourceString, this.startIdx, that.startIdx),\n        new Interval$3(this.sourceString, that.endIdx, this.endIdx),\n      ];\n    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {\n      // `that` contains a prefix of `this`\n      return [new Interval$3(this.sourceString, that.endIdx, this.endIdx)];\n    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {\n      // `that` contains a suffix of `this`\n      return [new Interval$3(this.sourceString, this.startIdx, that.startIdx)];\n    } else {\n      // `that` and `this` do not overlap\n      return [this];\n    }\n  },\n\n  // Returns a new Interval that has the same extent as this one, but which is relative\n  // to `that`, an Interval that fully covers this one.\n  relativeTo(that) {\n    if (this.sourceString !== that.sourceString) {\n      throw errors$5.intervalSourcesDontMatch();\n    }\n    assert$2(\n        this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,\n        'other interval does not cover this one'\n    );\n    return new Interval$3(\n        this.sourceString,\n        this.startIdx - that.startIdx,\n        this.endIdx - that.startIdx\n    );\n  },\n\n  // Returns a new Interval which contains the same contents as this one,\n  // but with whitespace trimmed from both ends.\n  trimmed() {\n    const {contents} = this;\n    const startIdx = this.startIdx + contents.match(/^\\s*/)[0].length;\n    const endIdx = this.endIdx - contents.match(/\\s*$/)[0].length;\n    return new Interval$3(this.sourceString, startIdx, endIdx);\n  },\n\n  subInterval(offset, len) {\n    const newStartIdx = this.startIdx + offset;\n    return new Interval$3(this.sourceString, newStartIdx, newStartIdx + len);\n  },\n};\n\nObject.defineProperties(Interval$3.prototype, {\n  contents: {\n    get() {\n      if (this._contents === undefined) {\n        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);\n      }\n      return this._contents;\n    },\n    enumerable: true,\n  },\n  length: {\n    get() {\n      return this.endIdx - this.startIdx;\n    },\n    enumerable: true,\n  },\n});\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Interval_1 = Interval$3;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Interval$2 = Interval_1;\nconst common$f = common$l;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Unicode characters that are used in the `toString` output.\nconst BALLOT_X = '\\u2717';\nconst CHECK_MARK = '\\u2713';\nconst DOT_OPERATOR = '\\u22C5';\nconst RIGHTWARDS_DOUBLE_ARROW = '\\u21D2';\nconst SYMBOL_FOR_HORIZONTAL_TABULATION = '\\u2409';\nconst SYMBOL_FOR_LINE_FEED = '\\u240A';\nconst SYMBOL_FOR_CARRIAGE_RETURN = '\\u240D';\n\nconst Flags = {\n  succeeded: 1 << 0,\n  isRootNode: 1 << 1,\n  isImplicitSpaces: 1 << 2,\n  isMemoized: 1 << 3,\n  isHeadOfLeftRecursion: 1 << 4,\n  terminatesLR: 1 << 5,\n};\n\nfunction spaces(n) {\n  return common$f.repeat(' ', n).join('');\n}\n\n// Return a string representation of a portion of `input` at offset `pos`.\n// The result will contain exactly `len` characters.\nfunction getInputExcerpt(input, pos, len) {\n  const excerpt = asEscapedString(input.slice(pos, pos + len));\n\n  // Pad the output if necessary.\n  if (excerpt.length < len) {\n    return excerpt + common$f.repeat(' ', len - excerpt.length).join('');\n  }\n  return excerpt;\n}\n\nfunction asEscapedString(obj) {\n  if (typeof obj === 'string') {\n    // Replace non-printable characters with visible symbols.\n    return obj\n        .replace(/ /g, DOT_OPERATOR)\n        .replace(/\\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION)\n        .replace(/\\n/g, SYMBOL_FOR_LINE_FEED)\n        .replace(/\\r/g, SYMBOL_FOR_CARRIAGE_RETURN);\n  }\n  return String(obj);\n}\n\n// ----------------- Trace -----------------\n\nfunction Trace$2(input, pos1, pos2, expr, succeeded, bindings, optChildren) {\n  this.input = input;\n  this.pos = this.pos1 = pos1;\n  this.pos2 = pos2;\n  this.source = new Interval$2(input, pos1, pos2);\n  this.expr = expr;\n  this.bindings = bindings;\n  this.children = optChildren || [];\n  this.terminatingLREntry = null;\n\n  this._flags = succeeded ? Flags.succeeded : 0;\n}\n\n// A value that can be returned from visitor functions to indicate that a\n// node should not be recursed into.\nTrace$2.prototype.SKIP = {};\n\nObject.defineProperty(Trace$2.prototype, 'displayString', {\n  get() {\n    return this.expr.toDisplayString();\n  },\n});\n\n// For convenience, create a getter and setter for the boolean flags in `Flags`.\nObject.keys(Flags).forEach(name => {\n  const mask = Flags[name];\n  Object.defineProperty(Trace$2.prototype, name, {\n    get() {\n      return (this._flags & mask) !== 0;\n    },\n    set(val) {\n      if (val) {\n        this._flags |= mask;\n      } else {\n        this._flags &= ~mask;\n      }\n    },\n  });\n});\n\nTrace$2.prototype.clone = function() {\n  return this.cloneWithExpr(this.expr);\n};\n\nTrace$2.prototype.cloneWithExpr = function(expr) {\n  const ans = new Trace$2(\n      this.input,\n      this.pos,\n      this.pos2,\n      expr,\n      this.succeeded,\n      this.bindings,\n      this.children\n  );\n\n  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;\n  ans.isImplicitSpaces = this.isImplicitSpaces;\n  ans.isMemoized = this.isMemoized;\n  ans.isRootNode = this.isRootNode;\n  ans.terminatesLR = this.terminatesLR;\n  ans.terminatingLREntry = this.terminatingLREntry;\n  return ans;\n};\n\n// Record the trace information for the terminating condition of the LR loop.\nTrace$2.prototype.recordLRTermination = function(ruleBodyTrace, value) {\n  this.terminatingLREntry = new Trace$2(\n      this.input,\n      this.pos,\n      this.pos2,\n      this.expr,\n      false,\n      [value],\n      [ruleBodyTrace]\n  );\n  this.terminatingLREntry.terminatesLR = true;\n};\n\n// Recursively traverse this trace node and all its descendents, calling a visitor function\n// for each node that is visited. If `vistorObjOrFn` is an object, then its 'enter' property\n// is a function to call before visiting the children of a node, and its 'exit' property is\n// a function to call afterwards. If `visitorObjOrFn` is a function, it represents the 'enter'\n// function.\n//\n// The functions are called with three arguments: the Trace node, its parent Trace, and a number\n// representing the depth of the node in the tree. (The root node has depth 0.) `optThisArg`, if\n// specified, is the value to use for `this` when executing the visitor functions.\nTrace$2.prototype.walk = function(visitorObjOrFn, optThisArg) {\n  let visitor = visitorObjOrFn;\n  if (typeof visitor === 'function') {\n    visitor = {enter: visitor};\n  }\n\n  function _walk(node, parent, depth) {\n    let recurse = true;\n    if (visitor.enter) {\n      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace$2.prototype.SKIP) {\n        recurse = false;\n      }\n    }\n    if (recurse) {\n      node.children.forEach(child => {\n        _walk(child, node, depth + 1);\n      });\n      if (visitor.exit) {\n        visitor.exit.call(optThisArg, node, parent, depth);\n      }\n    }\n  }\n  if (this.isRootNode) {\n    // Don't visit the root node itself, only its children.\n    this.children.forEach(c => {\n      _walk(c, null, 0);\n    });\n  } else {\n    _walk(this, null, 0);\n  }\n};\n\n// Return a string representation of the trace.\n// Sample:\n//     12+2*3  exp   \"12\"\n//     12+2*3    addExp (LR)   \"12\"\n//     12+2*3        addExp_plus\nTrace$2.prototype.toString = function() {\n  const sb = new common$f.StringBuffer();\n  this.walk((node, parent, depth) => {\n    if (!node) {\n      return this.SKIP;\n    }\n    const ctorName = node.expr.constructor.name;\n    // Don't print anything for Alt nodes.\n    if (ctorName === 'Alt') {\n      return; // eslint-disable-line consistent-return\n    }\n    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));\n    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + ' ' + node.displayString);\n    if (node.isHeadOfLeftRecursion) {\n      sb.append(' (LR)');\n    }\n    if (node.succeeded) {\n      const contents = asEscapedString(node.source.contents);\n      sb.append(' ' + RIGHTWARDS_DOUBLE_ARROW + '  ');\n      sb.append(typeof contents === 'string' ? '\"' + contents + '\"' : contents);\n    }\n    sb.append('\\n');\n  });\n  return sb.contents();\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Trace_1 = Trace$2;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Trace$1 = Trace_1;\nconst common$e = common$l;\nconst errors$4 = errors$9;\nconst nodes = nodes$1;\nconst pexprs$g = pexprsMain;\n\nconst {TerminalNode: TerminalNode$1} = nodes;\nconst {NonterminalNode} = nodes;\nconst {IterationNode: IterationNode$1} = nodes;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Evaluate the expression and return `true` if it succeeds, `false` otherwise. This method should\n  only be called directly by `State.prototype.eval(expr)`, which also updates the data structures\n  that are used for tracing. (Making those updates in a method of `State` enables the trace-specific\n  data structures to be \"secrets\" of that class, which is good for modularity.)\n\n  The contract of this method is as follows:\n  * When the return value is `true`,\n    - the state object will have `expr.getArity()` more bindings than it did before the call.\n  * When the return value is `false`,\n    - the state object may have more bindings than it did before the call, and\n    - its input stream's position may be anywhere.\n\n  Note that `State.prototype.eval(expr)`, unlike this method, guarantees that neither the state\n  object's bindings nor its input stream's position will change if the expression fails to match.\n*/\npexprs$g.PExpr.prototype.eval = common$e.abstract('eval'); // function(state) { ... }\n\npexprs$g.any.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const ch = inputStream.next();\n  if (ch) {\n    state.pushBinding(new TerminalNode$1(ch.length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs$g.end.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (inputStream.atEnd()) {\n    state.pushBinding(new TerminalNode$1(0), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs$g.Terminal.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (!inputStream.matchString(this.obj)) {\n    state.processFailure(origPos, this);\n    return false;\n  } else {\n    state.pushBinding(new TerminalNode$1(this.obj.length), origPos);\n    return true;\n  }\n};\n\npexprs$g.Range.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  // A range can operate in one of two modes: matching a single, 16-bit _code unit_,\n  // or matching a _code point_. (Code points over 0xFFFF take up two 16-bit code units.)\n  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();\n\n  // Always compare by code point value to get the correct result in all scenarios.\n  // Note that for strings of length 1, codePointAt(0) and charPointAt(0) are equivalent.\n  if (cp !== undefined && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {\n    state.pushBinding(new TerminalNode$1(String.fromCodePoint(cp).length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\npexprs$g.Param.prototype.eval = function(state) {\n  return state.eval(state.currentApplication().args[this.index]);\n};\n\npexprs$g.Lex.prototype.eval = function(state) {\n  state.enterLexifiedContext();\n  const ans = state.eval(this.expr);\n  state.exitLexifiedContext();\n  return ans;\n};\n\npexprs$g.Alt.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.terms.length; idx++) {\n    if (state.eval(this.terms[idx])) {\n      return true;\n    }\n  }\n  return false;\n};\n\npexprs$g.Seq.prototype.eval = function(state) {\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    const factor = this.factors[idx];\n    if (!state.eval(factor)) {\n      return false;\n    }\n  }\n  return true;\n};\n\npexprs$g.Iter.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const arity = this.getArity();\n  const cols = [];\n  const colOffsets = [];\n  while (cols.length < arity) {\n    cols.push([]);\n    colOffsets.push([]);\n  }\n\n  let numMatches = 0;\n  let prevPos = origPos;\n  let idx;\n  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {\n    if (inputStream.pos === prevPos) {\n      throw errors$4.kleeneExprHasNullableOperand(this, state._applicationStack);\n    }\n    prevPos = inputStream.pos;\n    numMatches++;\n    const row = state._bindings.splice(state._bindings.length - arity, arity);\n    const rowOffsets = state._bindingOffsets.splice(\n        state._bindingOffsets.length - arity,\n        arity\n    );\n    for (idx = 0; idx < row.length; idx++) {\n      cols[idx].push(row[idx]);\n      colOffsets[idx].push(rowOffsets[idx]);\n    }\n  }\n  if (numMatches < this.minNumMatches) {\n    return false;\n  }\n  let offset = state.posToOffset(origPos);\n  let matchLength = 0;\n  if (numMatches > 0) {\n    const lastCol = cols[arity - 1];\n    const lastColOffsets = colOffsets[arity - 1];\n\n    const endOffset =\n      lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;\n    offset = colOffsets[0][0];\n    matchLength = endOffset - offset;\n  }\n  const isOptional = this instanceof pexprs$g.Opt;\n  for (idx = 0; idx < cols.length; idx++) {\n    state._bindings.push(\n        new IterationNode$1(cols[idx], colOffsets[idx], matchLength, isOptional)\n    );\n    state._bindingOffsets.push(offset);\n  }\n  return true;\n};\n\npexprs$g.Not.prototype.eval = function(state) {\n  /*\n    TODO:\n    - Right now we're just throwing away all of the failures that happen inside a `not`, and\n      recording `this` as a failed expression.\n    - Double negation should be equivalent to lookahead, but that's not the case right now wrt\n      failures. E.g., ~~'foo' produces a failure for ~~'foo', but maybe it should produce\n      a failure for 'foo' instead.\n  */\n\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  state.pushFailuresInfo();\n\n  const ans = state.eval(this.expr);\n\n  state.popFailuresInfo();\n  if (ans) {\n    state.processFailure(origPos, this);\n    return false;\n  }\n\n  inputStream.pos = origPos;\n  return true;\n};\n\npexprs$g.Lookahead.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  if (state.eval(this.expr)) {\n    inputStream.pos = origPos;\n    return true;\n  } else {\n    return false;\n  }\n};\n\npexprs$g.Apply.prototype.eval = function(state) {\n  const caller = state.currentApplication();\n  const actuals = caller ? caller.args : [];\n  const app = this.substituteParams(actuals);\n\n  const posInfo = state.getCurrentPosInfo();\n  if (posInfo.isActive(app)) {\n    // This rule is already active at this position, i.e., it is left-recursive.\n    return app.handleCycle(state);\n  }\n\n  const memoKey = app.toMemoKey();\n  const memoRec = posInfo.memo[memoKey];\n\n  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {\n    if (state.hasNecessaryInfo(memoRec)) {\n      return state.useMemoizedResult(state.inputStream.pos, memoRec);\n    }\n    delete posInfo.memo[memoKey];\n  }\n  return app.reallyEval(state);\n};\n\npexprs$g.Apply.prototype.handleCycle = function(state) {\n  const posInfo = state.getCurrentPosInfo();\n  const {currentLeftRecursion} = posInfo;\n  const memoKey = this.toMemoKey();\n  let memoRec = posInfo.memo[memoKey];\n\n  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {\n    // We already know about this left recursion, but it's possible there are \"involved\n    // applications\" that we don't already know about, so...\n    memoRec.updateInvolvedApplicationMemoKeys();\n  } else if (!memoRec) {\n    // New left recursion detected! Memoize a failure to try to get a seed parse.\n    memoRec = posInfo.memoize(memoKey, {\n      matchLength: 0,\n      examinedLength: 0,\n      value: false,\n      rightmostFailureOffset: -1,\n    });\n    posInfo.startLeftRecursion(this, memoRec);\n  }\n  return state.useMemoizedResult(state.inputStream.pos, memoRec);\n};\n\npexprs$g.Apply.prototype.reallyEval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const origPosInfo = state.getCurrentPosInfo();\n  const ruleInfo = state.grammar.rules[this.ruleName];\n  const {body} = ruleInfo;\n  const {description} = ruleInfo;\n\n  state.enterApplication(origPosInfo, this);\n\n  if (description) {\n    state.pushFailuresInfo();\n  }\n\n  // Reset the input stream's examinedLength property so that we can track\n  // the examined length of this particular application.\n  const origInputStreamExaminedLength = inputStream.examinedLength;\n  inputStream.examinedLength = 0;\n\n  let value = this.evalOnce(body, state);\n  const currentLR = origPosInfo.currentLeftRecursion;\n  const memoKey = this.toMemoKey();\n  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;\n  let memoRec;\n\n  if (isHeadOfLeftRecursion) {\n    value = this.growSeedResult(body, state, origPos, currentLR, value);\n    origPosInfo.endLeftRecursion();\n    memoRec = currentLR;\n    memoRec.examinedLength = inputStream.examinedLength - origPos;\n    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();\n    origPosInfo.memoize(memoKey, memoRec); // updates origPosInfo's maxExaminedLength\n  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {\n    // This application is not involved in left recursion, so it's ok to memoize it.\n    memoRec = origPosInfo.memoize(memoKey, {\n      matchLength: inputStream.pos - origPos,\n      examinedLength: inputStream.examinedLength - origPos,\n      value,\n      failuresAtRightmostPosition: state.cloneRecordedFailures(),\n      rightmostFailureOffset: state._getRightmostFailureOffset(),\n    });\n  }\n  const succeeded = !!value;\n\n  if (description) {\n    state.popFailuresInfo();\n    if (!succeeded) {\n      state.processFailure(origPos, this);\n    }\n    if (memoRec) {\n      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n    }\n  }\n\n  // Record trace information in the memo table, so that it is available if the memoized result\n  // is used later.\n  if (state.isTracing() && memoRec) {\n    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);\n    if (isHeadOfLeftRecursion) {\n      common$e.assert(entry.terminatingLREntry != null || !succeeded);\n      entry.isHeadOfLeftRecursion = true;\n    }\n    memoRec.traceEntry = entry;\n  }\n\n  // Fix the input stream's examinedLength -- it should be the maximum examined length\n  // across all applications, not just this one.\n  inputStream.examinedLength = Math.max(\n      inputStream.examinedLength,\n      origInputStreamExaminedLength\n  );\n\n  state.exitApplication(origPosInfo, value);\n\n  return succeeded;\n};\n\npexprs$g.Apply.prototype.evalOnce = function(expr, state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n\n  if (state.eval(expr)) {\n    const arity = expr.getArity();\n    const bindings = state._bindings.splice(state._bindings.length - arity, arity);\n    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);\n    const matchLength = inputStream.pos - origPos;\n    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);\n  } else {\n    return false;\n  }\n};\n\npexprs$g.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {\n  if (!newValue) {\n    return false;\n  }\n\n  const {inputStream} = state;\n\n  while (true) {\n    lrMemoRec.matchLength = inputStream.pos - origPos;\n    lrMemoRec.value = newValue;\n    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();\n\n    if (state.isTracing()) {\n      // Before evaluating the body again, add a trace node for this application to the memo entry.\n      // Its only child is a copy of the trace node from `newValue`, which will always be the last\n      // element in `state.trace`.\n      const seedTrace = state.trace[state.trace.length - 1];\n      lrMemoRec.traceEntry = new Trace$1(\n          state.input,\n          origPos,\n          inputStream.pos,\n          this,\n          true,\n          [newValue],\n          [seedTrace.clone()]\n      );\n    }\n    inputStream.pos = origPos;\n    newValue = this.evalOnce(body, state);\n    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {\n      break;\n    }\n    if (state.isTracing()) {\n      state.trace.splice(-2, 1); // Drop the trace for the old seed.\n    }\n  }\n  if (state.isTracing()) {\n    // The last entry is for an unused result -- pop it and save it in the \"real\" entry.\n    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);\n  }\n  inputStream.pos = origPos + lrMemoRec.matchLength;\n  return lrMemoRec.value;\n};\n\npexprs$g.UnicodeChar.prototype.eval = function(state) {\n  const {inputStream} = state;\n  const origPos = inputStream.pos;\n  const ch = inputStream.next();\n  if (ch && this.pattern.test(ch)) {\n    state.pushBinding(new TerminalNode$1(ch.length), origPos);\n    return true;\n  } else {\n    state.processFailure(origPos, this);\n    return false;\n  }\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$d = common$l;\nconst pexprs$f = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs$f.PExpr.prototype.getArity = common$d.abstract('getArity');\n\npexprs$f.any.getArity =\n  pexprs$f.end.getArity =\n  pexprs$f.Terminal.prototype.getArity =\n  pexprs$f.Range.prototype.getArity =\n  pexprs$f.Param.prototype.getArity =\n  pexprs$f.Apply.prototype.getArity =\n  pexprs$f.UnicodeChar.prototype.getArity =\n    function() {\n      return 1;\n    };\n\npexprs$f.Alt.prototype.getArity = function() {\n  // This is ok b/c all terms must have the same arity -- this property is\n  // checked by the Grammar constructor.\n  return this.terms.length === 0 ? 0 : this.terms[0].getArity();\n};\n\npexprs$f.Seq.prototype.getArity = function() {\n  let arity = 0;\n  for (let idx = 0; idx < this.factors.length; idx++) {\n    arity += this.factors[idx].getArity();\n  }\n  return arity;\n};\n\npexprs$f.Iter.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\npexprs$f.Not.prototype.getArity = function() {\n  return 0;\n};\n\npexprs$f.Lookahead.prototype.getArity = pexprs$f.Lex.prototype.getArity = function() {\n  return this.expr.getArity();\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$c = common$l;\nconst pexprs$e = pexprsMain;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction getMetaInfo(expr, grammarInterval) {\n  const metaInfo = {};\n  if (expr.source && grammarInterval) {\n    const adjusted = expr.source.relativeTo(grammarInterval);\n    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n  }\n  return metaInfo;\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs$e.PExpr.prototype.outputRecipe = common$c.abstract('outputRecipe');\n\npexprs$e.any.outputRecipe = function(formals, grammarInterval) {\n  return ['any', getMetaInfo(this, grammarInterval)];\n};\n\npexprs$e.end.outputRecipe = function(formals, grammarInterval) {\n  return ['end', getMetaInfo(this, grammarInterval)];\n};\n\npexprs$e.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['terminal', getMetaInfo(this, grammarInterval), this.obj];\n};\n\npexprs$e.Range.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['range', getMetaInfo(this, grammarInterval), this.from, this.to];\n};\n\npexprs$e.Param.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['param', getMetaInfo(this, grammarInterval), this.index];\n};\n\npexprs$e.Alt.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['alt', getMetaInfo(this, grammarInterval)].concat(\n      this.terms.map(term => term.outputRecipe(formals, grammarInterval))\n  );\n};\n\npexprs$e.Extend.prototype.outputRecipe = function(formals, grammarInterval) {\n  const extension = this.terms[0]; // [extension, original]\n  return extension.outputRecipe(formals, grammarInterval);\n};\n\npexprs$e.Splice.prototype.outputRecipe = function(formals, grammarInterval) {\n  const beforeTerms = this.terms.slice(0, this.expansionPos);\n  const afterTerms = this.terms.slice(this.expansionPos + 1);\n  return [\n    'splice',\n    getMetaInfo(this, grammarInterval),\n    beforeTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n    afterTerms.map(term => term.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\npexprs$e.Seq.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['seq', getMetaInfo(this, grammarInterval)].concat(\n      this.factors.map(factor => factor.outputRecipe(formals, grammarInterval))\n  );\n};\n\npexprs$e.Star.prototype.outputRecipe =\n  pexprs$e.Plus.prototype.outputRecipe =\n  pexprs$e.Opt.prototype.outputRecipe =\n  pexprs$e.Not.prototype.outputRecipe =\n  pexprs$e.Lookahead.prototype.outputRecipe =\n  pexprs$e.Lex.prototype.outputRecipe =\n    function(formals, grammarInterval) {\n      return [\n        this.constructor.name.toLowerCase(),\n        getMetaInfo(this, grammarInterval),\n        this.expr.outputRecipe(formals, grammarInterval),\n      ];\n    };\n\npexprs$e.Apply.prototype.outputRecipe = function(formals, grammarInterval) {\n  return [\n    'app',\n    getMetaInfo(this, grammarInterval),\n    this.ruleName,\n    this.args.map(arg => arg.outputRecipe(formals, grammarInterval)),\n  ];\n};\n\npexprs$e.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {\n  return ['unicodeChar', getMetaInfo(this, grammarInterval), this.category];\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$b = common$l;\nconst pexprs$d = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Called at grammar creation time to rewrite a rule body, replacing each reference to a formal\n  parameter with a `Param` node. Returns a PExpr -- either a new one, or the original one if\n  it was modified in place.\n*/\npexprs$d.PExpr.prototype.introduceParams = common$b.abstract('introduceParams');\n\npexprs$d.any.introduceParams =\n  pexprs$d.end.introduceParams =\n  pexprs$d.Terminal.prototype.introduceParams =\n  pexprs$d.Range.prototype.introduceParams =\n  pexprs$d.Param.prototype.introduceParams =\n  pexprs$d.UnicodeChar.prototype.introduceParams =\n    function(formals) {\n      return this;\n    };\n\npexprs$d.Alt.prototype.introduceParams = function(formals) {\n  this.terms.forEach((term, idx, terms) => {\n    terms[idx] = term.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs$d.Seq.prototype.introduceParams = function(formals) {\n  this.factors.forEach((factor, idx, factors) => {\n    factors[idx] = factor.introduceParams(formals);\n  });\n  return this;\n};\n\npexprs$d.Iter.prototype.introduceParams =\n  pexprs$d.Not.prototype.introduceParams =\n  pexprs$d.Lookahead.prototype.introduceParams =\n  pexprs$d.Lex.prototype.introduceParams =\n    function(formals) {\n      this.expr = this.expr.introduceParams(formals);\n      return this;\n    };\n\npexprs$d.Apply.prototype.introduceParams = function(formals) {\n  const index = formals.indexOf(this.ruleName);\n  if (index >= 0) {\n    if (this.args.length > 0) {\n      // TODO: Should this be supported? See issue #64.\n      throw new Error('Parameterized rules cannot be passed as arguments to another rule.');\n    }\n    return new pexprs$d.Param(index).withSource(this.source);\n  } else {\n    this.args.forEach((arg, idx, args) => {\n      args[idx] = arg.introduceParams(formals);\n    });\n    return this;\n  }\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$a = common$l;\nconst pexprs$c = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns `true` if this parsing expression may accept without consuming any input.\npexprs$c.PExpr.prototype.isNullable = function(grammar) {\n  return this._isNullable(grammar, Object.create(null));\n};\n\npexprs$c.PExpr.prototype._isNullable = common$a.abstract('_isNullable');\n\npexprs$c.any._isNullable =\n  pexprs$c.Range.prototype._isNullable =\n  pexprs$c.Param.prototype._isNullable =\n  pexprs$c.Plus.prototype._isNullable =\n  pexprs$c.UnicodeChar.prototype._isNullable =\n    function(grammar, memo) {\n      return false;\n    };\n\npexprs$c.end._isNullable = function(grammar, memo) {\n  return true;\n};\n\npexprs$c.Terminal.prototype._isNullable = function(grammar, memo) {\n  if (typeof this.obj === 'string') {\n    // This is an over-simplification: it's only correct if the input is a string. If it's an array\n    // or an object, then the empty string parsing expression is not nullable.\n    return this.obj === '';\n  } else {\n    return false;\n  }\n};\n\npexprs$c.Alt.prototype._isNullable = function(grammar, memo) {\n  return this.terms.length === 0 || this.terms.some(term => term._isNullable(grammar, memo));\n};\n\npexprs$c.Seq.prototype._isNullable = function(grammar, memo) {\n  return this.factors.every(factor => factor._isNullable(grammar, memo));\n};\n\npexprs$c.Star.prototype._isNullable =\n  pexprs$c.Opt.prototype._isNullable =\n  pexprs$c.Not.prototype._isNullable =\n  pexprs$c.Lookahead.prototype._isNullable =\n    function(grammar, memo) {\n      return true;\n    };\n\npexprs$c.Lex.prototype._isNullable = function(grammar, memo) {\n  return this.expr._isNullable(grammar, memo);\n};\n\npexprs$c.Apply.prototype._isNullable = function(grammar, memo) {\n  const key = this.toMemoKey();\n  if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n    const {body} = grammar.rules[this.ruleName];\n    const inlined = body.substituteParams(this.args);\n    memo[key] = false; // Prevent infinite recursion for recursive rules.\n    memo[key] = inlined._isNullable(grammar, memo);\n  }\n  return memo[key];\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$9 = common$l;\nconst pexprs$b = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a PExpr that results from recursively replacing every formal parameter (i.e., instance\n  of `Param`) inside this PExpr with its actual value from `actuals` (an Array).\n\n  The receiver must not be modified; a new PExpr must be returned if any replacement is necessary.\n*/\n// function(actuals) { ... }\npexprs$b.PExpr.prototype.substituteParams = common$9.abstract('substituteParams');\n\npexprs$b.any.substituteParams =\n  pexprs$b.end.substituteParams =\n  pexprs$b.Terminal.prototype.substituteParams =\n  pexprs$b.Range.prototype.substituteParams =\n  pexprs$b.UnicodeChar.prototype.substituteParams =\n    function(actuals) {\n      return this;\n    };\n\npexprs$b.Param.prototype.substituteParams = function(actuals) {\n  return actuals[this.index];\n};\n\npexprs$b.Alt.prototype.substituteParams = function(actuals) {\n  return new pexprs$b.Alt(this.terms.map(term => term.substituteParams(actuals)));\n};\n\npexprs$b.Seq.prototype.substituteParams = function(actuals) {\n  return new pexprs$b.Seq(this.factors.map(factor => factor.substituteParams(actuals)));\n};\n\npexprs$b.Iter.prototype.substituteParams =\n  pexprs$b.Not.prototype.substituteParams =\n  pexprs$b.Lookahead.prototype.substituteParams =\n  pexprs$b.Lex.prototype.substituteParams =\n    function(actuals) {\n      return new this.constructor(this.expr.substituteParams(actuals));\n    };\n\npexprs$b.Apply.prototype.substituteParams = function(actuals) {\n  if (this.args.length === 0) {\n    // Avoid making a copy of this application, as an optimization\n    return this;\n  } else {\n    const args = this.args.map(arg => arg.substituteParams(actuals));\n    return new pexprs$b.Apply(this.ruleName, args);\n  }\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$8 = common$l;\nconst pexprs$a = pexprsMain;\n\nconst {copyWithoutDuplicates} = common$8;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction isRestrictedJSIdentifier(str) {\n  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);\n}\n\nfunction resolveDuplicatedNames(argumentNameList) {\n  // `count` is used to record the number of times each argument name occurs in the list,\n  // this is useful for checking duplicated argument name. It maps argument names to ints.\n  const count = Object.create(null);\n  argumentNameList.forEach(argName => {\n    count[argName] = (count[argName] || 0) + 1;\n  });\n\n  // Append subscripts ('_1', '_2', ...) to duplicate argument names.\n  Object.keys(count).forEach(dupArgName => {\n    if (count[dupArgName] <= 1) {\n      return;\n    }\n\n    // This name shows up more than once, so add subscripts.\n    let subscript = 1;\n    argumentNameList.forEach((argName, idx) => {\n      if (argName === dupArgName) {\n        argumentNameList[idx] = argName + '_' + subscript++;\n      }\n    });\n  });\n}\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  Returns a list of strings that will be used as the default argument names for its receiver\n  (a pexpr) in a semantic action. This is used exclusively by the Semantics Editor.\n\n  `firstArgIndex` is the 1-based index of the first argument name that will be generated for this\n  pexpr. It enables us to name arguments positionally, e.g., if the second argument is a\n  non-alphanumeric terminal like \"+\", it will be named '$2'.\n\n  `noDupCheck` is true if the caller of `toArgumentNameList` is not a top level caller. It enables\n  us to avoid nested duplication subscripts appending, e.g., '_1_1', '_1_2', by only checking\n  duplicates at the top level.\n\n  Here is a more elaborate example that illustrates how this method works:\n  `(a \"+\" b).toArgumentNameList(1)` evaluates to `['a', '$2', 'b']` with the following recursive\n  calls:\n\n    (a).toArgumentNameList(1) -> ['a'],\n    (\"+\").toArgumentNameList(2) -> ['$2'],\n    (b).toArgumentNameList(3) -> ['b']\n\n  Notes:\n  * This method must only be called on well-formed expressions, e.g., the receiver must\n    not have any Alt sub-expressions with inconsistent arities.\n  * e.getArity() === e.toArgumentNameList(1).length\n*/\n// function(firstArgIndex, noDupCheck) { ... }\npexprs$a.PExpr.prototype.toArgumentNameList = common$8.abstract('toArgumentNameList');\n\npexprs$a.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['any'];\n};\n\npexprs$a.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['end'];\n};\n\npexprs$a.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  if (typeof this.obj === 'string' && /^[_a-zA-Z0-9]+$/.test(this.obj)) {\n    // If this terminal is a valid suffix for a JS identifier, just prepend it with '_'\n    return ['_' + this.obj];\n  } else {\n    // Otherwise, name it positionally.\n    return ['$' + firstArgIndex];\n  }\n};\n\npexprs$a.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  let argName = this.from + '_to_' + this.to;\n  // If the `argName` is not valid then try to prepend a `_`.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '_' + argName;\n  }\n  // If the `argName` still not valid after prepending a `_`, then name it positionally.\n  if (!isRestrictedJSIdentifier(argName)) {\n    argName = '$' + firstArgIndex;\n  }\n  return [argName];\n};\n\npexprs$a.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // `termArgNameLists` is an array of arrays where each row is the\n  // argument name list that corresponds to a term in this alternation.\n  const termArgNameLists = this.terms.map(term =>\n    term.toArgumentNameList(firstArgIndex, true)\n  );\n\n  const argumentNameList = [];\n  const numArgs = termArgNameLists[0].length;\n  for (let colIdx = 0; colIdx < numArgs; colIdx++) {\n    const col = [];\n    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {\n      col.push(termArgNameLists[rowIdx][colIdx]);\n    }\n    const uniqueNames = copyWithoutDuplicates(col);\n    argumentNameList.push(uniqueNames.join('_or_'));\n  }\n\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs$a.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  // Generate the argument name list, without worrying about duplicates.\n  let argumentNameList = [];\n  this.factors.forEach(factor => {\n    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);\n    argumentNameList = argumentNameList.concat(factorArgumentNameList);\n\n    // Shift the firstArgIndex to take this factor's argument names into account.\n    firstArgIndex += factorArgumentNameList.length;\n  });\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs$a.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  const argumentNameList = this.expr\n      .toArgumentNameList(firstArgIndex, noDupCheck)\n      .map(exprArgumentString =>\n      exprArgumentString[exprArgumentString.length - 1] === 's' ?\n        exprArgumentString + 'es' :\n        exprArgumentString + 's'\n      );\n  if (!noDupCheck) {\n    resolveDuplicatedNames(argumentNameList);\n  }\n  return argumentNameList;\n};\n\npexprs$a.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(argName => {\n    return 'opt' + argName[0].toUpperCase() + argName.slice(1);\n  });\n};\n\npexprs$a.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [];\n};\n\npexprs$a.Lookahead.prototype.toArgumentNameList = pexprs$a.Lex.prototype.toArgumentNameList =\n  function(firstArgIndex, noDupCheck) {\n    return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);\n  };\n\npexprs$a.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return [this.ruleName];\n};\n\npexprs$a.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['$' + firstArgIndex];\n};\n\npexprs$a.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {\n  return ['param' + this.index];\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$7 = common$l;\nconst pexprs$9 = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n// Returns a string representing the PExpr, for use as a UI label, etc.\npexprs$9.PExpr.prototype.toDisplayString = common$7.abstract('toDisplayString');\n\npexprs$9.Alt.prototype.toDisplayString = pexprs$9.Seq.prototype.toDisplayString = function() {\n  if (this.source) {\n    return this.source.trimmed().contents;\n  }\n  return '[' + this.constructor.name + ']';\n};\n\npexprs$9.any.toDisplayString =\n  pexprs$9.end.toDisplayString =\n  pexprs$9.Iter.prototype.toDisplayString =\n  pexprs$9.Not.prototype.toDisplayString =\n  pexprs$9.Lookahead.prototype.toDisplayString =\n  pexprs$9.Lex.prototype.toDisplayString =\n  pexprs$9.Terminal.prototype.toDisplayString =\n  pexprs$9.Range.prototype.toDisplayString =\n  pexprs$9.Param.prototype.toDisplayString =\n    function() {\n      return this.toString();\n    };\n\npexprs$9.Apply.prototype.toDisplayString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toDisplayString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\npexprs$9.UnicodeChar.prototype.toDisplayString = function() {\n  return 'Unicode [' + this.category + '] character';\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Failure$1 = Failure_1;\nconst common$6 = common$l;\nconst pexprs$8 = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\npexprs$8.PExpr.prototype.toFailure = common$6.abstract('toFailure');\n\npexprs$8.any.toFailure = function(grammar) {\n  return new Failure$1(this, 'any object', 'description');\n};\n\npexprs$8.end.toFailure = function(grammar) {\n  return new Failure$1(this, 'end of input', 'description');\n};\n\npexprs$8.Terminal.prototype.toFailure = function(grammar) {\n  return new Failure$1(this, this.obj, 'string');\n};\n\npexprs$8.Range.prototype.toFailure = function(grammar) {\n  // TODO: come up with something better\n  return new Failure$1(this, JSON.stringify(this.from) + '..' + JSON.stringify(this.to), 'code');\n};\n\npexprs$8.Not.prototype.toFailure = function(grammar) {\n  const description =\n    this.expr === pexprs$8.any ? 'nothing' : 'not ' + this.expr.toFailure(grammar);\n  return new Failure$1(this, description, 'description');\n};\n\npexprs$8.Lookahead.prototype.toFailure = function(grammar) {\n  return this.expr.toFailure(grammar);\n};\n\npexprs$8.Apply.prototype.toFailure = function(grammar) {\n  let {description} = grammar.rules[this.ruleName];\n  if (!description) {\n    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? 'an' : 'a';\n    description = article + ' ' + this.ruleName;\n  }\n  return new Failure$1(this, description, 'description');\n};\n\npexprs$8.UnicodeChar.prototype.toFailure = function(grammar) {\n  return new Failure$1(this, 'a Unicode [' + this.category + '] character', 'description');\n};\n\npexprs$8.Alt.prototype.toFailure = function(grammar) {\n  const fs = this.terms.map(t => t.toFailure(grammar));\n  const description = '(' + fs.join(' or ') + ')';\n  return new Failure$1(this, description, 'description');\n};\n\npexprs$8.Seq.prototype.toFailure = function(grammar) {\n  const fs = this.factors.map(f => f.toFailure(grammar));\n  const description = '(' + fs.join(' ') + ')';\n  return new Failure$1(this, description, 'description');\n};\n\npexprs$8.Iter.prototype.toFailure = function(grammar) {\n  const description = '(' + this.expr.toFailure(grammar) + this.operator + ')';\n  return new Failure$1(this, description, 'description');\n};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$5 = common$l;\nconst pexprs$7 = pexprsMain;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\n/*\n  e1.toString() === e2.toString() ==> e1 and e2 are semantically equivalent.\n  Note that this is not an iff (<==>): e.g.,\n  (~\"b\" \"a\").toString() !== (\"a\").toString(), even though\n  ~\"b\" \"a\" and \"a\" are interchangeable in any grammar,\n  both in terms of the languages they accept and their arities.\n*/\npexprs$7.PExpr.prototype.toString = common$5.abstract('toString');\n\npexprs$7.any.toString = function() {\n  return 'any';\n};\n\npexprs$7.end.toString = function() {\n  return 'end';\n};\n\npexprs$7.Terminal.prototype.toString = function() {\n  return JSON.stringify(this.obj);\n};\n\npexprs$7.Range.prototype.toString = function() {\n  return JSON.stringify(this.from) + '..' + JSON.stringify(this.to);\n};\n\npexprs$7.Param.prototype.toString = function() {\n  return '$' + this.index;\n};\n\npexprs$7.Lex.prototype.toString = function() {\n  return '#(' + this.expr.toString() + ')';\n};\n\npexprs$7.Alt.prototype.toString = function() {\n  return this.terms.length === 1 ?\n    this.terms[0].toString() :\n    '(' + this.terms.map(term => term.toString()).join(' | ') + ')';\n};\n\npexprs$7.Seq.prototype.toString = function() {\n  return this.factors.length === 1 ?\n    this.factors[0].toString() :\n    '(' + this.factors.map(factor => factor.toString()).join(' ') + ')';\n};\n\npexprs$7.Iter.prototype.toString = function() {\n  return this.expr + this.operator;\n};\n\npexprs$7.Not.prototype.toString = function() {\n  return '~' + this.expr;\n};\n\npexprs$7.Lookahead.prototype.toString = function() {\n  return '&' + this.expr;\n};\n\npexprs$7.Apply.prototype.toString = function() {\n  if (this.args.length > 0) {\n    const ps = this.args.map(arg => arg.toString());\n    return this.ruleName + '<' + ps.join(',') + '>';\n  } else {\n    return this.ruleName;\n  }\n};\n\npexprs$7.UnicodeChar.prototype.toString = function() {\n  return '\\\\p{' + this.category + '}';\n};\n\n// --------------------------------------------------------------------\n// Re-export classes\n// --------------------------------------------------------------------\n\nvar pexprs$6 = pexprsMain;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Failure = Failure_1;\nconst {TerminalNode} = nodes$1;\nconst {assert: assert$1} = common$l;\nconst {PExpr, Terminal} = pexprs$6;\n\nclass CaseInsensitiveTerminal$1 extends PExpr {\n  constructor(param) {\n    super();\n    this.obj = param;\n  }\n\n  _getString(state) {\n    const terminal = state.currentApplication().args[this.obj.index];\n    assert$1(terminal instanceof Terminal, 'expected a Terminal expression');\n    return terminal.obj;\n  }\n\n  // Implementation of the PExpr API\n\n  allowsSkippingPrecedingSpace() {\n    return true;\n  }\n\n  eval(state) {\n    const {inputStream} = state;\n    const origPos = inputStream.pos;\n    const matchStr = this._getString(state);\n    if (!inputStream.matchString(matchStr, true)) {\n      state.processFailure(origPos, this);\n      return false;\n    } else {\n      state.pushBinding(new TerminalNode(matchStr.length), origPos);\n      return true;\n    }\n  }\n\n  getArity() {\n    return 1;\n  }\n\n  substituteParams(actuals) {\n    return new CaseInsensitiveTerminal$1(this.obj.substituteParams(actuals));\n  }\n\n  toDisplayString() {\n    return this.obj.toDisplayString() + ' (case-insensitive)';\n  }\n\n  toFailure(grammar) {\n    return new Failure(\n        this,\n        this.obj.toFailure(grammar) + ' (case-insensitive)',\n        'description'\n    );\n  }\n\n  _isNullable(grammar, memo) {\n    return this.obj._isNullable(grammar, memo);\n  }\n}\n\nvar CaseInsensitiveTerminal_1 = CaseInsensitiveTerminal$1;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Interval$1 = Interval_1;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction InputStream$3(source) {\n  this.source = source;\n  this.pos = 0;\n  this.examinedLength = 0;\n}\n\nInputStream$3.prototype = {\n  atEnd() {\n    const ans = this.pos === this.source.length;\n    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);\n    return ans;\n  },\n\n  next() {\n    const ans = this.source[this.pos++];\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return ans;\n  },\n\n  nextCharCode() {\n    const nextChar = this.next();\n    return nextChar && nextChar.charCodeAt(0);\n  },\n\n  nextCodePoint() {\n    const cp = this.source.slice(this.pos++).codePointAt(0);\n    // If the code point is beyond plane 0, it takes up two characters.\n    if (cp > 0xffff) {\n      this.pos += 1;\n    }\n    this.examinedLength = Math.max(this.examinedLength, this.pos);\n    return cp;\n  },\n\n  matchString(s, optIgnoreCase) {\n    let idx;\n    if (optIgnoreCase) {\n      /*\n        Case-insensitive comparison is a tricky business. Some notable gotchas include the\n        \"Turkish I\" problem (http://www.i18nguy.com/unicode/turkish-i18n.html) and the fact\n        that the German Esszet () turns into \"SS\" in upper case.\n\n        This is intended to be a locale-invariant comparison, which means it may not obey\n        locale-specific expectations (e.g. \"i\" => \"\").\n       */\n      for (idx = 0; idx < s.length; idx++) {\n        const actual = this.next();\n        const expected = s[idx];\n        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    // Default is case-sensitive comparison.\n    for (idx = 0; idx < s.length; idx++) {\n      if (this.next() !== s[idx]) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  sourceSlice(startIdx, endIdx) {\n    return this.source.slice(startIdx, endIdx);\n  },\n\n  interval(startIdx, optEndIdx) {\n    return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);\n  },\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar InputStream_1 = InputStream$3;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst common$4 = common$l;\nconst util$4 = util$7;\nconst Interval = Interval_1;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction MatchResult$2(\n    matcher,\n    input,\n    startExpr,\n    cst,\n    cstOffset,\n    rightmostFailurePosition,\n    optRecordedFailures\n) {\n  this.matcher = matcher;\n  this.input = input;\n  this.startExpr = startExpr;\n  this._cst = cst;\n  this._cstOffset = cstOffset;\n  this._rightmostFailurePosition = rightmostFailurePosition;\n  this._rightmostFailures = optRecordedFailures;\n\n  if (this.failed()) {\n    /* eslint-disable no-invalid-this */\n    common$4.defineLazyProperty(this, 'message', function() {\n      const detail = 'Expected ' + this.getExpectedText();\n      return (\n        util$4.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail\n      );\n    });\n    common$4.defineLazyProperty(this, 'shortMessage', function() {\n      const detail = 'expected ' + this.getExpectedText();\n      const errorInfo = util$4.getLineAndColumn(this.input, this.getRightmostFailurePosition());\n      return 'Line ' + errorInfo.lineNum + ', col ' + errorInfo.colNum + ': ' + detail;\n    });\n    /* eslint-enable no-invalid-this */\n  }\n}\n\nMatchResult$2.prototype.succeeded = function() {\n  return !!this._cst;\n};\n\nMatchResult$2.prototype.failed = function() {\n  return !this.succeeded();\n};\n\nMatchResult$2.prototype.getRightmostFailurePosition = function() {\n  return this._rightmostFailurePosition;\n};\n\nMatchResult$2.prototype.getRightmostFailures = function() {\n  if (!this._rightmostFailures) {\n    this.matcher.setInput(this.input);\n    const matchResultWithFailures = this.matcher._match(\n        this.startExpr,\n        false,\n        this.getRightmostFailurePosition()\n    );\n    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();\n  }\n  return this._rightmostFailures;\n};\n\nMatchResult$2.prototype.toString = function() {\n  return this.succeeded() ?\n    '[match succeeded]' :\n    '[match failed at position ' + this.getRightmostFailurePosition() + ']';\n};\n\n// Return a string summarizing the expected contents of the input stream when\n// the match failure occurred.\nMatchResult$2.prototype.getExpectedText = function() {\n  if (this.succeeded()) {\n    throw new Error('cannot get expected text of a successful MatchResult');\n  }\n\n  const sb = new common$4.StringBuffer();\n  let failures = this.getRightmostFailures();\n\n  // Filter out the fluffy failures to make the default error messages more useful\n  failures = failures.filter(failure => !failure.isFluffy());\n\n  for (let idx = 0; idx < failures.length; idx++) {\n    if (idx > 0) {\n      if (idx === failures.length - 1) {\n        sb.append(failures.length > 2 ? ', or ' : ' or ');\n      } else {\n        sb.append(', ');\n      }\n    }\n    sb.append(failures[idx].toString());\n  }\n  return sb.contents();\n};\n\nMatchResult$2.prototype.getInterval = function() {\n  const pos = this.getRightmostFailurePosition();\n  return new Interval(this.input, pos, pos);\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar MatchResult_1 = MatchResult$2;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction PosInfo$1() {\n  this.applicationMemoKeyStack = []; // active applications at this position\n  this.memo = {};\n  this.maxExaminedLength = 0;\n  this.maxRightmostFailureOffset = -1;\n  this.currentLeftRecursion = undefined;\n}\n\nPosInfo$1.prototype = {\n  isActive(application) {\n    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;\n  },\n\n  enter(application) {\n    this.applicationMemoKeyStack.push(application.toMemoKey());\n  },\n\n  exit() {\n    this.applicationMemoKeyStack.pop();\n  },\n\n  startLeftRecursion(headApplication, memoRec) {\n    memoRec.isLeftRecursion = true;\n    memoRec.headApplication = headApplication;\n    memoRec.nextLeftRecursion = this.currentLeftRecursion;\n    this.currentLeftRecursion = memoRec;\n\n    const {applicationMemoKeyStack} = this;\n    const indexOfFirstInvolvedRule =\n      applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;\n    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(\n        indexOfFirstInvolvedRule\n    );\n\n    memoRec.isInvolved = function(applicationMemoKey) {\n      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;\n    };\n\n    memoRec.updateInvolvedApplicationMemoKeys = function() {\n      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {\n        const applicationMemoKey = applicationMemoKeyStack[idx];\n        if (!this.isInvolved(applicationMemoKey)) {\n          involvedApplicationMemoKeys.push(applicationMemoKey);\n        }\n      }\n    };\n  },\n\n  endLeftRecursion() {\n    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;\n  },\n\n  // Note: this method doesn't get called for the \"head\" of a left recursion -- for LR heads,\n  // the memoized result (which starts out being a failure) is always used.\n  shouldUseMemoizedResult(memoRec) {\n    if (!memoRec.isLeftRecursion) {\n      return true;\n    }\n    const {applicationMemoKeyStack} = this;\n    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {\n      const applicationMemoKey = applicationMemoKeyStack[idx];\n      if (memoRec.isInvolved(applicationMemoKey)) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  memoize(memoKey, memoRec) {\n    this.memo[memoKey] = memoRec;\n    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n    this.maxRightmostFailureOffset = Math.max(\n        this.maxRightmostFailureOffset,\n        memoRec.rightmostFailureOffset\n    );\n    return memoRec;\n  },\n\n  clearObsoleteEntries(pos, invalidatedIdx) {\n    if (pos + this.maxExaminedLength <= invalidatedIdx) {\n      // Optimization: none of the rule applications that were memoized here examined the\n      // interval of the input that changed, so nothing has to be invalidated.\n      return;\n    }\n\n    const {memo} = this;\n    this.maxExaminedLength = 0;\n    this.maxRightmostFailureOffset = -1;\n    Object.keys(memo).forEach(k => {\n      const memoRec = memo[k];\n      if (pos + memoRec.examinedLength > invalidatedIdx) {\n        delete memo[k];\n      } else {\n        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);\n        this.maxRightmostFailureOffset = Math.max(\n            this.maxRightmostFailureOffset,\n            memoRec.rightmostFailureOffset\n        );\n      }\n    });\n  },\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar PosInfo_1 = PosInfo$1;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst InputStream$2 = InputStream_1;\nconst MatchResult$1 = MatchResult_1;\nconst PosInfo = PosInfo_1;\nconst Trace = Trace_1;\nconst pexprs$5 = pexprs$6;\nconst util$3 = util$7;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nlet builtInApplySyntacticBody;\n\nutil$3.awaitBuiltInRules(builtInRules => {\n  builtInApplySyntacticBody = builtInRules.rules.applySyntactic.body;\n});\n\nconst applySpaces = new pexprs$5.Apply('spaces');\n\nfunction MatchState$1(matcher, startExpr, optPositionToRecordFailures) {\n  this.matcher = matcher;\n  this.startExpr = startExpr;\n\n  this.grammar = matcher.grammar;\n  this.input = matcher.input;\n  this.inputStream = new InputStream$2(matcher.input);\n  this.memoTable = matcher.memoTable;\n\n  this._bindings = [];\n  this._bindingOffsets = [];\n  this._applicationStack = [];\n  this._posStack = [0];\n  this.inLexifiedContextStack = [false];\n\n  this.rightmostFailurePosition = -1;\n  this._rightmostFailurePositionStack = [];\n  this._recordedFailuresStack = [];\n\n  if (optPositionToRecordFailures !== undefined) {\n    this.positionToRecordFailures = optPositionToRecordFailures;\n    this.recordedFailures = Object.create(null);\n  }\n}\n\nMatchState$1.prototype = {\n  posToOffset(pos) {\n    return pos - this._posStack[this._posStack.length - 1];\n  },\n\n  enterApplication(posInfo, app) {\n    this._posStack.push(this.inputStream.pos);\n    this._applicationStack.push(app);\n    this.inLexifiedContextStack.push(false);\n    posInfo.enter(app);\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this.rightmostFailurePosition = -1;\n  },\n\n  exitApplication(posInfo, optNode) {\n    const origPos = this._posStack.pop();\n    this._applicationStack.pop();\n    this.inLexifiedContextStack.pop();\n    posInfo.exit();\n\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        this._rightmostFailurePositionStack.pop()\n    );\n\n    if (optNode) {\n      this.pushBinding(optNode, origPos);\n    }\n  },\n\n  enterLexifiedContext() {\n    this.inLexifiedContextStack.push(true);\n  },\n\n  exitLexifiedContext() {\n    this.inLexifiedContextStack.pop();\n  },\n\n  currentApplication() {\n    return this._applicationStack[this._applicationStack.length - 1];\n  },\n\n  inSyntacticContext() {\n    const currentApplication = this.currentApplication();\n    if (currentApplication) {\n      return currentApplication.isSyntactic() && !this.inLexifiedContext();\n    } else {\n      // The top-level context is syntactic if the start application is.\n      return this.startExpr.factors[0].isSyntactic();\n    }\n  },\n\n  inLexifiedContext() {\n    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];\n  },\n\n  skipSpaces() {\n    this.pushFailuresInfo();\n    this.eval(applySpaces);\n    this.popBinding();\n    this.popFailuresInfo();\n    return this.inputStream.pos;\n  },\n\n  skipSpacesIfInSyntacticContext() {\n    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;\n  },\n\n  maybeSkipSpacesBefore(expr) {\n    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {\n      return this.skipSpacesIfInSyntacticContext();\n    } else {\n      return this.inputStream.pos;\n    }\n  },\n\n  pushBinding(node, origPos) {\n    this._bindings.push(node);\n    this._bindingOffsets.push(this.posToOffset(origPos));\n  },\n\n  popBinding() {\n    this._bindings.pop();\n    this._bindingOffsets.pop();\n  },\n\n  numBindings() {\n    return this._bindings.length;\n  },\n\n  truncateBindings(newLength) {\n    // Yes, this is this really faster than setting the `length` property (tested with\n    // bin/es5bench on Node v6.1.0).\n    // Update 2021-10-25: still true on v14.15.5  it's ~20% speedup on es5bench.\n    while (this._bindings.length > newLength) {\n      this.popBinding();\n    }\n  },\n\n  getCurrentPosInfo() {\n    return this.getPosInfo(this.inputStream.pos);\n  },\n\n  getPosInfo(pos) {\n    let posInfo = this.memoTable[pos];\n    if (!posInfo) {\n      posInfo = this.memoTable[pos] = new PosInfo();\n    }\n    return posInfo;\n  },\n\n  processFailure(pos, expr) {\n    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);\n\n    if (this.recordedFailures && pos === this.positionToRecordFailures) {\n      const app = this.currentApplication();\n      if (app) {\n        // Substitute parameters with the actual pexprs that were passed to\n        // the current rule.\n        expr = expr.substituteParams(app.args);\n      }\n\n      this.recordFailure(expr.toFailure(this.grammar), false);\n    }\n  },\n\n  recordFailure(failure, shouldCloneIfNew) {\n    const key = failure.toKey();\n    if (!this.recordedFailures[key]) {\n      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;\n    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {\n      this.recordedFailures[key].clearFluffy();\n    }\n  },\n\n  recordFailures(failures, shouldCloneIfNew) {\n    Object.keys(failures).forEach(key => {\n      this.recordFailure(failures[key], shouldCloneIfNew);\n    });\n  },\n\n  cloneRecordedFailures() {\n    if (!this.recordedFailures) {\n      return undefined;\n    }\n\n    const ans = Object.create(null);\n    Object.keys(this.recordedFailures).forEach(key => {\n      ans[key] = this.recordedFailures[key].clone();\n    });\n    return ans;\n  },\n\n  getRightmostFailurePosition() {\n    return this.rightmostFailurePosition;\n  },\n\n  _getRightmostFailureOffset() {\n    return this.rightmostFailurePosition >= 0 ?\n      this.posToOffset(this.rightmostFailurePosition) :\n      -1;\n  },\n\n  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.\n  getMemoizedTraceEntry(pos, expr) {\n    const posInfo = this.memoTable[pos];\n    if (posInfo && expr instanceof pexprs$5.Apply) {\n      const memoRec = posInfo.memo[expr.toMemoKey()];\n      if (memoRec && memoRec.traceEntry) {\n        const entry = memoRec.traceEntry.cloneWithExpr(expr);\n        entry.isMemoized = true;\n        return entry;\n      }\n    }\n    return null;\n  },\n\n  // Returns a new trace entry, with the currently active trace array as its children.\n  getTraceEntry(pos, expr, succeeded, bindings) {\n    if (expr instanceof pexprs$5.Apply) {\n      const app = this.currentApplication();\n      const actuals = app ? app.args : [];\n      expr = expr.substituteParams(actuals);\n    }\n    return (\n      this.getMemoizedTraceEntry(pos, expr) ||\n      new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace)\n    );\n  },\n\n  isTracing() {\n    return !!this.trace;\n  },\n\n  hasNecessaryInfo(memoRec) {\n    if (this.trace && !memoRec.traceEntry) {\n      return false;\n    }\n\n    if (\n      this.recordedFailures &&\n      this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures\n    ) {\n      return !!memoRec.failuresAtRightmostPosition;\n    }\n\n    return true;\n  },\n\n  useMemoizedResult(origPos, memoRec) {\n    if (this.trace) {\n      this.trace.push(memoRec.traceEntry);\n    }\n\n    const memoRecRightmostFailurePosition =\n      this.inputStream.pos + memoRec.rightmostFailureOffset;\n    this.rightmostFailurePosition = Math.max(\n        this.rightmostFailurePosition,\n        memoRecRightmostFailurePosition\n    );\n    if (\n      this.recordedFailures &&\n      this.positionToRecordFailures === memoRecRightmostFailurePosition &&\n      memoRec.failuresAtRightmostPosition\n    ) {\n      this.recordFailures(memoRec.failuresAtRightmostPosition, true);\n    }\n\n    this.inputStream.examinedLength = Math.max(\n        this.inputStream.examinedLength,\n        memoRec.examinedLength + origPos\n    );\n\n    if (memoRec.value) {\n      this.inputStream.pos += memoRec.matchLength;\n      this.pushBinding(memoRec.value, origPos);\n      return true;\n    }\n    return false;\n  },\n\n  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`\n  // will have `expr.getArity()` more elements than before, and the input stream's position may\n  // have increased. On failure, `bindings` and position will be unchanged.\n  eval(expr) {\n    const {inputStream} = this;\n    const origNumBindings = this._bindings.length;\n\n    let origRecordedFailures;\n    if (this.recordedFailures) {\n      origRecordedFailures = this.recordedFailures;\n      this.recordedFailures = Object.create(null);\n    }\n\n    const origPos = inputStream.pos;\n    const memoPos = this.maybeSkipSpacesBefore(expr);\n\n    let origTrace;\n    if (this.trace) {\n      origTrace = this.trace;\n      this.trace = [];\n    }\n\n    // Do the actual evaluation.\n    const ans = expr.eval(this);\n\n    if (this.trace) {\n      const bindings = this._bindings.slice(origNumBindings);\n      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);\n      traceEntry.isImplicitSpaces = expr === applySpaces;\n      traceEntry.isRootNode = expr === this.startExpr;\n      origTrace.push(traceEntry);\n      this.trace = origTrace;\n    }\n\n    if (ans) {\n      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {\n        Object.keys(this.recordedFailures).forEach(key => {\n          this.recordedFailures[key].makeFluffy();\n        });\n      }\n    } else {\n      // Reset the position and the bindings.\n      inputStream.pos = origPos;\n      this.truncateBindings(origNumBindings);\n    }\n\n    if (this.recordedFailures) {\n      this.recordFailures(origRecordedFailures, false);\n    }\n\n    // The built-in applySyntactic rule needs special handling: we want to skip\n    // trailing spaces, just as with the top-level application of a syntactic rule.\n    if (expr === builtInApplySyntacticBody) {\n      this.skipSpaces();\n    }\n\n    return ans;\n  },\n\n  getMatchResult() {\n    this.eval(this.startExpr);\n    let rightmostFailures;\n    if (this.recordedFailures) {\n      rightmostFailures = Object.keys(this.recordedFailures).map(\n          key => this.recordedFailures[key]\n      );\n    }\n    const cst = this._bindings[0];\n    if (cst) {\n      cst.grammar = this.grammar;\n    }\n    return new MatchResult$1(\n        this.matcher,\n        this.input,\n        this.startExpr,\n        cst,\n        this._bindingOffsets[0],\n        this.rightmostFailurePosition,\n        rightmostFailures\n    );\n  },\n\n  getTrace() {\n    this.trace = [];\n    const matchResult = this.getMatchResult();\n\n    // The trace node for the start rule is always the last entry. If it is a syntactic rule,\n    // the first entry is for an application of 'spaces'.\n    // TODO(pdubroy): Clean this up by introducing a special `Match<startAppl>` rule, which will\n    // ensure that there is always a single root trace node.\n    const rootTrace = this.trace[this.trace.length - 1];\n    rootTrace.result = matchResult;\n    return rootTrace;\n  },\n\n  pushFailuresInfo() {\n    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);\n    this._recordedFailuresStack.push(this.recordedFailures);\n  },\n\n  popFailuresInfo() {\n    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();\n    this.recordedFailures = this._recordedFailuresStack.pop();\n  },\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar MatchState_1 = MatchState$1;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst MatchState = MatchState_1;\n\nconst pexprs$4 = pexprs$6;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Matcher$1(grammar) {\n  this.grammar = grammar;\n  this.memoTable = [];\n  this.input = '';\n}\n\nMatcher$1.prototype.getInput = function() {\n  return this.input;\n};\n\nMatcher$1.prototype.setInput = function(str) {\n  if (this.input !== str) {\n    this.replaceInputRange(0, this.input.length, str);\n  }\n  return this;\n};\n\nMatcher$1.prototype.replaceInputRange = function(startIdx, endIdx, str) {\n  const currentInput = this.input;\n  if (\n    startIdx < 0 ||\n    startIdx > currentInput.length ||\n    endIdx < 0 ||\n    endIdx > currentInput.length ||\n    startIdx > endIdx\n  ) {\n    throw new Error('Invalid indices: ' + startIdx + ' and ' + endIdx);\n  }\n\n  // update input\n  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);\n\n  // update memo table (similar to the above)\n  const restOfMemoTable = this.memoTable.slice(endIdx);\n  this.memoTable.length = startIdx;\n  for (let idx = 0; idx < str.length; idx++) {\n    this.memoTable.push(undefined);\n  }\n  restOfMemoTable.forEach(function(posInfo) {\n    this.memoTable.push(posInfo);\n  }, this);\n\n  // Invalidate memoRecs\n  for (let pos = 0; pos < startIdx; pos++) {\n    const posInfo = this.memoTable[pos];\n    if (posInfo) {\n      posInfo.clearObsoleteEntries(pos, startIdx);\n    }\n  }\n\n  return this;\n};\n\nMatcher$1.prototype.match = function(optStartApplicationStr) {\n  return this._match(this._getStartExpr(optStartApplicationStr), false);\n};\n\nMatcher$1.prototype.trace = function(optStartApplicationStr) {\n  return this._match(this._getStartExpr(optStartApplicationStr), true);\n};\n\nMatcher$1.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {\n  const state = new MatchState(this, startExpr, optPositionToRecordFailures);\n  return tracing ? state.getTrace() : state.getMatchResult();\n};\n\n/*\n  Returns the starting expression for this Matcher's associated grammar. If `optStartApplicationStr`\n  is specified, it is a string expressing a rule application in the grammar. If not specified, the\n  grammar's default start rule will be used.\n*/\nMatcher$1.prototype._getStartExpr = function(optStartApplicationStr) {\n  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;\n  if (!applicationStr) {\n    throw new Error('Missing start rule argument -- the grammar has no default start rule.');\n  }\n\n  const startApp = this.grammar.parseApplication(applicationStr);\n  return new pexprs$4.Seq([startApp, pexprs$4.end]);\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Matcher_1 = Matcher$1;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst InputStream$1 = InputStream_1;\nconst {IterationNode} = nodes$1;\nconst MatchResult = MatchResult_1;\nconst common$3 = common$l;\nconst errors$3 = errors$9;\nconst util$2 = util$7;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst globalActionStack = [];\n\nconst hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);\n\n// ----------------- Wrappers -----------------\n\n// Wrappers decorate CST nodes with all of the functionality (i.e., operations and attributes)\n// provided by a Semantics (see below). `Wrapper` is the abstract superclass of all wrappers. A\n// `Wrapper` must have `_node` and `_semantics` instance variables, which refer to the CST node and\n// Semantics (resp.) for which it was created, and a `_childWrappers` instance variable which is\n// used to cache the wrapper instances that are created for its child nodes. Setting these instance\n// variables is the responsibility of the constructor of each Semantics-specific subclass of\n// `Wrapper`.\nclass Wrapper {\n  constructor(node, sourceInterval, baseInterval) {\n    this._node = node;\n    this.source = sourceInterval;\n\n    // The interval that the childOffsets of `node` are relative to. It should be the source\n    // of the closest Nonterminal node.\n    this._baseInterval = baseInterval;\n\n    if (node.isNonterminal()) {\n      common$3.assert(sourceInterval === baseInterval);\n    }\n    this._childWrappers = [];\n  }\n\n  toString() {\n    return '[semantics wrapper for ' + this._node.grammar.name + ']';\n  }\n\n  _forgetMemoizedResultFor(attributeName) {\n    // Remove the memoized attribute from the cstNode and all its children.\n    delete this._node[this._semantics.attributeKeys[attributeName]];\n    this.children.forEach(child => {\n      child._forgetMemoizedResultFor(attributeName);\n    });\n  }\n\n  // Returns the wrapper of the specified child node. Child wrappers are created lazily and\n  // cached in the parent wrapper's `_childWrappers` instance variable.\n  child(idx) {\n    if (!(0 <= idx && idx < this._node.numChildren())) {\n      // TODO: Consider throwing an exception here.\n      return undefined;\n    }\n    let childWrapper = this._childWrappers[idx];\n    if (!childWrapper) {\n      const childNode = this._node.childAt(idx);\n      const offset = this._node.childOffsets[idx];\n\n      const source = this._baseInterval.subInterval(offset, childNode.matchLength);\n      const base = childNode.isNonterminal() ? source : this._baseInterval;\n      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);\n    }\n    return childWrapper;\n  }\n\n  // Returns an array containing the wrappers of all of the children of the node associated\n  // with this wrapper.\n  _children() {\n    // Force the creation of all child wrappers\n    for (let idx = 0; idx < this._node.numChildren(); idx++) {\n      this.child(idx);\n    }\n    return this._childWrappers;\n  }\n\n  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration\n  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.\n  isIteration() {\n    return this._node.isIteration();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`\n  // otherwise.\n  isTerminal() {\n    return this._node.isTerminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`\n  // otherwise.\n  isNonterminal() {\n    return this._node.isNonterminal();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a syntactic rule, `false` otherwise.\n  isSyntactic() {\n    return this.isNonterminal() && this._node.isSyntactic();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is a nonterminal node\n  // corresponding to a lexical rule, `false` otherwise.\n  isLexical() {\n    return this.isNonterminal() && this._node.isLexical();\n  }\n\n  // Returns `true` if the CST node associated with this wrapper is an iterator node\n  // having either one or no child (? operator), `false` otherwise.\n  // Otherwise, throws an exception.\n  isOptional() {\n    return this._node.isOptional();\n  }\n\n  // Create a new _iter wrapper in the same semantics as this wrapper.\n  iteration(optChildWrappers) {\n    const childWrappers = optChildWrappers || [];\n\n    const childNodes = childWrappers.map(c => c._node);\n    const iter = new IterationNode(childNodes, [], -1, false);\n\n    const wrapper = this._semantics.wrap(iter, null, null);\n    wrapper._childWrappers = childWrappers;\n    return wrapper;\n  }\n\n  // Returns an array containing the children of this CST node.\n  get children() {\n    return this._children();\n  }\n\n  // Returns the name of grammar rule that created this CST node.\n  get ctorName() {\n    return this._node.ctorName;\n  }\n\n  // TODO: Remove this eventually (deprecated in v0.12).\n  get interval() {\n    throw new Error('The `interval` property is deprecated -- use `source` instead');\n  }\n\n  // Returns the number of children of this CST node.\n  get numChildren() {\n    return this._node.numChildren();\n  }\n\n  // Returns the contents of the input stream consumed by this CST node.\n  get sourceString() {\n    return this.source.contents;\n  }\n}\n\n// ----------------- Semantics -----------------\n\n// A Semantics is a container for a family of Operations and Attributes for a given grammar.\n// Semantics enable modularity (different clients of a grammar can create their set of operations\n// and attributes in isolation) and extensibility even when operations and attributes are mutually-\n// recursive. This constructor should not be called directly except from\n// `Semantics.createSemantics`. The normal ways to create a Semantics, given a grammar 'g', are\n// `g.createSemantics()` and `g.extendSemantics(parentSemantics)`.\nfunction Semantics$2(grammar, superSemantics) {\n  const self = this;\n  this.grammar = grammar;\n  this.checkedActionDicts = false;\n\n  // Constructor for wrapper instances, which are passed as the arguments to the semantic actions\n  // of an operation or attribute. Operations and attributes require double dispatch: the semantic\n  // action is chosen based on both the node's type and the semantics. Wrappers ensure that\n  // the `execute` method is called with the correct (most specific) semantics object as an\n  // argument.\n  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {\n    constructor(node, sourceInterval, baseInterval) {\n      super(node, sourceInterval, baseInterval);\n      self.checkActionDictsIfHaventAlready();\n      this._semantics = self;\n    }\n  };\n\n  this.super = superSemantics;\n  if (superSemantics) {\n    if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) {\n      throw new Error(\n          \"Cannot extend a semantics for grammar '\" +\n          this.super.grammar.name +\n          \"' for use with grammar '\" +\n          grammar.name +\n          \"' (not a sub-grammar)\"\n      );\n    }\n    this.operations = Object.create(this.super.operations);\n    this.attributes = Object.create(this.super.attributes);\n    this.attributeKeys = Object.create(null);\n\n    // Assign unique symbols for each of the attributes inherited from the super-semantics so that\n    // they are memoized independently.\n    // eslint-disable-next-line guard-for-in\n    for (const attributeName in this.attributes) {\n      Object.defineProperty(this.attributeKeys, attributeName, {\n        value: util$2.uniqueId(attributeName),\n      });\n    }\n  } else {\n    this.operations = Object.create(null);\n    this.attributes = Object.create(null);\n    this.attributeKeys = Object.create(null);\n  }\n}\n\nSemantics$2.prototype.toString = function() {\n  return '[semantics for ' + this.grammar.name + ']';\n};\n\nSemantics$2.prototype.checkActionDictsIfHaventAlready = function() {\n  if (!this.checkedActionDicts) {\n    this.checkActionDicts();\n    this.checkedActionDicts = true;\n  }\n};\n\n// Checks that the action dictionaries for all operations and attributes in this semantics,\n// including the ones that were inherited from the super-semantics, agree with the grammar.\n// Throws an exception if one or more of them doesn't.\nSemantics$2.prototype.checkActionDicts = function() {\n  let name;\n  // eslint-disable-next-line guard-for-in\n  for (name in this.operations) {\n    this.operations[name].checkActionDict(this.grammar);\n  }\n  // eslint-disable-next-line guard-for-in\n  for (name in this.attributes) {\n    this.attributes[name].checkActionDict(this.grammar);\n  }\n};\n\nSemantics$2.prototype.toRecipe = function(semanticsOnly) {\n  function hasSuperSemantics(s) {\n    return s.super !== Semantics$2.BuiltInSemantics._getSemantics();\n  }\n\n  let str = '(function(g) {\\n';\n  if (hasSuperSemantics(this)) {\n    str += '  var semantics = ' + this.super.toRecipe(true) + '(g';\n\n    const superSemanticsGrammar = this.super.grammar;\n    let relatedGrammar = this.grammar;\n    while (relatedGrammar !== superSemanticsGrammar) {\n      str += '.superGrammar';\n      relatedGrammar = relatedGrammar.superGrammar;\n    }\n\n    str += ');\\n';\n    str += '  return g.extendSemantics(semantics)';\n  } else {\n    str += '  return g.createSemantics()';\n  }\n  ['Operation', 'Attribute'].forEach(type => {\n    const semanticOperations = this[type.toLowerCase() + 's'];\n    Object.keys(semanticOperations).forEach(name => {\n      const {actionDict, formals, builtInDefault} = semanticOperations[name];\n\n      let signature = name;\n      if (formals.length > 0) {\n        signature += '(' + formals.join(', ') + ')';\n      }\n\n      let method;\n      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + 's'][name]) {\n        method = 'extend' + type;\n      } else {\n        method = 'add' + type;\n      }\n      str += '\\n    .' + method + '(' + JSON.stringify(signature) + ', {';\n\n      const srcArray = [];\n      Object.keys(actionDict).forEach(actionName => {\n        if (actionDict[actionName] !== builtInDefault) {\n          let source = actionDict[actionName].toString().trim();\n\n          // Convert method shorthand to plain old function syntax.\n          // https://github.com/harc/ohm/issues/263\n          source = source.replace(/^.*\\(/, 'function(');\n\n          srcArray.push('\\n      ' + JSON.stringify(actionName) + ': ' + source);\n        }\n      });\n      str += srcArray.join(',') + '\\n    })';\n    });\n  });\n  str += ';\\n  })';\n\n  if (!semanticsOnly) {\n    str =\n      '(function() {\\n' +\n      '  var grammar = this.fromRecipe(' +\n      this.grammar.toRecipe() +\n      ');\\n' +\n      '  var semantics = ' +\n      str +\n      '(grammar);\\n' +\n      '  return semantics;\\n' +\n      '});\\n';\n  }\n\n  return str;\n};\n\nfunction parseSignature$1(signature, type) {\n  if (!Semantics$2.prototypeGrammar) {\n    // The Operations and Attributes grammar won't be available while Ohm is loading,\n    // but we can get away the following simplification b/c none of the operations\n    // that are used while loading take arguments.\n    common$3.assert(signature.indexOf('(') === -1);\n    return {\n      name: signature,\n      formals: [],\n    };\n  }\n\n  const r = Semantics$2.prototypeGrammar.match(\n      signature,\n    type === 'operation' ? 'OperationSignature' : 'AttributeSignature'\n  );\n  if (r.failed()) {\n    throw new Error(r.message);\n  }\n\n  return Semantics$2.prototypeGrammarSemantics(r).parse();\n}\n\nfunction newDefaultAction(type, name, doIt) {\n  return function(...children) {\n    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];\n    const args = thisThing.formals.map(formal => this.args[formal]);\n\n    if (!this.isIteration() && children.length === 1) {\n      // This CST node corresponds to a non-terminal in the grammar (e.g., AddExpr). The fact that\n      // we got here means that this action dictionary doesn't have an action for this particular\n      // non-terminal or a generic `_nonterminal` action.\n      // As a convenience, if this node only has one child, we just return the result of applying\n      // this operation / attribute to the child node.\n      return doIt.apply(children[0], args);\n    } else {\n      // Otherwise, we throw an exception to let the programmer know that we don't know what\n      // to do with this node.\n      throw errors$3.missingSemanticAction(this.ctorName, name, type, globalActionStack);\n    }\n  };\n}\n\nSemantics$2.prototype.addOperationOrAttribute = function(type, signature, actionDict) {\n  const typePlural = type + 's';\n\n  const parsedNameAndFormalArgs = parseSignature$1(signature, type);\n  const {name} = parsedNameAndFormalArgs;\n  const {formals} = parsedNameAndFormalArgs;\n\n  // TODO: check that there are no duplicate formal arguments\n\n  this.assertNewName(name, type);\n\n  // Create the action dictionary for this operation / attribute that contains a `_default` action\n  // which defines the default behavior of iteration, terminal, and non-terminal nodes...\n  const builtInDefault = newDefaultAction(type, name, doIt);\n  const realActionDict = {_default: builtInDefault};\n  // ... and add in the actions supplied by the programmer, which may override some or all of the\n  // default ones.\n  Object.keys(actionDict).forEach(name => {\n    realActionDict[name] = actionDict[name];\n  });\n\n  const entry =\n    type === 'operation' ?\n      new Operation(name, formals, realActionDict, builtInDefault) :\n      new Attribute(name, realActionDict, builtInDefault);\n\n  // The following check is not strictly necessary (it will happen later anyway) but it's better to\n  // catch errors early.\n  entry.checkActionDict(this.grammar);\n\n  this[typePlural][name] = entry;\n\n  function doIt(...args) {\n    // Dispatch to most specific version of this operation / attribute -- it may have been\n    // overridden by a sub-semantics.\n    const thisThing = this._semantics[typePlural][name];\n\n    // Check that the caller passed the correct number of arguments.\n    if (arguments.length !== thisThing.formals.length) {\n      throw new Error(\n          'Invalid number of arguments passed to ' +\n          name +\n          ' ' +\n          type +\n          ' (expected ' +\n          thisThing.formals.length +\n          ', got ' +\n          arguments.length +\n          ')'\n      );\n    }\n\n    // Create an \"arguments object\" from the arguments that were passed to this\n    // operation / attribute.\n    const argsObj = Object.create(null);\n    for (const [idx, val] of Object.entries(args)) {\n      const formal = thisThing.formals[idx];\n      argsObj[formal] = val;\n    }\n\n    const oldArgs = this.args;\n    this.args = argsObj;\n    const ans = thisThing.execute(this._semantics, this);\n    this.args = oldArgs;\n    return ans;\n  }\n\n  if (type === 'operation') {\n    this.Wrapper.prototype[name] = doIt;\n    this.Wrapper.prototype[name].toString = function() {\n      return '[' + name + ' operation]';\n    };\n  } else {\n    Object.defineProperty(this.Wrapper.prototype, name, {\n      get: doIt,\n      configurable: true, // So the property can be deleted.\n    });\n    Object.defineProperty(this.attributeKeys, name, {\n      value: util$2.uniqueId(name),\n    });\n  }\n};\n\nSemantics$2.prototype.extendOperationOrAttribute = function(type, name, actionDict) {\n  const typePlural = type + 's';\n\n  // Make sure that `name` really is just a name, i.e., that it doesn't also contain formals.\n  parseSignature$1(name, 'attribute');\n\n  if (!(this.super && name in this.super[typePlural])) {\n    throw new Error(\n        'Cannot extend ' +\n        type +\n        \" '\" +\n        name +\n        \"': did not inherit an \" +\n        type +\n        ' with that name'\n    );\n  }\n  if (hasOwnProperty(this[typePlural], name)) {\n    throw new Error('Cannot extend ' + type + \" '\" + name + \"' again\");\n  }\n\n  // Create a new operation / attribute whose actionDict delegates to the super operation /\n  // attribute's actionDict, and which has all the keys from `inheritedActionDict`.\n  const inheritedFormals = this[typePlural][name].formals;\n  const inheritedActionDict = this[typePlural][name].actionDict;\n  const newActionDict = Object.create(inheritedActionDict);\n  Object.keys(actionDict).forEach(name => {\n    newActionDict[name] = actionDict[name];\n  });\n\n  this[typePlural][name] =\n    type === 'operation' ?\n      new Operation(name, inheritedFormals, newActionDict) :\n      new Attribute(name, newActionDict);\n\n  // The following check is not strictly necessary (it will happen later anyway) but it's better to\n  // catch errors early.\n  this[typePlural][name].checkActionDict(this.grammar);\n};\n\nSemantics$2.prototype.assertNewName = function(name, type) {\n  if (hasOwnProperty(Wrapper.prototype, name)) {\n    throw new Error('Cannot add ' + type + \" '\" + name + \"': that's a reserved name\");\n  }\n  if (name in this.operations) {\n    throw new Error(\n        'Cannot add ' + type + \" '\" + name + \"': an operation with that name already exists\"\n    );\n  }\n  if (name in this.attributes) {\n    throw new Error(\n        'Cannot add ' + type + \" '\" + name + \"': an attribute with that name already exists\"\n    );\n  }\n};\n\n// Returns a wrapper for the given CST `node` in this semantics.\n// If `node` is already a wrapper, returns `node` itself.  // TODO: why is this needed?\nSemantics$2.prototype.wrap = function(node, source, optBaseInterval) {\n  const baseInterval = optBaseInterval || source;\n  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);\n};\n\n// Creates a new Semantics instance for `grammar`, inheriting operations and attributes from\n// `optSuperSemantics`, if it is specified. Returns a function that acts as a proxy for the new\n// Semantics instance. When that function is invoked with a CST node as an argument, it returns\n// a wrapper for that node which gives access to the operations and attributes provided by this\n// semantics.\nSemantics$2.createSemantics = function(grammar, optSuperSemantics) {\n  const s = new Semantics$2(\n      grammar,\n    optSuperSemantics !== undefined ?\n      optSuperSemantics :\n      Semantics$2.BuiltInSemantics._getSemantics()\n  );\n\n  // To enable clients to invoke a semantics like a function, return a function that acts as a proxy\n  // for `s`, which is the real `Semantics` instance.\n  const proxy = function ASemantics(matchResult) {\n    if (!(matchResult instanceof MatchResult)) {\n      throw new TypeError(\n          'Semantics expected a MatchResult, but got ' +\n          common$3.unexpectedObjToString(matchResult)\n      );\n    }\n    if (matchResult.failed()) {\n      throw new TypeError('cannot apply Semantics to ' + matchResult.toString());\n    }\n\n    const cst = matchResult._cst;\n    if (cst.grammar !== grammar) {\n      throw new Error(\n          \"Cannot use a MatchResult from grammar '\" +\n          cst.grammar.name +\n          \"' with a semantics for '\" +\n          grammar.name +\n          \"'\"\n      );\n    }\n    const inputStream = new InputStream$1(matchResult.input);\n    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));\n  };\n\n  // Forward public methods from the proxy to the semantics instance.\n  proxy.addOperation = function(signature, actionDict) {\n    s.addOperationOrAttribute('operation', signature, actionDict);\n    return proxy;\n  };\n  proxy.extendOperation = function(name, actionDict) {\n    s.extendOperationOrAttribute('operation', name, actionDict);\n    return proxy;\n  };\n  proxy.addAttribute = function(name, actionDict) {\n    s.addOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy.extendAttribute = function(name, actionDict) {\n    s.extendOperationOrAttribute('attribute', name, actionDict);\n    return proxy;\n  };\n  proxy._getActionDict = function(operationOrAttributeName) {\n    const action =\n      s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];\n    if (!action) {\n      throw new Error(\n          '\"' +\n          operationOrAttributeName +\n          '\" is not a valid operation or attribute ' +\n          'name in this semantics for \"' +\n          grammar.name +\n          '\"'\n      );\n    }\n    return action.actionDict;\n  };\n  proxy._remove = function(operationOrAttributeName) {\n    let semantic;\n    if (operationOrAttributeName in s.operations) {\n      semantic = s.operations[operationOrAttributeName];\n      delete s.operations[operationOrAttributeName];\n    } else if (operationOrAttributeName in s.attributes) {\n      semantic = s.attributes[operationOrAttributeName];\n      delete s.attributes[operationOrAttributeName];\n    }\n    delete s.Wrapper.prototype[operationOrAttributeName];\n    return semantic;\n  };\n  proxy.getOperationNames = function() {\n    return Object.keys(s.operations);\n  };\n  proxy.getAttributeNames = function() {\n    return Object.keys(s.attributes);\n  };\n  proxy.getGrammar = function() {\n    return s.grammar;\n  };\n  proxy.toRecipe = function(semanticsOnly) {\n    return s.toRecipe(semanticsOnly);\n  };\n\n  // Make the proxy's toString() work.\n  proxy.toString = s.toString.bind(s);\n\n  // Returns the semantics for the proxy.\n  proxy._getSemantics = function() {\n    return s;\n  };\n\n  return proxy;\n};\n\n// ----------------- Operation -----------------\n\n// An Operation represents a function to be applied to a concrete syntax tree (CST) -- it's very\n// similar to a Visitor (http://en.wikipedia.org/wiki/Visitor_pattern). An operation is executed by\n// recursively walking the CST, and at each node, invoking the matching semantic action from\n// `actionDict`. See `Operation.prototype.execute` for details of how a CST node's matching semantic\n// action is found.\nclass Operation {\n  constructor(name, formals, actionDict, builtInDefault) {\n    this.name = name;\n    this.formals = formals;\n    this.actionDict = actionDict;\n    this.builtInDefault = builtInDefault;\n  }\n\n  checkActionDict(grammar) {\n    grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);\n  }\n\n  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the\n  // given Semantics instance.\n  execute(semantics, nodeWrapper) {\n    try {\n      // Look for a semantic action whose name matches the node's constructor name, which is either\n      // the name of a rule in the grammar, or '_terminal' (for a terminal node), or '_iter' (for an\n      // iteration node).\n      const {ctorName} = nodeWrapper._node;\n      let actionFn = this.actionDict[ctorName];\n      if (actionFn) {\n        globalActionStack.push([this, ctorName]);\n        return actionFn.apply(nodeWrapper, nodeWrapper._children());\n      }\n\n      // The action dictionary does not contain a semantic action for this specific type of node.\n      // If this is a nonterminal node and the programmer has provided a `_nonterminal` semantic\n      // action, we invoke it:\n      if (nodeWrapper.isNonterminal()) {\n        actionFn = this.actionDict._nonterminal;\n        if (actionFn) {\n          globalActionStack.push([this, '_nonterminal', ctorName]);\n          return actionFn.apply(nodeWrapper, nodeWrapper._children());\n        }\n      }\n\n      // Otherwise, we invoke the '_default' semantic action.\n      globalActionStack.push([this, 'default action', ctorName]);\n      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());\n    } finally {\n      globalActionStack.pop();\n    }\n  }\n}\n\nOperation.prototype.typeName = 'operation';\n\n// ----------------- Attribute -----------------\n\n// Attributes are Operations whose results are memoized. This means that, for any given semantics,\n// the semantic action for a CST node will be invoked no more than once.\nclass Attribute extends Operation {\n  constructor(name, actionDict, builtInDefault) {\n    super(name, [], actionDict, builtInDefault);\n  }\n\n  execute(semantics, nodeWrapper) {\n    const node = nodeWrapper._node;\n    const key = semantics.attributeKeys[this.name];\n    if (!hasOwnProperty(node, key)) {\n      // The following is a super-send -- isn't JS beautiful? :/\n      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);\n    }\n    return node[key];\n  }\n}\n\nAttribute.prototype.typeName = 'attribute';\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Semantics_1 = Semantics$2;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst CaseInsensitiveTerminal = CaseInsensitiveTerminal_1;\nconst Matcher = Matcher_1;\nconst Semantics$1 = Semantics_1;\nconst common$2 = common$l;\nconst errors$2 = errors$9;\nconst pexprs$3 = pexprs$6;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nconst SPECIAL_ACTION_NAMES = ['_iter', '_terminal', '_nonterminal', '_default'];\n\nfunction getSortedRuleValues(grammar) {\n  return Object.keys(grammar.rules)\n      .sort()\n      .map(name => grammar.rules[name]);\n}\n\n// Until ES2019, JSON was not a valid subset of JavaScript because U+2028 (line separator)\n// and U+2029 (paragraph separator) are allowed in JSON string literals, but not in JS.\n// This function properly encodes those two characters so that the resulting string is\n// represents both valid JSON, and valid JavaScript (for ES2018 and below).\n// See https://v8.dev/features/subsume-json for more details.\nconst jsonToJS = str => str.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n\nfunction Grammar$4(name, superGrammar, rules, optDefaultStartRule) {\n  this.name = name;\n  this.superGrammar = superGrammar;\n  this.rules = rules;\n  if (optDefaultStartRule) {\n    if (!(optDefaultStartRule in rules)) {\n      throw new Error(\n          \"Invalid start rule: '\" +\n          optDefaultStartRule +\n          \"' is not a rule in grammar '\" +\n          name +\n          \"'\"\n      );\n    }\n    this.defaultStartRule = optDefaultStartRule;\n  }\n}\n\nlet ohmGrammar$2;\nlet buildGrammar$1;\n\n// This method is called from main.js once Ohm has loaded.\nGrammar$4.initApplicationParser = function(grammar, builderFn) {\n  ohmGrammar$2 = grammar;\n  buildGrammar$1 = builderFn;\n};\n\nGrammar$4.prototype = {\n  matcher() {\n    return new Matcher(this);\n  },\n\n  // Return true if the grammar is a built-in grammar, otherwise false.\n  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!\n  isBuiltIn() {\n    return this === Grammar$4.ProtoBuiltInRules || this === Grammar$4.BuiltInRules;\n  },\n\n  equals(g) {\n    if (this === g) {\n      return true;\n    }\n    // Do the cheapest comparisons first.\n    if (\n      g == null ||\n      this.name !== g.name ||\n      this.defaultStartRule !== g.defaultStartRule ||\n      !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))\n    ) {\n      return false;\n    }\n    const myRules = getSortedRuleValues(this);\n    const otherRules = getSortedRuleValues(g);\n    return (\n      myRules.length === otherRules.length &&\n      myRules.every((rule, i) => {\n        return (\n          rule.description === otherRules[i].description &&\n          rule.formals.join(',') === otherRules[i].formals.join(',') &&\n          rule.body.toString() === otherRules[i].body.toString()\n        );\n      })\n    );\n  },\n\n  match(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.match(optStartApplication);\n  },\n\n  trace(input, optStartApplication) {\n    const m = this.matcher();\n    m.replaceInputRange(0, 0, input);\n    return m.trace(optStartApplication);\n  },\n\n  createSemantics() {\n    return Semantics$1.createSemantics(this);\n  },\n\n  extendSemantics(superSemantics) {\n    return Semantics$1.createSemantics(this, superSemantics._getSemantics());\n  },\n\n  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to\n  // a function of the correct arity. If not, throw an exception.\n  _checkTopDownActionDict(what, name, actionDict) {\n    const problems = [];\n\n    // eslint-disable-next-line guard-for-in\n    for (const k in actionDict) {\n      const v = actionDict[k];\n      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);\n\n      if (!isSpecialAction && !(k in this.rules)) {\n        problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);\n        continue;\n      }\n      if (typeof v !== 'function') {\n        problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);\n        continue;\n      }\n      const actual = v.length;\n      const expected = this._topDownActionArity(k);\n      if (actual !== expected) {\n        let details;\n        if (k === '_iter' || k === '_nonterminal') {\n          details =\n            `it should use a rest parameter, e.g. \\`${k}(...children) {}\\`. ` +\n            'NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.';\n        } else {\n          details = `expected ${expected}, got ${actual}`;\n        }\n        problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);\n      }\n    }\n    if (problems.length > 0) {\n      const prettyProblems = problems.map(problem => '- ' + problem);\n      const error = new Error(\n          [\n            `Found errors in the action dictionary of the '${name}' ${what}:`,\n            ...prettyProblems,\n          ].join('\\n')\n      );\n      error.problems = problems;\n      throw error;\n    }\n  },\n\n  // Return the expected arity for a semantic action named `actionName`, which\n  // is either a rule name or a special action name like '_nonterminal'.\n  _topDownActionArity(actionName) {\n    // All special actions have an expected arity of 0, though all but _terminal\n    // are expected to use the rest parameter syntax (e.g. `_iter(...children)`).\n    // This is considered to have arity 0, i.e. `((...args) => {}).length` is 0.\n    return SPECIAL_ACTION_NAMES.includes(actionName) ?\n      0 :\n      this.rules[actionName].body.getArity();\n  },\n\n  _inheritsFrom(grammar) {\n    let g = this.superGrammar;\n    while (g) {\n      if (g.equals(grammar, true)) {\n        return true;\n      }\n      g = g.superGrammar;\n    }\n    return false;\n  },\n\n  toRecipe(superGrammarExpr = undefined) {\n    const metaInfo = {};\n    // Include the grammar source if it is available.\n    if (this.source) {\n      metaInfo.source = this.source.contents;\n    }\n\n    let startRule = null;\n    if (this.defaultStartRule) {\n      startRule = this.defaultStartRule;\n    }\n\n    const rules = {};\n    Object.keys(this.rules).forEach(ruleName => {\n      const ruleInfo = this.rules[ruleName];\n      const {body} = ruleInfo;\n      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];\n\n      let operation;\n      if (isDefinition) {\n        operation = 'define';\n      } else {\n        operation = body instanceof pexprs$3.Extend ? 'extend' : 'override';\n      }\n\n      const metaInfo = {};\n      if (ruleInfo.source && this.source) {\n        const adjusted = ruleInfo.source.relativeTo(this.source);\n        metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];\n      }\n\n      const description = isDefinition ? ruleInfo.description : null;\n      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);\n\n      rules[ruleName] = [\n        operation, // \"define\"/\"extend\"/\"override\"\n        metaInfo,\n        description,\n        ruleInfo.formals,\n        bodyRecipe,\n      ];\n    });\n\n    // If the caller provided an expression to use for the supergrammar, use that.\n    // Otherwise, if the supergrammar is a user grammar, use its recipe inline.\n    let superGrammarOutput = 'null';\n    if (superGrammarExpr) {\n      superGrammarOutput = superGrammarExpr;\n    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {\n      superGrammarOutput = this.superGrammar.toRecipe();\n    }\n\n    const recipeElements = [\n      ...['grammar', metaInfo, this.name].map(JSON.stringify),\n      superGrammarOutput,\n      ...[startRule, rules].map(JSON.stringify),\n    ];\n    return jsonToJS(`[${recipeElements.join(',')}]`);\n  },\n\n  // TODO: Come up with better names for these methods.\n  // TODO: Write the analog of these methods for inherited attributes.\n  toOperationActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  },\n  toAttributeActionDictionaryTemplate() {\n    return this._toOperationOrAttributeActionDictionaryTemplate();\n  },\n\n  _toOperationOrAttributeActionDictionaryTemplate() {\n    // TODO: add the super-grammar's templates at the right place, e.g., a case for AddExpr_plus\n    // should appear next to other cases of AddExpr.\n\n    const sb = new common$2.StringBuffer();\n    sb.append('{');\n\n    let first = true;\n    // eslint-disable-next-line guard-for-in\n    for (const ruleName in this.rules) {\n      const {body} = this.rules[ruleName];\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append('\\n');\n      sb.append('  ');\n      this.addSemanticActionTemplate(ruleName, body, sb);\n    }\n\n    sb.append('\\n}');\n    return sb.contents();\n  },\n\n  addSemanticActionTemplate(ruleName, body, sb) {\n    sb.append(ruleName);\n    sb.append(': function(');\n    const arity = this._topDownActionArity(ruleName);\n    sb.append(common$2.repeat('_', arity).join(', '));\n    sb.append(') {\\n');\n    sb.append('  }');\n  },\n\n  // Parse a string which expresses a rule application in this grammar, and return the\n  // resulting Apply node.\n  parseApplication(str) {\n    let app;\n    if (str.indexOf('<') === -1) {\n      // simple application\n      app = new pexprs$3.Apply(str);\n    } else {\n      // parameterized application\n      const cst = ohmGrammar$2.match(str, 'Base_application');\n      app = buildGrammar$1(cst, {});\n    }\n\n    // Ensure that the application is valid.\n    if (!(app.ruleName in this.rules)) {\n      throw errors$2.undeclaredRule(app.ruleName, this.name);\n    }\n    const {formals} = this.rules[app.ruleName];\n    if (formals.length !== app.args.length) {\n      const {source} = this.rules[app.ruleName];\n      throw errors$2.wrongNumberOfParameters(\n          app.ruleName,\n          formals.length,\n          app.args.length,\n          source\n      );\n    }\n    return app;\n  },\n};\n\n// The following grammar contains a few rules that couldn't be written  in \"userland\".\n// At the bottom of src/main.js, we create a sub-grammar of this grammar that's called\n// `BuiltInRules`. That grammar contains several convenience rules, e.g., `letter` and\n// `digit`, and is implicitly the super-grammar of any grammar whose super-grammar\n// isn't specified.\nGrammar$4.ProtoBuiltInRules = new Grammar$4(\n    'ProtoBuiltInRules', // name\n    undefined, // supergrammar\n    {\n      any: {\n        body: pexprs$3.any,\n        formals: [],\n        description: 'any character',\n        primitive: true,\n      },\n      end: {\n        body: pexprs$3.end,\n        formals: [],\n        description: 'end of input',\n        primitive: true,\n      },\n\n      caseInsensitive: {\n        body: new CaseInsensitiveTerminal(new pexprs$3.Param(0)),\n        formals: ['str'],\n        primitive: true,\n      },\n      lower: {\n        body: new pexprs$3.UnicodeChar('Ll'),\n        formals: [],\n        description: 'a lowercase letter',\n        primitive: true,\n      },\n      upper: {\n        body: new pexprs$3.UnicodeChar('Lu'),\n        formals: [],\n        description: 'an uppercase letter',\n        primitive: true,\n      },\n      // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.\n      unicodeLtmo: {\n        body: new pexprs$3.UnicodeChar('Ltmo'),\n        formals: [],\n        description: 'a Unicode character in Lt, Lm, or Lo',\n        primitive: true,\n      },\n\n      // These rules are not truly primitive (they could be written in userland) but are defined\n      // here for bootstrapping purposes.\n      spaces: {\n        body: new pexprs$3.Star(new pexprs$3.Apply('space')),\n        formals: [],\n      },\n      space: {\n        body: new pexprs$3.Range('\\x00', ' '),\n        formals: [],\n        description: 'a space',\n      },\n    }\n);\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Grammar_1 = Grammar$4;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Grammar$3 = Grammar_1;\nconst InputStream = InputStream_1;\nconst common$1 = common$l;\nconst errors$1 = errors$9;\nconst pexprs$2 = pexprs$6;\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Constructors\n\nfunction GrammarDecl$1(name) {\n  this.name = name;\n}\n\n// Helpers\n\nGrammarDecl$1.prototype.sourceInterval = function(startIdx, endIdx) {\n  return this.source.subInterval(startIdx, endIdx - startIdx);\n};\n\nGrammarDecl$1.prototype.ensureSuperGrammar = function() {\n  if (!this.superGrammar) {\n    this.withSuperGrammar(\n      // TODO: The conditional expression below is an ugly hack. It's kind of ok because\n      // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,\n      // we should try to find a better way to do this.\n      this.name === 'BuiltInRules' ? Grammar$3.ProtoBuiltInRules : Grammar$3.BuiltInRules\n    );\n  }\n  return this.superGrammar;\n};\n\nGrammarDecl$1.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {\n  const ruleInfo = this.ensureSuperGrammar().rules[name];\n  if (!ruleInfo) {\n    throw errors$1.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);\n  }\n  return ruleInfo;\n};\n\nGrammarDecl$1.prototype.installOverriddenOrExtendedRule = function(\n    name,\n    formals,\n    body,\n    source\n) {\n  const duplicateParameterNames = common$1.getDuplicates(formals);\n  if (duplicateParameterNames.length > 0) {\n    throw errors$1.duplicateParameterNames(name, duplicateParameterNames, source);\n  }\n  const ruleInfo = this.ensureSuperGrammar().rules[name];\n  const expectedFormals = ruleInfo.formals;\n  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;\n  if (formals.length !== expectedNumFormals) {\n    throw errors$1.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);\n  }\n  return this.install(name, formals, body, ruleInfo.description, source);\n};\n\nGrammarDecl$1.prototype.install = function(name, formals, body, description, source) {\n  this.rules[name] = {\n    body: body.introduceParams(formals),\n    formals,\n    description,\n    source,\n  };\n  return this;\n};\n\n// Stuff that you should only do once\n\nGrammarDecl$1.prototype.withSuperGrammar = function(superGrammar) {\n  if (this.superGrammar) {\n    throw new Error('the super grammar of a GrammarDecl cannot be set more than once');\n  }\n  this.superGrammar = superGrammar;\n  this.rules = Object.create(superGrammar.rules);\n\n  // Grammars with an explicit supergrammar inherit a default start rule.\n  if (!superGrammar.isBuiltIn()) {\n    this.defaultStartRule = superGrammar.defaultStartRule;\n  }\n  return this;\n};\n\nGrammarDecl$1.prototype.withDefaultStartRule = function(ruleName) {\n  this.defaultStartRule = ruleName;\n  return this;\n};\n\nGrammarDecl$1.prototype.withSource = function(source) {\n  this.source = new InputStream(source).interval(0, source.length);\n  return this;\n};\n\n// Creates a Grammar instance, and if it passes the sanity checks, returns it.\nGrammarDecl$1.prototype.build = function() {\n  const grammar = new Grammar$3(\n      this.name,\n      this.ensureSuperGrammar(),\n      this.rules,\n      this.defaultStartRule\n  );\n\n  // TODO: change the pexpr.prototype.assert... methods to make them add\n  // exceptions to an array that's provided as an arg. Then we'll be able to\n  // show more than one error of the same type at a time.\n  // TODO: include the offending pexpr in the errors, that way we can show\n  // the part of the source that caused it.\n  const grammarErrors = [];\n  let grammarHasInvalidApplications = false;\n  Object.keys(grammar.rules).forEach(ruleName => {\n    const {body} = grammar.rules[ruleName];\n    try {\n      body.assertChoicesHaveUniformArity(ruleName);\n    } catch (e) {\n      grammarErrors.push(e);\n    }\n    try {\n      body.assertAllApplicationsAreValid(ruleName, grammar);\n    } catch (e) {\n      grammarErrors.push(e);\n      grammarHasInvalidApplications = true;\n    }\n  });\n  if (!grammarHasInvalidApplications) {\n    // The following check can only be done if the grammar has no invalid applications.\n    Object.keys(grammar.rules).forEach(ruleName => {\n      const {body} = grammar.rules[ruleName];\n      try {\n        body.assertIteratedExprsAreNotNullable(grammar, []);\n      } catch (e) {\n        grammarErrors.push(e);\n      }\n    });\n  }\n  if (grammarErrors.length > 0) {\n    errors$1.throwErrors(grammarErrors);\n  }\n  if (this.source) {\n    grammar.source = this.source;\n  }\n\n  return grammar;\n};\n\n// Rule declarations\n\nGrammarDecl$1.prototype.define = function(name, formals, body, description, source) {\n  this.ensureSuperGrammar();\n  if (this.superGrammar.rules[name]) {\n    throw errors$1.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);\n  } else if (this.rules[name]) {\n    throw errors$1.duplicateRuleDeclaration(name, this.name, this.name, source);\n  }\n  const duplicateParameterNames = common$1.getDuplicates(formals);\n  if (duplicateParameterNames.length > 0) {\n    throw errors$1.duplicateParameterNames(name, duplicateParameterNames, source);\n  }\n  return this.install(name, formals, body, description, source);\n};\n\nGrammarDecl$1.prototype.override = function(name, formals, body, descIgnored, source) {\n  this.ensureSuperGrammarRuleForOverriding(name, source);\n  this.installOverriddenOrExtendedRule(name, formals, body, source);\n  return this;\n};\n\nGrammarDecl$1.prototype.extend = function(name, formals, fragment, descIgnored, source) {\n  const ruleInfo = this.ensureSuperGrammar().rules[name];\n  if (!ruleInfo) {\n    throw errors$1.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);\n  }\n  const body = new pexprs$2.Extend(this.superGrammar, name, fragment);\n  body.source = fragment.source;\n  this.installOverriddenOrExtendedRule(name, formals, body, source);\n  return this;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar GrammarDecl_1 = GrammarDecl$1;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Grammar$2 = Grammar_1;\nconst GrammarDecl = GrammarDecl_1;\nconst pexprs$1 = pexprs$6;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction Builder$2() {}\n\nBuilder$2.prototype = {\n  currentDecl: null,\n  currentRuleName: null,\n\n  newGrammar(name) {\n    return new GrammarDecl(name);\n  },\n\n  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {\n    const gDecl = new GrammarDecl(name);\n    if (superGrammar) {\n      // `superGrammar` may be a recipe (i.e. an Array), or an actual grammar instance.\n      gDecl.withSuperGrammar(\n        superGrammar instanceof Grammar$2 ? superGrammar : this.fromRecipe(superGrammar)\n      );\n    }\n    if (defaultStartRule) {\n      gDecl.withDefaultStartRule(defaultStartRule);\n    }\n    if (metaInfo && metaInfo.source) {\n      gDecl.withSource(metaInfo.source);\n    }\n\n    this.currentDecl = gDecl;\n    Object.keys(rules).forEach(ruleName => {\n      this.currentRuleName = ruleName;\n      const ruleRecipe = rules[ruleName];\n\n      const action = ruleRecipe[0]; // define/extend/override\n      const metaInfo = ruleRecipe[1];\n      const description = ruleRecipe[2];\n      const formals = ruleRecipe[3];\n      const body = this.fromRecipe(ruleRecipe[4]);\n\n      let source;\n      if (gDecl.source && metaInfo && metaInfo.sourceInterval) {\n        source = gDecl.source.subInterval(\n            metaInfo.sourceInterval[0],\n            metaInfo.sourceInterval[1] - metaInfo.sourceInterval[0]\n        );\n      }\n      gDecl[action](ruleName, formals, body, description, source);\n    });\n    this.currentRuleName = this.currentDecl = null;\n    return gDecl.build();\n  },\n\n  terminal(x) {\n    return new pexprs$1.Terminal(x);\n  },\n\n  range(from, to) {\n    return new pexprs$1.Range(from, to);\n  },\n\n  param(index) {\n    return new pexprs$1.Param(index);\n  },\n\n  alt(...termArgs) {\n    let terms = [];\n    for (let arg of termArgs) {\n      if (!(arg instanceof pexprs$1.PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof pexprs$1.Alt) {\n        terms = terms.concat(arg.terms);\n      } else {\n        terms.push(arg);\n      }\n    }\n    return terms.length === 1 ? terms[0] : new pexprs$1.Alt(terms);\n  },\n\n  seq(...factorArgs) {\n    let factors = [];\n    for (let arg of factorArgs) {\n      if (!(arg instanceof pexprs$1.PExpr)) {\n        arg = this.fromRecipe(arg);\n      }\n      if (arg instanceof pexprs$1.Seq) {\n        factors = factors.concat(arg.factors);\n      } else {\n        factors.push(arg);\n      }\n    }\n    return factors.length === 1 ? factors[0] : new pexprs$1.Seq(factors);\n  },\n\n  star(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Star(expr);\n  },\n\n  plus(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Plus(expr);\n  },\n\n  opt(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Opt(expr);\n  },\n\n  not(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Not(expr);\n  },\n\n  la(expr) {\n    // TODO: temporary to still be able to read old recipes\n    return this.lookahead(expr);\n  },\n\n  lookahead(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Lookahead(expr);\n  },\n\n  lex(expr) {\n    if (!(expr instanceof pexprs$1.PExpr)) {\n      expr = this.fromRecipe(expr);\n    }\n    return new pexprs$1.Lex(expr);\n  },\n\n  app(ruleName, optParams) {\n    if (optParams && optParams.length > 0) {\n      optParams = optParams.map(function(param) {\n        return param instanceof pexprs$1.PExpr ? param : this.fromRecipe(param);\n      }, this);\n    }\n    return new pexprs$1.Apply(ruleName, optParams);\n  },\n\n  // Note that unlike other methods in this class, this method cannot be used as a\n  // convenience constructor. It only works with recipes, because it relies on\n  // `this.currentDecl` and `this.currentRuleName` being set.\n  splice(beforeTerms, afterTerms) {\n    return new pexprs$1.Splice(\n        this.currentDecl.superGrammar,\n        this.currentRuleName,\n        beforeTerms.map(term => this.fromRecipe(term)),\n        afterTerms.map(term => this.fromRecipe(term))\n    );\n  },\n\n  fromRecipe(recipe) {\n    // the meta-info of 'grammar' is processed in Builder.grammar\n    const args = recipe[0] === 'grammar' ? recipe.slice(1) : recipe.slice(2);\n    const result = this[recipe[0]](...args);\n\n    const metaInfo = recipe[1];\n    if (metaInfo) {\n      if (metaInfo.sourceInterval && this.currentDecl) {\n        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));\n      }\n    }\n    return result;\n  },\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar Builder_1 = Builder$2;\n\nvar name = \"ohm-js\";\nvar version$2 = \"16.6.0\";\nvar description = \"An object-oriented language for parsing and pattern matching\";\nvar repository = \"https://github.com/harc/ohm\";\nvar keywords = [\n\t\"parser\",\n\t\"compiler\",\n\t\"pattern matching\",\n\t\"pattern-matching\",\n\t\"ometa\",\n\t\"ometa/js\",\n\t\"ometa-js\",\n\t\"ometajs\",\n\t\"rapid\",\n\t\"prototyping\"\n];\nvar homepage = \"https://ohmjs.org\";\nvar bugs = \"https://github.com/harc/ohm/issues\";\nvar main = \"index.js\";\nvar module = \"dist/ohm.esm.js\";\nvar files = [\n\t\"src\",\n\t\"dist\",\n\t\"extras\",\n\t\"third_party\",\n\t\"index.d.ts\"\n];\nvar types = \"index.d.ts\";\nvar scripts = {\n\tprebootstrap: \"bash scripts/prebootstrap\",\n\tbootstrap: \"bash scripts/bootstrap --test || (echo 'Bootstrap failed.' && mv -v dist/ohm-grammar.js.old dist/ohm-grammar.js && mv -v dist/built-in-rules.js.old dist/built-in-rules.js && mv -v dist/operations-and-attributes.js.old dist/operations-and-attributes.js)\",\n\tbuild: \"yarn build-debug && webpack --mode=production\",\n\t\"build-debug\": \"webpack --mode=development && yarn build-esm && node scripts/generate-types.mjs\",\n\t\"build-esm\": \"rollup -c rollup.config.mjs\",\n\tclean: \"rm -f dist/ohm.js dist/ohm.min.js\",\n\tlint: \"eslint . --ignore-path ../.eslintignore\",\n\tformat: \"prettier . --write --ignore-path ../.prettierignore --config ../.prettierrc && eslint . --ignore-path ../.eslintignore --fix\",\n\ttest: \"ava && ava --config ava-ts.config.js test/test-typings.ts\",\n\t\"test-watch\": \"ava --watch\",\n\t\"pre-commit\": \"yarn run lint && yarn run build && yarn run test\",\n\tprepublishOnly: \"bash scripts/prepublishOnly\",\n\tprepack: \"cp ../../README.md . && yarn build\",\n\tpostpack: \"rm README.md\",\n\tpostpublish: \"echo '  Now go to https://github.com/harc/ohm/releases and create a release.'\",\n\t\"unsafe-bootstrap\": \"bash scripts/bootstrap\",\n\t\"update-contributors\": \"bash scripts/update-contributors\",\n\twatch: \"webpack --mode=development --watch\"\n};\nvar license = \"MIT\";\nvar author = \"Alex Warth <alexwarth@gmail.com> (http://tinlizzie.org/~awarth)\";\nvar contributors = [\n\t\"Patrick Dubroy <pdubroy@gmail.com>\",\n\t\"Meixian Li <lmeixian@gmail.com>\",\n\t\"Marko Rder <m.roeder@photon-software.de>\",\n\t\"Tony Garnock-Jones <tonygarnockjones@gmail.com>\",\n\t\"Saketh Kasibatla <sake.kasi@gmail.com>\",\n\t\"Lionel Landwerlin <llandwerlin@gmail.com>\",\n\t\"Jason Merrill <jwmerrill@gmail.com>\",\n\t\"Ray Toal <rtoal@lmu.edu>\",\n\t\"Yoshiki Ohshima <Yoshiki.Ohshima@acm.org>\",\n\t\"megabuz <3299889+megabuz@users.noreply.github.com>\",\n\t\"Jonathan Edwards <JonathanMEdwards@gmail.com>\",\n\t\"Milan Lajto <milan.lajtos@me.com>\",\n\t\"Neil Jewers <njjewers@uwaterloo.ca>\",\n\t\"stagas <gstagas@gmail.com>\",\n\t\"AngryPowman <angrypowman@qq.com>\",\n\t\"Arthur Carabott <arthurc@gmail.com>\",\n\t\"Casey Olson <casey.m.olson@gmail.com>\",\n\t\"Daniel Tomlinson <DanielTomlinson@me.com>\",\n\t\"Ian Harris <ian@fofgof.xyz>\",\n\t\"Justin Chase <justin.m.chase@gmail.com>\",\n\t\"Leslie Ying <acetophore@users.noreply.github.com>\",\n\t\"Luca Guzzon <luca.guzzon@gmail.com>\",\n\t\"Mike Niebling <(none)>\",\n\t\"Patrick Dubroy <patrick@sourcegraph.com>\",\n\t\"Pierre Donias <pierre.donias@gmail.com>\",\n\t\"Stan Rozenraukh <stan@stanistan.com>\",\n\t\"Stephan Seidt <stephan.seidt@gmail.com>\",\n\t\"Steve Phillips <steve@tryingtobeawesome.com>\",\n\t\"Szymon Kaliski <kaliskiszymon@gmail.com>\",\n\t\"Thomas Nyberg <tomnyberg@gmail.com>\",\n\t\"Vse Mozhet Byt <vsemozhetbyt@gmail.com>\",\n\t\"Wil Chung <10446+iamwilhelm@users.noreply.github.com>\",\n\t\"Zachary Sakowitz <zsakowitz@gmail.com>\",\n\t\"abego <ub@abego-software.de>\",\n\t\"acslk <d_vd415@hotmail.com>\",\n\t\"codeZeilen <codeZeilen@users.noreply.github.com>\",\n\t\"kassadin <kassadin@foxmail.com>\",\n\t\"owch <bowenrainyday@gmail.com>\",\n\t\"sfinnie <scott.finnie@gmail.com>\"\n];\nvar dependencies = {\n};\nvar devDependencies = {\n\t\"@ohm-js/cli\": \"^1.0.0\",\n\t\"@rollup/plugin-commonjs\": \"^21.0.1\",\n\t\"@rollup/plugin-json\": \"^4.1.0\",\n\t\"@rollup/plugin-node-resolve\": \"^13.1.3\",\n\tava: \"^3.15.0\",\n\t\"ava-spec\": \"^1.1.1\",\n\tdedent: \"^0.7.0\",\n\teslint: \"^7.9.0\",\n\t\"eslint-config-google\": \"^0.14.0\",\n\t\"eslint-plugin-ava\": \"^11.0.0\",\n\t\"eslint-plugin-camelcase-ohm\": \"^0.2.1\",\n\t\"eslint-plugin-no-extension-in-require\": \"^0.2.0\",\n\thusky: \"^4.2.5\",\n\tjsdom: \"^9.9.1\",\n\tjson: \"^9.0.6\",\n\tmarkscript: \"^0.5.0\",\n\t\"node-static\": \"^0.7.11\",\n\t\"ohm-grammar-ecmascript\": \"^1.0.0\",\n\trollup: \"^2.63.0\",\n\t\"ts-loader\": \"^8.0.4\",\n\t\"ts-node\": \"^9.0.0\",\n\ttypescript: \"^4.0.3\",\n\t\"walk-sync\": \"^2.2.0\",\n\twebpack: \"^4.44.2\",\n\t\"webpack-cli\": \"^3.3.12\"\n};\nvar engines = {\n\tnode: \">=0.12.1\"\n};\nvar require$$0 = {\n\tname: name,\n\tversion: version$2,\n\tdescription: description,\n\trepository: repository,\n\tkeywords: keywords,\n\thomepage: homepage,\n\tbugs: bugs,\n\tmain: main,\n\tmodule: module,\n\tfiles: files,\n\ttypes: types,\n\tscripts: scripts,\n\tlicense: license,\n\tauthor: author,\n\tcontributors: contributors,\n\tdependencies: dependencies,\n\tdevDependencies: devDependencies,\n\tengines: engines\n};\n\n/* global __GLOBAL_OHM_VERSION__ */\n\n// When running under Node, read the version from package.json. For the browser,\n// use a special global variable defined in the build process (see webpack.config.js).\nvar version$1 =\n  typeof __GLOBAL_OHM_VERSION__ === 'string' ?\n    __GLOBAL_OHM_VERSION__ :\n    require$$0.version;\n\nvar makeRecipe$5 = {};\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Builder$1 = Builder_1;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nfunction makeRecipe$4(recipe) {\n  if (typeof recipe === 'function') {\n    return recipe.call(new Builder$1());\n  } else {\n    if (typeof recipe === 'string') {\n      // stringified JSON recipe\n      recipe = JSON.parse(recipe);\n    }\n    return new Builder$1().fromRecipe(recipe);\n  }\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmakeRecipe$5.makeRecipe = makeRecipe$4;\n\nvar {makeRecipe: makeRecipe$3} = makeRecipe$5;\nvar builtInRules = makeRecipe$3([\"grammar\",{\"source\":\"BuiltInRules {\\n\\n  alnum  (an alpha-numeric character)\\n    = letter\\n    | digit\\n\\n  letter  (a letter)\\n    = lower\\n    | upper\\n    | unicodeLtmo\\n\\n  digit  (a digit)\\n    = \\\"0\\\"..\\\"9\\\"\\n\\n  hexDigit  (a hexadecimal digit)\\n    = digit\\n    | \\\"a\\\"..\\\"f\\\"\\n    | \\\"A\\\"..\\\"F\\\"\\n\\n  ListOf<elem, sep>\\n    = NonemptyListOf<elem, sep>\\n    | EmptyListOf<elem, sep>\\n\\n  NonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  EmptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  listOf<elem, sep>\\n    = nonemptyListOf<elem, sep>\\n    | emptyListOf<elem, sep>\\n\\n  nonemptyListOf<elem, sep>\\n    = elem (sep elem)*\\n\\n  emptyListOf<elem, sep>\\n    = /* nothing */\\n\\n  // Allows a syntactic rule application within a lexical context.\\n  applySyntactic<app> = app\\n}\"},\"BuiltInRules\",null,null,{\"alnum\":[\"define\",{\"sourceInterval\":[18,78]},\"an alpha-numeric character\",[],[\"alt\",{\"sourceInterval\":[60,78]},[\"app\",{\"sourceInterval\":[60,66]},\"letter\",[]],[\"app\",{\"sourceInterval\":[73,78]},\"digit\",[]]]],\"letter\":[\"define\",{\"sourceInterval\":[82,142]},\"a letter\",[],[\"alt\",{\"sourceInterval\":[107,142]},[\"app\",{\"sourceInterval\":[107,112]},\"lower\",[]],[\"app\",{\"sourceInterval\":[119,124]},\"upper\",[]],[\"app\",{\"sourceInterval\":[131,142]},\"unicodeLtmo\",[]]]],\"digit\":[\"define\",{\"sourceInterval\":[146,177]},\"a digit\",[],[\"range\",{\"sourceInterval\":[169,177]},\"0\",\"9\"]],\"hexDigit\":[\"define\",{\"sourceInterval\":[181,254]},\"a hexadecimal digit\",[],[\"alt\",{\"sourceInterval\":[219,254]},[\"app\",{\"sourceInterval\":[219,224]},\"digit\",[]],[\"range\",{\"sourceInterval\":[231,239]},\"a\",\"f\"],[\"range\",{\"sourceInterval\":[246,254]},\"A\",\"F\"]]],\"ListOf\":[\"define\",{\"sourceInterval\":[258,336]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[282,336]},[\"app\",{\"sourceInterval\":[282,307]},\"NonemptyListOf\",[[\"param\",{\"sourceInterval\":[297,301]},0],[\"param\",{\"sourceInterval\":[303,306]},1]]],[\"app\",{\"sourceInterval\":[314,336]},\"EmptyListOf\",[[\"param\",{\"sourceInterval\":[326,330]},0],[\"param\",{\"sourceInterval\":[332,335]},1]]]]],\"NonemptyListOf\":[\"define\",{\"sourceInterval\":[340,388]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[372,388]},[\"param\",{\"sourceInterval\":[372,376]},0],[\"star\",{\"sourceInterval\":[377,388]},[\"seq\",{\"sourceInterval\":[378,386]},[\"param\",{\"sourceInterval\":[378,381]},1],[\"param\",{\"sourceInterval\":[382,386]},0]]]]],\"EmptyListOf\":[\"define\",{\"sourceInterval\":[392,434]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[438,438]}]],\"listOf\":[\"define\",{\"sourceInterval\":[438,516]},null,[\"elem\",\"sep\"],[\"alt\",{\"sourceInterval\":[462,516]},[\"app\",{\"sourceInterval\":[462,487]},\"nonemptyListOf\",[[\"param\",{\"sourceInterval\":[477,481]},0],[\"param\",{\"sourceInterval\":[483,486]},1]]],[\"app\",{\"sourceInterval\":[494,516]},\"emptyListOf\",[[\"param\",{\"sourceInterval\":[506,510]},0],[\"param\",{\"sourceInterval\":[512,515]},1]]]]],\"nonemptyListOf\":[\"define\",{\"sourceInterval\":[520,568]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[552,568]},[\"param\",{\"sourceInterval\":[552,556]},0],[\"star\",{\"sourceInterval\":[557,568]},[\"seq\",{\"sourceInterval\":[558,566]},[\"param\",{\"sourceInterval\":[558,561]},1],[\"param\",{\"sourceInterval\":[562,566]},0]]]]],\"emptyListOf\":[\"define\",{\"sourceInterval\":[572,682]},null,[\"elem\",\"sep\"],[\"seq\",{\"sourceInterval\":[685,685]}]],\"applySyntactic\":[\"define\",{\"sourceInterval\":[685,710]},null,[\"app\"],[\"param\",{\"sourceInterval\":[707,710]},0]]}]);\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Grammar$1 = Grammar_1;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\nGrammar$1.BuiltInRules = builtInRules;\n\nvar {makeRecipe: makeRecipe$2} = makeRecipe$5;\nvar operationsAndAttributes = makeRecipe$2([\"grammar\",{\"source\":\"OperationsAndAttributes {\\n\\n  AttributeSignature =\\n    name\\n\\n  OperationSignature =\\n    name Formals?\\n\\n  Formals\\n    = \\\"(\\\" ListOf<name, \\\",\\\"> \\\")\\\"\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n}\"},\"OperationsAndAttributes\",null,\"AttributeSignature\",{\"AttributeSignature\":[\"define\",{\"sourceInterval\":[29,58]},null,[],[\"app\",{\"sourceInterval\":[54,58]},\"name\",[]]],\"OperationSignature\":[\"define\",{\"sourceInterval\":[62,100]},null,[],[\"seq\",{\"sourceInterval\":[87,100]},[\"app\",{\"sourceInterval\":[87,91]},\"name\",[]],[\"opt\",{\"sourceInterval\":[92,100]},[\"app\",{\"sourceInterval\":[92,99]},\"Formals\",[]]]]],\"Formals\":[\"define\",{\"sourceInterval\":[104,143]},null,[],[\"seq\",{\"sourceInterval\":[118,143]},[\"terminal\",{\"sourceInterval\":[118,121]},\"(\"],[\"app\",{\"sourceInterval\":[122,139]},\"ListOf\",[[\"app\",{\"sourceInterval\":[129,133]},\"name\",[]],[\"terminal\",{\"sourceInterval\":[135,138]},\",\"]]],[\"terminal\",{\"sourceInterval\":[140,143]},\")\"]]],\"name\":[\"define\",{\"sourceInterval\":[147,187]},\"a name\",[],[\"seq\",{\"sourceInterval\":[168,187]},[\"app\",{\"sourceInterval\":[168,177]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[178,187]},[\"app\",{\"sourceInterval\":[178,186]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[191,223]},null,[],[\"alt\",{\"sourceInterval\":[207,223]},[\"terminal\",{\"sourceInterval\":[207,210]},\"_\"],[\"app\",{\"sourceInterval\":[217,223]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[227,257]},null,[],[\"alt\",{\"sourceInterval\":[242,257]},[\"terminal\",{\"sourceInterval\":[242,245]},\"_\"],[\"app\",{\"sourceInterval\":[252,257]},\"alnum\",[]]]]}]);\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Semantics = Semantics_1;\nconst util$1 = util$7;\n\n// ----------------- Deferred initialization -----------------\n\nutil$1.awaitBuiltInRules(builtInRules => {\n  const operationsAndAttributesGrammar = operationsAndAttributes;\n  initBuiltInSemantics(builtInRules);\n  initPrototypeParser(operationsAndAttributesGrammar); // requires BuiltInSemantics\n});\n\nfunction initBuiltInSemantics(builtInRules) {\n  const actions = {\n    empty() {\n      return this.iteration();\n    },\n    nonEmpty(first, _, rest) {\n      return this.iteration([first].concat(rest.children));\n    },\n  };\n\n  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules, null).addOperation(\n      'asIteration',\n      {\n        emptyListOf: actions.empty,\n        nonemptyListOf: actions.nonEmpty,\n        EmptyListOf: actions.empty,\n        NonemptyListOf: actions.nonEmpty,\n      }\n  );\n}\n\nfunction initPrototypeParser(grammar) {\n  Semantics.prototypeGrammarSemantics = grammar.createSemantics().addOperation('parse', {\n    AttributeSignature(name) {\n      return {\n        name: name.parse(),\n        formals: [],\n      };\n    },\n    OperationSignature(name, optFormals) {\n      return {\n        name: name.parse(),\n        formals: optFormals.children.map(c => c.parse())[0] || [],\n      };\n    },\n    Formals(oparen, fs, cparen) {\n      return fs.asIteration().children.map(c => c.parse());\n    },\n    name(first, rest) {\n      return this.sourceString;\n    },\n  });\n  Semantics.prototypeGrammar = grammar;\n}\n\nvar {makeRecipe: makeRecipe$1} = makeRecipe$5;\nvar ohmGrammar$1 = makeRecipe$1([\"grammar\",{\"source\":\"Ohm {\\n\\n  Grammars\\n    = Grammar*\\n\\n  Grammar\\n    = ident SuperGrammar? \\\"{\\\" Rule* \\\"}\\\"\\n\\n  SuperGrammar\\n    = \\\"<:\\\" ident\\n\\n  Rule\\n    = ident Formals? ruleDescr? \\\"=\\\"  RuleBody  -- define\\n    | ident Formals?            \\\":=\\\" OverrideRuleBody  -- override\\n    | ident Formals?            \\\"+=\\\" RuleBody  -- extend\\n\\n  RuleBody\\n    = \\\"|\\\"? NonemptyListOf<TopLevelTerm, \\\"|\\\">\\n\\n  TopLevelTerm\\n    = Seq caseName  -- inline\\n    | Seq\\n\\n  OverrideRuleBody\\n    = \\\"|\\\"? NonemptyListOf<OverrideTopLevelTerm, \\\"|\\\">\\n\\n  OverrideTopLevelTerm\\n    = \\\"...\\\"  -- superSplice\\n    | TopLevelTerm\\n\\n  Formals\\n    = \\\"<\\\" ListOf<ident, \\\",\\\"> \\\">\\\"\\n\\n  Params\\n    = \\\"<\\\" ListOf<Seq, \\\",\\\"> \\\">\\\"\\n\\n  Alt\\n    = NonemptyListOf<Seq, \\\"|\\\">\\n\\n  Seq\\n    = Iter*\\n\\n  Iter\\n    = Pred \\\"*\\\"  -- star\\n    | Pred \\\"+\\\"  -- plus\\n    | Pred \\\"?\\\"  -- opt\\n    | Pred\\n\\n  Pred\\n    = \\\"~\\\" Lex  -- not\\n    | \\\"&\\\" Lex  -- lookahead\\n    | Lex\\n\\n  Lex\\n    = \\\"#\\\" Base  -- lex\\n    | Base\\n\\n  Base\\n    = ident Params? ~(ruleDescr? \\\"=\\\" | \\\":=\\\" | \\\"+=\\\")  -- application\\n    | oneCharTerminal \\\"..\\\" oneCharTerminal           -- range\\n    | terminal                                       -- terminal\\n    | \\\"(\\\" Alt \\\")\\\"                                    -- paren\\n\\n  ruleDescr  (a rule description)\\n    = \\\"(\\\" ruleDescrText \\\")\\\"\\n\\n  ruleDescrText\\n    = (~\\\")\\\" any)*\\n\\n  caseName\\n    = \\\"--\\\" (~\\\"\\\\n\\\" space)* name (~\\\"\\\\n\\\" space)* (\\\"\\\\n\\\" | &\\\"}\\\")\\n\\n  name  (a name)\\n    = nameFirst nameRest*\\n\\n  nameFirst\\n    = \\\"_\\\"\\n    | letter\\n\\n  nameRest\\n    = \\\"_\\\"\\n    | alnum\\n\\n  ident  (an identifier)\\n    = name\\n\\n  terminal\\n    = \\\"\\\\\\\"\\\" terminalChar* \\\"\\\\\\\"\\\"\\n\\n  oneCharTerminal\\n    = \\\"\\\\\\\"\\\" terminalChar \\\"\\\\\\\"\\\"\\n\\n  terminalChar\\n    = escapeChar\\n      | ~\\\"\\\\\\\\\\\" ~\\\"\\\\\\\"\\\" ~\\\"\\\\n\\\" \\\"\\\\u{0}\\\"..\\\"\\\\u{10FFFF}\\\"\\n\\n  escapeChar  (an escape sequence)\\n    = \\\"\\\\\\\\\\\\\\\\\\\"                                     -- backslash\\n    | \\\"\\\\\\\\\\\\\\\"\\\"                                     -- doubleQuote\\n    | \\\"\\\\\\\\\\\\'\\\"                                     -- singleQuote\\n    | \\\"\\\\\\\\b\\\"                                      -- backspace\\n    | \\\"\\\\\\\\n\\\"                                      -- lineFeed\\n    | \\\"\\\\\\\\r\\\"                                      -- carriageReturn\\n    | \\\"\\\\\\\\t\\\"                                      -- tab\\n    | \\\"\\\\\\\\u{\\\" hexDigit hexDigit? hexDigit?\\n             hexDigit? hexDigit? hexDigit? \\\"}\\\"   -- unicodeCodePoint\\n    | \\\"\\\\\\\\u\\\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\\n    | \\\"\\\\\\\\x\\\" hexDigit hexDigit                    -- hexEscape\\n\\n  space\\n   += comment\\n\\n  comment\\n    = \\\"//\\\" (~\\\"\\\\n\\\" any)* &(\\\"\\\\n\\\" | end)  -- singleLine\\n    | \\\"/*\\\" (~\\\"*/\\\" any)* \\\"*/\\\"  -- multiLine\\n\\n  tokens = token*\\n\\n  token = caseName | comment | ident | operator | punctuation | terminal | any\\n\\n  operator = \\\"<:\\\" | \\\"=\\\" | \\\":=\\\" | \\\"+=\\\" | \\\"*\\\" | \\\"+\\\" | \\\"?\\\" | \\\"~\\\" | \\\"&\\\"\\n\\n  punctuation = \\\"<\\\" | \\\">\\\" | \\\",\\\" | \\\"--\\\"\\n}\"},\"Ohm\",null,\"Grammars\",{\"Grammars\":[\"define\",{\"sourceInterval\":[9,32]},null,[],[\"star\",{\"sourceInterval\":[24,32]},[\"app\",{\"sourceInterval\":[24,31]},\"Grammar\",[]]]],\"Grammar\":[\"define\",{\"sourceInterval\":[36,83]},null,[],[\"seq\",{\"sourceInterval\":[50,83]},[\"app\",{\"sourceInterval\":[50,55]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[56,69]},[\"app\",{\"sourceInterval\":[56,68]},\"SuperGrammar\",[]]],[\"terminal\",{\"sourceInterval\":[70,73]},\"{\"],[\"star\",{\"sourceInterval\":[74,79]},[\"app\",{\"sourceInterval\":[74,78]},\"Rule\",[]]],[\"terminal\",{\"sourceInterval\":[80,83]},\"}\"]]],\"SuperGrammar\":[\"define\",{\"sourceInterval\":[87,116]},null,[],[\"seq\",{\"sourceInterval\":[106,116]},[\"terminal\",{\"sourceInterval\":[106,110]},\"<:\"],[\"app\",{\"sourceInterval\":[111,116]},\"ident\",[]]]],\"Rule_define\":[\"define\",{\"sourceInterval\":[131,181]},null,[],[\"seq\",{\"sourceInterval\":[131,170]},[\"app\",{\"sourceInterval\":[131,136]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[137,145]},[\"app\",{\"sourceInterval\":[137,144]},\"Formals\",[]]],[\"opt\",{\"sourceInterval\":[146,156]},[\"app\",{\"sourceInterval\":[146,155]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[157,160]},\"=\"],[\"app\",{\"sourceInterval\":[162,170]},\"RuleBody\",[]]]],\"Rule_override\":[\"define\",{\"sourceInterval\":[188,248]},null,[],[\"seq\",{\"sourceInterval\":[188,235]},[\"app\",{\"sourceInterval\":[188,193]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[194,202]},[\"app\",{\"sourceInterval\":[194,201]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[214,218]},\":=\"],[\"app\",{\"sourceInterval\":[219,235]},\"OverrideRuleBody\",[]]]],\"Rule_extend\":[\"define\",{\"sourceInterval\":[255,305]},null,[],[\"seq\",{\"sourceInterval\":[255,294]},[\"app\",{\"sourceInterval\":[255,260]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[261,269]},[\"app\",{\"sourceInterval\":[261,268]},\"Formals\",[]]],[\"terminal\",{\"sourceInterval\":[281,285]},\"+=\"],[\"app\",{\"sourceInterval\":[286,294]},\"RuleBody\",[]]]],\"Rule\":[\"define\",{\"sourceInterval\":[120,305]},null,[],[\"alt\",{\"sourceInterval\":[131,305]},[\"app\",{\"sourceInterval\":[131,170]},\"Rule_define\",[]],[\"app\",{\"sourceInterval\":[188,235]},\"Rule_override\",[]],[\"app\",{\"sourceInterval\":[255,294]},\"Rule_extend\",[]]]],\"RuleBody\":[\"define\",{\"sourceInterval\":[309,362]},null,[],[\"seq\",{\"sourceInterval\":[324,362]},[\"opt\",{\"sourceInterval\":[324,328]},[\"terminal\",{\"sourceInterval\":[324,327]},\"|\"]],[\"app\",{\"sourceInterval\":[329,362]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[344,356]},\"TopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[358,361]},\"|\"]]]]],\"TopLevelTerm_inline\":[\"define\",{\"sourceInterval\":[385,408]},null,[],[\"seq\",{\"sourceInterval\":[385,397]},[\"app\",{\"sourceInterval\":[385,388]},\"Seq\",[]],[\"app\",{\"sourceInterval\":[389,397]},\"caseName\",[]]]],\"TopLevelTerm\":[\"define\",{\"sourceInterval\":[366,418]},null,[],[\"alt\",{\"sourceInterval\":[385,418]},[\"app\",{\"sourceInterval\":[385,397]},\"TopLevelTerm_inline\",[]],[\"app\",{\"sourceInterval\":[415,418]},\"Seq\",[]]]],\"OverrideRuleBody\":[\"define\",{\"sourceInterval\":[422,491]},null,[],[\"seq\",{\"sourceInterval\":[445,491]},[\"opt\",{\"sourceInterval\":[445,449]},[\"terminal\",{\"sourceInterval\":[445,448]},\"|\"]],[\"app\",{\"sourceInterval\":[450,491]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[465,485]},\"OverrideTopLevelTerm\",[]],[\"terminal\",{\"sourceInterval\":[487,490]},\"|\"]]]]],\"OverrideTopLevelTerm_superSplice\":[\"define\",{\"sourceInterval\":[522,543]},null,[],[\"terminal\",{\"sourceInterval\":[522,527]},\"...\"]],\"OverrideTopLevelTerm\":[\"define\",{\"sourceInterval\":[495,562]},null,[],[\"alt\",{\"sourceInterval\":[522,562]},[\"app\",{\"sourceInterval\":[522,527]},\"OverrideTopLevelTerm_superSplice\",[]],[\"app\",{\"sourceInterval\":[550,562]},\"TopLevelTerm\",[]]]],\"Formals\":[\"define\",{\"sourceInterval\":[566,606]},null,[],[\"seq\",{\"sourceInterval\":[580,606]},[\"terminal\",{\"sourceInterval\":[580,583]},\"<\"],[\"app\",{\"sourceInterval\":[584,602]},\"ListOf\",[[\"app\",{\"sourceInterval\":[591,596]},\"ident\",[]],[\"terminal\",{\"sourceInterval\":[598,601]},\",\"]]],[\"terminal\",{\"sourceInterval\":[603,606]},\">\"]]],\"Params\":[\"define\",{\"sourceInterval\":[610,647]},null,[],[\"seq\",{\"sourceInterval\":[623,647]},[\"terminal\",{\"sourceInterval\":[623,626]},\"<\"],[\"app\",{\"sourceInterval\":[627,643]},\"ListOf\",[[\"app\",{\"sourceInterval\":[634,637]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[639,642]},\",\"]]],[\"terminal\",{\"sourceInterval\":[644,647]},\">\"]]],\"Alt\":[\"define\",{\"sourceInterval\":[651,685]},null,[],[\"app\",{\"sourceInterval\":[661,685]},\"NonemptyListOf\",[[\"app\",{\"sourceInterval\":[676,679]},\"Seq\",[]],[\"terminal\",{\"sourceInterval\":[681,684]},\"|\"]]]],\"Seq\":[\"define\",{\"sourceInterval\":[689,704]},null,[],[\"star\",{\"sourceInterval\":[699,704]},[\"app\",{\"sourceInterval\":[699,703]},\"Iter\",[]]]],\"Iter_star\":[\"define\",{\"sourceInterval\":[719,736]},null,[],[\"seq\",{\"sourceInterval\":[719,727]},[\"app\",{\"sourceInterval\":[719,723]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[724,727]},\"*\"]]],\"Iter_plus\":[\"define\",{\"sourceInterval\":[743,760]},null,[],[\"seq\",{\"sourceInterval\":[743,751]},[\"app\",{\"sourceInterval\":[743,747]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[748,751]},\"+\"]]],\"Iter_opt\":[\"define\",{\"sourceInterval\":[767,783]},null,[],[\"seq\",{\"sourceInterval\":[767,775]},[\"app\",{\"sourceInterval\":[767,771]},\"Pred\",[]],[\"terminal\",{\"sourceInterval\":[772,775]},\"?\"]]],\"Iter\":[\"define\",{\"sourceInterval\":[708,794]},null,[],[\"alt\",{\"sourceInterval\":[719,794]},[\"app\",{\"sourceInterval\":[719,727]},\"Iter_star\",[]],[\"app\",{\"sourceInterval\":[743,751]},\"Iter_plus\",[]],[\"app\",{\"sourceInterval\":[767,775]},\"Iter_opt\",[]],[\"app\",{\"sourceInterval\":[790,794]},\"Pred\",[]]]],\"Pred_not\":[\"define\",{\"sourceInterval\":[809,824]},null,[],[\"seq\",{\"sourceInterval\":[809,816]},[\"terminal\",{\"sourceInterval\":[809,812]},\"~\"],[\"app\",{\"sourceInterval\":[813,816]},\"Lex\",[]]]],\"Pred_lookahead\":[\"define\",{\"sourceInterval\":[831,852]},null,[],[\"seq\",{\"sourceInterval\":[831,838]},[\"terminal\",{\"sourceInterval\":[831,834]},\"&\"],[\"app\",{\"sourceInterval\":[835,838]},\"Lex\",[]]]],\"Pred\":[\"define\",{\"sourceInterval\":[798,862]},null,[],[\"alt\",{\"sourceInterval\":[809,862]},[\"app\",{\"sourceInterval\":[809,816]},\"Pred_not\",[]],[\"app\",{\"sourceInterval\":[831,838]},\"Pred_lookahead\",[]],[\"app\",{\"sourceInterval\":[859,862]},\"Lex\",[]]]],\"Lex_lex\":[\"define\",{\"sourceInterval\":[876,892]},null,[],[\"seq\",{\"sourceInterval\":[876,884]},[\"terminal\",{\"sourceInterval\":[876,879]},\"#\"],[\"app\",{\"sourceInterval\":[880,884]},\"Base\",[]]]],\"Lex\":[\"define\",{\"sourceInterval\":[866,903]},null,[],[\"alt\",{\"sourceInterval\":[876,903]},[\"app\",{\"sourceInterval\":[876,884]},\"Lex_lex\",[]],[\"app\",{\"sourceInterval\":[899,903]},\"Base\",[]]]],\"Base_application\":[\"define\",{\"sourceInterval\":[918,979]},null,[],[\"seq\",{\"sourceInterval\":[918,963]},[\"app\",{\"sourceInterval\":[918,923]},\"ident\",[]],[\"opt\",{\"sourceInterval\":[924,931]},[\"app\",{\"sourceInterval\":[924,930]},\"Params\",[]]],[\"not\",{\"sourceInterval\":[932,963]},[\"alt\",{\"sourceInterval\":[934,962]},[\"seq\",{\"sourceInterval\":[934,948]},[\"opt\",{\"sourceInterval\":[934,944]},[\"app\",{\"sourceInterval\":[934,943]},\"ruleDescr\",[]]],[\"terminal\",{\"sourceInterval\":[945,948]},\"=\"]],[\"terminal\",{\"sourceInterval\":[951,955]},\":=\"],[\"terminal\",{\"sourceInterval\":[958,962]},\"+=\"]]]]],\"Base_range\":[\"define\",{\"sourceInterval\":[986,1041]},null,[],[\"seq\",{\"sourceInterval\":[986,1022]},[\"app\",{\"sourceInterval\":[986,1001]},\"oneCharTerminal\",[]],[\"terminal\",{\"sourceInterval\":[1002,1006]},\"..\"],[\"app\",{\"sourceInterval\":[1007,1022]},\"oneCharTerminal\",[]]]],\"Base_terminal\":[\"define\",{\"sourceInterval\":[1048,1106]},null,[],[\"app\",{\"sourceInterval\":[1048,1056]},\"terminal\",[]]],\"Base_paren\":[\"define\",{\"sourceInterval\":[1113,1168]},null,[],[\"seq\",{\"sourceInterval\":[1113,1124]},[\"terminal\",{\"sourceInterval\":[1113,1116]},\"(\"],[\"app\",{\"sourceInterval\":[1117,1120]},\"Alt\",[]],[\"terminal\",{\"sourceInterval\":[1121,1124]},\")\"]]],\"Base\":[\"define\",{\"sourceInterval\":[907,1168]},null,[],[\"alt\",{\"sourceInterval\":[918,1168]},[\"app\",{\"sourceInterval\":[918,963]},\"Base_application\",[]],[\"app\",{\"sourceInterval\":[986,1022]},\"Base_range\",[]],[\"app\",{\"sourceInterval\":[1048,1056]},\"Base_terminal\",[]],[\"app\",{\"sourceInterval\":[1113,1124]},\"Base_paren\",[]]]],\"ruleDescr\":[\"define\",{\"sourceInterval\":[1172,1231]},\"a rule description\",[],[\"seq\",{\"sourceInterval\":[1210,1231]},[\"terminal\",{\"sourceInterval\":[1210,1213]},\"(\"],[\"app\",{\"sourceInterval\":[1214,1227]},\"ruleDescrText\",[]],[\"terminal\",{\"sourceInterval\":[1228,1231]},\")\"]]],\"ruleDescrText\":[\"define\",{\"sourceInterval\":[1235,1266]},null,[],[\"star\",{\"sourceInterval\":[1255,1266]},[\"seq\",{\"sourceInterval\":[1256,1264]},[\"not\",{\"sourceInterval\":[1256,1260]},[\"terminal\",{\"sourceInterval\":[1257,1260]},\")\"]],[\"app\",{\"sourceInterval\":[1261,1264]},\"any\",[]]]]],\"caseName\":[\"define\",{\"sourceInterval\":[1270,1338]},null,[],[\"seq\",{\"sourceInterval\":[1285,1338]},[\"terminal\",{\"sourceInterval\":[1285,1289]},\"--\"],[\"star\",{\"sourceInterval\":[1290,1304]},[\"seq\",{\"sourceInterval\":[1291,1302]},[\"not\",{\"sourceInterval\":[1291,1296]},[\"terminal\",{\"sourceInterval\":[1292,1296]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1297,1302]},\"space\",[]]]],[\"app\",{\"sourceInterval\":[1305,1309]},\"name\",[]],[\"star\",{\"sourceInterval\":[1310,1324]},[\"seq\",{\"sourceInterval\":[1311,1322]},[\"not\",{\"sourceInterval\":[1311,1316]},[\"terminal\",{\"sourceInterval\":[1312,1316]},\"\\n\"]],[\"app\",{\"sourceInterval\":[1317,1322]},\"space\",[]]]],[\"alt\",{\"sourceInterval\":[1326,1337]},[\"terminal\",{\"sourceInterval\":[1326,1330]},\"\\n\"],[\"lookahead\",{\"sourceInterval\":[1333,1337]},[\"terminal\",{\"sourceInterval\":[1334,1337]},\"}\"]]]]],\"name\":[\"define\",{\"sourceInterval\":[1342,1382]},\"a name\",[],[\"seq\",{\"sourceInterval\":[1363,1382]},[\"app\",{\"sourceInterval\":[1363,1372]},\"nameFirst\",[]],[\"star\",{\"sourceInterval\":[1373,1382]},[\"app\",{\"sourceInterval\":[1373,1381]},\"nameRest\",[]]]]],\"nameFirst\":[\"define\",{\"sourceInterval\":[1386,1418]},null,[],[\"alt\",{\"sourceInterval\":[1402,1418]},[\"terminal\",{\"sourceInterval\":[1402,1405]},\"_\"],[\"app\",{\"sourceInterval\":[1412,1418]},\"letter\",[]]]],\"nameRest\":[\"define\",{\"sourceInterval\":[1422,1452]},null,[],[\"alt\",{\"sourceInterval\":[1437,1452]},[\"terminal\",{\"sourceInterval\":[1437,1440]},\"_\"],[\"app\",{\"sourceInterval\":[1447,1452]},\"alnum\",[]]]],\"ident\":[\"define\",{\"sourceInterval\":[1456,1489]},\"an identifier\",[],[\"app\",{\"sourceInterval\":[1485,1489]},\"name\",[]]],\"terminal\":[\"define\",{\"sourceInterval\":[1493,1531]},null,[],[\"seq\",{\"sourceInterval\":[1508,1531]},[\"terminal\",{\"sourceInterval\":[1508,1512]},\"\\\"\"],[\"star\",{\"sourceInterval\":[1513,1526]},[\"app\",{\"sourceInterval\":[1513,1525]},\"terminalChar\",[]]],[\"terminal\",{\"sourceInterval\":[1527,1531]},\"\\\"\"]]],\"oneCharTerminal\":[\"define\",{\"sourceInterval\":[1535,1579]},null,[],[\"seq\",{\"sourceInterval\":[1557,1579]},[\"terminal\",{\"sourceInterval\":[1557,1561]},\"\\\"\"],[\"app\",{\"sourceInterval\":[1562,1574]},\"terminalChar\",[]],[\"terminal\",{\"sourceInterval\":[1575,1579]},\"\\\"\"]]],\"terminalChar\":[\"define\",{\"sourceInterval\":[1583,1660]},null,[],[\"alt\",{\"sourceInterval\":[1602,1660]},[\"app\",{\"sourceInterval\":[1602,1612]},\"escapeChar\",[]],[\"seq\",{\"sourceInterval\":[1621,1660]},[\"not\",{\"sourceInterval\":[1621,1626]},[\"terminal\",{\"sourceInterval\":[1622,1626]},\"\\\\\"]],[\"not\",{\"sourceInterval\":[1627,1632]},[\"terminal\",{\"sourceInterval\":[1628,1632]},\"\\\"\"]],[\"not\",{\"sourceInterval\":[1633,1638]},[\"terminal\",{\"sourceInterval\":[1634,1638]},\"\\n\"]],[\"range\",{\"sourceInterval\":[1639,1660]},\"\\u0000\",\"\"]]]],\"escapeChar_backslash\":[\"define\",{\"sourceInterval\":[1703,1758]},null,[],[\"terminal\",{\"sourceInterval\":[1703,1709]},\"\\\\\\\\\"]],\"escapeChar_doubleQuote\":[\"define\",{\"sourceInterval\":[1765,1822]},null,[],[\"terminal\",{\"sourceInterval\":[1765,1771]},\"\\\\\\\"\"]],\"escapeChar_singleQuote\":[\"define\",{\"sourceInterval\":[1829,1886]},null,[],[\"terminal\",{\"sourceInterval\":[1829,1835]},\"\\\\'\"]],\"escapeChar_backspace\":[\"define\",{\"sourceInterval\":[1893,1948]},null,[],[\"terminal\",{\"sourceInterval\":[1893,1898]},\"\\\\b\"]],\"escapeChar_lineFeed\":[\"define\",{\"sourceInterval\":[1955,2009]},null,[],[\"terminal\",{\"sourceInterval\":[1955,1960]},\"\\\\n\"]],\"escapeChar_carriageReturn\":[\"define\",{\"sourceInterval\":[2016,2076]},null,[],[\"terminal\",{\"sourceInterval\":[2016,2021]},\"\\\\r\"]],\"escapeChar_tab\":[\"define\",{\"sourceInterval\":[2083,2132]},null,[],[\"terminal\",{\"sourceInterval\":[2083,2088]},\"\\\\t\"]],\"escapeChar_unicodeCodePoint\":[\"define\",{\"sourceInterval\":[2139,2243]},null,[],[\"seq\",{\"sourceInterval\":[2139,2221]},[\"terminal\",{\"sourceInterval\":[2139,2145]},\"\\\\u{\"],[\"app\",{\"sourceInterval\":[2146,2154]},\"hexDigit\",[]],[\"opt\",{\"sourceInterval\":[2155,2164]},[\"app\",{\"sourceInterval\":[2155,2163]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2165,2174]},[\"app\",{\"sourceInterval\":[2165,2173]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2188,2197]},[\"app\",{\"sourceInterval\":[2188,2196]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2198,2207]},[\"app\",{\"sourceInterval\":[2198,2206]},\"hexDigit\",[]]],[\"opt\",{\"sourceInterval\":[2208,2217]},[\"app\",{\"sourceInterval\":[2208,2216]},\"hexDigit\",[]]],[\"terminal\",{\"sourceInterval\":[2218,2221]},\"}\"]]],\"escapeChar_unicodeEscape\":[\"define\",{\"sourceInterval\":[2250,2309]},null,[],[\"seq\",{\"sourceInterval\":[2250,2291]},[\"terminal\",{\"sourceInterval\":[2250,2255]},\"\\\\u\"],[\"app\",{\"sourceInterval\":[2256,2264]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2265,2273]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2274,2282]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2283,2291]},\"hexDigit\",[]]]],\"escapeChar_hexEscape\":[\"define\",{\"sourceInterval\":[2316,2371]},null,[],[\"seq\",{\"sourceInterval\":[2316,2339]},[\"terminal\",{\"sourceInterval\":[2316,2321]},\"\\\\x\"],[\"app\",{\"sourceInterval\":[2322,2330]},\"hexDigit\",[]],[\"app\",{\"sourceInterval\":[2331,2339]},\"hexDigit\",[]]]],\"escapeChar\":[\"define\",{\"sourceInterval\":[1664,2371]},\"an escape sequence\",[],[\"alt\",{\"sourceInterval\":[1703,2371]},[\"app\",{\"sourceInterval\":[1703,1709]},\"escapeChar_backslash\",[]],[\"app\",{\"sourceInterval\":[1765,1771]},\"escapeChar_doubleQuote\",[]],[\"app\",{\"sourceInterval\":[1829,1835]},\"escapeChar_singleQuote\",[]],[\"app\",{\"sourceInterval\":[1893,1898]},\"escapeChar_backspace\",[]],[\"app\",{\"sourceInterval\":[1955,1960]},\"escapeChar_lineFeed\",[]],[\"app\",{\"sourceInterval\":[2016,2021]},\"escapeChar_carriageReturn\",[]],[\"app\",{\"sourceInterval\":[2083,2088]},\"escapeChar_tab\",[]],[\"app\",{\"sourceInterval\":[2139,2221]},\"escapeChar_unicodeCodePoint\",[]],[\"app\",{\"sourceInterval\":[2250,2291]},\"escapeChar_unicodeEscape\",[]],[\"app\",{\"sourceInterval\":[2316,2339]},\"escapeChar_hexEscape\",[]]]],\"space\":[\"extend\",{\"sourceInterval\":[2375,2394]},null,[],[\"app\",{\"sourceInterval\":[2387,2394]},\"comment\",[]]],\"comment_singleLine\":[\"define\",{\"sourceInterval\":[2412,2458]},null,[],[\"seq\",{\"sourceInterval\":[2412,2443]},[\"terminal\",{\"sourceInterval\":[2412,2416]},\"//\"],[\"star\",{\"sourceInterval\":[2417,2429]},[\"seq\",{\"sourceInterval\":[2418,2427]},[\"not\",{\"sourceInterval\":[2418,2423]},[\"terminal\",{\"sourceInterval\":[2419,2423]},\"\\n\"]],[\"app\",{\"sourceInterval\":[2424,2427]},\"any\",[]]]],[\"lookahead\",{\"sourceInterval\":[2430,2443]},[\"alt\",{\"sourceInterval\":[2432,2442]},[\"terminal\",{\"sourceInterval\":[2432,2436]},\"\\n\"],[\"app\",{\"sourceInterval\":[2439,2442]},\"end\",[]]]]]],\"comment_multiLine\":[\"define\",{\"sourceInterval\":[2465,2501]},null,[],[\"seq\",{\"sourceInterval\":[2465,2487]},[\"terminal\",{\"sourceInterval\":[2465,2469]},\"/*\"],[\"star\",{\"sourceInterval\":[2470,2482]},[\"seq\",{\"sourceInterval\":[2471,2480]},[\"not\",{\"sourceInterval\":[2471,2476]},[\"terminal\",{\"sourceInterval\":[2472,2476]},\"*/\"]],[\"app\",{\"sourceInterval\":[2477,2480]},\"any\",[]]]],[\"terminal\",{\"sourceInterval\":[2483,2487]},\"*/\"]]],\"comment\":[\"define\",{\"sourceInterval\":[2398,2501]},null,[],[\"alt\",{\"sourceInterval\":[2412,2501]},[\"app\",{\"sourceInterval\":[2412,2443]},\"comment_singleLine\",[]],[\"app\",{\"sourceInterval\":[2465,2487]},\"comment_multiLine\",[]]]],\"tokens\":[\"define\",{\"sourceInterval\":[2505,2520]},null,[],[\"star\",{\"sourceInterval\":[2514,2520]},[\"app\",{\"sourceInterval\":[2514,2519]},\"token\",[]]]],\"token\":[\"define\",{\"sourceInterval\":[2524,2600]},null,[],[\"alt\",{\"sourceInterval\":[2532,2600]},[\"app\",{\"sourceInterval\":[2532,2540]},\"caseName\",[]],[\"app\",{\"sourceInterval\":[2543,2550]},\"comment\",[]],[\"app\",{\"sourceInterval\":[2553,2558]},\"ident\",[]],[\"app\",{\"sourceInterval\":[2561,2569]},\"operator\",[]],[\"app\",{\"sourceInterval\":[2572,2583]},\"punctuation\",[]],[\"app\",{\"sourceInterval\":[2586,2594]},\"terminal\",[]],[\"app\",{\"sourceInterval\":[2597,2600]},\"any\",[]]]],\"operator\":[\"define\",{\"sourceInterval\":[2604,2669]},null,[],[\"alt\",{\"sourceInterval\":[2615,2669]},[\"terminal\",{\"sourceInterval\":[2615,2619]},\"<:\"],[\"terminal\",{\"sourceInterval\":[2622,2625]},\"=\"],[\"terminal\",{\"sourceInterval\":[2628,2632]},\":=\"],[\"terminal\",{\"sourceInterval\":[2635,2639]},\"+=\"],[\"terminal\",{\"sourceInterval\":[2642,2645]},\"*\"],[\"terminal\",{\"sourceInterval\":[2648,2651]},\"+\"],[\"terminal\",{\"sourceInterval\":[2654,2657]},\"?\"],[\"terminal\",{\"sourceInterval\":[2660,2663]},\"~\"],[\"terminal\",{\"sourceInterval\":[2666,2669]},\"&\"]]],\"punctuation\":[\"define\",{\"sourceInterval\":[2673,2709]},null,[],[\"alt\",{\"sourceInterval\":[2687,2709]},[\"terminal\",{\"sourceInterval\":[2687,2690]},\"<\"],[\"terminal\",{\"sourceInterval\":[2693,2696]},\">\"],[\"terminal\",{\"sourceInterval\":[2699,2702]},\",\"],[\"terminal\",{\"sourceInterval\":[2705,2709]},\"--\"]]]}]);\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst Builder = Builder_1;\nconst Grammar = Grammar_1;\nconst Namespace = Namespace_1;\nconst common = common$l;\nconst errors = errors$9;\nconst pexprs = pexprs$6;\nconst util = util$7;\nconst version = version$1;\nconst {makeRecipe} = makeRecipe$5;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// The metagrammar, i.e. the grammar for Ohm grammars. Initialized at the\n// bottom of this file because loading the grammar requires Ohm itself.\nlet ohmGrammar;\n\nconst superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);\n\nconst isBuffer = obj =>\n  !!obj.constructor &&\n  typeof obj.constructor.isBuffer === 'function' &&\n  obj.constructor.isBuffer(obj);\n\n// Returns a Grammar instance (i.e., an object with a `match` method) for\n// `tree`, which is the concrete syntax tree of a user-written grammar.\n// The grammar will be assigned into `namespace` under the name of the grammar\n// as specified in the source.\nfunction buildGrammar(match, namespace, optOhmGrammarForTesting) {\n  const builder = new Builder();\n  let decl;\n  let currentRuleName;\n  let currentRuleFormals;\n  let overriding = false;\n  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;\n\n  // A visitor that produces a Grammar instance from the CST.\n  const helpers = metaGrammar.createSemantics().addOperation('visit', {\n    Grammars(grammarIter) {\n      return grammarIter.children.map(c => c.visit());\n    },\n    Grammar(id, s, _open, rules, _close) {\n      const grammarName = id.visit();\n      decl = builder.newGrammar(grammarName, namespace);\n      s.child(0) && s.child(0).visit();\n      rules.children.map(c => c.visit());\n      const g = decl.build();\n      g.source = this.source.trimmed();\n      if (grammarName in namespace) {\n        throw errors.duplicateGrammarDeclaration(g, namespace);\n      }\n      namespace[grammarName] = g;\n      return g;\n    },\n\n    SuperGrammar(_, n) {\n      const superGrammarName = n.visit();\n      if (superGrammarName === 'null') {\n        decl.withSuperGrammar(null);\n      } else {\n        if (!namespace || !(superGrammarName in namespace)) {\n          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);\n        }\n        decl.withSuperGrammar(namespace[superGrammarName]);\n      }\n    },\n\n    Rule_define(n, fs, d, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      // If there is no default start rule yet, set it now. This must be done before visiting\n      // the body, because it might contain an inline rule definition.\n      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {\n        decl.withDefaultStartRule(currentRuleName);\n      }\n      const body = b.visit();\n      const description = d.children.map(c => c.visit())[0];\n      const source = this.source.trimmed();\n      return decl.define(currentRuleName, currentRuleFormals, body, description, source);\n    },\n    Rule_override(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n\n      const source = this.source.trimmed();\n      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);\n\n      overriding = true;\n      const body = b.visit();\n      overriding = false;\n      return decl.override(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    Rule_extend(n, fs, _, b) {\n      currentRuleName = n.visit();\n      currentRuleFormals = fs.children.map(c => c.visit())[0] || [];\n      const body = b.visit();\n      const source = this.source.trimmed();\n      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);\n    },\n    RuleBody(_, terms) {\n      return builder.alt(...terms.visit()).withSource(this.source);\n    },\n    OverrideRuleBody(_, terms) {\n      const args = terms.visit();\n\n      // Check if the super-splice operator (`...`) appears in the terms.\n      const expansionPos = args.indexOf(superSplicePlaceholder);\n      if (expansionPos >= 0) {\n        const beforeTerms = args.slice(0, expansionPos);\n        const afterTerms = args.slice(expansionPos + 1);\n\n        // Ensure it appears no more than once.\n        afterTerms.forEach(t => {\n          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);\n        });\n\n        return new pexprs.Splice(\n            decl.superGrammar,\n            currentRuleName,\n            beforeTerms,\n            afterTerms\n        ).withSource(this.source);\n      } else {\n        return builder.alt(...args).withSource(this.source);\n      }\n    },\n    Formals(opointy, fs, cpointy) {\n      return fs.visit();\n    },\n\n    Params(opointy, ps, cpointy) {\n      return ps.visit();\n    },\n\n    Alt(seqs) {\n      return builder.alt(...seqs.visit()).withSource(this.source);\n    },\n\n    TopLevelTerm_inline(b, n) {\n      const inlineRuleName = currentRuleName + '_' + n.visit();\n      const body = b.visit();\n      const source = this.source.trimmed();\n      const isNewRuleDeclaration = !(\n        decl.superGrammar && decl.superGrammar.rules[inlineRuleName]\n      );\n      if (overriding && !isNewRuleDeclaration) {\n        decl.override(inlineRuleName, currentRuleFormals, body, null, source);\n      } else {\n        decl.define(inlineRuleName, currentRuleFormals, body, null, source);\n      }\n      const params = currentRuleFormals.map(formal => builder.app(formal));\n      return builder.app(inlineRuleName, params).withSource(body.source);\n    },\n    OverrideTopLevelTerm_superSplice(_) {\n      return superSplicePlaceholder;\n    },\n\n    Seq(expr) {\n      return builder.seq(...expr.children.map(c => c.visit())).withSource(this.source);\n    },\n\n    Iter_star(x, _) {\n      return builder.star(x.visit()).withSource(this.source);\n    },\n    Iter_plus(x, _) {\n      return builder.plus(x.visit()).withSource(this.source);\n    },\n    Iter_opt(x, _) {\n      return builder.opt(x.visit()).withSource(this.source);\n    },\n\n    Pred_not(_, x) {\n      return builder.not(x.visit()).withSource(this.source);\n    },\n    Pred_lookahead(_, x) {\n      return builder.lookahead(x.visit()).withSource(this.source);\n    },\n\n    Lex_lex(_, x) {\n      return builder.lex(x.visit()).withSource(this.source);\n    },\n\n    Base_application(rule, ps) {\n      const params = ps.children.map(c => c.visit())[0] || [];\n      return builder.app(rule.visit(), params).withSource(this.source);\n    },\n    Base_range(from, _, to) {\n      return builder.range(from.visit(), to.visit()).withSource(this.source);\n    },\n    Base_terminal(expr) {\n      return builder.terminal(expr.visit()).withSource(this.source);\n    },\n    Base_paren(open, x, close) {\n      return x.visit();\n    },\n\n    ruleDescr(open, t, close) {\n      return t.visit();\n    },\n    ruleDescrText(_) {\n      return this.sourceString.trim();\n    },\n\n    caseName(_, space1, n, space2, end) {\n      return n.visit();\n    },\n\n    name(first, rest) {\n      return this.sourceString;\n    },\n    nameFirst(expr) {},\n    nameRest(expr) {},\n\n    terminal(open, cs, close) {\n      return cs.children.map(c => c.visit()).join('');\n    },\n\n    oneCharTerminal(open, c, close) {\n      return c.visit();\n    },\n\n    escapeChar(c) {\n      try {\n        return common.unescapeCodePoint(this.sourceString);\n      } catch (err) {\n        if (err instanceof RangeError && err.message.startsWith('Invalid code point ')) {\n          throw errors.invalidCodePoint(c);\n        }\n        throw err; // Rethrow\n      }\n    },\n\n    NonemptyListOf(x, _, xs) {\n      return [x.visit()].concat(xs.children.map(c => c.visit()));\n    },\n    EmptyListOf() {\n      return [];\n    },\n\n    _terminal() {\n      return this.sourceString;\n    },\n  });\n  return helpers(match).visit();\n}\n\nfunction compileAndLoad(source, namespace) {\n  const m = ohmGrammar.match(source, 'Grammars');\n  if (m.failed()) {\n    throw errors.grammarSyntaxError(m);\n  }\n  return buildGrammar(m, namespace);\n}\n\nfunction grammar(source, optNamespace) {\n  const ns = grammars(source, optNamespace);\n\n  // Ensure that the source contained no more than one grammar definition.\n  const grammarNames = Object.keys(ns);\n  if (grammarNames.length === 0) {\n    throw new Error('Missing grammar definition');\n  } else if (grammarNames.length > 1) {\n    const secondGrammar = ns[grammarNames[1]];\n    const interval = secondGrammar.source;\n    throw new Error(\n        util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) +\n        'Found more than one grammar definition -- use ohm.grammars() instead.'\n    );\n  }\n  return ns[grammarNames[0]]; // Return the one and only grammar.\n}\n\nfunction grammars(source, optNamespace) {\n  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));\n  if (typeof source !== 'string') {\n    // For convenience, detect Node.js Buffer objects and automatically call toString().\n    if (isBuffer(source)) {\n      source = source.toString();\n    } else {\n      throw new TypeError(\n          'Expected string as first argument, got ' + common.unexpectedObjToString(source)\n      );\n    }\n  }\n  compileAndLoad(source, ns);\n  return ns;\n}\n\nfunction grammarFromScriptElement(optNode) {\n  throw new Error(\n      'grammarFromScriptElement was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info.'\n  );\n}\n\nfunction grammarsFromScriptElements(optNodeOrNodeList) {\n  throw new Error(\n      'grammarsFromScriptElements was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info.'\n  );\n}\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\n// Stuff that users should know about\nmain$1.exports = {\n  createNamespace: Namespace.createNamespace,\n  grammar,\n  grammars,\n  grammarFromScriptElement,\n  grammarsFromScriptElements,\n  makeRecipe,\n  ohmGrammar: null, // Initialized below, after Grammar.BuiltInRules.\n  pexprs,\n  util,\n  version,\n};\n\n// Stuff for testing, etc.\nmain$1.exports._buildGrammar = buildGrammar;\n\n// Late initialization for stuff that is bootstrapped.\n\n\nutil.announceBuiltInRules(Grammar.BuiltInRules);\n\nmain$1.exports.ohmGrammar = ohmGrammar = ohmGrammar$1;\nGrammar.initApplicationParser(ohmGrammar, buildGrammar);\n\nvar ohm = main$1.exports;\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst {assert} = common$l;\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nfunction getProp(name, thing, fn) {\n  return fn(thing[name]);\n}\n\nfunction mapProp(name, thing, fn) {\n  return thing[name].map(fn);\n}\n\n// Returns a function that will walk a single property of a node.\n// `descriptor` is a string indicating the property name, optionally ending\n// with '[]' (e.g., 'children[]').\nfunction getPropWalkFn(descriptor) {\n  const parts = descriptor.split(/ ?\\[\\]/);\n  if (parts.length === 2) {\n    return mapProp.bind(null, parts[0]);\n  }\n  return getProp.bind(null, descriptor);\n}\n\nfunction getProps(walkFns, thing, fn) {\n  return walkFns.map(walkFn => walkFn(thing, fn));\n}\n\nfunction getWalkFn(shape) {\n  if (typeof shape === 'string') {\n    return getProps.bind(null, [getPropWalkFn(shape)]);\n  } else if (Array.isArray(shape)) {\n    return getProps.bind(null, shape.map(getPropWalkFn));\n  } else {\n    assert(typeof shape === 'function', 'Expected a string, Array, or function');\n    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);\n    return shape;\n  }\n}\n\nfunction isRestrictedIdentifier(str) {\n  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);\n}\n\nfunction trim(s) {\n  return s.trim();\n}\n\nfunction parseSignature(sig) {\n  const parts = sig.split(/[()]/).map(trim);\n  if (parts.length === 3 && parts[2] === '') {\n    const name = parts[0];\n    let params = [];\n    if (parts[1].length > 0) {\n      params = parts[1].split(',').map(trim);\n    }\n    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {\n      return {name, formals: params};\n    }\n  }\n  throw new Error('Invalid operation signature: ' + sig);\n}\n\n/*\n  A VisitorFamily contains a set of recursive operations that are defined over some kind of\n  tree structure. The `config` parameter specifies how to walk the tree:\n  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)\n  - 'shapes' an object that maps from a tag to a value that describes how to recursively\n    evaluate the operation for nodes of that type. The value can be:\n    * a string indicating the property name that holds that node's only child\n    * an Array of property names (or an empty array indicating a leaf type), or\n    * a function taking two arguments (node, fn), and returning an Array which is the result\n      of apply `fn` to each of the node's children.\n */\nfunction VisitorFamily(config) {\n  this._shapes = config.shapes;\n  this._getTag = config.getTag;\n\n  this.Adapter = function(thing, family) {\n    this._adaptee = thing;\n    this._family = family;\n  };\n  this.Adapter.prototype.valueOf = function() {\n    throw new Error('heeey!');\n  };\n  this.operations = {};\n\n  this._arities = Object.create(null);\n  this._getChildren = Object.create(null);\n\n  Object.keys(this._shapes).forEach(k => {\n    const shape = this._shapes[k];\n    this._getChildren[k] = getWalkFn(shape);\n\n    // A function means the arity isn't fixed, so don't put an entry in the arity map.\n    if (typeof shape !== 'function') {\n      this._arities[k] = Array.isArray(shape) ? shape.length : 1;\n    }\n  });\n  this._wrap = thing => new this.Adapter(thing, this);\n}\n\nVisitorFamily.prototype.wrap = function(thing) {\n  return this._wrap(thing);\n};\n\nVisitorFamily.prototype._checkActionDict = function(dict) {\n  Object.keys(dict).forEach(k => {\n    assert(k in this._getChildren, \"Unrecognized action name '\" + k + \"'\");\n    const action = dict[k];\n    assert(typeof action === 'function', \"Key '\" + k + \"': expected function, got \" + action);\n    if (k in this._arities) {\n      const expected = this._arities[k];\n      const actual = dict[k].length;\n      assert(\n          actual === expected,\n          \"Action '\" + k + \"' has the wrong arity: expected \" + expected + ', got ' + actual\n      );\n    }\n  });\n};\n\nVisitorFamily.prototype.addOperation = function(signature, actions) {\n  const sig = parseSignature(signature);\n  const {name} = sig;\n  this._checkActionDict(actions);\n  this.operations[name] = {\n    name,\n    formals: sig.formals,\n    actions,\n  };\n\n  const family = this;\n  this.Adapter.prototype[name] = function(...args) {\n    const tag = family._getTag(this._adaptee);\n    assert(tag in family._getChildren, \"getTag returned unrecognized tag '\" + tag + \"'\");\n    assert(tag in actions, \"No action for '\" + tag + \"' in operation '\" + name + \"'\");\n\n    // Create an \"arguments object\" from the arguments that were passed to this\n    // operation / attribute.\n    const argsObj = Object.create(null);\n    for (const [i, val] of Object.entries(args)) {\n      argsObj[sig.formals[i]] = val;\n    }\n\n    const oldArgs = this.args;\n    this.args = argsObj;\n    const ans = actions[tag].apply(\n        this,\n        family._getChildren[tag](this._adaptee, family._wrap)\n    );\n    this.args = oldArgs;\n    return ans;\n  };\n  return this;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nvar VisitorFamily_1 = VisitorFamily;\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nconst defaultOperation = {\n  _terminal() {\n    return this.sourceString;\n  },\n\n  _nonterminal(...children) {\n    const {ctorName} = this._node;\n    const {mapping} = this.args;\n\n    // without customization\n    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {\n      // lexical rule\n      if (this.isLexical()) {\n        return this.sourceString;\n      }\n\n      // singular node (e.g. only surrounded by literals or lookaheads)\n      const realChildren = children.filter(child => !child.isTerminal());\n      if (realChildren.length === 1) {\n        return realChildren[0].toAST(mapping);\n      }\n\n      // rest: terms with multiple children\n    }\n\n    // direct forward\n    if (typeof mapping[ctorName] === 'number') {\n      return children[mapping[ctorName]].toAST(mapping);\n    }\n\n    // named/mapped children or unnamed children ('0', '1', '2', ...)\n    const propMap = mapping[ctorName] || children;\n    const node = {\n      type: ctorName,\n    };\n    // eslint-disable-next-line guard-for-in\n    for (const prop in propMap) {\n      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];\n      if (typeof mappedProp === 'number') {\n        // direct forward\n        node[prop] = children[mappedProp].toAST(mapping);\n      } else if (\n        typeof mappedProp === 'string' ||\n        typeof mappedProp === 'boolean' ||\n        mappedProp === null\n      ) {\n        // primitive value\n        node[prop] = mappedProp;\n      } else if (typeof mappedProp === 'object' && mappedProp instanceof Number) {\n        // primitive number (must be unboxed)\n        node[prop] = Number(mappedProp);\n      } else if (typeof mappedProp === 'function') {\n        // computed value\n        node[prop] = mappedProp.call(this, children);\n      } else if (mappedProp === undefined) {\n        if (children[prop] && !children[prop].isTerminal()) {\n          node[prop] = children[prop].toAST(mapping);\n        } else {\n          // delete predefined 'type' properties, like 'type', if explicitely removed\n          delete node[prop];\n        }\n      }\n    }\n    return node;\n  },\n\n  _iter(...children) {\n    if (this._node.isOptional()) {\n      if (this.numChildren === 0) {\n        return null;\n      } else {\n        return children[0].toAST(this.args.mapping);\n      }\n    }\n\n    return children.map(function(child) {\n      return child.toAST(this.args.mapping);\n    }, this);\n  },\n\n  NonemptyListOf(first, sep, rest) {\n    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));\n  },\n\n  EmptyListOf() {\n    return [];\n  },\n};\n\n// Returns a plain JavaScript object that includes an abstract syntax tree (AST)\n// for the given match result `res` containg a concrete syntax tree (CST) and grammar.\n// The optional `mapping` parameter can be used to customize how the nodes of the CST\n// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).\nfunction toAST(res, mapping) {\n  if (typeof res.failed !== 'function' || res.failed()) {\n    throw new Error('toAST() expects a succesful MatchResult as first parameter');\n  }\n\n  mapping = Object.assign({}, mapping);\n  const operation = Object.assign({}, defaultOperation);\n  for (const termName in mapping) {\n    if (typeof mapping[termName] === 'function') {\n      operation[termName] = mapping[termName];\n      delete mapping[termName];\n    }\n  }\n  const g = res._cst.grammar;\n  const s = g.createSemantics().addOperation('toAST(mapping)', operation);\n  return s(res).toAST(mapping);\n}\n\n// Returns a semantics containg the toAST(mapping) operation for the given grammar g.\nfunction semanticsForToAST(g) {\n  if (typeof g.createSemantics !== 'function') {\n    throw new Error('semanticsToAST() expects a Grammar as parameter');\n  }\n\n  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);\n}\n\nvar semanticsToAST = {\n  helper: toAST,\n  semantics: semanticsForToAST,\n};\n\nvar extras = {\n  VisitorFamily: VisitorFamily_1,\n  semanticsForToAST: semanticsToAST.semantics,\n  toAST: semanticsToAST.helper,\n};\n\nexport { ohm as default, extras };\n","'use strict';\n\n// --------------------------------------------------------------------\n// Imports\n// --------------------------------------------------------------------\n\nconst {assert} = require('../src/common');\n\n// --------------------------------------------------------------------\n// Private stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nfunction getProp(name, thing, fn) {\n  return fn(thing[name]);\n}\n\nfunction mapProp(name, thing, fn) {\n  return thing[name].map(fn);\n}\n\n// Returns a function that will walk a single property of a node.\n// `descriptor` is a string indicating the property name, optionally ending\n// with '[]' (e.g., 'children[]').\nfunction getPropWalkFn(descriptor) {\n  const parts = descriptor.split(/ ?\\[\\]/);\n  if (parts.length === 2) {\n    return mapProp.bind(null, parts[0]);\n  }\n  return getProp.bind(null, descriptor);\n}\n\nfunction getProps(walkFns, thing, fn) {\n  return walkFns.map(walkFn => walkFn(thing, fn));\n}\n\nfunction getWalkFn(shape) {\n  if (typeof shape === 'string') {\n    return getProps.bind(null, [getPropWalkFn(shape)]);\n  } else if (Array.isArray(shape)) {\n    return getProps.bind(null, shape.map(getPropWalkFn));\n  } else {\n    assert(typeof shape === 'function', 'Expected a string, Array, or function');\n    assert(shape.length === 2, 'Expected a function of arity 2, got ' + shape.length);\n    return shape;\n  }\n}\n\nfunction isRestrictedIdentifier(str) {\n  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);\n}\n\nfunction trim(s) {\n  return s.trim();\n}\n\nfunction parseSignature(sig) {\n  const parts = sig.split(/[()]/).map(trim);\n  if (parts.length === 3 && parts[2] === '') {\n    const name = parts[0];\n    let params = [];\n    if (parts[1].length > 0) {\n      params = parts[1].split(',').map(trim);\n    }\n    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {\n      return {name, formals: params};\n    }\n  }\n  throw new Error('Invalid operation signature: ' + sig);\n}\n\n/*\n  A VisitorFamily contains a set of recursive operations that are defined over some kind of\n  tree structure. The `config` parameter specifies how to walk the tree:\n  - 'getTag' is function which, given a node in the tree, returns the node's 'tag' (type)\n  - 'shapes' an object that maps from a tag to a value that describes how to recursively\n    evaluate the operation for nodes of that type. The value can be:\n    * a string indicating the property name that holds that node's only child\n    * an Array of property names (or an empty array indicating a leaf type), or\n    * a function taking two arguments (node, fn), and returning an Array which is the result\n      of apply `fn` to each of the node's children.\n */\nfunction VisitorFamily(config) {\n  this._shapes = config.shapes;\n  this._getTag = config.getTag;\n\n  this.Adapter = function(thing, family) {\n    this._adaptee = thing;\n    this._family = family;\n  };\n  this.Adapter.prototype.valueOf = function() {\n    throw new Error('heeey!');\n  };\n  this.operations = {};\n\n  this._arities = Object.create(null);\n  this._getChildren = Object.create(null);\n\n  Object.keys(this._shapes).forEach(k => {\n    const shape = this._shapes[k];\n    this._getChildren[k] = getWalkFn(shape);\n\n    // A function means the arity isn't fixed, so don't put an entry in the arity map.\n    if (typeof shape !== 'function') {\n      this._arities[k] = Array.isArray(shape) ? shape.length : 1;\n    }\n  });\n  this._wrap = thing => new this.Adapter(thing, this);\n}\n\nVisitorFamily.prototype.wrap = function(thing) {\n  return this._wrap(thing);\n};\n\nVisitorFamily.prototype._checkActionDict = function(dict) {\n  Object.keys(dict).forEach(k => {\n    assert(k in this._getChildren, \"Unrecognized action name '\" + k + \"'\");\n    const action = dict[k];\n    assert(typeof action === 'function', \"Key '\" + k + \"': expected function, got \" + action);\n    if (k in this._arities) {\n      const expected = this._arities[k];\n      const actual = dict[k].length;\n      assert(\n          actual === expected,\n          \"Action '\" + k + \"' has the wrong arity: expected \" + expected + ', got ' + actual\n      );\n    }\n  });\n};\n\nVisitorFamily.prototype.addOperation = function(signature, actions) {\n  const sig = parseSignature(signature);\n  const {name} = sig;\n  this._checkActionDict(actions);\n  this.operations[name] = {\n    name,\n    formals: sig.formals,\n    actions,\n  };\n\n  const family = this;\n  this.Adapter.prototype[name] = function(...args) {\n    const tag = family._getTag(this._adaptee);\n    assert(tag in family._getChildren, \"getTag returned unrecognized tag '\" + tag + \"'\");\n    assert(tag in actions, \"No action for '\" + tag + \"' in operation '\" + name + \"'\");\n\n    // Create an \"arguments object\" from the arguments that were passed to this\n    // operation / attribute.\n    const argsObj = Object.create(null);\n    for (const [i, val] of Object.entries(args)) {\n      argsObj[sig.formals[i]] = val;\n    }\n\n    const oldArgs = this.args;\n    this.args = argsObj;\n    const ans = actions[tag].apply(\n        this,\n        family._getChildren[tag](this._adaptee, family._wrap)\n    );\n    this.args = oldArgs;\n    return ans;\n  };\n  return this;\n};\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nmodule.exports = VisitorFamily;\n","'use strict';\n\nmodule.exports = {\n  VisitorFamily: require('./VisitorFamily'),\n  semanticsForToAST: require('./semantics-toAST').semantics,\n  toAST: require('./semantics-toAST').helper,\n};\n","'use strict';\n\n// --------------------------------------------------------------------\n// Operations\n// --------------------------------------------------------------------\n\nconst defaultOperation = {\n  _terminal() {\n    return this.sourceString;\n  },\n\n  _nonterminal(...children) {\n    const {ctorName} = this._node;\n    const {mapping} = this.args;\n\n    // without customization\n    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {\n      // lexical rule\n      if (this.isLexical()) {\n        return this.sourceString;\n      }\n\n      // singular node (e.g. only surrounded by literals or lookaheads)\n      const realChildren = children.filter(child => !child.isTerminal());\n      if (realChildren.length === 1) {\n        return realChildren[0].toAST(mapping);\n      }\n\n      // rest: terms with multiple children\n    }\n\n    // direct forward\n    if (typeof mapping[ctorName] === 'number') {\n      return children[mapping[ctorName]].toAST(mapping);\n    }\n\n    // named/mapped children or unnamed children ('0', '1', '2', ...)\n    const propMap = mapping[ctorName] || children;\n    const node = {\n      type: ctorName,\n    };\n    // eslint-disable-next-line guard-for-in\n    for (const prop in propMap) {\n      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];\n      if (typeof mappedProp === 'number') {\n        // direct forward\n        node[prop] = children[mappedProp].toAST(mapping);\n      } else if (\n        typeof mappedProp === 'string' ||\n        typeof mappedProp === 'boolean' ||\n        mappedProp === null\n      ) {\n        // primitive value\n        node[prop] = mappedProp;\n      } else if (typeof mappedProp === 'object' && mappedProp instanceof Number) {\n        // primitive number (must be unboxed)\n        node[prop] = Number(mappedProp);\n      } else if (typeof mappedProp === 'function') {\n        // computed value\n        node[prop] = mappedProp.call(this, children);\n      } else if (mappedProp === undefined) {\n        if (children[prop] && !children[prop].isTerminal()) {\n          node[prop] = children[prop].toAST(mapping);\n        } else {\n          // delete predefined 'type' properties, like 'type', if explicitely removed\n          delete node[prop];\n        }\n      }\n    }\n    return node;\n  },\n\n  _iter(...children) {\n    if (this._node.isOptional()) {\n      if (this.numChildren === 0) {\n        return null;\n      } else {\n        return children[0].toAST(this.args.mapping);\n      }\n    }\n\n    return children.map(function(child) {\n      return child.toAST(this.args.mapping);\n    }, this);\n  },\n\n  NonemptyListOf(first, sep, rest) {\n    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));\n  },\n\n  EmptyListOf() {\n    return [];\n  },\n};\n\n// Returns a plain JavaScript object that includes an abstract syntax tree (AST)\n// for the given match result `res` containg a concrete syntax tree (CST) and grammar.\n// The optional `mapping` parameter can be used to customize how the nodes of the CST\n// are mapped to the AST (see /doc/extras.md#toastmatchresult-mapping).\nfunction toAST(res, mapping) {\n  if (typeof res.failed !== 'function' || res.failed()) {\n    throw new Error('toAST() expects a succesful MatchResult as first parameter');\n  }\n\n  mapping = Object.assign({}, mapping);\n  const operation = Object.assign({}, defaultOperation);\n  for (const termName in mapping) {\n    if (typeof mapping[termName] === 'function') {\n      operation[termName] = mapping[termName];\n      delete mapping[termName];\n    }\n  }\n  const g = res._cst.grammar;\n  const s = g.createSemantics().addOperation('toAST(mapping)', operation);\n  return s(res).toAST(mapping);\n}\n\n// Returns a semantics containg the toAST(mapping) operation for the given grammar g.\nfunction semanticsForToAST(g) {\n  if (typeof g.createSemantics !== 'function') {\n    throw new Error('semanticsToAST() expects a Grammar as parameter');\n  }\n\n  return g.createSemantics().addOperation('toAST(mapping)', defaultOperation);\n}\n\nmodule.exports = {\n  helper: toAST,\n  semantics: semanticsForToAST,\n};\n","'use strict';\n\n// --------------------------------------------------------------------\n// Private Stuff\n// --------------------------------------------------------------------\n\n// Helpers\n\nconst escapeStringFor = {};\nfor (let c = 0; c < 128; c++) {\n  escapeStringFor[c] = String.fromCharCode(c);\n}\nescapeStringFor[\"'\".charCodeAt(0)] = \"\\\\'\";\nescapeStringFor['\"'.charCodeAt(0)] = '\\\\\"';\nescapeStringFor['\\\\'.charCodeAt(0)] = '\\\\\\\\';\nescapeStringFor['\\b'.charCodeAt(0)] = '\\\\b';\nescapeStringFor['\\f'.charCodeAt(0)] = '\\\\f';\nescapeStringFor['\\n'.charCodeAt(0)] = '\\\\n';\nescapeStringFor['\\r'.charCodeAt(0)] = '\\\\r';\nescapeStringFor['\\t'.charCodeAt(0)] = '\\\\t';\nescapeStringFor['\\u000b'.charCodeAt(0)] = '\\\\v';\n\n// --------------------------------------------------------------------\n// Exports\n// --------------------------------------------------------------------\n\nexports.abstract = function(optMethodName) {\n  const methodName = optMethodName || '';\n  return function() {\n    throw new Error(\n        'this method ' +\n        methodName +\n        ' is abstract! ' +\n        '(it has no implementation in class ' +\n        this.constructor.name +\n        ')'\n    );\n  };\n};\n\nexports.assert = function(cond, message) {\n  if (!cond) {\n    throw new Error(message || 'Assertion failed');\n  }\n};\n\n// Define a lazily-computed, non-enumerable property named `propName`\n// on the object `obj`. `getterFn` will be called to compute the value the\n// first time the property is accessed.\nexports.defineLazyProperty = function(obj, propName, getterFn) {\n  let memo;\n  Object.defineProperty(obj, propName, {\n    get() {\n      if (!memo) {\n        memo = getterFn.call(this);\n      }\n      return memo;\n    },\n  });\n};\n\nexports.clone = function(obj) {\n  if (obj) {\n    return Object.assign({}, obj);\n  }\n  return obj;\n};\n\nexports.repeatFn = function(fn, n) {\n  const arr = [];\n  while (n-- > 0) {\n    arr.push(fn());\n  }\n  return arr;\n};\n\nexports.repeatStr = function(str, n) {\n  return new Array(n + 1).join(str);\n};\n\nexports.repeat = function(x, n) {\n  return exports.repeatFn(() => x, n);\n};\n\nexports.getDuplicates = function(array) {\n  const duplicates = [];\n  for (let idx = 0; idx < array.length; idx++) {\n    const x = array[idx];\n    if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {\n      duplicates.push(x);\n    }\n  }\n  return duplicates;\n};\n\nexports.copyWithoutDuplicates = function(array) {\n  const noDuplicates = [];\n  array.forEach(entry => {\n    if (noDuplicates.indexOf(entry) < 0) {\n      noDuplicates.push(entry);\n    }\n  });\n  return noDuplicates;\n};\n\nexports.isSyntactic = function(ruleName) {\n  const firstChar = ruleName[0];\n  return firstChar === firstChar.toUpperCase();\n};\n\nexports.isLexical = function(ruleName) {\n  return !exports.isSyntactic(ruleName);\n};\n\nexports.padLeft = function(str, len, optChar) {\n  const ch = optChar || ' ';\n  if (str.length < len) {\n    return exports.repeatStr(ch, len - str.length) + str;\n  }\n  return str;\n};\n\n// StringBuffer\n\nexports.StringBuffer = function() {\n  this.strings = [];\n};\n\nexports.StringBuffer.prototype.append = function(str) {\n  this.strings.push(str);\n};\n\nexports.StringBuffer.prototype.contents = function() {\n  return this.strings.join('');\n};\n\nconst escapeUnicode = str => String.fromCodePoint(parseInt(str, 16));\n\nexports.unescapeCodePoint = function(s) {\n  if (s.charAt(0) === '\\\\') {\n    switch (s.charAt(1)) {\n      case 'b':\n        return '\\b';\n      case 'f':\n        return '\\f';\n      case 'n':\n        return '\\n';\n      case 'r':\n        return '\\r';\n      case 't':\n        return '\\t';\n      case 'v':\n        return '\\v';\n      case 'x':\n        return escapeUnicode(s.slice(2, 4));\n      case 'u':\n        return s.charAt(2) === '{' ?\n          escapeUnicode(s.slice(3, -1)) :\n          escapeUnicode(s.slice(2, 6));\n      default:\n        return s.charAt(1);\n    }\n  } else {\n    return s;\n  }\n};\n\n// Helper for producing a description of an unknown object in a safe way.\n// Especially useful for error messages where an unexpected type of object was encountered.\nexports.unexpectedObjToString = function(obj) {\n  if (obj == null) {\n    return String(obj);\n  }\n  const baseToString = Object.prototype.toString.call(obj);\n  try {\n    let typeName;\n    if (obj.constructor && obj.constructor.name) {\n      typeName = obj.constructor.name;\n    } else if (baseToString.indexOf('[object ') === 0) {\n      typeName = baseToString.slice(8, -1); // Extract e.g. \"Array\" from \"[object Array]\".\n    } else {\n      typeName = typeof obj;\n    }\n    return typeName + ': ' + JSON.stringify(String(obj));\n  } catch (e) {\n    return baseToString;\n  }\n};\n","import { AbstractFileSystem, FileTuple, FileStat } from '@shopify/theme-check-common';\nimport { Connection } from 'vscode-languageserver';\nimport { URI } from 'vscode-uri';\n\n/** e.g. `file`, `vscode-vfs`, `github`, `browser` */\nexport type UriScheme = string;\n\n/**\n * An optimization we can use so the Language Server can avoid\n * querying VS Code for information.\n *\n * In the desktop version of the extension, the `file` scheme gets mapped to the\n * NodeFileSystem class.\n *\n * In the browser, this is not available, so the Language Server queries\n * VS Code for the information.\n */\nexport type FileSystems = Record<UriScheme, AbstractFileSystem>;\n\nexport class VsCodeFileSystem implements AbstractFileSystem {\n  constructor(\n    private connection: Connection,\n    private fileSystems: Record<UriScheme, AbstractFileSystem>,\n  ) {}\n\n  readDirectory(uriString: string): Promise<FileTuple[]> {\n    const uri = URI.parse(uriString);\n    const fs = this.fileSystems[uri.scheme];\n    if (fs) return fs.readDirectory(uriString);\n    return this.connection.sendRequest('fs/readDirectory', uriString);\n  }\n\n  readFile(uriString: string): Promise<string> {\n    const uri = URI.parse(uriString);\n    const fs = this.fileSystems[uri.scheme];\n    if (fs) return fs.readFile(uriString);\n    return this.connection.sendRequest('fs/readFile', uriString);\n  }\n\n  stat(uriString: string): Promise<FileStat> {\n    const uri = URI.parse(uriString);\n    const fs = this.fileSystems[uri.scheme];\n    if (fs) return fs.stat(uriString);\n    return this.connection.sendRequest('fs/stat', uriString);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nexport function equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\n        return false;\n    }\n    let i, key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        const oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        const otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexport function isNumber(val) {\n    return typeof val === 'number';\n}\nexport function isDefined(val) {\n    return typeof val !== 'undefined';\n}\nexport function isBoolean(val) {\n    return typeof val === 'boolean';\n}\nexport function isString(val) {\n    return typeof val === 'string';\n}\nexport function isObject(val) {\n    return typeof val === 'object' && val !== null && !Array.isArray(val);\n}\n","/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nexport function startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    for (let i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack, needle) {\n    const diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.lastIndexOf(needle) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nexport function convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nexport function repeat(value, count) {\n    let s = '';\n    while (count > 0) {\n        if ((count & 1) === 1) {\n            s += value;\n        }\n        value += value;\n        count = count >>> 1;\n    }\n    return s;\n}\nexport function extendedRegExp(pattern) {\n    let flags = '';\n    if (startsWith(pattern, '(?i)')) {\n        pattern = pattern.substring(4);\n        flags = 'i';\n    }\n    try {\n        return new RegExp(pattern, flags + 'u');\n    }\n    catch (e) {\n        // could be an exception due to the 'u ' flag\n        try {\n            return new RegExp(pattern, flags);\n        }\n        catch (e) {\n            // invalid pattern\n            return undefined;\n        }\n    }\n}\n// from https://tanishiking.github.io/posts/count-unicode-codepoint/#work-hard-with-for-statements\nexport function stringLength(str) {\n    let count = 0;\n    for (let i = 0; i < str.length; i++) {\n        count++;\n        // obtain the i-th 16-bit\n        const code = str.charCodeAt(i);\n        if (0xD800 <= code && code <= 0xDBFF) {\n            // if the i-th 16bit is an upper surrogate\n            // skip the next 16 bits (lower surrogate)\n            i++;\n        }\n    }\n    return count;\n}\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line, character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri, range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range,\n            color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = { range, message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command, ...args) {\n        let result = { title, command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range, newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = { label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument, edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'create',\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: 'rename',\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: 'delete',\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */\nclass ChangeAnnotations {\n    constructor(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nexport class WorkspaceChange {\n    constructor(workspaceEdit) {\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change) => {\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key) => {\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */\n    get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            }\n            else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            const textDocument = { uri: key.uri, version: key.version };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri, languageId, version, text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText, insert, replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label, documentation } : { label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = { label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        let result = { range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: { uri, range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name, kind, location: { uri, range } }\n            : { name, kind, location: { uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        let result = { diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = { title };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        let result = { range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize, insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range, target, data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range, parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range, text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range, variableName, caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range, expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId, stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        const result = { position, label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var StringValue;\n(function (StringValue) {\n    function createSnippet(value) {\n        return { kind: 'snippet', value };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nexport var InlineCompletionItem;\n(function (InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return { insertText, filterText, range, command };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nexport var InlineCompletionList;\n(function (InlineCompletionList) {\n    function create(items) {\n        return { items };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */\n    InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */\n    InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SelectedCompletionInfo;\n(function (SelectedCompletionInfo) {\n    function create(range, text) {\n        return { range, text };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nexport var InlineCompletionContext;\n(function (InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return { triggerKind, selectedCompletionInfo };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport const EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = (data.length / 2) | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for (let i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function (Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position, DocumentUri, MarkupContent, MarkupKind, Color, ColorInformation, ColorPresentation, FoldingRange, FoldingRangeKind, SelectionRange, Diagnostic, DiagnosticSeverity, CompletionItem, CompletionItemKind, CompletionList, CompletionItemTag, InsertTextFormat, SymbolInformation, SymbolKind, DocumentSymbol, Location, Hover, MarkedString, CodeActionContext, Command, CodeAction, DocumentHighlight, DocumentLink, WorkspaceEdit, TextEdit, CodeActionKind, TextDocumentEdit, VersionedTextDocumentIdentifier, DocumentHighlightKind } from 'vscode-languageserver-types';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nexport { TextDocument, Range, Position, DocumentUri, MarkupContent, MarkupKind, Color, ColorInformation, ColorPresentation, FoldingRange, FoldingRangeKind, SelectionRange, Diagnostic, DiagnosticSeverity, CompletionItem, CompletionItemKind, CompletionList, CompletionItemTag, InsertTextFormat, SymbolInformation, SymbolKind, DocumentSymbol, Location, Hover, MarkedString, CodeActionContext, Command, CodeAction, DocumentHighlight, DocumentLink, WorkspaceEdit, TextEdit, CodeActionKind, TextDocumentEdit, VersionedTextDocumentIdentifier, DocumentHighlightKind };\n/**\n * Error codes used by diagnostics\n */\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"Undefined\"] = 0] = \"Undefined\";\n    ErrorCode[ErrorCode[\"EnumValueMismatch\"] = 1] = \"EnumValueMismatch\";\n    ErrorCode[ErrorCode[\"Deprecated\"] = 2] = \"Deprecated\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfComment\"] = 257] = \"UnexpectedEndOfComment\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfString\"] = 258] = \"UnexpectedEndOfString\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfNumber\"] = 259] = \"UnexpectedEndOfNumber\";\n    ErrorCode[ErrorCode[\"InvalidUnicode\"] = 260] = \"InvalidUnicode\";\n    ErrorCode[ErrorCode[\"InvalidEscapeCharacter\"] = 261] = \"InvalidEscapeCharacter\";\n    ErrorCode[ErrorCode[\"InvalidCharacter\"] = 262] = \"InvalidCharacter\";\n    ErrorCode[ErrorCode[\"PropertyExpected\"] = 513] = \"PropertyExpected\";\n    ErrorCode[ErrorCode[\"CommaExpected\"] = 514] = \"CommaExpected\";\n    ErrorCode[ErrorCode[\"ColonExpected\"] = 515] = \"ColonExpected\";\n    ErrorCode[ErrorCode[\"ValueExpected\"] = 516] = \"ValueExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBacketExpected\"] = 517] = \"CommaOrCloseBacketExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBraceExpected\"] = 518] = \"CommaOrCloseBraceExpected\";\n    ErrorCode[ErrorCode[\"TrailingComma\"] = 519] = \"TrailingComma\";\n    ErrorCode[ErrorCode[\"DuplicateKey\"] = 520] = \"DuplicateKey\";\n    ErrorCode[ErrorCode[\"CommentNotPermitted\"] = 521] = \"CommentNotPermitted\";\n    ErrorCode[ErrorCode[\"PropertyKeysMustBeDoublequoted\"] = 528] = \"PropertyKeysMustBeDoublequoted\";\n    ErrorCode[ErrorCode[\"SchemaResolveError\"] = 768] = \"SchemaResolveError\";\n    ErrorCode[ErrorCode[\"SchemaUnsupportedFeature\"] = 769] = \"SchemaUnsupportedFeature\";\n})(ErrorCode || (ErrorCode = {}));\nexport var SchemaDraft;\n(function (SchemaDraft) {\n    SchemaDraft[SchemaDraft[\"v3\"] = 3] = \"v3\";\n    SchemaDraft[SchemaDraft[\"v4\"] = 4] = \"v4\";\n    SchemaDraft[SchemaDraft[\"v6\"] = 6] = \"v6\";\n    SchemaDraft[SchemaDraft[\"v7\"] = 7] = \"v7\";\n    SchemaDraft[SchemaDraft[\"v2019_09\"] = 19] = \"v2019_09\";\n    SchemaDraft[SchemaDraft[\"v2020_12\"] = 20] = \"v2020_12\";\n})(SchemaDraft || (SchemaDraft = {}));\nexport var ClientCapabilities;\n(function (ClientCapabilities) {\n    ClientCapabilities.LATEST = {\n        textDocument: {\n            completion: {\n                completionItem: {\n                    documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],\n                    commitCharactersSupport: true,\n                    labelDetailsSupport: true\n                }\n            }\n        }\n    };\n})(ClientCapabilities || (ClientCapabilities = {}));\n","// src/browser/reader.ts\nasync function readFileFromUri(uri) {\n  if (uri.protocol === \"http:\" || uri.protocol === \"https:\") {\n    const res = await fetch(uri);\n    return await res.text();\n  }\n  throw new Error(\"Unsupported protocol\");\n}\nfunction readFileFromFsPath(_) {\n  throw new Error(\"Unsupported in browser\");\n}\n\n// src/main.ts\nvar bundle;\nfunction config(config2) {\n  if (\"contents\" in config2) {\n    if (typeof config2.contents === \"string\") {\n      bundle = JSON.parse(config2.contents);\n    } else {\n      bundle = config2.contents;\n    }\n    return;\n  }\n  if (\"fsPath\" in config2) {\n    const fileContent = readFileFromFsPath(config2.fsPath);\n    const content = JSON.parse(fileContent);\n    bundle = isBuiltinExtension(content) ? content.contents.bundle : content;\n    return;\n  }\n  if (config2.uri) {\n    let uri = config2.uri;\n    if (typeof config2.uri === \"string\") {\n      uri = new URL(config2.uri);\n    }\n    return new Promise((resolve, reject) => {\n      readFileFromUri(uri).then((uriContent) => {\n        try {\n          const content = JSON.parse(uriContent);\n          bundle = isBuiltinExtension(content) ? content.contents.bundle : content;\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      }).catch((err) => {\n        reject(err);\n      });\n    });\n  }\n}\nfunction t(...args) {\n  const firstArg = args[0];\n  let key;\n  let message;\n  let formatArgs;\n  if (typeof firstArg === \"string\") {\n    key = firstArg;\n    message = firstArg;\n    args.splice(0, 1);\n    formatArgs = !args || typeof args[0] !== \"object\" ? args : args[0];\n  } else if (firstArg instanceof Array) {\n    const replacements = args.slice(1);\n    if (firstArg.length !== replacements.length + 1) {\n      throw new Error(\"expected a string as the first argument to l10n.t\");\n    }\n    let str = firstArg[0];\n    for (let i = 1; i < firstArg.length; i++) {\n      str += `{${i - 1}}` + firstArg[i];\n    }\n    return t(str, ...replacements);\n  } else {\n    message = firstArg.message;\n    key = message;\n    if (firstArg.comment && firstArg.comment.length > 0) {\n      key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join(\"\") : firstArg.comment}`;\n    }\n    formatArgs = firstArg.args ?? {};\n  }\n  const messageFromBundle = bundle?.[key];\n  if (!messageFromBundle) {\n    return format(message, formatArgs);\n  }\n  if (typeof messageFromBundle === \"string\") {\n    return format(messageFromBundle, formatArgs);\n  }\n  if (messageFromBundle.comment) {\n    return format(messageFromBundle.message, formatArgs);\n  }\n  return format(message, formatArgs);\n}\nvar _format2Regexp = /{([^}]+)}/g;\nfunction format(template, values) {\n  if (Object.keys(values).length === 0) {\n    return template;\n  }\n  return template.replace(_format2Regexp, (match, group) => values[group] ?? match);\n}\nfunction isBuiltinExtension(json) {\n  return !!(typeof json?.contents?.bundle === \"object\" && typeof json?.version === \"string\");\n}\nexport {\n  config,\n  t\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Json from 'jsonc-parser';\nimport { isNumber, equals, isBoolean, isString, isDefined, isObject } from '../utils/objects';\nimport { extendedRegExp, stringLength } from '../utils/strings';\nimport { ErrorCode, Diagnostic, DiagnosticSeverity, Range, SchemaDraft } from '../jsonLanguageTypes';\nimport * as l10n from '@vscode/l10n';\nconst formats = {\n    'color-hex': { errorMessage: l10n.t('Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },\n    'date-time': { errorMessage: l10n.t('String is not a RFC3339 date-time.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'date': { errorMessage: l10n.t('String is not a RFC3339 date.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },\n    'time': { errorMessage: l10n.t('String is not a RFC3339 time.'), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'email': { errorMessage: l10n.t('String is not an e-mail address.'), pattern: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}))$/ },\n    'hostname': { errorMessage: l10n.t('String is not a hostname.'), pattern: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i },\n    'ipv4': { errorMessage: l10n.t('String is not an IPv4 address.'), pattern: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/ },\n    'ipv6': { errorMessage: l10n.t('String is not an IPv6 address.'), pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i },\n};\nexport class ASTNodeImpl {\n    constructor(parent, offset, length = 0) {\n        this.offset = offset;\n        this.length = length;\n        this.parent = parent;\n    }\n    get children() {\n        return [];\n    }\n    toString() {\n        return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');\n    }\n}\nexport class NullASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset) {\n        super(parent, offset);\n        this.type = 'null';\n        this.value = null;\n    }\n}\nexport class BooleanASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, boolValue, offset) {\n        super(parent, offset);\n        this.type = 'boolean';\n        this.value = boolValue;\n    }\n}\nexport class ArrayASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset) {\n        super(parent, offset);\n        this.type = 'array';\n        this.items = [];\n    }\n    get children() {\n        return this.items;\n    }\n}\nexport class NumberASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset) {\n        super(parent, offset);\n        this.type = 'number';\n        this.isInteger = true;\n        this.value = Number.NaN;\n    }\n}\nexport class StringASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset, length) {\n        super(parent, offset, length);\n        this.type = 'string';\n        this.value = '';\n    }\n}\nexport class PropertyASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset, keyNode) {\n        super(parent, offset);\n        this.type = 'property';\n        this.colonOffset = -1;\n        this.keyNode = keyNode;\n    }\n    get children() {\n        return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n    }\n}\nexport class ObjectASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, offset) {\n        super(parent, offset);\n        this.type = 'object';\n        this.properties = [];\n    }\n    get children() {\n        return this.properties;\n    }\n}\nexport function asSchema(schema) {\n    if (isBoolean(schema)) {\n        return schema ? {} : { \"not\": {} };\n    }\n    return schema;\n}\nexport var EnumMatch;\n(function (EnumMatch) {\n    EnumMatch[EnumMatch[\"Key\"] = 0] = \"Key\";\n    EnumMatch[EnumMatch[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch || (EnumMatch = {}));\nconst schemaDraftFromId = {\n    'http://json-schema.org/draft-03/schema#': SchemaDraft.v3,\n    'http://json-schema.org/draft-04/schema#': SchemaDraft.v4,\n    'http://json-schema.org/draft-06/schema#': SchemaDraft.v6,\n    'http://json-schema.org/draft-07/schema#': SchemaDraft.v7,\n    'https://json-schema.org/draft/2019-09/schema': SchemaDraft.v2019_09,\n    'https://json-schema.org/draft/2020-12/schema': SchemaDraft.v2020_12\n};\nclass EvaluationContext {\n    constructor(schemaDraft) {\n        this.schemaDraft = schemaDraft;\n    }\n}\nclass SchemaCollector {\n    constructor(focusOffset = -1, exclude) {\n        this.focusOffset = focusOffset;\n        this.exclude = exclude;\n        this.schemas = [];\n    }\n    add(schema) {\n        this.schemas.push(schema);\n    }\n    merge(other) {\n        Array.prototype.push.apply(this.schemas, other.schemas);\n    }\n    include(node) {\n        return (this.focusOffset === -1 || contains(node, this.focusOffset)) && (node !== this.exclude);\n    }\n    newSub() {\n        return new SchemaCollector(-1, this.exclude);\n    }\n}\nclass NoOpSchemaCollector {\n    constructor() { }\n    get schemas() { return []; }\n    add(_schema) { }\n    merge(_other) { }\n    include(_node) { return true; }\n    newSub() { return this; }\n}\nNoOpSchemaCollector.instance = new NoOpSchemaCollector();\nexport class ValidationResult {\n    constructor() {\n        this.problems = [];\n        this.propertiesMatches = 0;\n        this.processedProperties = new Set();\n        this.propertiesValueMatches = 0;\n        this.primaryValueMatches = 0;\n        this.enumValueMatch = false;\n        this.enumValues = undefined;\n    }\n    hasProblems() {\n        return !!this.problems.length;\n    }\n    merge(validationResult) {\n        this.problems = this.problems.concat(validationResult.problems);\n        this.propertiesMatches += validationResult.propertiesMatches;\n        this.propertiesValueMatches += validationResult.propertiesValueMatches;\n        this.mergeProcessedProperties(validationResult);\n    }\n    mergeEnumValues(validationResult) {\n        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\n            this.enumValues = this.enumValues.concat(validationResult.enumValues);\n            for (const error of this.problems) {\n                if (error.code === ErrorCode.EnumValueMismatch) {\n                    error.message = l10n.t('Value is not accepted. Valid values: {0}.', this.enumValues.map(v => JSON.stringify(v)).join(', '));\n                }\n            }\n        }\n    }\n    mergePropertyMatch(propertyValidationResult) {\n        this.problems = this.problems.concat(propertyValidationResult.problems);\n        this.propertiesMatches++;\n        if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {\n            this.propertiesValueMatches++;\n        }\n        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {\n            this.primaryValueMatches++;\n        }\n    }\n    mergeProcessedProperties(validationResult) {\n        validationResult.processedProperties.forEach(p => this.processedProperties.add(p));\n    }\n    compare(other) {\n        const hasProblems = this.hasProblems();\n        if (hasProblems !== other.hasProblems()) {\n            return hasProblems ? -1 : 1;\n        }\n        if (this.enumValueMatch !== other.enumValueMatch) {\n            return other.enumValueMatch ? -1 : 1;\n        }\n        if (this.primaryValueMatches !== other.primaryValueMatches) {\n            return this.primaryValueMatches - other.primaryValueMatches;\n        }\n        if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n            return this.propertiesValueMatches - other.propertiesValueMatches;\n        }\n        return this.propertiesMatches - other.propertiesMatches;\n    }\n}\nexport function newJSONDocument(root, diagnostics = []) {\n    return new JSONDocument(root, diagnostics, []);\n}\nexport function getNodeValue(node) {\n    return Json.getNodeValue(node);\n}\nexport function getNodePath(node) {\n    return Json.getNodePath(node);\n}\nexport function contains(node, offset, includeRightBound = false) {\n    return offset >= node.offset && offset < (node.offset + node.length) || includeRightBound && offset === (node.offset + node.length);\n}\nexport class JSONDocument {\n    constructor(root, syntaxErrors = [], comments = []) {\n        this.root = root;\n        this.syntaxErrors = syntaxErrors;\n        this.comments = comments;\n    }\n    getNodeFromOffset(offset, includeRightBound = false) {\n        if (this.root) {\n            return Json.findNodeAtOffset(this.root, offset, includeRightBound);\n        }\n        return undefined;\n    }\n    visit(visitor) {\n        if (this.root) {\n            const doVisit = (node) => {\n                let ctn = visitor(node);\n                const children = node.children;\n                if (Array.isArray(children)) {\n                    for (let i = 0; i < children.length && ctn; i++) {\n                        ctn = doVisit(children[i]);\n                    }\n                }\n                return ctn;\n            };\n            doVisit(this.root);\n        }\n    }\n    validate(textDocument, schema, severity = DiagnosticSeverity.Warning, schemaDraft) {\n        if (this.root && schema) {\n            const validationResult = new ValidationResult();\n            validate(this.root, schema, validationResult, NoOpSchemaCollector.instance, new EvaluationContext(schemaDraft ?? getSchemaDraft(schema)));\n            return validationResult.problems.map(p => {\n                const range = Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n                return Diagnostic.create(range, p.message, p.severity ?? severity, p.code);\n            });\n        }\n        return undefined;\n    }\n    getMatchingSchemas(schema, focusOffset = -1, exclude) {\n        if (this.root && schema) {\n            const matchingSchemas = new SchemaCollector(focusOffset, exclude);\n            const schemaDraft = getSchemaDraft(schema);\n            const context = new EvaluationContext(schemaDraft);\n            validate(this.root, schema, new ValidationResult(), matchingSchemas, context);\n            return matchingSchemas.schemas;\n        }\n        return [];\n    }\n}\nfunction getSchemaDraft(schema, fallBack = SchemaDraft.v2020_12) {\n    let schemaId = schema.$schema;\n    if (schemaId) {\n        return schemaDraftFromId[schemaId] ?? fallBack;\n    }\n    return fallBack;\n}\nfunction validate(n, schema, validationResult, matchingSchemas, context) {\n    if (!n || !matchingSchemas.include(n)) {\n        return;\n    }\n    if (n.type === 'property') {\n        return validate(n.valueNode, schema, validationResult, matchingSchemas, context);\n    }\n    const node = n;\n    _validateNode();\n    switch (node.type) {\n        case 'object':\n            _validateObjectNode(node);\n            break;\n        case 'array':\n            _validateArrayNode(node);\n            break;\n        case 'string':\n            _validateStringNode(node);\n            break;\n        case 'number':\n            _validateNumberNode(node);\n            break;\n    }\n    matchingSchemas.add({ node: node, schema: schema });\n    function _validateNode() {\n        function matchesType(type) {\n            return node.type === type || (type === 'integer' && node.type === 'number' && node.isInteger);\n        }\n        if (Array.isArray(schema.type)) {\n            if (!schema.type.some(matchesType)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || l10n.t('Incorrect type. Expected one of {0}.', schema.type.join(', '))\n                });\n            }\n        }\n        else if (schema.type) {\n            if (!matchesType(schema.type)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || l10n.t('Incorrect type. Expected \"{0}\".', schema.type)\n                });\n            }\n        }\n        if (Array.isArray(schema.allOf)) {\n            for (const subSchemaRef of schema.allOf) {\n                const subValidationResult = new ValidationResult();\n                const subMatchingSchemas = matchingSchemas.newSub();\n                validate(node, asSchema(subSchemaRef), subValidationResult, subMatchingSchemas, context);\n                validationResult.merge(subValidationResult);\n                matchingSchemas.merge(subMatchingSchemas);\n            }\n        }\n        const notSchema = asSchema(schema.not);\n        if (notSchema) {\n            const subValidationResult = new ValidationResult();\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, notSchema, subValidationResult, subMatchingSchemas, context);\n            if (!subValidationResult.hasProblems()) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || l10n.t(\"Matches a schema that is not allowed.\")\n                });\n            }\n            for (const ms of subMatchingSchemas.schemas) {\n                ms.inverted = !ms.inverted;\n                matchingSchemas.add(ms);\n            }\n        }\n        const testAlternatives = (alternatives, maxOneMatch) => {\n            const matches = [];\n            // remember the best match that is used for error messages\n            let bestMatch = undefined;\n            for (const subSchemaRef of alternatives) {\n                const subSchema = asSchema(subSchemaRef);\n                const subValidationResult = new ValidationResult();\n                const subMatchingSchemas = matchingSchemas.newSub();\n                validate(node, subSchema, subValidationResult, subMatchingSchemas, context);\n                if (!subValidationResult.hasProblems()) {\n                    matches.push(subSchema);\n                }\n                if (!bestMatch) {\n                    bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                }\n                else {\n                    if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {\n                        // no errors, both are equally good matches\n                        bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                        bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n                        bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n                        bestMatch.validationResult.mergeProcessedProperties(subValidationResult);\n                    }\n                    else {\n                        const compareResult = subValidationResult.compare(bestMatch.validationResult);\n                        if (compareResult > 0) {\n                            // our node is the best matching so far\n                            bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                        }\n                        else if (compareResult === 0) {\n                            // there's already a best matching but we are as good\n                            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                            bestMatch.validationResult.mergeEnumValues(subValidationResult);\n                        }\n                    }\n                }\n            }\n            if (matches.length > 1 && maxOneMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: 1 },\n                    message: l10n.t(\"Matches multiple schemas when only one must validate.\")\n                });\n            }\n            if (bestMatch) {\n                validationResult.merge(bestMatch.validationResult);\n                matchingSchemas.merge(bestMatch.matchingSchemas);\n            }\n            return matches.length;\n        };\n        if (Array.isArray(schema.anyOf)) {\n            testAlternatives(schema.anyOf, false);\n        }\n        if (Array.isArray(schema.oneOf)) {\n            testAlternatives(schema.oneOf, true);\n        }\n        const testBranch = (schema) => {\n            const subValidationResult = new ValidationResult();\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, asSchema(schema), subValidationResult, subMatchingSchemas, context);\n            validationResult.merge(subValidationResult);\n            matchingSchemas.merge(subMatchingSchemas);\n        };\n        const testCondition = (ifSchema, thenSchema, elseSchema) => {\n            const subSchema = asSchema(ifSchema);\n            const subValidationResult = new ValidationResult();\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, subSchema, subValidationResult, subMatchingSchemas, context);\n            matchingSchemas.merge(subMatchingSchemas);\n            validationResult.mergeProcessedProperties(subValidationResult);\n            if (!subValidationResult.hasProblems()) {\n                if (thenSchema) {\n                    testBranch(thenSchema);\n                }\n            }\n            else if (elseSchema) {\n                testBranch(elseSchema);\n            }\n        };\n        const ifSchema = asSchema(schema.if);\n        if (ifSchema) {\n            testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));\n        }\n        if (Array.isArray(schema.enum)) {\n            const val = getNodeValue(node);\n            let enumValueMatch = false;\n            for (const e of schema.enum) {\n                if (equals(val, e)) {\n                    enumValueMatch = true;\n                    break;\n                }\n            }\n            validationResult.enumValues = schema.enum;\n            validationResult.enumValueMatch = enumValueMatch;\n            if (!enumValueMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || l10n.t('Value is not accepted. Valid values: {0}.', schema.enum.map(v => JSON.stringify(v)).join(', '))\n                });\n            }\n        }\n        if (isDefined(schema.const)) {\n            const val = getNodeValue(node);\n            if (!equals(val, schema.const)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || l10n.t('Value must be {0}.', JSON.stringify(schema.const))\n                });\n                validationResult.enumValueMatch = false;\n            }\n            else {\n                validationResult.enumValueMatch = true;\n            }\n            validationResult.enumValues = [schema.const];\n        }\n        let deprecationMessage = schema.deprecationMessage;\n        if (deprecationMessage || schema.deprecated) {\n            deprecationMessage = deprecationMessage || l10n.t('Value is deprecated');\n            let targetNode = node.parent?.type === 'property' ? node.parent : node;\n            validationResult.problems.push({\n                location: { offset: targetNode.offset, length: targetNode.length },\n                severity: DiagnosticSeverity.Warning,\n                message: deprecationMessage,\n                code: ErrorCode.Deprecated\n            });\n        }\n    }\n    function _validateNumberNode(node) {\n        const val = node.value;\n        function normalizeFloats(float) {\n            const parts = /^(-?\\d+)(?:\\.(\\d+))?(?:e([-+]\\d+))?$/.exec(float.toString());\n            return parts && {\n                value: Number(parts[1] + (parts[2] || '')),\n                multiplier: (parts[2]?.length || 0) - (parseInt(parts[3]) || 0)\n            };\n        }\n        ;\n        if (isNumber(schema.multipleOf)) {\n            let remainder = -1;\n            if (Number.isInteger(schema.multipleOf)) {\n                remainder = val % schema.multipleOf;\n            }\n            else {\n                let normMultipleOf = normalizeFloats(schema.multipleOf);\n                let normValue = normalizeFloats(val);\n                if (normMultipleOf && normValue) {\n                    const multiplier = 10 ** Math.abs(normValue.multiplier - normMultipleOf.multiplier);\n                    if (normValue.multiplier < normMultipleOf.multiplier) {\n                        normValue.value *= multiplier;\n                    }\n                    else {\n                        normMultipleOf.value *= multiplier;\n                    }\n                    remainder = normValue.value % normMultipleOf.value;\n                }\n            }\n            if (remainder !== 0) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Value is not divisible by {0}.', schema.multipleOf)\n                });\n            }\n        }\n        function getExclusiveLimit(limit, exclusive) {\n            if (isNumber(exclusive)) {\n                return exclusive;\n            }\n            if (isBoolean(exclusive) && exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        function getLimit(limit, exclusive) {\n            if (!isBoolean(exclusive) || !exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\n        if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Value is below the exclusive minimum of {0}.', exclusiveMinimum)\n            });\n        }\n        const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\n        if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Value is above the exclusive maximum of {0}.', exclusiveMaximum)\n            });\n        }\n        const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\n        if (isNumber(minimum) && val < minimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Value is below the minimum of {0}.', minimum)\n            });\n        }\n        const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\n        if (isNumber(maximum) && val > maximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Value is above the maximum of {0}.', maximum)\n            });\n        }\n    }\n    function _validateStringNode(node) {\n        if (isNumber(schema.minLength) && stringLength(node.value) < schema.minLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('String is shorter than the minimum length of {0}.', schema.minLength)\n            });\n        }\n        if (isNumber(schema.maxLength) && stringLength(node.value) > schema.maxLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('String is longer than the maximum length of {0}.', schema.maxLength)\n            });\n        }\n        if (isString(schema.pattern)) {\n            const regex = extendedRegExp(schema.pattern);\n            if (!(regex?.test(node.value))) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.patternErrorMessage || schema.errorMessage || l10n.t('String does not match the pattern of \"{0}\".', schema.pattern)\n                });\n            }\n        }\n        if (schema.format) {\n            switch (schema.format) {\n                case 'uri':\n                case 'uri-reference':\n                    {\n                        let errorMessage;\n                        if (!node.value) {\n                            errorMessage = l10n.t('URI expected.');\n                        }\n                        else {\n                            const match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node.value);\n                            if (!match) {\n                                errorMessage = l10n.t('URI is expected.');\n                            }\n                            else if (!match[2] && schema.format === 'uri') {\n                                errorMessage = l10n.t('URI with a scheme is expected.');\n                            }\n                        }\n                        if (errorMessage) {\n                            validationResult.problems.push({\n                                location: { offset: node.offset, length: node.length },\n                                message: schema.patternErrorMessage || schema.errorMessage || l10n.t('String is not a URI: {0}', errorMessage)\n                            });\n                        }\n                    }\n                    break;\n                case 'color-hex':\n                case 'date-time':\n                case 'date':\n                case 'time':\n                case 'email':\n                case 'hostname':\n                case 'ipv4':\n                case 'ipv6':\n                    const format = formats[schema.format];\n                    if (!node.value || !format.pattern.exec(node.value)) {\n                        validationResult.problems.push({\n                            location: { offset: node.offset, length: node.length },\n                            message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage\n                        });\n                    }\n                default:\n            }\n        }\n    }\n    function _validateArrayNode(node) {\n        let prefixItemsSchemas;\n        let additionalItemSchema;\n        if (context.schemaDraft >= SchemaDraft.v2020_12) {\n            prefixItemsSchemas = schema.prefixItems;\n            additionalItemSchema = !Array.isArray(schema.items) ? schema.items : undefined;\n        }\n        else {\n            prefixItemsSchemas = Array.isArray(schema.items) ? schema.items : undefined;\n            additionalItemSchema = !Array.isArray(schema.items) ? schema.items : schema.additionalItems;\n        }\n        let index = 0;\n        if (prefixItemsSchemas !== undefined) {\n            const max = Math.min(prefixItemsSchemas.length, node.items.length);\n            for (; index < max; index++) {\n                const subSchemaRef = prefixItemsSchemas[index];\n                const subSchema = asSchema(subSchemaRef);\n                const itemValidationResult = new ValidationResult();\n                const item = node.items[index];\n                if (item) {\n                    validate(item, subSchema, itemValidationResult, matchingSchemas, context);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                }\n                validationResult.processedProperties.add(String(index));\n            }\n        }\n        if (additionalItemSchema !== undefined && index < node.items.length) {\n            if (typeof additionalItemSchema === 'boolean') {\n                if (additionalItemSchema === false) {\n                    validationResult.problems.push({\n                        location: { offset: node.offset, length: node.length },\n                        message: l10n.t('Array has too many items according to schema. Expected {0} or fewer.', index)\n                    });\n                }\n                for (; index < node.items.length; index++) {\n                    validationResult.processedProperties.add(String(index));\n                    validationResult.propertiesValueMatches++;\n                }\n            }\n            else {\n                for (; index < node.items.length; index++) {\n                    const itemValidationResult = new ValidationResult();\n                    validate(node.items[index], additionalItemSchema, itemValidationResult, matchingSchemas, context);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                    validationResult.processedProperties.add(String(index));\n                }\n            }\n        }\n        const containsSchema = asSchema(schema.contains);\n        if (containsSchema) {\n            let containsCount = 0;\n            for (let index = 0; index < node.items.length; index++) {\n                const item = node.items[index];\n                const itemValidationResult = new ValidationResult();\n                validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance, context);\n                if (!itemValidationResult.hasProblems()) {\n                    containsCount++;\n                    if (context.schemaDraft >= SchemaDraft.v2020_12) {\n                        validationResult.processedProperties.add(String(index));\n                    }\n                }\n            }\n            if (containsCount === 0 && !isNumber(schema.minContains)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || l10n.t('Array does not contain required item.')\n                });\n            }\n            if (isNumber(schema.minContains) && containsCount < schema.minContains) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Array has too few items that match the contains contraint. Expected {0} or more.', schema.minContains)\n                });\n            }\n            if (isNumber(schema.maxContains) && containsCount > schema.maxContains) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Array has too many items that match the contains contraint. Expected {0} or less.', schema.maxContains)\n                });\n            }\n        }\n        const unevaluatedItems = schema.unevaluatedItems;\n        if (unevaluatedItems !== undefined) {\n            for (let i = 0; i < node.items.length; i++) {\n                if (!validationResult.processedProperties.has(String(i))) {\n                    if (unevaluatedItems === false) {\n                        validationResult.problems.push({\n                            location: { offset: node.offset, length: node.length },\n                            message: l10n.t('Item does not match any validation rule from the array.')\n                        });\n                    }\n                    else {\n                        const itemValidationResult = new ValidationResult();\n                        validate(node.items[i], schema.unevaluatedItems, itemValidationResult, matchingSchemas, context);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                    }\n                }\n                validationResult.processedProperties.add(String(i));\n                validationResult.propertiesValueMatches++;\n            }\n        }\n        if (isNumber(schema.minItems) && node.items.length < schema.minItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Array has too few items. Expected {0} or more.', schema.minItems)\n            });\n        }\n        if (isNumber(schema.maxItems) && node.items.length > schema.maxItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: l10n.t('Array has too many items. Expected {0} or fewer.', schema.maxItems)\n            });\n        }\n        if (schema.uniqueItems === true) {\n            const values = getNodeValue(node);\n            function hasDuplicates() {\n                for (let i = 0; i < values.length - 1; i++) {\n                    const value = values[i];\n                    for (let j = i + 1; j < values.length; j++) {\n                        if (equals(value, values[j])) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            if (hasDuplicates()) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Array has duplicate items.')\n                });\n            }\n        }\n    }\n    function _validateObjectNode(node) {\n        const seenKeys = Object.create(null);\n        const unprocessedProperties = new Set();\n        for (const propertyNode of node.properties) {\n            const key = propertyNode.keyNode.value;\n            seenKeys[key] = propertyNode.valueNode;\n            unprocessedProperties.add(key);\n        }\n        if (Array.isArray(schema.required)) {\n            for (const propertyName of schema.required) {\n                if (!seenKeys[propertyName]) {\n                    const keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;\n                    const location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node.offset, length: 1 };\n                    validationResult.problems.push({\n                        location: location,\n                        message: l10n.t('Missing property \"{0}\".', propertyName)\n                    });\n                }\n            }\n        }\n        const propertyProcessed = (prop) => {\n            unprocessedProperties.delete(prop);\n            validationResult.processedProperties.add(prop);\n        };\n        if (schema.properties) {\n            for (const propertyName of Object.keys(schema.properties)) {\n                propertyProcessed(propertyName);\n                const propertySchema = schema.properties[propertyName];\n                const child = seenKeys[propertyName];\n                if (child) {\n                    if (isBoolean(propertySchema)) {\n                        if (!propertySchema) {\n                            const propertyNode = child.parent;\n                            validationResult.problems.push({\n                                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                message: schema.errorMessage || l10n.t('Property {0} is not allowed.', propertyName)\n                            });\n                        }\n                        else {\n                            validationResult.propertiesMatches++;\n                            validationResult.propertiesValueMatches++;\n                        }\n                    }\n                    else {\n                        const propertyValidationResult = new ValidationResult();\n                        validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);\n                        validationResult.mergePropertyMatch(propertyValidationResult);\n                    }\n                }\n            }\n        }\n        if (schema.patternProperties) {\n            for (const propertyPattern of Object.keys(schema.patternProperties)) {\n                const regex = extendedRegExp(propertyPattern);\n                if (regex) {\n                    const processed = [];\n                    for (const propertyName of unprocessedProperties) {\n                        if (regex.test(propertyName)) {\n                            processed.push(propertyName);\n                            const child = seenKeys[propertyName];\n                            if (child) {\n                                const propertySchema = schema.patternProperties[propertyPattern];\n                                if (isBoolean(propertySchema)) {\n                                    if (!propertySchema) {\n                                        const propertyNode = child.parent;\n                                        validationResult.problems.push({\n                                            location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                            message: schema.errorMessage || l10n.t('Property {0} is not allowed.', propertyName)\n                                        });\n                                    }\n                                    else {\n                                        validationResult.propertiesMatches++;\n                                        validationResult.propertiesValueMatches++;\n                                    }\n                                }\n                                else {\n                                    const propertyValidationResult = new ValidationResult();\n                                    validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);\n                                    validationResult.mergePropertyMatch(propertyValidationResult);\n                                }\n                            }\n                        }\n                    }\n                    processed.forEach(propertyProcessed);\n                }\n            }\n        }\n        const additionalProperties = schema.additionalProperties;\n        if (additionalProperties !== undefined) {\n            for (const propertyName of unprocessedProperties) {\n                propertyProcessed(propertyName);\n                const child = seenKeys[propertyName];\n                if (child) {\n                    if (additionalProperties === false) {\n                        const propertyNode = child.parent;\n                        validationResult.problems.push({\n                            location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                            message: schema.errorMessage || l10n.t('Property {0} is not allowed.', propertyName)\n                        });\n                    }\n                    else if (additionalProperties !== true) {\n                        const propertyValidationResult = new ValidationResult();\n                        validate(child, additionalProperties, propertyValidationResult, matchingSchemas, context);\n                        validationResult.mergePropertyMatch(propertyValidationResult);\n                    }\n                }\n            }\n        }\n        const unevaluatedProperties = schema.unevaluatedProperties;\n        if (unevaluatedProperties !== undefined) {\n            const processed = [];\n            for (const propertyName of unprocessedProperties) {\n                if (!validationResult.processedProperties.has(propertyName)) {\n                    processed.push(propertyName);\n                    const child = seenKeys[propertyName];\n                    if (child) {\n                        if (unevaluatedProperties === false) {\n                            const propertyNode = child.parent;\n                            validationResult.problems.push({\n                                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                message: schema.errorMessage || l10n.t('Property {0} is not allowed.', propertyName)\n                            });\n                        }\n                        else if (unevaluatedProperties !== true) {\n                            const propertyValidationResult = new ValidationResult();\n                            validate(child, unevaluatedProperties, propertyValidationResult, matchingSchemas, context);\n                            validationResult.mergePropertyMatch(propertyValidationResult);\n                        }\n                    }\n                }\n            }\n            processed.forEach(propertyProcessed);\n        }\n        if (isNumber(schema.maxProperties)) {\n            if (node.properties.length > schema.maxProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Object has more properties than limit of {0}.', schema.maxProperties)\n                });\n            }\n        }\n        if (isNumber(schema.minProperties)) {\n            if (node.properties.length < schema.minProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: l10n.t('Object has fewer properties than the required number of {0}', schema.minProperties)\n                });\n            }\n        }\n        if (schema.dependentRequired) {\n            for (const key in schema.dependentRequired) {\n                const prop = seenKeys[key];\n                const propertyDeps = schema.dependentRequired[key];\n                if (prop && Array.isArray(propertyDeps)) {\n                    _validatePropertyDependencies(key, propertyDeps);\n                }\n            }\n        }\n        if (schema.dependentSchemas) {\n            for (const key in schema.dependentSchemas) {\n                const prop = seenKeys[key];\n                const propertyDeps = schema.dependentSchemas[key];\n                if (prop && isObject(propertyDeps)) {\n                    _validatePropertyDependencies(key, propertyDeps);\n                }\n            }\n        }\n        if (schema.dependencies) {\n            for (const key in schema.dependencies) {\n                const prop = seenKeys[key];\n                if (prop) {\n                    _validatePropertyDependencies(key, schema.dependencies[key]);\n                }\n            }\n        }\n        const propertyNames = asSchema(schema.propertyNames);\n        if (propertyNames) {\n            for (const f of node.properties) {\n                const key = f.keyNode;\n                if (key) {\n                    validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance, context);\n                }\n            }\n        }\n        function _validatePropertyDependencies(key, propertyDep) {\n            if (Array.isArray(propertyDep)) {\n                for (const requiredProp of propertyDep) {\n                    if (!seenKeys[requiredProp]) {\n                        validationResult.problems.push({\n                            location: { offset: node.offset, length: node.length },\n                            message: l10n.t('Object is missing property {0} required by property {1}.', requiredProp, key)\n                        });\n                    }\n                    else {\n                        validationResult.propertiesValueMatches++;\n                    }\n                }\n            }\n            else {\n                const propertySchema = asSchema(propertyDep);\n                if (propertySchema) {\n                    const propertyValidationResult = new ValidationResult();\n                    validate(node, propertySchema, propertyValidationResult, matchingSchemas, context);\n                    validationResult.mergePropertyMatch(propertyValidationResult);\n                }\n            }\n        }\n    }\n}\nexport function parse(textDocument, config) {\n    const problems = [];\n    let lastProblemOffset = -1;\n    const text = textDocument.getText();\n    const scanner = Json.createScanner(text, false);\n    const commentRanges = config && config.collectComments ? [] : undefined;\n    function _scanNext() {\n        while (true) {\n            const token = scanner.scan();\n            _checkScanError();\n            switch (token) {\n                case 12 /* Json.SyntaxKind.LineCommentTrivia */:\n                case 13 /* Json.SyntaxKind.BlockCommentTrivia */:\n                    if (Array.isArray(commentRanges)) {\n                        commentRanges.push(Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\n                    }\n                    break;\n                case 15 /* Json.SyntaxKind.Trivia */:\n                case 14 /* Json.SyntaxKind.LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function _accept(token) {\n        if (scanner.getToken() === token) {\n            _scanNext();\n            return true;\n        }\n        return false;\n    }\n    function _errorAtRange(message, code, startOffset, endOffset, severity = DiagnosticSeverity.Error) {\n        if (problems.length === 0 || startOffset !== lastProblemOffset) {\n            const range = Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\n            problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\n            lastProblemOffset = startOffset;\n        }\n    }\n    function _error(message, code, node = undefined, skipUntilAfter = [], skipUntil = []) {\n        let start = scanner.getTokenOffset();\n        let end = scanner.getTokenOffset() + scanner.getTokenLength();\n        if (start === end && start > 0) {\n            start--;\n            while (start > 0 && /\\s/.test(text.charAt(start))) {\n                start--;\n            }\n            end = start + 1;\n        }\n        _errorAtRange(message, code, start, end);\n        if (node) {\n            _finalize(node, false);\n        }\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            let token = scanner.getToken();\n            while (token !== 17 /* Json.SyntaxKind.EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    _scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = _scanNext();\n            }\n        }\n        return node;\n    }\n    function _checkScanError() {\n        switch (scanner.getTokenError()) {\n            case 4 /* Json.ScanError.InvalidUnicode */:\n                _error(l10n.t('Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);\n                return true;\n            case 5 /* Json.ScanError.InvalidEscapeCharacter */:\n                _error(l10n.t('Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);\n                return true;\n            case 3 /* Json.ScanError.UnexpectedEndOfNumber */:\n                _error(l10n.t('Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);\n                return true;\n            case 1 /* Json.ScanError.UnexpectedEndOfComment */:\n                _error(l10n.t('Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);\n                return true;\n            case 2 /* Json.ScanError.UnexpectedEndOfString */:\n                _error(l10n.t('Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);\n                return true;\n            case 6 /* Json.ScanError.InvalidCharacter */:\n                _error(l10n.t('Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);\n                return true;\n        }\n        return false;\n    }\n    function _finalize(node, scanNext) {\n        node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\n        if (scanNext) {\n            _scanNext();\n        }\n        return node;\n    }\n    function _parseArray(parent) {\n        if (scanner.getToken() !== 3 /* Json.SyntaxKind.OpenBracketToken */) {\n            return undefined;\n        }\n        const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\n        _scanNext(); // consume OpenBracketToken\n        const count = 0;\n        let needsComma = false;\n        while (scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */ && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */) {\n            if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    _error(l10n.t('Value expected'), ErrorCode.ValueExpected);\n                }\n                const commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 4 /* Json.SyntaxKind.CloseBracketToken */) {\n                    if (needsComma) {\n                        _errorAtRange(l10n.t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(l10n.t('Expected comma'), ErrorCode.CommaExpected);\n            }\n            const item = _parseValue(node);\n            if (!item) {\n                _error(l10n.t('Value expected'), ErrorCode.ValueExpected, undefined, [], [4 /* Json.SyntaxKind.CloseBracketToken */, 5 /* Json.SyntaxKind.CommaToken */]);\n            }\n            else {\n                node.items.push(item);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */) {\n            return _error(l10n.t('Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    const keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);\n    function _parseProperty(parent, keysSeen) {\n        const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);\n        let key = _parseString(node);\n        if (!key) {\n            if (scanner.getToken() === 16 /* Json.SyntaxKind.Unknown */) {\n                // give a more helpful error message\n                _error(l10n.t('Property keys must be doublequoted'), ErrorCode.PropertyKeysMustBeDoublequoted);\n                const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\n                keyNode.value = scanner.getTokenValue();\n                key = keyNode;\n                _scanNext(); // consume Unknown\n            }\n            else {\n                return undefined;\n            }\n        }\n        node.keyNode = key;\n        // For JSON files that forbid code comments, there is a convention to use the key name \"//\" to add comments.\n        // Multiple instances of \"//\" are okay.\n        if (key.value !== \"//\") {\n            const seen = keysSeen[key.value];\n            if (seen) {\n                _errorAtRange(l10n.t(\"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\n                if (isObject(seen)) {\n                    _errorAtRange(l10n.t(\"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\n                }\n                keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting\n            }\n            else {\n                keysSeen[key.value] = node;\n            }\n        }\n        if (scanner.getToken() === 6 /* Json.SyntaxKind.ColonToken */) {\n            node.colonOffset = scanner.getTokenOffset();\n            _scanNext(); // consume ColonToken\n        }\n        else {\n            _error(l10n.t('Colon expected'), ErrorCode.ColonExpected);\n            if (scanner.getToken() === 10 /* Json.SyntaxKind.StringLiteral */ && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {\n                node.length = key.length;\n                return node;\n            }\n        }\n        const value = _parseValue(node);\n        if (!value) {\n            return _error(l10n.t('Value expected'), ErrorCode.ValueExpected, node, [], [2 /* Json.SyntaxKind.CloseBraceToken */, 5 /* Json.SyntaxKind.CommaToken */]);\n        }\n        node.valueNode = value;\n        node.length = value.offset + value.length - node.offset;\n        return node;\n    }\n    function _parseObject(parent) {\n        if (scanner.getToken() !== 1 /* Json.SyntaxKind.OpenBraceToken */) {\n            return undefined;\n        }\n        const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\n        const keysSeen = Object.create(null);\n        _scanNext(); // consume OpenBraceToken\n        let needsComma = false;\n        while (scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */ && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */) {\n            if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    _error(l10n.t('Property expected'), ErrorCode.PropertyExpected);\n                }\n                const commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 2 /* Json.SyntaxKind.CloseBraceToken */) {\n                    if (needsComma) {\n                        _errorAtRange(l10n.t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(l10n.t('Expected comma'), ErrorCode.CommaExpected);\n            }\n            const property = _parseProperty(node, keysSeen);\n            if (!property) {\n                _error(l10n.t('Property expected'), ErrorCode.PropertyExpected, undefined, [], [2 /* Json.SyntaxKind.CloseBraceToken */, 5 /* Json.SyntaxKind.CommaToken */]);\n            }\n            else {\n                node.properties.push(property);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */) {\n            return _error(l10n.t('Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    function _parseString(parent) {\n        if (scanner.getToken() !== 10 /* Json.SyntaxKind.StringLiteral */) {\n            return undefined;\n        }\n        const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\n        node.value = scanner.getTokenValue();\n        return _finalize(node, true);\n    }\n    function _parseNumber(parent) {\n        if (scanner.getToken() !== 11 /* Json.SyntaxKind.NumericLiteral */) {\n            return undefined;\n        }\n        const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\n        if (scanner.getTokenError() === 0 /* Json.ScanError.None */) {\n            const tokenValue = scanner.getTokenValue();\n            try {\n                const numberValue = JSON.parse(tokenValue);\n                if (!isNumber(numberValue)) {\n                    return _error(l10n.t('Invalid number format.'), ErrorCode.Undefined, node);\n                }\n                node.value = numberValue;\n            }\n            catch (e) {\n                return _error(l10n.t('Invalid number format.'), ErrorCode.Undefined, node);\n            }\n            node.isInteger = tokenValue.indexOf('.') === -1;\n        }\n        return _finalize(node, true);\n    }\n    function _parseLiteral(parent) {\n        let node;\n        switch (scanner.getToken()) {\n            case 7 /* Json.SyntaxKind.NullKeyword */:\n                return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\n            case 8 /* Json.SyntaxKind.TrueKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\n            case 9 /* Json.SyntaxKind.FalseKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\n            default:\n                return undefined;\n        }\n    }\n    function _parseValue(parent) {\n        return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\n    }\n    let _root = undefined;\n    const token = _scanNext();\n    if (token !== 17 /* Json.SyntaxKind.EOF */) {\n        _root = _parseValue(_root);\n        if (!_root) {\n            _error(l10n.t('Expected a JSON object, array or literal.'), ErrorCode.Undefined);\n        }\n        else if (scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */) {\n            _error(l10n.t('End of file expected.'), ErrorCode.Undefined);\n        }\n    }\n    return new JSONDocument(_root, problems, commentRanges);\n}\n","/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nexport function stringifyObject(obj, indent, stringifyLiteral) {\n    if (obj !== null && typeof obj === 'object') {\n        const newIndent = indent + '\\t';\n        if (Array.isArray(obj)) {\n            if (obj.length === 0) {\n                return '[]';\n            }\n            let result = '[\\n';\n            for (let i = 0; i < obj.length; i++) {\n                result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);\n                if (i < obj.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + ']';\n            return result;\n        }\n        else {\n            const keys = Object.keys(obj);\n            if (keys.length === 0) {\n                return '{}';\n            }\n            let result = '{\\n';\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);\n                if (i < keys.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + '}';\n            return result;\n        }\n    }\n    return stringifyLiteral(obj);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Parser from '../parser/jsonParser';\nimport * as Json from 'jsonc-parser';\nimport { stringifyObject } from '../utils/json';\nimport { endsWith, extendedRegExp } from '../utils/strings';\nimport { isDefined } from '../utils/objects';\nimport { CompletionItem, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from '../jsonLanguageTypes';\nimport * as l10n from '@vscode/l10n';\nconst valueCommitCharacters = [',', '}', ']'];\nconst propertyCommitCharacters = [':'];\nexport class JSONCompletion {\n    constructor(schemaService, contributions = [], promiseConstructor = Promise, clientCapabilities = {}) {\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promiseConstructor = promiseConstructor;\n        this.clientCapabilities = clientCapabilities;\n    }\n    doResolve(item) {\n        for (let i = this.contributions.length - 1; i >= 0; i--) {\n            const resolveCompletion = this.contributions[i].resolveCompletion;\n            if (resolveCompletion) {\n                const resolver = resolveCompletion(item);\n                if (resolver) {\n                    return resolver;\n                }\n            }\n        }\n        return this.promiseConstructor.resolve(item);\n    }\n    doComplete(document, position, doc) {\n        const result = {\n            items: [],\n            isIncomplete: false\n        };\n        const text = document.getText();\n        const offset = document.offsetAt(position);\n        let node = doc.getNodeFromOffset(offset, true);\n        if (this.isInComment(document, node ? node.offset : 0, offset)) {\n            return Promise.resolve(result);\n        }\n        if (node && (offset === node.offset + node.length) && offset > 0) {\n            const ch = text[offset - 1];\n            if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {\n                // after ] or }\n                node = node.parent;\n            }\n        }\n        const currentWord = this.getCurrentWord(document, offset);\n        let overwriteRange;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            overwriteRange = Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n        }\n        else {\n            let overwriteStart = offset - currentWord.length;\n            if (overwriteStart > 0 && text[overwriteStart - 1] === '\"') {\n                overwriteStart--;\n            }\n            overwriteRange = Range.create(document.positionAt(overwriteStart), position);\n        }\n        const supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544\n        const proposed = new Map();\n        const collector = {\n            add: (suggestion) => {\n                let label = suggestion.label;\n                const existing = proposed.get(label);\n                if (!existing) {\n                    label = label.replace(/[\\n]/g, '');\n                    if (label.length > 60) {\n                        const shortendedLabel = label.substr(0, 57).trim() + '...';\n                        if (!proposed.has(shortendedLabel)) {\n                            label = shortendedLabel;\n                        }\n                    }\n                    suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);\n                    if (supportsCommitCharacters) {\n                        suggestion.commitCharacters = suggestion.kind === CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;\n                    }\n                    suggestion.label = label;\n                    proposed.set(label, suggestion);\n                    result.items.push(suggestion);\n                }\n                else {\n                    if (!existing.documentation) {\n                        existing.documentation = suggestion.documentation;\n                    }\n                    if (!existing.detail) {\n                        existing.detail = suggestion.detail;\n                    }\n                    if (!existing.labelDetails) {\n                        existing.labelDetails = suggestion.labelDetails;\n                    }\n                }\n            },\n            setAsIncomplete: () => {\n                result.isIncomplete = true;\n            },\n            error: (message) => {\n                console.error(message);\n            },\n            getNumberOfProposals: () => {\n                return result.items.length;\n            }\n        };\n        return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\n            const collectionPromises = [];\n            let addValue = true;\n            let currentKey = '';\n            let currentProperty = undefined;\n            if (node) {\n                if (node.type === 'string') {\n                    const parent = node.parent;\n                    if (parent && parent.type === 'property' && parent.keyNode === node) {\n                        addValue = !parent.valueNode;\n                        currentProperty = parent;\n                        currentKey = text.substr(node.offset + 1, node.length - 2);\n                        if (parent) {\n                            node = parent.parent;\n                        }\n                    }\n                }\n            }\n            // proposals for properties\n            if (node && node.type === 'object') {\n                // don't suggest keys when the cursor is just before the opening curly brace\n                if (node.offset === offset) {\n                    return result;\n                }\n                // don't suggest properties that are already present\n                const properties = node.properties;\n                properties.forEach(p => {\n                    if (!currentProperty || currentProperty !== p) {\n                        proposed.set(p.keyNode.value, CompletionItem.create('__'));\n                    }\n                });\n                let separatorAfter = '';\n                if (addValue) {\n                    separatorAfter = this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));\n                }\n                if (schema) {\n                    // property proposals with schema\n                    this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector);\n                }\n                else {\n                    // property proposals without schema\n                    this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\n                }\n                const location = Parser.getNodePath(node);\n                this.contributions.forEach((contribution) => {\n                    const collectPromise = contribution.collectPropertyCompletions(document.uri, location, currentWord, addValue, separatorAfter === '', collector);\n                    if (collectPromise) {\n                        collectionPromises.push(collectPromise);\n                    }\n                });\n                if ((!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '\"')) {\n                    collector.add({\n                        kind: CompletionItemKind.Property,\n                        label: this.getLabelForValue(currentWord),\n                        insertText: this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter),\n                        insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                    });\n                    collector.setAsIncomplete();\n                }\n            }\n            // proposals for values\n            const types = {};\n            if (schema) {\n                // value proposals with schema\n                this.getValueCompletions(schema, doc, node, offset, document, collector, types);\n            }\n            else {\n                // value proposals without schema\n                this.getSchemaLessValueCompletions(doc, node, offset, document, collector);\n            }\n            if (this.contributions.length > 0) {\n                this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);\n            }\n            return this.promiseConstructor.all(collectionPromises).then(() => {\n                if (collector.getNumberOfProposals() === 0) {\n                    let offsetForSeparator = offset;\n                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n                        offsetForSeparator = node.offset + node.length;\n                    }\n                    const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n                    this.addFillerValueCompletions(types, separatorAfter, collector);\n                }\n                return result;\n            });\n        });\n    }\n    getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector) {\n        const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n        matchingSchemas.forEach((s) => {\n            if (s.node === node && !s.inverted) {\n                const schemaProperties = s.schema.properties;\n                if (schemaProperties) {\n                    Object.keys(schemaProperties).forEach((key) => {\n                        const propertySchema = schemaProperties[key];\n                        if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {\n                            const proposal = {\n                                kind: CompletionItemKind.Property,\n                                label: key,\n                                insertText: this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\n                                insertTextFormat: InsertTextFormat.Snippet,\n                                filterText: this.getFilterTextForValue(key),\n                                documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',\n                            };\n                            if (propertySchema.suggestSortText !== undefined) {\n                                proposal.sortText = propertySchema.suggestSortText;\n                            }\n                            if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {\n                                proposal.command = {\n                                    title: 'Suggest',\n                                    command: 'editor.action.triggerSuggest'\n                                };\n                            }\n                            collector.add(proposal);\n                        }\n                    });\n                }\n                const schemaPropertyNames = s.schema.propertyNames;\n                if (typeof schemaPropertyNames === 'object' && !schemaPropertyNames.deprecationMessage && !schemaPropertyNames.doNotSuggest) {\n                    const propertyNameCompletionItem = (name, enumDescription = undefined) => {\n                        const proposal = {\n                            kind: CompletionItemKind.Property,\n                            label: name,\n                            insertText: this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),\n                            insertTextFormat: InsertTextFormat.Snippet,\n                            filterText: this.getFilterTextForValue(name),\n                            documentation: enumDescription || this.fromMarkup(schemaPropertyNames.markdownDescription) || schemaPropertyNames.description || '',\n                        };\n                        if (schemaPropertyNames.suggestSortText !== undefined) {\n                            proposal.sortText = schemaPropertyNames.suggestSortText;\n                        }\n                        if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {\n                            proposal.command = {\n                                title: 'Suggest',\n                                command: 'editor.action.triggerSuggest'\n                            };\n                        }\n                        collector.add(proposal);\n                    };\n                    if (schemaPropertyNames.enum) {\n                        for (let i = 0; i < schemaPropertyNames.enum.length; i++) {\n                            let enumDescription = undefined;\n                            if (schemaPropertyNames.markdownEnumDescriptions && i < schemaPropertyNames.markdownEnumDescriptions.length) {\n                                enumDescription = this.fromMarkup(schemaPropertyNames.markdownEnumDescriptions[i]);\n                            }\n                            else if (schemaPropertyNames.enumDescriptions && i < schemaPropertyNames.enumDescriptions.length) {\n                                enumDescription = schemaPropertyNames.enumDescriptions[i];\n                            }\n                            propertyNameCompletionItem(schemaPropertyNames.enum[i], enumDescription);\n                        }\n                    }\n                    if (schemaPropertyNames.const) {\n                        propertyNameCompletionItem(schemaPropertyNames.const);\n                    }\n                }\n            }\n        });\n    }\n    getSchemaLessPropertyCompletions(doc, node, currentKey, collector) {\n        const collectCompletionsForSimilarObject = (obj) => {\n            obj.properties.forEach((p) => {\n                const key = p.keyNode.value;\n                collector.add({\n                    kind: CompletionItemKind.Property,\n                    label: key,\n                    insertText: this.getInsertTextForValue(key, ''),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText: this.getFilterTextForValue(key),\n                    documentation: ''\n                });\n            });\n        };\n        if (node.parent) {\n            if (node.parent.type === 'property') {\n                // if the object is a property value, check the tree for other objects that hang under a property of the same name\n                const parentKey = node.parent.keyNode.value;\n                doc.visit(n => {\n                    if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'object') {\n                        collectCompletionsForSimilarObject(n.valueNode);\n                    }\n                    return true;\n                });\n            }\n            else if (node.parent.type === 'array') {\n                // if the object is in an array, use all other array elements as similar objects\n                node.parent.items.forEach(n => {\n                    if (n.type === 'object' && n !== node) {\n                        collectCompletionsForSimilarObject(n);\n                    }\n                });\n            }\n        }\n        else if (node.type === 'object') {\n            collector.add({\n                kind: CompletionItemKind.Property,\n                label: '$schema',\n                insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),\n                insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                filterText: this.getFilterTextForValue(\"$schema\")\n            });\n        }\n    }\n    getSchemaLessValueCompletions(doc, node, offset, document, collector) {\n        let offsetForSeparator = offset;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            node = node.parent;\n        }\n        if (!node) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: 'Empty object',\n                insertText: this.getInsertTextForValue({}, ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: 'Empty array',\n                insertText: this.getInsertTextForValue([], ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            return;\n        }\n        const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n        const collectSuggestionsForValues = (value) => {\n            if (value.parent && !Parser.contains(value.parent, offset, true)) {\n                collector.add({\n                    kind: this.getSuggestionKind(value.type),\n                    label: this.getLabelTextForMatchingNode(value, document),\n                    insertText: this.getInsertTextForMatchingNode(value, document, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n                });\n            }\n            if (value.type === 'boolean') {\n                this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\n            }\n        };\n        if (node.type === 'property') {\n            if (offset > (node.colonOffset || 0)) {\n                const valueNode = node.valueNode;\n                if (valueNode && (offset > (valueNode.offset + valueNode.length) || valueNode.type === 'object' || valueNode.type === 'array')) {\n                    return;\n                }\n                // suggest values at the same key\n                const parentKey = node.keyNode.value;\n                doc.visit(n => {\n                    if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode) {\n                        collectSuggestionsForValues(n.valueNode);\n                    }\n                    return true;\n                });\n                if (parentKey === '$schema' && node.parent && !node.parent.parent) {\n                    this.addDollarSchemaCompletions(separatorAfter, collector);\n                }\n            }\n        }\n        if (node.type === 'array') {\n            if (node.parent && node.parent.type === 'property') {\n                // suggest items of an array at the same key\n                const parentKey = node.parent.keyNode.value;\n                doc.visit((n) => {\n                    if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'array') {\n                        n.valueNode.items.forEach(collectSuggestionsForValues);\n                    }\n                    return true;\n                });\n            }\n            else {\n                // suggest items in the same array\n                node.items.forEach(collectSuggestionsForValues);\n            }\n        }\n    }\n    getValueCompletions(schema, doc, node, offset, document, collector, types) {\n        let offsetForSeparator = offset;\n        let parentKey = undefined;\n        let valueNode = undefined;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            valueNode = node;\n            node = node.parent;\n        }\n        if (!node) {\n            this.addSchemaValueCompletions(schema.schema, '', collector, types);\n            return;\n        }\n        if ((node.type === 'property') && offset > (node.colonOffset || 0)) {\n            const valueNode = node.valueNode;\n            if (valueNode && offset > (valueNode.offset + valueNode.length)) {\n                return; // we are past the value node\n            }\n            parentKey = node.keyNode.value;\n            node = node.parent;\n        }\n        if (node && (parentKey !== undefined || node.type === 'array')) {\n            const separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n            const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);\n            for (const s of matchingSchemas) {\n                if (s.node === node && !s.inverted && s.schema) {\n                    if (node.type === 'array' && s.schema.items) {\n                        let c = collector;\n                        if (s.schema.uniqueItems) {\n                            const existingValues = new Set();\n                            node.children.forEach(n => {\n                                if (n.type !== 'array' && n.type !== 'object') {\n                                    existingValues.add(this.getLabelForValue(Parser.getNodeValue(n)));\n                                }\n                            });\n                            c = {\n                                ...collector,\n                                add(suggestion) {\n                                    if (!existingValues.has(suggestion.label)) {\n                                        collector.add(suggestion);\n                                    }\n                                }\n                            };\n                        }\n                        if (Array.isArray(s.schema.items)) {\n                            const index = this.findItemAtOffset(node, document, offset);\n                            if (index < s.schema.items.length) {\n                                this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, c, types);\n                            }\n                        }\n                        else {\n                            this.addSchemaValueCompletions(s.schema.items, separatorAfter, c, types);\n                        }\n                    }\n                    if (parentKey !== undefined) {\n                        let propertyMatched = false;\n                        if (s.schema.properties) {\n                            const propertySchema = s.schema.properties[parentKey];\n                            if (propertySchema) {\n                                propertyMatched = true;\n                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                            }\n                        }\n                        if (s.schema.patternProperties && !propertyMatched) {\n                            for (const pattern of Object.keys(s.schema.patternProperties)) {\n                                const regex = extendedRegExp(pattern);\n                                if (regex?.test(parentKey)) {\n                                    propertyMatched = true;\n                                    const propertySchema = s.schema.patternProperties[pattern];\n                                    this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                                }\n                            }\n                        }\n                        if (s.schema.additionalProperties && !propertyMatched) {\n                            const propertySchema = s.schema.additionalProperties;\n                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                        }\n                    }\n                }\n            }\n            if (parentKey === '$schema' && !node.parent) {\n                this.addDollarSchemaCompletions(separatorAfter, collector);\n            }\n            if (types['boolean']) {\n                this.addBooleanValueCompletion(true, separatorAfter, collector);\n                this.addBooleanValueCompletion(false, separatorAfter, collector);\n            }\n            if (types['null']) {\n                this.addNullValueCompletion(separatorAfter, collector);\n            }\n        }\n    }\n    getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises) {\n        if (!node) {\n            this.contributions.forEach((contribution) => {\n                const collectPromise = contribution.collectDefaultCompletions(document.uri, collector);\n                if (collectPromise) {\n                    collectionPromises.push(collectPromise);\n                }\n            });\n        }\n        else {\n            if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {\n                node = node.parent;\n            }\n            if (node && (node.type === 'property') && offset > (node.colonOffset || 0)) {\n                const parentKey = node.keyNode.value;\n                const valueNode = node.valueNode;\n                if ((!valueNode || offset <= (valueNode.offset + valueNode.length)) && node.parent) {\n                    const location = Parser.getNodePath(node.parent);\n                    this.contributions.forEach((contribution) => {\n                        const collectPromise = contribution.collectValueCompletions(document.uri, location, parentKey, collector);\n                        if (collectPromise) {\n                            collectionPromises.push(collectPromise);\n                        }\n                    });\n                }\n            }\n        }\n    }\n    addSchemaValueCompletions(schema, separatorAfter, collector, types) {\n        if (typeof schema === 'object') {\n            this.addEnumValueCompletions(schema, separatorAfter, collector);\n            this.addDefaultValueCompletions(schema, separatorAfter, collector);\n            this.collectTypes(schema, types);\n            if (Array.isArray(schema.allOf)) {\n                schema.allOf.forEach(s => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\n            }\n            if (Array.isArray(schema.anyOf)) {\n                schema.anyOf.forEach(s => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\n            }\n            if (Array.isArray(schema.oneOf)) {\n                schema.oneOf.forEach(s => this.addSchemaValueCompletions(s, separatorAfter, collector, types));\n            }\n        }\n    }\n    addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {\n        let hasProposals = false;\n        if (isDefined(schema.default)) {\n            let type = schema.type;\n            let value = schema.default;\n            for (let i = arrayDepth; i > 0; i--) {\n                value = [value];\n                type = 'array';\n            }\n            const completionItem = {\n                kind: this.getSuggestionKind(type),\n                label: this.getLabelForValue(value),\n                insertText: this.getInsertTextForValue(value, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet\n            };\n            if (this.doesSupportsLabelDetails()) {\n                completionItem.labelDetails = { description: l10n.t('Default value') };\n            }\n            else {\n                completionItem.detail = l10n.t('Default value');\n            }\n            collector.add(completionItem);\n            hasProposals = true;\n        }\n        if (Array.isArray(schema.examples)) {\n            schema.examples.forEach(example => {\n                let type = schema.type;\n                let value = example;\n                for (let i = arrayDepth; i > 0; i--) {\n                    value = [value];\n                    type = 'array';\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(type),\n                    label: this.getLabelForValue(value),\n                    insertText: this.getInsertTextForValue(value, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet\n                });\n                hasProposals = true;\n            });\n        }\n        if (Array.isArray(schema.defaultSnippets)) {\n            schema.defaultSnippets.forEach(s => {\n                let type = schema.type;\n                let value = s.body;\n                let label = s.label;\n                let insertText;\n                let filterText;\n                if (isDefined(value)) {\n                    let type = schema.type;\n                    for (let i = arrayDepth; i > 0; i--) {\n                        value = [value];\n                        type = 'array';\n                    }\n                    insertText = this.getInsertTextForSnippetValue(value, separatorAfter);\n                    filterText = this.getFilterTextForSnippetValue(value);\n                    label = label || this.getLabelForSnippetValue(value);\n                }\n                else if (typeof s.bodyText === 'string') {\n                    let prefix = '', suffix = '', indent = '';\n                    for (let i = arrayDepth; i > 0; i--) {\n                        prefix = prefix + indent + '[\\n';\n                        suffix = suffix + '\\n' + indent + ']';\n                        indent += '\\t';\n                        type = 'array';\n                    }\n                    insertText = prefix + indent + s.bodyText.split('\\n').join('\\n' + indent) + suffix + separatorAfter;\n                    label = label || insertText,\n                        filterText = insertText.replace(/[\\n]/g, ''); // remove new lines\n                }\n                else {\n                    return;\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(type),\n                    label,\n                    documentation: this.fromMarkup(s.markdownDescription) || s.description,\n                    insertText,\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText\n                });\n                hasProposals = true;\n            });\n        }\n        if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */) {\n            this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\n        }\n    }\n    addEnumValueCompletions(schema, separatorAfter, collector) {\n        if (isDefined(schema.const)) {\n            collector.add({\n                kind: this.getSuggestionKind(schema.type),\n                label: this.getLabelForValue(schema.const),\n                insertText: this.getInsertTextForValue(schema.const, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: this.fromMarkup(schema.markdownDescription) || schema.description\n            });\n        }\n        if (Array.isArray(schema.enum)) {\n            for (let i = 0, length = schema.enum.length; i < length; i++) {\n                const enm = schema.enum[i];\n                let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\n                if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\n                    documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\n                }\n                else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\n                    documentation = schema.enumDescriptions[i];\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(schema.type),\n                    label: this.getLabelForValue(enm),\n                    insertText: this.getInsertTextForValue(enm, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    documentation\n                });\n            }\n        }\n    }\n    collectTypes(schema, types) {\n        if (Array.isArray(schema.enum) || isDefined(schema.const)) {\n            return;\n        }\n        const type = schema.type;\n        if (Array.isArray(type)) {\n            type.forEach(t => types[t] = true);\n        }\n        else if (type) {\n            types[type] = true;\n        }\n    }\n    addFillerValueCompletions(types, separatorAfter, collector) {\n        if (types['object']) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: '{}',\n                insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: l10n.t('New object'),\n                documentation: ''\n            });\n        }\n        if (types['array']) {\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: '[]',\n                insertText: this.getInsertTextForGuessedValue([], separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: l10n.t('New array'),\n                documentation: ''\n            });\n        }\n    }\n    addBooleanValueCompletion(value, separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('boolean'),\n            label: value ? 'true' : 'false',\n            insertText: this.getInsertTextForValue(value, separatorAfter),\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    }\n    addNullValueCompletion(separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('null'),\n            label: 'null',\n            insertText: 'null' + separatorAfter,\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    }\n    addDollarSchemaCompletions(separatorAfter, collector) {\n        const schemaIds = this.schemaService.getRegisteredSchemaIds(schema => schema === 'http' || schema === 'https');\n        schemaIds.forEach(schemaId => {\n            if (schemaId.startsWith('http://json-schema.org/draft-')) {\n                schemaId = schemaId + '#';\n            }\n            collector.add({\n                kind: CompletionItemKind.Module,\n                label: this.getLabelForValue(schemaId),\n                filterText: this.getFilterTextForValue(schemaId),\n                insertText: this.getInsertTextForValue(schemaId, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n            });\n        });\n    }\n    getLabelForValue(value) {\n        return JSON.stringify(value);\n    }\n    getValueFromLabel(value) {\n        return JSON.parse(value);\n    }\n    getFilterTextForValue(value) {\n        return JSON.stringify(value);\n    }\n    getFilterTextForSnippetValue(value) {\n        return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    }\n    getLabelForSnippetValue(value) {\n        const label = JSON.stringify(value);\n        return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    }\n    getInsertTextForPlainText(text) {\n        return text.replace(/[\\\\\\$\\}]/g, '\\\\$&'); // escape $, \\ and }\n    }\n    getInsertTextForValue(value, separatorAfter) {\n        const text = JSON.stringify(value, null, '\\t');\n        if (text === '{}') {\n            return '{$1}' + separatorAfter;\n        }\n        else if (text === '[]') {\n            return '[$1]' + separatorAfter;\n        }\n        return this.getInsertTextForPlainText(text + separatorAfter);\n    }\n    getInsertTextForSnippetValue(value, separatorAfter) {\n        const replacer = (value) => {\n            if (typeof value === 'string') {\n                if (value[0] === '^') {\n                    return value.substr(1);\n                }\n            }\n            return JSON.stringify(value);\n        };\n        return stringifyObject(value, '', replacer) + separatorAfter;\n    }\n    getInsertTextForGuessedValue(value, separatorAfter) {\n        switch (typeof value) {\n            case 'object':\n                if (value === null) {\n                    return '${1:null}' + separatorAfter;\n                }\n                return this.getInsertTextForValue(value, separatorAfter);\n            case 'string':\n                let snippetValue = JSON.stringify(value);\n                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n                return '\"${1:' + snippetValue + '}\"' + separatorAfter;\n            case 'number':\n            case 'boolean':\n                return '${1:' + JSON.stringify(value) + '}' + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter);\n    }\n    getSuggestionKind(type) {\n        if (Array.isArray(type)) {\n            const array = type;\n            type = array.length > 0 ? array[0] : undefined;\n        }\n        if (!type) {\n            return CompletionItemKind.Value;\n        }\n        switch (type) {\n            case 'string': return CompletionItemKind.Value;\n            case 'object': return CompletionItemKind.Module;\n            case 'property': return CompletionItemKind.Property;\n            default: return CompletionItemKind.Value;\n        }\n    }\n    getLabelTextForMatchingNode(node, document) {\n        switch (node.type) {\n            case 'array':\n                return '[]';\n            case 'object':\n                return '{}';\n            default:\n                const content = document.getText().substr(node.offset, node.length);\n                return content;\n        }\n    }\n    getInsertTextForMatchingNode(node, document, separatorAfter) {\n        switch (node.type) {\n            case 'array':\n                return this.getInsertTextForValue([], separatorAfter);\n            case 'object':\n                return this.getInsertTextForValue({}, separatorAfter);\n            default:\n                const content = document.getText().substr(node.offset, node.length) + separatorAfter;\n                return this.getInsertTextForPlainText(content);\n        }\n    }\n    getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {\n        const propertyText = this.getInsertTextForValue(key, '');\n        if (!addValue) {\n            return propertyText;\n        }\n        const resultText = propertyText + ': ';\n        let value;\n        let nValueProposals = 0;\n        if (propertySchema) {\n            if (Array.isArray(propertySchema.defaultSnippets)) {\n                if (propertySchema.defaultSnippets.length === 1) {\n                    const body = propertySchema.defaultSnippets[0].body;\n                    if (isDefined(body)) {\n                        value = this.getInsertTextForSnippetValue(body, '');\n                    }\n                }\n                nValueProposals += propertySchema.defaultSnippets.length;\n            }\n            if (propertySchema.enum) {\n                if (!value && propertySchema.enum.length === 1) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');\n                }\n                nValueProposals += propertySchema.enum.length;\n            }\n            if (isDefined(propertySchema.const)) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.const, '');\n                }\n                nValueProposals++;\n            }\n            if (isDefined(propertySchema.default)) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.default, '');\n                }\n                nValueProposals++;\n            }\n            if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');\n                }\n                nValueProposals += propertySchema.examples.length;\n            }\n            if (nValueProposals === 0) {\n                let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n                if (!type) {\n                    if (propertySchema.properties) {\n                        type = 'object';\n                    }\n                    else if (propertySchema.items) {\n                        type = 'array';\n                    }\n                }\n                switch (type) {\n                    case 'boolean':\n                        value = '$1';\n                        break;\n                    case 'string':\n                        value = '\"$1\"';\n                        break;\n                    case 'object':\n                        value = '{$1}';\n                        break;\n                    case 'array':\n                        value = '[$1]';\n                        break;\n                    case 'number':\n                    case 'integer':\n                        value = '${1:0}';\n                        break;\n                    case 'null':\n                        value = '${1:null}';\n                        break;\n                    default:\n                        return propertyText;\n                }\n            }\n        }\n        if (!value || nValueProposals > 1) {\n            value = '$1';\n        }\n        return resultText + value + separatorAfter;\n    }\n    getCurrentWord(document, offset) {\n        let i = offset - 1;\n        const text = document.getText();\n        while (i >= 0 && ' \\t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n            i--;\n        }\n        return text.substring(i + 1, offset);\n    }\n    evaluateSeparatorAfter(document, offset) {\n        const scanner = Json.createScanner(document.getText(), true);\n        scanner.setPosition(offset);\n        const token = scanner.scan();\n        switch (token) {\n            case 5 /* Json.SyntaxKind.CommaToken */:\n            case 2 /* Json.SyntaxKind.CloseBraceToken */:\n            case 4 /* Json.SyntaxKind.CloseBracketToken */:\n            case 17 /* Json.SyntaxKind.EOF */:\n                return '';\n            default:\n                return ',';\n        }\n    }\n    findItemAtOffset(node, document, offset) {\n        const scanner = Json.createScanner(document.getText(), true);\n        const children = node.items;\n        for (let i = children.length - 1; i >= 0; i--) {\n            const child = children[i];\n            if (offset > child.offset + child.length) {\n                scanner.setPosition(child.offset + child.length);\n                const token = scanner.scan();\n                if (token === 5 /* Json.SyntaxKind.CommaToken */ && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {\n                    return i + 1;\n                }\n                return i;\n            }\n            else if (offset >= child.offset) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    isInComment(document, start, offset) {\n        const scanner = Json.createScanner(document.getText(), false);\n        scanner.setPosition(start);\n        let token = scanner.scan();\n        while (token !== 17 /* Json.SyntaxKind.EOF */ && (scanner.getTokenOffset() + scanner.getTokenLength() < offset)) {\n            token = scanner.scan();\n        }\n        return (token === 12 /* Json.SyntaxKind.LineCommentTrivia */ || token === 13 /* Json.SyntaxKind.BlockCommentTrivia */) && scanner.getTokenOffset() <= offset;\n    }\n    fromMarkup(markupString) {\n        if (markupString && this.doesSupportMarkdown()) {\n            return {\n                kind: MarkupKind.Markdown,\n                value: markupString\n            };\n        }\n        return undefined;\n    }\n    doesSupportMarkdown() {\n        if (!isDefined(this.supportsMarkdown)) {\n            const documentationFormat = this.clientCapabilities.textDocument?.completion?.completionItem?.documentationFormat;\n            this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    }\n    doesSupportsCommitCharacters() {\n        if (!isDefined(this.supportsCommitCharacters)) {\n            this.labelDetailsSupport = this.clientCapabilities.textDocument?.completion?.completionItem?.commitCharactersSupport;\n        }\n        return this.supportsCommitCharacters;\n    }\n    doesSupportsLabelDetails() {\n        if (!isDefined(this.labelDetailsSupport)) {\n            this.labelDetailsSupport = this.clientCapabilities.textDocument?.completion?.completionItem?.labelDetailsSupport;\n        }\n        return this.labelDetailsSupport;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Parser from '../parser/jsonParser';\nimport { Range } from '../jsonLanguageTypes';\nexport class JSONHover {\n    constructor(schemaService, contributions = [], promiseConstructor) {\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promise = promiseConstructor || Promise;\n    }\n    doHover(document, position, doc) {\n        const offset = document.offsetAt(position);\n        let node = doc.getNodeFromOffset(offset);\n        if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {\n            return this.promise.resolve(null);\n        }\n        const hoverRangeNode = node;\n        // use the property description when hovering over an object key\n        if (node.type === 'string') {\n            const parent = node.parent;\n            if (parent && parent.type === 'property' && parent.keyNode === node) {\n                node = parent.valueNode;\n                if (!node) {\n                    return this.promise.resolve(null);\n                }\n            }\n        }\n        const hoverRange = Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\n        const createHover = (contents) => {\n            const result = {\n                contents: contents,\n                range: hoverRange\n            };\n            return result;\n        };\n        const location = Parser.getNodePath(node);\n        for (let i = this.contributions.length - 1; i >= 0; i--) {\n            const contribution = this.contributions[i];\n            const promise = contribution.getInfoContribution(document.uri, location);\n            if (promise) {\n                return promise.then(htmlContent => createHover(htmlContent));\n            }\n        }\n        return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\n            if (schema && node) {\n                const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n                let title = undefined;\n                let markdownDescription = undefined;\n                let markdownEnumValueDescription = undefined, enumValue = undefined;\n                matchingSchemas.every((s) => {\n                    if (s.node === node && !s.inverted && s.schema) {\n                        title = title || s.schema.title;\n                        markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);\n                        if (s.schema.enum) {\n                            const idx = s.schema.enum.indexOf(Parser.getNodeValue(node));\n                            if (s.schema.markdownEnumDescriptions) {\n                                markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];\n                            }\n                            else if (s.schema.enumDescriptions) {\n                                markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);\n                            }\n                            if (markdownEnumValueDescription) {\n                                enumValue = s.schema.enum[idx];\n                                if (typeof enumValue !== 'string') {\n                                    enumValue = JSON.stringify(enumValue);\n                                }\n                            }\n                        }\n                    }\n                    return true;\n                });\n                let result = '';\n                if (title) {\n                    result = toMarkdown(title);\n                }\n                if (markdownDescription) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += markdownDescription;\n                }\n                if (markdownEnumValueDescription) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += `\\`${toMarkdownCodeBlock(enumValue)}\\`: ${markdownEnumValueDescription}`;\n                }\n                return createHover([result]);\n            }\n            return null;\n        });\n    }\n}\nfunction toMarkdown(plain) {\n    if (plain) {\n        const res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, '$1\\n\\n$3'); // single new lines to \\n\\n (Markdown paragraph)\n        return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    return undefined;\n}\nfunction toMarkdownCodeBlock(content) {\n    // see https://daringfireball.net/projects/markdown/syntax#precode\n    if (content.indexOf('`') !== -1) {\n        return '`` ' + content + ' ``';\n    }\n    return content;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ErrorCode, Diagnostic, DiagnosticSeverity, Range } from '../jsonLanguageTypes';\nimport * as l10n from '@vscode/l10n';\nimport { isBoolean } from '../utils/objects';\nexport class JSONValidation {\n    constructor(jsonSchemaService, promiseConstructor) {\n        this.jsonSchemaService = jsonSchemaService;\n        this.promise = promiseConstructor;\n        this.validationEnabled = true;\n    }\n    configure(raw) {\n        if (raw) {\n            this.validationEnabled = raw.validate !== false;\n            this.commentSeverity = raw.allowComments ? undefined : DiagnosticSeverity.Error;\n        }\n    }\n    doValidation(textDocument, jsonDocument, documentSettings, schema) {\n        if (!this.validationEnabled) {\n            return this.promise.resolve([]);\n        }\n        const diagnostics = [];\n        const added = {};\n        const addProblem = (problem) => {\n            // remove duplicated messages\n            const signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;\n            if (!added[signature]) {\n                added[signature] = true;\n                diagnostics.push(problem);\n            }\n        };\n        const getDiagnostics = (schema) => {\n            let trailingCommaSeverity = documentSettings?.trailingCommas ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;\n            let commentSeverity = documentSettings?.comments ? toDiagnosticSeverity(documentSettings.comments) : this.commentSeverity;\n            let schemaValidation = documentSettings?.schemaValidation ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;\n            let schemaRequest = documentSettings?.schemaRequest ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;\n            if (schema) {\n                const addSchemaProblem = (errorMessage, errorCode) => {\n                    if (jsonDocument.root && schemaRequest) {\n                        const astRoot = jsonDocument.root;\n                        const property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;\n                        if (property && property.keyNode.value === '$schema') {\n                            const node = property.valueNode || property;\n                            const range = Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\n                            addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));\n                        }\n                        else {\n                            const range = Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\n                            addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));\n                        }\n                    }\n                };\n                if (schema.errors.length) {\n                    addSchemaProblem(schema.errors[0], ErrorCode.SchemaResolveError);\n                }\n                else if (schemaValidation) {\n                    for (const warning of schema.warnings) {\n                        addSchemaProblem(warning, ErrorCode.SchemaUnsupportedFeature);\n                    }\n                    const semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation, documentSettings?.schemaDraft);\n                    if (semanticErrors) {\n                        semanticErrors.forEach(addProblem);\n                    }\n                }\n                if (schemaAllowsComments(schema.schema)) {\n                    commentSeverity = undefined;\n                }\n                if (schemaAllowsTrailingCommas(schema.schema)) {\n                    trailingCommaSeverity = undefined;\n                }\n            }\n            for (const p of jsonDocument.syntaxErrors) {\n                if (p.code === ErrorCode.TrailingComma) {\n                    if (typeof trailingCommaSeverity !== 'number') {\n                        continue;\n                    }\n                    p.severity = trailingCommaSeverity;\n                }\n                addProblem(p);\n            }\n            if (typeof commentSeverity === 'number') {\n                const message = l10n.t('Comments are not permitted in JSON.');\n                jsonDocument.comments.forEach(c => {\n                    addProblem(Diagnostic.create(c, message, commentSeverity, ErrorCode.CommentNotPermitted));\n                });\n            }\n            return diagnostics;\n        };\n        if (schema) {\n            const uri = schema.id || ('schemaservice://untitled/' + idCounter++);\n            const handle = this.jsonSchemaService.registerExternalSchema({ uri, schema });\n            return handle.getResolvedSchema().then(resolvedSchema => {\n                return getDiagnostics(resolvedSchema);\n            });\n        }\n        return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(schema => {\n            return getDiagnostics(schema);\n        });\n    }\n    getLanguageStatus(textDocument, jsonDocument) {\n        return { schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument) };\n    }\n}\nlet idCounter = 0;\nfunction schemaAllowsComments(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (isBoolean(schemaRef.allowComments)) {\n            return schemaRef.allowComments;\n        }\n        if (schemaRef.allOf) {\n            for (const schema of schemaRef.allOf) {\n                const allow = schemaAllowsComments(schema);\n                if (isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction schemaAllowsTrailingCommas(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (isBoolean(schemaRef.allowTrailingCommas)) {\n            return schemaRef.allowTrailingCommas;\n        }\n        const deprSchemaRef = schemaRef;\n        if (isBoolean(deprSchemaRef['allowsTrailingCommas'])) { // deprecated\n            return deprSchemaRef['allowsTrailingCommas'];\n        }\n        if (schemaRef.allOf) {\n            for (const schema of schemaRef.allOf) {\n                const allow = schemaAllowsTrailingCommas(schema);\n                if (isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction toDiagnosticSeverity(severityLevel) {\n    switch (severityLevel) {\n        case 'error': return DiagnosticSeverity.Error;\n        case 'warning': return DiagnosticSeverity.Warning;\n        case 'ignore': return undefined;\n    }\n    return undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst Digit0 = 48;\nconst Digit9 = 57;\nconst A = 65;\nconst a = 97;\nconst f = 102;\nexport function hexDigit(charCode) {\n    if (charCode < Digit0) {\n        return 0;\n    }\n    if (charCode <= Digit9) {\n        return charCode - Digit0;\n    }\n    if (charCode < a) {\n        charCode += (a - A);\n    }\n    if (charCode >= a && charCode <= f) {\n        return charCode - a + 10;\n    }\n    return 0;\n}\nexport function colorFromHex(text) {\n    if (text[0] !== '#') {\n        return undefined;\n    }\n    switch (text.length) {\n        case 4:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: 1\n            };\n        case 5:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(4)) * 0x11) / 255.0,\n            };\n        case 7:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: 1\n            };\n        case 9:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0\n            };\n    }\n    return undefined;\n}\nexport function colorFrom256RGB(red, green, blue, alpha = 1.0) {\n    return {\n        red: red / 255.0,\n        green: green / 255.0,\n        blue: blue / 255.0,\n        alpha\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Parser from '../parser/jsonParser';\nimport * as Strings from '../utils/strings';\nimport { colorFromHex } from '../utils/colors';\nimport * as l10n from '@vscode/l10n';\nimport { Range, TextEdit, SymbolKind, Location } from \"../jsonLanguageTypes\";\nexport class JSONDocumentSymbols {\n    constructor(schemaService) {\n        this.schemaService = schemaService;\n    }\n    findDocumentSymbols(document, doc, context = { resultLimit: Number.MAX_VALUE }) {\n        const root = doc.root;\n        if (!root) {\n            return [];\n        }\n        let limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        const resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || Strings.endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                const result = [];\n                for (const item of root.items) {\n                    if (item.type === 'object') {\n                        for (const property of item.properties) {\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                const location = Location.create(document.uri, getRange(document, item));\n                                result.push({ name: getName(property.valueNode), kind: SymbolKind.Function, location: location });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        const toVisit = [\n            { node: root, containerName: '' }\n        ];\n        let nextToVisit = 0;\n        let limitExceeded = false;\n        const result = [];\n        const collectOutlineEntries = (node, containerName) => {\n            if (node.type === 'array') {\n                node.items.forEach(node => {\n                    if (node) {\n                        toVisit.push({ node, containerName });\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach((property) => {\n                    const valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            const location = Location.create(document.uri, getRange(document, property));\n                            const childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;\n                            result.push({ name: this.getKeyLabel(property), kind: this.getSymbolKind(valueNode.type), location: location, containerName: containerName });\n                            toVisit.push({ node: valueNode, containerName: childContainerName });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            const next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.containerName);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    }\n    findDocumentSymbols2(document, doc, context = { resultLimit: Number.MAX_VALUE }) {\n        const root = doc.root;\n        if (!root) {\n            return [];\n        }\n        let limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        const resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || Strings.endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                const result = [];\n                for (const item of root.items) {\n                    if (item.type === 'object') {\n                        for (const property of item.properties) {\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                const range = getRange(document, item);\n                                const selectionRange = getRange(document, property.keyNode);\n                                result.push({ name: getName(property.valueNode), kind: SymbolKind.Function, range, selectionRange });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        const result = [];\n        const toVisit = [\n            { node: root, result }\n        ];\n        let nextToVisit = 0;\n        let limitExceeded = false;\n        const collectOutlineEntries = (node, result) => {\n            if (node.type === 'array') {\n                node.items.forEach((node, index) => {\n                    if (node) {\n                        if (limit > 0) {\n                            limit--;\n                            const range = getRange(document, node);\n                            const selectionRange = range;\n                            const name = String(index);\n                            const symbol = { name, kind: this.getSymbolKind(node.type), range, selectionRange, children: [] };\n                            result.push(symbol);\n                            toVisit.push({ result: symbol.children, node });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach((property) => {\n                    const valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            const range = getRange(document, property);\n                            const selectionRange = getRange(document, property.keyNode);\n                            const children = [];\n                            const symbol = { name: this.getKeyLabel(property), kind: this.getSymbolKind(valueNode.type), range, selectionRange, children, detail: this.getDetail(valueNode) };\n                            result.push(symbol);\n                            toVisit.push({ result: children, node: valueNode });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            const next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.result);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    }\n    getSymbolKind(nodeType) {\n        switch (nodeType) {\n            case 'object':\n                return SymbolKind.Module;\n            case 'string':\n                return SymbolKind.String;\n            case 'number':\n                return SymbolKind.Number;\n            case 'array':\n                return SymbolKind.Array;\n            case 'boolean':\n                return SymbolKind.Boolean;\n            default: // 'null'\n                return SymbolKind.Variable;\n        }\n    }\n    getKeyLabel(property) {\n        let name = property.keyNode.value;\n        if (name) {\n            name = name.replace(/[\\n]/g, '');\n        }\n        if (name && name.trim()) {\n            return name;\n        }\n        return `\"${name}\"`;\n    }\n    getDetail(node) {\n        if (!node) {\n            return undefined;\n        }\n        if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {\n            return String(node.value);\n        }\n        else {\n            if (node.type === 'array') {\n                return node.children.length ? undefined : '[]';\n            }\n            else if (node.type === 'object') {\n                return node.children.length ? undefined : '{}';\n            }\n        }\n        return undefined;\n    }\n    findDocumentColors(document, doc, context) {\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(schema => {\n            const result = [];\n            if (schema) {\n                let limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;\n                const matchingSchemas = doc.getMatchingSchemas(schema.schema);\n                const visitedNode = {};\n                for (const s of matchingSchemas) {\n                    if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {\n                        const nodeId = String(s.node.offset);\n                        if (!visitedNode[nodeId]) {\n                            const color = colorFromHex(Parser.getNodeValue(s.node));\n                            if (color) {\n                                const range = getRange(document, s.node);\n                                result.push({ color, range });\n                            }\n                            visitedNode[nodeId] = true;\n                            limit--;\n                            if (limit <= 0) {\n                                if (context && context.onResultLimitExceeded) {\n                                    context.onResultLimitExceeded(document.uri);\n                                }\n                                return result;\n                            }\n                        }\n                    }\n                }\n            }\n            return result;\n        });\n    }\n    getColorPresentations(document, doc, color, range) {\n        const result = [];\n        const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\n        function toTwoDigitHex(n) {\n            const r = n.toString(16);\n            return r.length !== 2 ? '0' + r : r;\n        }\n        let label;\n        if (color.alpha === 1) {\n            label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;\n        }\n        else {\n            label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;\n        }\n        result.push({ label: label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });\n        return result;\n    }\n}\nfunction getRange(document, node) {\n    return Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n}\nfunction getName(node) {\n    return Parser.getNodeValue(node) || l10n.t('<empty>');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as l10n from '@vscode/l10n';\nexport const schemaContributions = {\n    schemaAssociations: [],\n    schemas: {\n        // bundle the schema-schema to include (localized) descriptions\n        'http://json-schema.org/draft-04/schema#': {\n            '$schema': 'http://json-schema.org/draft-04/schema#',\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': {\n                        '$ref': '#'\n                    }\n                },\n                'positiveInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'positiveIntegerDefault0': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        },\n                        {\n                            'default': 0\n                        }\n                    ]\n                },\n                'simpleTypes': {\n                    'type': 'string',\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': {\n                        'type': 'string'\n                    },\n                    'minItems': 1,\n                    'uniqueItems': true\n                }\n            },\n            'type': 'object',\n            'properties': {\n                'id': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': {},\n                'multipleOf': {\n                    'type': 'number',\n                    'minimum': 0,\n                    'exclusiveMinimum': true\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'items': {\n                    'anyOf': [\n                        {\n                            '$ref': '#'\n                        },\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ],\n                    'default': {}\n                },\n                'maxItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'required': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/stringArray'\n                        }\n                    ]\n                },\n                'additionalProperties': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            {\n                                '$ref': '#'\n                            },\n                            {\n                                '$ref': '#/definitions/stringArray'\n                            }\n                        ]\n                    }\n                },\n                'enum': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        {\n                            '$ref': '#/definitions/simpleTypes'\n                        },\n                        {\n                            'type': 'array',\n                            'items': {\n                                '$ref': '#/definitions/simpleTypes'\n                            },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': {\n                    'anyOf': [\n                        {\n                            'type': 'string',\n                            'enum': [\n                                'date-time',\n                                'uri',\n                                'email',\n                                'hostname',\n                                'ipv4',\n                                'ipv6',\n                                'regex'\n                            ]\n                        },\n                        {\n                            'type': 'string'\n                        }\n                    ]\n                },\n                'allOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'anyOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'oneOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'not': {\n                    'allOf': [\n                        {\n                            '$ref': '#'\n                        }\n                    ]\n                }\n            },\n            'dependencies': {\n                'exclusiveMaximum': [\n                    'maximum'\n                ],\n                'exclusiveMinimum': [\n                    'minimum'\n                ]\n            },\n            'default': {}\n        },\n        'http://json-schema.org/draft-07/schema#': {\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': { '$ref': '#' }\n                },\n                'nonNegativeInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'nonNegativeIntegerDefault0': {\n                    'allOf': [\n                        { '$ref': '#/definitions/nonNegativeInteger' },\n                        { 'default': 0 }\n                    ]\n                },\n                'simpleTypes': {\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': { 'type': 'string' },\n                    'uniqueItems': true,\n                    'default': []\n                }\n            },\n            'type': ['object', 'boolean'],\n            'properties': {\n                '$id': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$ref': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$comment': {\n                    'type': 'string'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': true,\n                'readOnly': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'examples': {\n                    'type': 'array',\n                    'items': true\n                },\n                'multipleOf': {\n                    'type': 'number',\n                    'exclusiveMinimum': 0\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'number'\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'number'\n                },\n                'maxLength': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minLength': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': { '$ref': '#' },\n                'items': {\n                    'anyOf': [\n                        { '$ref': '#' },\n                        { '$ref': '#/definitions/schemaArray' }\n                    ],\n                    'default': true\n                },\n                'maxItems': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minItems': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'contains': { '$ref': '#' },\n                'maxProperties': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minProperties': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'required': { '$ref': '#/definitions/stringArray' },\n                'additionalProperties': { '$ref': '#' },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'propertyNames': { 'format': 'regex' },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            { '$ref': '#' },\n                            { '$ref': '#/definitions/stringArray' }\n                        ]\n                    }\n                },\n                'propertyNames': { '$ref': '#' },\n                'const': true,\n                'enum': {\n                    'type': 'array',\n                    'items': true,\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        { '$ref': '#/definitions/simpleTypes' },\n                        {\n                            'type': 'array',\n                            'items': { '$ref': '#/definitions/simpleTypes' },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': { 'type': 'string' },\n                'contentMediaType': { 'type': 'string' },\n                'contentEncoding': { 'type': 'string' },\n                'if': { '$ref': '#' },\n                'then': { '$ref': '#' },\n                'else': { '$ref': '#' },\n                'allOf': { '$ref': '#/definitions/schemaArray' },\n                'anyOf': { '$ref': '#/definitions/schemaArray' },\n                'oneOf': { '$ref': '#/definitions/schemaArray' },\n                'not': { '$ref': '#' }\n            },\n            'default': true\n        }\n    }\n};\nconst descriptions = {\n    id: l10n.t(\"A unique identifier for the schema.\"),\n    $schema: l10n.t(\"The schema to verify this document against.\"),\n    title: l10n.t(\"A descriptive title of the element.\"),\n    description: l10n.t(\"A long description of the element. Used in hover menus and suggestions.\"),\n    default: l10n.t(\"A default value. Used by suggestions.\"),\n    multipleOf: l10n.t(\"A number that should cleanly divide the current value (i.e. have no remainder).\"),\n    maximum: l10n.t(\"The maximum numerical value, inclusive by default.\"),\n    exclusiveMaximum: l10n.t(\"Makes the maximum property exclusive.\"),\n    minimum: l10n.t(\"The minimum numerical value, inclusive by default.\"),\n    exclusiveMinimum: l10n.t(\"Makes the minimum property exclusive.\"),\n    maxLength: l10n.t(\"The maximum length of a string.\"),\n    minLength: l10n.t(\"The minimum length of a string.\"),\n    pattern: l10n.t(\"A regular expression to match the string against. It is not implicitly anchored.\"),\n    additionalItems: l10n.t(\"For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.\"),\n    items: l10n.t(\"For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.\"),\n    maxItems: l10n.t(\"The maximum number of items that can be inside an array. Inclusive.\"),\n    minItems: l10n.t(\"The minimum number of items that can be inside an array. Inclusive.\"),\n    uniqueItems: l10n.t(\"If all of the items in the array must be unique. Defaults to false.\"),\n    maxProperties: l10n.t(\"The maximum number of properties an object can have. Inclusive.\"),\n    minProperties: l10n.t(\"The minimum number of properties an object can have. Inclusive.\"),\n    required: l10n.t(\"An array of strings that lists the names of all properties required on this object.\"),\n    additionalProperties: l10n.t(\"Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail.\"),\n    definitions: l10n.t(\"Not used for validation. Place subschemas here that you wish to reference inline with $ref.\"),\n    properties: l10n.t(\"A map of property names to schemas for each property.\"),\n    patternProperties: l10n.t(\"A map of regular expressions on property names to schemas for matching properties.\"),\n    dependencies: l10n.t(\"A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.\"),\n    enum: l10n.t(\"The set of literal values that are valid.\"),\n    type: l10n.t(\"Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.\"),\n    format: l10n.t(\"Describes the format expected for the value.\"),\n    allOf: l10n.t(\"An array of schemas, all of which must match.\"),\n    anyOf: l10n.t(\"An array of schemas, where at least one must match.\"),\n    oneOf: l10n.t(\"An array of schemas, exactly one of which must match.\"),\n    not: l10n.t(\"A schema which must not match.\"),\n    $id: l10n.t(\"A unique identifier for the schema.\"),\n    $ref: l10n.t(\"Reference a definition hosted on any location.\"),\n    $comment: l10n.t(\"Comments from schema authors to readers or maintainers of the schema.\"),\n    readOnly: l10n.t(\"Indicates that the value of the instance is managed exclusively by the owning authority.\"),\n    examples: l10n.t(\"Sample JSON values associated with a particular schema, for the purpose of illustrating usage.\"),\n    contains: l10n.t(\"An array instance is valid against \\\"contains\\\" if at least one of its elements is valid against the given schema.\"),\n    propertyNames: l10n.t(\"If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.\"),\n    const: l10n.t(\"An instance validates successfully against this keyword if its value is equal to the value of the keyword.\"),\n    contentMediaType: l10n.t(\"Describes the media type of a string property.\"),\n    contentEncoding: l10n.t(\"Describes the content encoding of a string property.\"),\n    if: l10n.t(\"The validation outcome of the \\\"if\\\" subschema controls which of the \\\"then\\\" or \\\"else\\\" keywords are evaluated.\"),\n    then: l10n.t(\"The \\\"if\\\" subschema is used for validation when the \\\"if\\\" subschema succeeds.\"),\n    else: l10n.t(\"The \\\"else\\\" subschema is used for validation when the \\\"if\\\" subschema fails.\")\n};\nfor (const schemaName in schemaContributions.schemas) {\n    const schema = schemaContributions.schemas[schemaName];\n    for (const property in schema.properties) {\n        let propertyObject = schema.properties[property];\n        if (typeof propertyObject === 'boolean') {\n            propertyObject = schema.properties[property] = {};\n        }\n        const description = descriptions[property];\n        if (description) {\n            propertyObject['description'] = description;\n        }\n    }\n}\n","var LIB;(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf(\"/\");if(a!==n.length-1){-1===a?(n=\"\",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf(\"/\"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=h,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+=\"..\":g+=\"/..\");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),\"object\"==typeof process)t=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let e=navigator.userAgent;t=e.indexOf(\"Windows\")>=0}const e=/^\\w[\\w\\d+.-]*$/,i=/^\\//,o=/^\\/\\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!e.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",a=\"/\",c=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l(\"file\",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&\"file\"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,\"\\\\\")),n}function y(t,e){const r=e?p:d;let n=\"\",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=a,n+=a),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+=\"?\",n+=r(h,!1,!1)),c&&(n+=\"#\",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x=\"/\";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();export const{URI,Utils}=LIB;\n//# sourceMappingURL=index.mjs.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Copyright (c) 2013, Nick Fitzgerald\n *  Licensed under the MIT License. See LICENCE.md in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createRegex(glob, opts) {\n    if (typeof glob !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    const str = String(glob);\n    // The regexp we are building, as a string.\n    let reStr = \"\";\n    // Whether we are matching so called \"extended\" globs (like bash) and should\n    // support single character matching, matching ranges of characters, group\n    // matching, etc.\n    const extended = opts ? !!opts.extended : false;\n    // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n    // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n    // When globstar is _true_, '/foo/*' is translated to regexp like\n    // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n    // which does not have a '/' to the right of it.\n    // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n    // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n    // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n    // globstar is _false_\n    const globstar = opts ? !!opts.globstar : false;\n    // If we are doing extended matching, this boolean is true when we are inside\n    // a group (eg {*.html,*.js}), and false otherwise.\n    let inGroup = false;\n    // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n    const flags = opts && typeof (opts.flags) === \"string\" ? opts.flags : \"\";\n    let c;\n    for (let i = 0, len = str.length; i < len; i++) {\n        c = str[i];\n        switch (c) {\n            case \"/\":\n            case \"$\":\n            case \"^\":\n            case \"+\":\n            case \".\":\n            case \"(\":\n            case \")\":\n            case \"=\":\n            case \"!\":\n            case \"|\":\n                reStr += \"\\\\\" + c;\n                break;\n            case \"?\":\n                if (extended) {\n                    reStr += \".\";\n                    break;\n                }\n            case \"[\":\n            case \"]\":\n                if (extended) {\n                    reStr += c;\n                    break;\n                }\n            case \"{\":\n                if (extended) {\n                    inGroup = true;\n                    reStr += \"(\";\n                    break;\n                }\n            case \"}\":\n                if (extended) {\n                    inGroup = false;\n                    reStr += \")\";\n                    break;\n                }\n            case \",\":\n                if (inGroup) {\n                    reStr += \"|\";\n                    break;\n                }\n                reStr += \"\\\\\" + c;\n                break;\n            case \"*\":\n                // Move over all consecutive \"*\"'s.\n                // Also store the previous and next characters\n                const prevChar = str[i - 1];\n                let starCount = 1;\n                while (str[i + 1] === \"*\") {\n                    starCount++;\n                    i++;\n                }\n                const nextChar = str[i + 1];\n                if (!globstar) {\n                    // globstar is disabled, so treat any number of \"*\" as one\n                    reStr += \".*\";\n                }\n                else {\n                    // globstar is enabled, so determine if this is a globstar segment\n                    const isGlobstar = starCount > 1 // multiple \"*\"'s\n                        && (prevChar === \"/\" || prevChar === undefined || prevChar === '{' || prevChar === ',') // from the start of the segment\n                        && (nextChar === \"/\" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment\n                    if (isGlobstar) {\n                        if (nextChar === \"/\") {\n                            i++; // move over the \"/\"\n                        }\n                        else if (prevChar === '/' && reStr.endsWith('\\\\/')) {\n                            reStr = reStr.substr(0, reStr.length - 2);\n                        }\n                        // it's a globstar, so match zero or more path segments\n                        reStr += \"((?:[^/]*(?:\\/|$))*)\";\n                    }\n                    else {\n                        // it's not a globstar, so only match one path segment\n                        reStr += \"([^/]*)\";\n                    }\n                }\n                break;\n            default:\n                reStr += c;\n        }\n    }\n    // When regexp 'g' flag is specified don't\n    // constrain the regular expression with ^ & $\n    if (!flags || !~flags.indexOf('g')) {\n        reStr = \"^\" + reStr + \"$\";\n    }\n    return new RegExp(reStr, flags);\n}\n;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Json from 'jsonc-parser';\nimport { URI } from 'vscode-uri';\nimport * as Strings from '../utils/strings';\nimport * as Parser from '../parser/jsonParser';\nimport * as l10n from '@vscode/l10n';\nimport { createRegex } from '../utils/glob';\nimport { isObject, isString } from '../utils/objects';\nconst BANG = '!';\nconst PATH_SEP = '/';\nclass FilePatternAssociation {\n    constructor(pattern, folderUri, uris) {\n        this.folderUri = folderUri;\n        this.uris = uris;\n        this.globWrappers = [];\n        try {\n            for (let patternString of pattern) {\n                const include = patternString[0] !== BANG;\n                if (!include) {\n                    patternString = patternString.substring(1);\n                }\n                if (patternString.length > 0) {\n                    if (patternString[0] === PATH_SEP) {\n                        patternString = patternString.substring(1);\n                    }\n                    this.globWrappers.push({\n                        regexp: createRegex('**/' + patternString, { extended: true, globstar: true }),\n                        include: include,\n                    });\n                }\n            }\n            ;\n            if (folderUri) {\n                folderUri = normalizeResourceForMatching(folderUri);\n                if (!folderUri.endsWith('/')) {\n                    folderUri = folderUri + '/';\n                }\n                this.folderUri = folderUri;\n            }\n        }\n        catch (e) {\n            this.globWrappers.length = 0;\n            this.uris = [];\n        }\n    }\n    matchesPattern(fileName) {\n        if (this.folderUri && !fileName.startsWith(this.folderUri)) {\n            return false;\n        }\n        let match = false;\n        for (const { regexp, include } of this.globWrappers) {\n            if (regexp.test(fileName)) {\n                match = include;\n            }\n        }\n        return match;\n    }\n    getURIs() {\n        return this.uris;\n    }\n}\nclass SchemaHandle {\n    constructor(service, uri, unresolvedSchemaContent) {\n        this.service = service;\n        this.uri = uri;\n        this.dependencies = new Set();\n        this.anchors = undefined;\n        if (unresolvedSchemaContent) {\n            this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n        }\n    }\n    getUnresolvedSchema() {\n        if (!this.unresolvedSchema) {\n            this.unresolvedSchema = this.service.loadSchema(this.uri);\n        }\n        return this.unresolvedSchema;\n    }\n    getResolvedSchema() {\n        if (!this.resolvedSchema) {\n            this.resolvedSchema = this.getUnresolvedSchema().then(unresolved => {\n                return this.service.resolveSchemaContent(unresolved, this);\n            });\n        }\n        return this.resolvedSchema;\n    }\n    clearSchema() {\n        const hasChanges = !!this.unresolvedSchema;\n        this.resolvedSchema = undefined;\n        this.unresolvedSchema = undefined;\n        this.dependencies.clear();\n        this.anchors = undefined;\n        return hasChanges;\n    }\n}\nexport class UnresolvedSchema {\n    constructor(schema, errors = []) {\n        this.schema = schema;\n        this.errors = errors;\n    }\n}\nexport class ResolvedSchema {\n    constructor(schema, errors = [], warnings = [], schemaDraft) {\n        this.schema = schema;\n        this.errors = errors;\n        this.warnings = warnings;\n        this.schemaDraft = schemaDraft;\n    }\n    getSection(path) {\n        const schemaRef = this.getSectionRecursive(path, this.schema);\n        if (schemaRef) {\n            return Parser.asSchema(schemaRef);\n        }\n        return undefined;\n    }\n    getSectionRecursive(path, schema) {\n        if (!schema || typeof schema === 'boolean' || path.length === 0) {\n            return schema;\n        }\n        const next = path.shift();\n        if (schema.properties && typeof schema.properties[next]) {\n            return this.getSectionRecursive(path, schema.properties[next]);\n        }\n        else if (schema.patternProperties) {\n            for (const pattern of Object.keys(schema.patternProperties)) {\n                const regex = Strings.extendedRegExp(pattern);\n                if (regex?.test(next)) {\n                    return this.getSectionRecursive(path, schema.patternProperties[pattern]);\n                }\n            }\n        }\n        else if (typeof schema.additionalProperties === 'object') {\n            return this.getSectionRecursive(path, schema.additionalProperties);\n        }\n        else if (next.match('[0-9]+')) {\n            if (Array.isArray(schema.items)) {\n                const index = parseInt(next, 10);\n                if (!isNaN(index) && schema.items[index]) {\n                    return this.getSectionRecursive(path, schema.items[index]);\n                }\n            }\n            else if (schema.items) {\n                return this.getSectionRecursive(path, schema.items);\n            }\n        }\n        return undefined;\n    }\n}\nexport class JSONSchemaService {\n    constructor(requestService, contextService, promiseConstructor) {\n        this.contextService = contextService;\n        this.requestService = requestService;\n        this.promiseConstructor = promiseConstructor || Promise;\n        this.callOnDispose = [];\n        this.contributionSchemas = {};\n        this.contributionAssociations = [];\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n    }\n    getRegisteredSchemaIds(filter) {\n        return Object.keys(this.registeredSchemasIds).filter(id => {\n            const scheme = URI.parse(id).scheme;\n            return scheme !== 'schemaservice' && (!filter || filter(scheme));\n        });\n    }\n    get promise() {\n        return this.promiseConstructor;\n    }\n    dispose() {\n        while (this.callOnDispose.length > 0) {\n            this.callOnDispose.pop()();\n        }\n    }\n    onResourceChange(uri) {\n        // always clear this local cache when a resource changes\n        this.cachedSchemaForResource = undefined;\n        let hasChanges = false;\n        uri = normalizeId(uri);\n        const toWalk = [uri];\n        const all = Object.keys(this.schemasById).map(key => this.schemasById[key]);\n        while (toWalk.length) {\n            const curr = toWalk.pop();\n            for (let i = 0; i < all.length; i++) {\n                const handle = all[i];\n                if (handle && (handle.uri === curr || handle.dependencies.has(curr))) {\n                    if (handle.uri !== curr) {\n                        toWalk.push(handle.uri);\n                    }\n                    if (handle.clearSchema()) {\n                        hasChanges = true;\n                    }\n                    all[i] = undefined;\n                }\n            }\n        }\n        return hasChanges;\n    }\n    setSchemaContributions(schemaContributions) {\n        if (schemaContributions.schemas) {\n            const schemas = schemaContributions.schemas;\n            for (const id in schemas) {\n                const normalizedId = normalizeId(id);\n                this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n            }\n        }\n        if (Array.isArray(schemaContributions.schemaAssociations)) {\n            const schemaAssociations = schemaContributions.schemaAssociations;\n            for (let schemaAssociation of schemaAssociations) {\n                const uris = schemaAssociation.uris.map(normalizeId);\n                const association = this.addFilePatternAssociation(schemaAssociation.pattern, schemaAssociation.folderUri, uris);\n                this.contributionAssociations.push(association);\n            }\n        }\n    }\n    addSchemaHandle(id, unresolvedSchemaContent) {\n        const schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n        this.schemasById[id] = schemaHandle;\n        return schemaHandle;\n    }\n    getOrAddSchemaHandle(id, unresolvedSchemaContent) {\n        return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n    }\n    addFilePatternAssociation(pattern, folderUri, uris) {\n        const fpa = new FilePatternAssociation(pattern, folderUri, uris);\n        this.filePatternAssociations.push(fpa);\n        return fpa;\n    }\n    registerExternalSchema(config) {\n        const id = normalizeId(config.uri);\n        this.registeredSchemasIds[id] = true;\n        this.cachedSchemaForResource = undefined;\n        if (config.fileMatch && config.fileMatch.length) {\n            this.addFilePatternAssociation(config.fileMatch, config.folderUri, [id]);\n        }\n        return config.schema ? this.addSchemaHandle(id, config.schema) : this.getOrAddSchemaHandle(id);\n    }\n    clearExternalSchemas() {\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n        this.cachedSchemaForResource = undefined;\n        for (const id in this.contributionSchemas) {\n            this.schemasById[id] = this.contributionSchemas[id];\n            this.registeredSchemasIds[id] = true;\n        }\n        for (const contributionAssociation of this.contributionAssociations) {\n            this.filePatternAssociations.push(contributionAssociation);\n        }\n    }\n    getResolvedSchema(schemaId) {\n        const id = normalizeId(schemaId);\n        const schemaHandle = this.schemasById[id];\n        if (schemaHandle) {\n            return schemaHandle.getResolvedSchema();\n        }\n        return this.promise.resolve(undefined);\n    }\n    loadSchema(url) {\n        if (!this.requestService) {\n            const errorMessage = l10n.t('Unable to load schema from \\'{0}\\'. No schema request service available', toDisplayString(url));\n            return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n        }\n        if (url.startsWith('http://json-schema.org/')) {\n            url = 'https' + url.substring(4); // always access json-schema.org with https. See https://github.com/microsoft/vscode/issues/195189\n        }\n        return this.requestService(url).then(content => {\n            if (!content) {\n                const errorMessage = l10n.t('Unable to load schema from \\'{0}\\': No content.', toDisplayString(url));\n                return new UnresolvedSchema({}, [errorMessage]);\n            }\n            const errors = [];\n            if (content.charCodeAt(0) === 65279) {\n                errors.push(l10n.t('Problem reading content from \\'{0}\\': UTF-8 with BOM detected, only UTF 8 is allowed.', toDisplayString(url)));\n                content = content.trimStart();\n            }\n            let schemaContent = {};\n            const jsonErrors = [];\n            schemaContent = Json.parse(content, jsonErrors);\n            if (jsonErrors.length) {\n                errors.push(l10n.t('Unable to parse content from \\'{0}\\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset));\n            }\n            return new UnresolvedSchema(schemaContent, errors);\n        }, (error) => {\n            let errorMessage = error.toString();\n            const errorSplit = error.toString().split('Error: ');\n            if (errorSplit.length > 1) {\n                // more concise error message, URL and context are attached by caller anyways\n                errorMessage = errorSplit[1];\n            }\n            if (Strings.endsWith(errorMessage, '.')) {\n                errorMessage = errorMessage.substr(0, errorMessage.length - 1);\n            }\n            return new UnresolvedSchema({}, [l10n.t('Unable to load schema from \\'{0}\\': {1}.', toDisplayString(url), errorMessage)]);\n        });\n    }\n    resolveSchemaContent(schemaToResolve, handle) {\n        const resolveErrors = schemaToResolve.errors.slice(0);\n        const schema = schemaToResolve.schema;\n        let schemaDraft = schema.$schema ? normalizeId(schema.$schema) : undefined;\n        if (schemaDraft === 'http://json-schema.org/draft-03/schema') {\n            return this.promise.resolve(new ResolvedSchema({}, [l10n.t(\"Draft-03 schemas are not supported.\")], [], schemaDraft));\n        }\n        let usesUnsupportedFeatures = new Set();\n        const contextService = this.contextService;\n        const findSectionByJSONPointer = (schema, path) => {\n            path = decodeURIComponent(path);\n            let current = schema;\n            if (path[0] === '/') {\n                path = path.substring(1);\n            }\n            path.split('/').some((part) => {\n                part = part.replace(/~1/g, '/').replace(/~0/g, '~');\n                current = current[part];\n                return !current;\n            });\n            return current;\n        };\n        const findSchemaById = (schema, handle, id) => {\n            if (!handle.anchors) {\n                handle.anchors = collectAnchors(schema);\n            }\n            return handle.anchors.get(id);\n        };\n        const merge = (target, section) => {\n            for (const key in section) {\n                if (section.hasOwnProperty(key) && key !== 'id' && key !== '$id') {\n                    target[key] = section[key];\n                }\n            }\n        };\n        const mergeRef = (target, sourceRoot, sourceHandle, refSegment) => {\n            let section;\n            if (refSegment === undefined || refSegment.length === 0) {\n                section = sourceRoot;\n            }\n            else if (refSegment.charAt(0) === '/') {\n                // A $ref to a JSON Pointer (i.e #/definitions/foo)\n                section = findSectionByJSONPointer(sourceRoot, refSegment);\n            }\n            else {\n                // A $ref to a sub-schema with an $id (i.e #hello)\n                section = findSchemaById(sourceRoot, sourceHandle, refSegment);\n            }\n            if (section) {\n                merge(target, section);\n            }\n            else {\n                resolveErrors.push(l10n.t('$ref \\'{0}\\' in \\'{1}\\' can not be resolved.', refSegment || '', sourceHandle.uri));\n            }\n        };\n        const resolveExternalLink = (node, uri, refSegment, parentHandle) => {\n            if (contextService && !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\n                uri = contextService.resolveRelativePath(uri, parentHandle.uri);\n            }\n            uri = normalizeId(uri);\n            const referencedHandle = this.getOrAddSchemaHandle(uri);\n            return referencedHandle.getUnresolvedSchema().then(unresolvedSchema => {\n                parentHandle.dependencies.add(uri);\n                if (unresolvedSchema.errors.length) {\n                    const loc = refSegment ? uri + '#' + refSegment : uri;\n                    resolveErrors.push(l10n.t('Problems loading reference \\'{0}\\': {1}', loc, unresolvedSchema.errors[0]));\n                }\n                mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);\n                return resolveRefs(node, unresolvedSchema.schema, referencedHandle);\n            });\n        };\n        const resolveRefs = (node, parentSchema, parentHandle) => {\n            const openPromises = [];\n            this.traverseNodes(node, next => {\n                const seenRefs = new Set();\n                while (next.$ref) {\n                    const ref = next.$ref;\n                    const segments = ref.split('#', 2);\n                    delete next.$ref;\n                    if (segments[0].length > 0) {\n                        // This is a reference to an external schema\n                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));\n                        return;\n                    }\n                    else {\n                        // This is a reference inside the current schema\n                        if (!seenRefs.has(ref)) {\n                            const id = segments[1];\n                            mergeRef(next, parentSchema, parentHandle, id);\n                            seenRefs.add(ref);\n                        }\n                    }\n                }\n                if (next.$recursiveRef) {\n                    usesUnsupportedFeatures.add('$recursiveRef');\n                }\n                if (next.$dynamicRef) {\n                    usesUnsupportedFeatures.add('$dynamicRef');\n                }\n            });\n            return this.promise.all(openPromises);\n        };\n        const collectAnchors = (root) => {\n            const result = new Map();\n            this.traverseNodes(root, next => {\n                const id = next.$id || next.id;\n                const anchor = isString(id) && id.charAt(0) === '#' ? id.substring(1) : next.$anchor;\n                if (anchor) {\n                    if (result.has(anchor)) {\n                        resolveErrors.push(l10n.t('Duplicate anchor declaration: \\'{0}\\'', anchor));\n                    }\n                    else {\n                        result.set(anchor, next);\n                    }\n                }\n                if (next.$recursiveAnchor) {\n                    usesUnsupportedFeatures.add('$recursiveAnchor');\n                }\n                if (next.$dynamicAnchor) {\n                    usesUnsupportedFeatures.add('$dynamicAnchor');\n                }\n            });\n            return result;\n        };\n        return resolveRefs(schema, schema, handle).then(_ => {\n            let resolveWarnings = [];\n            if (usesUnsupportedFeatures.size) {\n                resolveWarnings.push(l10n.t('The schema uses meta-schema features ({0}) that are not yet supported by the validator.', Array.from(usesUnsupportedFeatures.keys()).join(', ')));\n            }\n            return new ResolvedSchema(schema, resolveErrors, resolveWarnings, schemaDraft);\n        });\n    }\n    traverseNodes(root, handle) {\n        if (!root || typeof root !== 'object') {\n            return Promise.resolve(null);\n        }\n        const seen = new Set();\n        const collectEntries = (...entries) => {\n            for (const entry of entries) {\n                if (isObject(entry)) {\n                    toWalk.push(entry);\n                }\n            }\n        };\n        const collectMapEntries = (...maps) => {\n            for (const map of maps) {\n                if (isObject(map)) {\n                    for (const k in map) {\n                        const key = k;\n                        const entry = map[key];\n                        if (isObject(entry)) {\n                            toWalk.push(entry);\n                        }\n                    }\n                }\n            }\n        };\n        const collectArrayEntries = (...arrays) => {\n            for (const array of arrays) {\n                if (Array.isArray(array)) {\n                    for (const entry of array) {\n                        if (isObject(entry)) {\n                            toWalk.push(entry);\n                        }\n                    }\n                }\n            }\n        };\n        const collectEntryOrArrayEntries = (items) => {\n            if (Array.isArray(items)) {\n                for (const entry of items) {\n                    if (isObject(entry)) {\n                        toWalk.push(entry);\n                    }\n                }\n            }\n            else if (isObject(items)) {\n                toWalk.push(items);\n            }\n        };\n        const toWalk = [root];\n        let next = toWalk.pop();\n        while (next) {\n            if (!seen.has(next)) {\n                seen.add(next);\n                handle(next);\n                collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);\n                collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);\n                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);\n                collectEntryOrArrayEntries(next.items);\n            }\n            next = toWalk.pop();\n        }\n    }\n    ;\n    getSchemaFromProperty(resource, document) {\n        if (document.root?.type === 'object') {\n            for (const p of document.root.properties) {\n                if (p.keyNode.value === '$schema' && p.valueNode?.type === 'string') {\n                    let schemaId = p.valueNode.value;\n                    if (this.contextService && !/^\\w[\\w\\d+.-]*:/.test(schemaId)) { // has scheme\n                        schemaId = this.contextService.resolveRelativePath(schemaId, resource);\n                    }\n                    return schemaId;\n                }\n            }\n        }\n        return undefined;\n    }\n    getAssociatedSchemas(resource) {\n        const seen = Object.create(null);\n        const schemas = [];\n        const normalizedResource = normalizeResourceForMatching(resource);\n        for (const entry of this.filePatternAssociations) {\n            if (entry.matchesPattern(normalizedResource)) {\n                for (const schemaId of entry.getURIs()) {\n                    if (!seen[schemaId]) {\n                        schemas.push(schemaId);\n                        seen[schemaId] = true;\n                    }\n                }\n            }\n        }\n        return schemas;\n    }\n    getSchemaURIsForResource(resource, document) {\n        let schemeId = document && this.getSchemaFromProperty(resource, document);\n        if (schemeId) {\n            return [schemeId];\n        }\n        return this.getAssociatedSchemas(resource);\n    }\n    getSchemaForResource(resource, document) {\n        if (document) {\n            // first use $schema if present\n            let schemeId = this.getSchemaFromProperty(resource, document);\n            if (schemeId) {\n                const id = normalizeId(schemeId);\n                return this.getOrAddSchemaHandle(id).getResolvedSchema();\n            }\n        }\n        if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {\n            return this.cachedSchemaForResource.resolvedSchema;\n        }\n        const schemas = this.getAssociatedSchemas(resource);\n        const resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);\n        this.cachedSchemaForResource = { resource, resolvedSchema };\n        return resolvedSchema;\n    }\n    createCombinedSchema(resource, schemaIds) {\n        if (schemaIds.length === 1) {\n            return this.getOrAddSchemaHandle(schemaIds[0]);\n        }\n        else {\n            const combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);\n            const combinedSchema = {\n                allOf: schemaIds.map(schemaId => ({ $ref: schemaId }))\n            };\n            return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n        }\n    }\n    getMatchingSchemas(document, jsonDocument, schema) {\n        if (schema) {\n            const id = schema.id || ('schemaservice://untitled/matchingSchemas/' + idCounter++);\n            const handle = this.addSchemaHandle(id, schema);\n            return handle.getResolvedSchema().then(resolvedSchema => {\n                return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(s => !s.inverted);\n            });\n        }\n        return this.getSchemaForResource(document.uri, jsonDocument).then(schema => {\n            if (schema) {\n                return jsonDocument.getMatchingSchemas(schema.schema).filter(s => !s.inverted);\n            }\n            return [];\n        });\n    }\n}\nlet idCounter = 0;\nfunction normalizeId(id) {\n    // remove trailing '#', normalize drive capitalization\n    try {\n        return URI.parse(id).toString(true);\n    }\n    catch (e) {\n        return id;\n    }\n}\nfunction normalizeResourceForMatching(resource) {\n    // remove queries and fragments, normalize drive capitalization\n    try {\n        return URI.parse(resource).with({ fragment: null, query: null }).toString(true);\n    }\n    catch (e) {\n        return resource;\n    }\n}\nfunction toDisplayString(url) {\n    try {\n        const uri = URI.parse(url);\n        if (uri.scheme === 'file') {\n            return uri.fsPath;\n        }\n    }\n    catch (e) {\n        // ignore\n    }\n    return url;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from 'jsonc-parser';\nimport { FoldingRangeKind, Position } from '../jsonLanguageTypes';\nexport function getFoldingRanges(document, context) {\n    const ranges = [];\n    const nestingLevels = [];\n    const stack = [];\n    let prevStart = -1;\n    const scanner = createScanner(document.getText(), false);\n    let token = scanner.scan();\n    function addRange(range) {\n        ranges.push(range);\n        nestingLevels.push(stack.length);\n    }\n    while (token !== 17 /* SyntaxKind.EOF */) {\n        switch (token) {\n            case 1 /* SyntaxKind.OpenBraceToken */:\n            case 3 /* SyntaxKind.OpenBracketToken */: {\n                const startLine = document.positionAt(scanner.getTokenOffset()).line;\n                const range = { startLine, endLine: startLine, kind: token === 1 /* SyntaxKind.OpenBraceToken */ ? 'object' : 'array' };\n                stack.push(range);\n                break;\n            }\n            case 2 /* SyntaxKind.CloseBraceToken */:\n            case 4 /* SyntaxKind.CloseBracketToken */: {\n                const kind = token === 2 /* SyntaxKind.CloseBraceToken */ ? 'object' : 'array';\n                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n                    const range = stack.pop();\n                    const line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n                        range.endLine = line - 1;\n                        addRange(range);\n                        prevStart = range.startLine;\n                    }\n                }\n                break;\n            }\n            case 13 /* SyntaxKind.BlockCommentTrivia */: {\n                const startLine = document.positionAt(scanner.getTokenOffset()).line;\n                const endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                if (scanner.getTokenError() === 1 /* ScanError.UnexpectedEndOfComment */ && startLine + 1 < document.lineCount) {\n                    scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\n                }\n                else {\n                    if (startLine < endLine) {\n                        addRange({ startLine, endLine, kind: FoldingRangeKind.Comment });\n                        prevStart = startLine;\n                    }\n                }\n                break;\n            }\n            case 12 /* SyntaxKind.LineCommentTrivia */: {\n                const text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n                const m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    const line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (m[1]) { // start pattern match\n                        const range = { startLine: line, endLine: line, kind: FoldingRangeKind.Region };\n                        stack.push(range);\n                    }\n                    else {\n                        let i = stack.length - 1;\n                        while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            const range = stack[i];\n                            stack.length = i;\n                            if (line > range.startLine && prevStart !== range.startLine) {\n                                range.endLine = line;\n                                addRange(range);\n                                prevStart = range.startLine;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    const rangeLimit = context && context.rangeLimit;\n    if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n        return ranges;\n    }\n    if (context && context.onRangeLimitExceeded) {\n        context.onRangeLimitExceeded(document.uri);\n    }\n    const counts = [];\n    for (let level of nestingLevels) {\n        if (level < 30) {\n            counts[level] = (counts[level] || 0) + 1;\n        }\n    }\n    let entries = 0;\n    let maxLevel = 0;\n    for (let i = 0; i < counts.length; i++) {\n        const n = counts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    const result = [];\n    for (let i = 0; i < ranges.length; i++) {\n        const level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, SelectionRange } from '../jsonLanguageTypes';\nimport { createScanner } from 'jsonc-parser';\nexport function getSelectionRanges(document, positions, doc) {\n    function getSelectionRange(position) {\n        let offset = document.offsetAt(position);\n        let node = doc.getNodeFromOffset(offset, true);\n        const result = [];\n        while (node) {\n            switch (node.type) {\n                case 'string':\n                case 'object':\n                case 'array':\n                    // range without \", [ or {\n                    const cStart = node.offset + 1, cEnd = node.offset + node.length - 1;\n                    if (cStart < cEnd && offset >= cStart && offset <= cEnd) {\n                        result.push(newRange(cStart, cEnd));\n                    }\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n                case 'number':\n                case 'boolean':\n                case 'null':\n                case 'property':\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n            }\n            if (node.type === 'property' || node.parent && node.parent.type === 'array') {\n                const afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* SyntaxKind.CommaToken */);\n                if (afterCommaOffset !== -1) {\n                    result.push(newRange(node.offset, afterCommaOffset));\n                }\n            }\n            node = node.parent;\n        }\n        let current = undefined;\n        for (let index = result.length - 1; index >= 0; index--) {\n            current = SelectionRange.create(result[index], current);\n        }\n        if (!current) {\n            current = SelectionRange.create(Range.create(position, position));\n        }\n        return current;\n    }\n    function newRange(start, end) {\n        return Range.create(document.positionAt(start), document.positionAt(end));\n    }\n    const scanner = createScanner(document.getText(), true);\n    function getOffsetAfterNextToken(offset, expectedToken) {\n        scanner.setPosition(offset);\n        let token = scanner.scan();\n        if (token === expectedToken) {\n            return scanner.getTokenOffset() + scanner.getTokenLength();\n        }\n        return -1;\n    }\n    return positions.map(getSelectionRange);\n}\n","import { format as formatJSON } from 'jsonc-parser';\nimport { Range, TextEdit } from '../jsonLanguageTypes';\nexport function format(documentToFormat, formattingOptions, formattingRange) {\n    let range = undefined;\n    if (formattingRange) {\n        const offset = documentToFormat.offsetAt(formattingRange.start);\n        const length = documentToFormat.offsetAt(formattingRange.end) - offset;\n        range = { offset, length };\n    }\n    const options = {\n        tabSize: formattingOptions ? formattingOptions.tabSize : 4,\n        insertSpaces: formattingOptions?.insertSpaces === true,\n        insertFinalNewline: formattingOptions?.insertFinalNewline === true,\n        eol: '\\n',\n        keepLines: formattingOptions?.keepLines === true\n    };\n    return formatJSON(documentToFormat.getText(), range, options).map(edit => {\n        return TextEdit.replace(Range.create(documentToFormat.positionAt(edit.offset), documentToFormat.positionAt(edit.offset + edit.length)), edit.content);\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nexport var Container;\n(function (Container) {\n    Container[Container[\"Object\"] = 0] = \"Object\";\n    Container[Container[\"Array\"] = 1] = \"Array\";\n})(Container || (Container = {}));\nexport class PropertyTree {\n    constructor(propertyName, beginningLineNumber) {\n        this.propertyName = propertyName ?? '';\n        this.beginningLineNumber = beginningLineNumber;\n        this.childrenProperties = [];\n        this.lastProperty = false;\n        this.noKeyName = false;\n    }\n    addChildProperty(childProperty) {\n        childProperty.parent = this;\n        if (this.childrenProperties.length > 0) {\n            let insertionIndex = 0;\n            if (childProperty.noKeyName) {\n                insertionIndex = this.childrenProperties.length;\n            }\n            else {\n                insertionIndex = binarySearchOnPropertyArray(this.childrenProperties, childProperty, compareProperties);\n            }\n            if (insertionIndex < 0) {\n                insertionIndex = (insertionIndex * -1) - 1;\n            }\n            this.childrenProperties.splice(insertionIndex, 0, childProperty);\n        }\n        else {\n            this.childrenProperties.push(childProperty);\n        }\n        return childProperty;\n    }\n}\nfunction compareProperties(propertyTree1, propertyTree2) {\n    const propertyName1 = propertyTree1.propertyName.toLowerCase();\n    const propertyName2 = propertyTree2.propertyName.toLowerCase();\n    if (propertyName1 < propertyName2) {\n        return -1;\n    }\n    else if (propertyName1 > propertyName2) {\n        return 1;\n    }\n    return 0;\n}\nfunction binarySearchOnPropertyArray(propertyTreeArray, propertyTree, compare_fn) {\n    const propertyName = propertyTree.propertyName.toLowerCase();\n    const firstPropertyInArrayName = propertyTreeArray[0].propertyName.toLowerCase();\n    const lastPropertyInArrayName = propertyTreeArray[propertyTreeArray.length - 1].propertyName.toLowerCase();\n    if (propertyName < firstPropertyInArrayName) {\n        return 0;\n    }\n    if (propertyName > lastPropertyInArrayName) {\n        return propertyTreeArray.length;\n    }\n    let m = 0;\n    let n = propertyTreeArray.length - 1;\n    while (m <= n) {\n        let k = (n + m) >> 1;\n        let cmp = compare_fn(propertyTree, propertyTreeArray[k]);\n        if (cmp > 0) {\n            m = k + 1;\n        }\n        else if (cmp < 0) {\n            n = k - 1;\n        }\n        else {\n            return k;\n        }\n    }\n    return -m - 1;\n}\n","/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\n// import { TextEdit} from 'vscode-languageserver-textdocument';\nimport { createScanner } from 'jsonc-parser';\nimport { TextDocument, TextEdit, Position, Range } from '../jsonLanguageTypes';\nimport { format } from './format';\nimport { PropertyTree, Container } from './propertyTree';\nexport function sort(documentToSort, formattingOptions) {\n    const options = {\n        ...formattingOptions,\n        keepLines: false, // keepLines must be false so that the properties are on separate lines for the sorting\n    };\n    const formattedJsonString = TextDocument.applyEdits(documentToSort, format(documentToSort, options, undefined));\n    const formattedJsonDocument = TextDocument.create('test://test.json', 'json', 0, formattedJsonString);\n    const jsonPropertyTree = findJsoncPropertyTree(formattedJsonDocument);\n    const sortedJsonDocument = sortJsoncDocument(formattedJsonDocument, jsonPropertyTree);\n    const edits = format(sortedJsonDocument, options, undefined);\n    const sortedAndFormattedJsonDocument = TextDocument.applyEdits(sortedJsonDocument, edits);\n    return [TextEdit.replace(Range.create(Position.create(0, 0), documentToSort.positionAt(documentToSort.getText().length)), sortedAndFormattedJsonDocument)];\n}\nfunction findJsoncPropertyTree(formattedDocument) {\n    const formattedString = formattedDocument.getText();\n    const scanner = createScanner(formattedString, false);\n    // The tree that will be returned\n    let rootTree = new PropertyTree();\n    // The tree where the current properties can be added as children\n    let currentTree = rootTree;\n    // The tree representing the current property analyzed\n    let currentProperty = rootTree;\n    // The tree representing the previous property analyzed\n    let lastProperty = rootTree;\n    // The current scanned token\n    let token = undefined;\n    // Line number of the last token found\n    let lastTokenLine = 0;\n    // Total number of characters on the lines prior to current line \n    let numberOfCharactersOnPreviousLines = 0;\n    // The last token scanned that is not trivial, nor a comment\n    let lastNonTriviaNonCommentToken = undefined;\n    // The second to last token scanned that is not trivial, nor a comment\n    let secondToLastNonTriviaNonCommentToken = undefined;\n    // Line number of last token that is not trivial, nor a comment\n    let lineOfLastNonTriviaNonCommentToken = -1;\n    // End index on its line of last token that is not trivial, nor a comment\n    let endIndexOfLastNonTriviaNonCommentToken = -1;\n    // Line number of the start of the range of current/next property\n    let beginningLineNumber = 0;\n    // Line number of the end of the range of current/next property\n    let endLineNumber = 0;\n    // Stack indicating whether we are inside of an object or an array\n    let currentContainerStack = [];\n    // Boolean indicating that the current property end line number needs to be updated. Used only when block comments are encountered.\n    let updateLastPropertyEndLineNumber = false;\n    // Boolean indicating that the beginning line number should be updated. Used only when block comments are encountered. \n    let updateBeginningLineNumber = false;\n    while ((token = scanner.scan()) !== 17 /* SyntaxKind.EOF */) {\n        // In the case when a block comment has been encountered that starts on the same line as the comma ending a property, update the end line of that\n        // property so that it covers the block comment. For example, if we have: \n        // 1. \"key\" : {}, /* some block\n        // 2. comment */\n        // Then, the end line of the property \"key\" should be line 2 not line 1\n        if (updateLastPropertyEndLineNumber === true\n            && token !== 14 /* SyntaxKind.LineBreakTrivia */\n            && token !== 15 /* SyntaxKind.Trivia */\n            && token !== 12 /* SyntaxKind.LineCommentTrivia */\n            && token !== 13 /* SyntaxKind.BlockCommentTrivia */\n            && currentProperty.endLineNumber === undefined) {\n            let endLineNumber = scanner.getTokenStartLine();\n            // Update the end line number in the case when the last property visited is a container (object or array)\n            if (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */\n                || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */) {\n                lastProperty.endLineNumber = endLineNumber - 1;\n            }\n            // Update the end line number in the case when the last property visited is a simple property \n            else {\n                currentProperty.endLineNumber = endLineNumber - 1;\n            }\n            beginningLineNumber = endLineNumber;\n            updateLastPropertyEndLineNumber = false;\n        }\n        // When a block comment follows an open brace or an open bracket, that block comment should be associated to that brace or bracket, not the property below it. For example, for:\n        // 1. { /*\n        // 2. ... */\n        // 3. \"key\" : {}\n        // 4. }\n        // Instead of associating the block comment to the property on line 3, it is associate to the property on line 1\n        if (updateBeginningLineNumber === true\n            && token !== 14 /* SyntaxKind.LineBreakTrivia */\n            && token !== 15 /* SyntaxKind.Trivia */\n            && token !== 12 /* SyntaxKind.LineCommentTrivia */\n            && token !== 13 /* SyntaxKind.BlockCommentTrivia */) {\n            beginningLineNumber = scanner.getTokenStartLine();\n            updateBeginningLineNumber = false;\n        }\n        // Update the number of characters on all the previous lines each time the new token is on a different line to the previous token\n        if (scanner.getTokenStartLine() !== lastTokenLine) {\n            for (let i = lastTokenLine; i < scanner.getTokenStartLine(); i++) {\n                const lengthOfLine = formattedDocument.getText(Range.create(Position.create(i, 0), Position.create(i + 1, 0))).length;\n                numberOfCharactersOnPreviousLines = numberOfCharactersOnPreviousLines + lengthOfLine;\n            }\n            lastTokenLine = scanner.getTokenStartLine();\n        }\n        switch (token) {\n            // When a string is found, if it follows an open brace or a comma token and it is within an object, then it corresponds to a key name, not a simple string\n            case 10 /* SyntaxKind.StringLiteral */: {\n                if ((lastNonTriviaNonCommentToken === undefined\n                    || lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */\n                    || (lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */\n                        && currentContainerStack[currentContainerStack.length - 1] === Container.Object))) {\n                    // In that case create the child property which starts at beginningLineNumber, add it to the current tree\n                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\n                    lastProperty = currentProperty;\n                    currentProperty = currentTree.addChildProperty(childProperty);\n                }\n                break;\n            }\n            // When the token is an open bracket, then we enter into an array\n            case 3 /* SyntaxKind.OpenBracketToken */: {\n                // If the root tree beginning line number is not defined, then this open bracket is the first open bracket in the document\n                if (rootTree.beginningLineNumber === undefined) {\n                    rootTree.beginningLineNumber = scanner.getTokenStartLine();\n                }\n                // Suppose we are inside of an object, then the current array is associated to a key, and has already been created\n                // We have the following configuration: {\"a\": \"val\", \"array\": [...], \"b\": \"val\"}\n                // In that case navigate down to the child property\n                if (currentContainerStack[currentContainerStack.length - 1] === Container.Object) {\n                    currentTree = currentProperty;\n                }\n                // Suppose we are inside of an array, then since the current array is not associated to a key, it has not been created yet\n                // We have the following configuration: [\"a\", [...], \"b\"]\n                // In that case create the property and navigate down\n                else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {\n                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\n                    childProperty.noKeyName = true;\n                    lastProperty = currentProperty;\n                    currentProperty = currentTree.addChildProperty(childProperty);\n                    currentTree = currentProperty;\n                }\n                currentContainerStack.push(Container.Array);\n                currentProperty.type = Container.Array;\n                beginningLineNumber = scanner.getTokenStartLine();\n                beginningLineNumber++;\n                break;\n            }\n            // When the token is an open brace, then we enter into an object\n            case 1 /* SyntaxKind.OpenBraceToken */: {\n                // If the root tree beginning line number is not defined, then this open brace is the first open brace in the document\n                if (rootTree.beginningLineNumber === undefined) {\n                    rootTree.beginningLineNumber = scanner.getTokenStartLine();\n                }\n                // 1. If we are inside of an objet, the current object is associated to a key and has already been created\n                // We have the following configuration: {\"a\": \"val\", \"object\": {...}, \"b\": \"val\"}\n                // 2. Otherwise the current object property is inside of an array, not associated to a key name and the property has not yet been created\n                // We have the following configuration: [\"a\", {...}, \"b\"]\n                else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {\n                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);\n                    childProperty.noKeyName = true;\n                    lastProperty = currentProperty;\n                    currentProperty = currentTree.addChildProperty(childProperty);\n                }\n                currentProperty.type = Container.Object;\n                currentContainerStack.push(Container.Object);\n                currentTree = currentProperty;\n                beginningLineNumber = scanner.getTokenStartLine();\n                beginningLineNumber++;\n                break;\n            }\n            case 4 /* SyntaxKind.CloseBracketToken */: {\n                endLineNumber = scanner.getTokenStartLine();\n                currentContainerStack.pop();\n                // If the last non-trivial non-comment token is a closing brace or bracket, then the currentProperty end line number has not been set yet so set it\n                // The configuration considered is: [..., {}] or [..., []]\n                if (currentProperty.endLineNumber === undefined\n                    && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */\n                        || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */)) {\n                    currentProperty.endLineNumber = endLineNumber - 1;\n                    currentProperty.lastProperty = true;\n                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;\n                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;\n                    lastProperty = currentProperty;\n                    currentProperty = currentProperty ? currentProperty.parent : undefined;\n                    currentTree = currentProperty;\n                }\n                rootTree.endLineNumber = endLineNumber;\n                beginningLineNumber = endLineNumber + 1;\n                break;\n            }\n            case 2 /* SyntaxKind.CloseBraceToken */: {\n                endLineNumber = scanner.getTokenStartLine();\n                currentContainerStack.pop();\n                // If we are not inside of an empty object\n                if (lastNonTriviaNonCommentToken !== 1 /* SyntaxKind.OpenBraceToken */) {\n                    // If current property end line number has not yet been defined, define it\n                    if (currentProperty.endLineNumber === undefined) {\n                        currentProperty.endLineNumber = endLineNumber - 1;\n                        // The current property is also the last property\n                        currentProperty.lastProperty = true;\n                        // The last property of an object is associated with the line and index of where to add the comma, in case after sorting, it is no longer the last property\n                        currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;\n                        currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;\n                    }\n                    lastProperty = currentProperty;\n                    currentProperty = currentProperty ? currentProperty.parent : undefined;\n                    currentTree = currentProperty;\n                }\n                rootTree.endLineNumber = scanner.getTokenStartLine();\n                beginningLineNumber = endLineNumber + 1;\n                break;\n            }\n            case 5 /* SyntaxKind.CommaToken */: {\n                endLineNumber = scanner.getTokenStartLine();\n                // If the current container is an object or the current container is an array and the last non-trivia non-comment token is a closing brace or a closing bracket\n                // Then update the end line number of the current property\n                if (currentProperty.endLineNumber === undefined\n                    && (currentContainerStack[currentContainerStack.length - 1] === Container.Object\n                        || (currentContainerStack[currentContainerStack.length - 1] === Container.Array\n                            && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */\n                                || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */)))) {\n                    currentProperty.endLineNumber = endLineNumber;\n                    // Store the line and the index of the comma in case it needs to be removed during the sorting\n                    currentProperty.commaIndex = scanner.getTokenOffset() - numberOfCharactersOnPreviousLines;\n                    currentProperty.commaLine = endLineNumber;\n                }\n                if (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */\n                    || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */) {\n                    lastProperty = currentProperty;\n                    currentProperty = currentProperty ? currentProperty.parent : undefined;\n                    currentTree = currentProperty;\n                }\n                beginningLineNumber = endLineNumber + 1;\n                break;\n            }\n            case 13 /* SyntaxKind.BlockCommentTrivia */: {\n                // If the last non trivia non-comment token is a comma and the block comment starts on the same line as the comma, then update the end line number of the current property. For example if:\n                // 1. {}, /* ...\n                // 2. ..*/\n                // The the property on line 1 shoud end on line 2, not line 1\n                // In the case we are in an array we update the end line number only if the second to last non-trivia non-comment token is a closing brace or bracket\n                if (lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */\n                    && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()\n                    && (currentContainerStack[currentContainerStack.length - 1] === Container.Array\n                        && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */\n                            || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */)\n                        || currentContainerStack[currentContainerStack.length - 1] === Container.Object)) {\n                    if (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */ || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */) || currentContainerStack[currentContainerStack.length - 1] === Container.Object) {\n                        currentProperty.endLineNumber = undefined;\n                        updateLastPropertyEndLineNumber = true;\n                    }\n                }\n                // When the block comment follows an open brace or an open token, we have the following scenario:\n                // { /**\n                // ../\n                // }\n                // The block comment should be assigned to the open brace not the first property below it\n                if ((lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */\n                    || lastNonTriviaNonCommentToken === 3 /* SyntaxKind.OpenBracketToken */)\n                    && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()) {\n                    updateBeginningLineNumber = true;\n                }\n                break;\n            }\n        }\n        // Update the last and second to last non-trivia non-comment tokens\n        if (token !== 14 /* SyntaxKind.LineBreakTrivia */\n            && token !== 13 /* SyntaxKind.BlockCommentTrivia */\n            && token !== 12 /* SyntaxKind.LineCommentTrivia */\n            && token !== 15 /* SyntaxKind.Trivia */) {\n            secondToLastNonTriviaNonCommentToken = lastNonTriviaNonCommentToken;\n            lastNonTriviaNonCommentToken = token;\n            lineOfLastNonTriviaNonCommentToken = scanner.getTokenStartLine();\n            endIndexOfLastNonTriviaNonCommentToken = scanner.getTokenOffset() + scanner.getTokenLength() - numberOfCharactersOnPreviousLines;\n        }\n    }\n    return rootTree;\n}\nfunction sortJsoncDocument(jsonDocument, propertyTree) {\n    if (propertyTree.childrenProperties.length === 0) {\n        return jsonDocument;\n    }\n    const sortedJsonDocument = TextDocument.create('test://test.json', 'json', 0, jsonDocument.getText());\n    const queueToSort = [];\n    updateSortingQueue(queueToSort, propertyTree, propertyTree.beginningLineNumber);\n    while (queueToSort.length > 0) {\n        const dataToSort = queueToSort.shift();\n        const propertyTreeArray = dataToSort.propertyTreeArray;\n        let beginningLineNumber = dataToSort.beginningLineNumber;\n        for (let i = 0; i < propertyTreeArray.length; i++) {\n            const propertyTree = propertyTreeArray[i];\n            const range = Range.create(Position.create(propertyTree.beginningLineNumber, 0), Position.create(propertyTree.endLineNumber + 1, 0));\n            const jsonContentToReplace = jsonDocument.getText(range);\n            const jsonDocumentToReplace = TextDocument.create('test://test.json', 'json', 0, jsonContentToReplace);\n            if (propertyTree.lastProperty === true && i !== propertyTreeArray.length - 1) {\n                const lineWhereToAddComma = propertyTree.lineWhereToAddComma - propertyTree.beginningLineNumber;\n                const indexWhereToAddComma = propertyTree.indexWhereToAddComa;\n                const edit = {\n                    range: Range.create(Position.create(lineWhereToAddComma, indexWhereToAddComma), Position.create(lineWhereToAddComma, indexWhereToAddComma)),\n                    text: ','\n                };\n                TextDocument.update(jsonDocumentToReplace, [edit], 1);\n            }\n            else if (propertyTree.lastProperty === false && i === propertyTreeArray.length - 1) {\n                const commaIndex = propertyTree.commaIndex;\n                const commaLine = propertyTree.commaLine;\n                const lineWhereToRemoveComma = commaLine - propertyTree.beginningLineNumber;\n                const edit = {\n                    range: Range.create(Position.create(lineWhereToRemoveComma, commaIndex), Position.create(lineWhereToRemoveComma, commaIndex + 1)),\n                    text: ''\n                };\n                TextDocument.update(jsonDocumentToReplace, [edit], 1);\n            }\n            const length = propertyTree.endLineNumber - propertyTree.beginningLineNumber + 1;\n            const edit = {\n                range: Range.create(Position.create(beginningLineNumber, 0), Position.create(beginningLineNumber + length, 0)),\n                text: jsonDocumentToReplace.getText()\n            };\n            TextDocument.update(sortedJsonDocument, [edit], 1);\n            updateSortingQueue(queueToSort, propertyTree, beginningLineNumber);\n            beginningLineNumber = beginningLineNumber + length;\n        }\n    }\n    return sortedJsonDocument;\n}\nfunction updateSortingQueue(queue, propertyTree, beginningLineNumber) {\n    if (propertyTree.childrenProperties.length === 0) {\n        return;\n    }\n    if (propertyTree.type === Container.Object) {\n        let minimumBeginningLineNumber = Infinity;\n        for (const childProperty of propertyTree.childrenProperties) {\n            if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {\n                minimumBeginningLineNumber = childProperty.beginningLineNumber;\n            }\n        }\n        const diff = minimumBeginningLineNumber - propertyTree.beginningLineNumber;\n        beginningLineNumber = beginningLineNumber + diff;\n        queue.push(new SortingRange(beginningLineNumber, propertyTree.childrenProperties));\n    }\n    else if (propertyTree.type === Container.Array) {\n        updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber);\n    }\n}\nfunction updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber) {\n    for (const subObject of propertyTree.childrenProperties) {\n        // If the child property of the array is an object, then you can sort the properties within this object\n        if (subObject.type === Container.Object) {\n            let minimumBeginningLineNumber = Infinity;\n            for (const childProperty of subObject.childrenProperties) {\n                if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {\n                    minimumBeginningLineNumber = childProperty.beginningLineNumber;\n                }\n            }\n            const diff = minimumBeginningLineNumber - subObject.beginningLineNumber;\n            queue.push(new SortingRange(beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber + diff, subObject.childrenProperties));\n        }\n        // If the child property of the array is an array, then you need to recurse on the children properties, until you find an object to sort\n        if (subObject.type === Container.Array) {\n            updateSortingQueueForArrayProperties(queue, subObject, beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber);\n        }\n    }\n}\nclass SortingRange {\n    constructor(beginningLineNumber, propertyTreeArray) {\n        this.beginningLineNumber = beginningLineNumber;\n        this.propertyTreeArray = propertyTreeArray;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../jsonLanguageTypes';\nexport function findLinks(document, doc) {\n    const links = [];\n    doc.visit(node => {\n        if (node.type === \"property\" && node.keyNode.value === \"$ref\" && node.valueNode?.type === 'string') {\n            const path = node.valueNode.value;\n            const targetNode = findTargetNode(doc, path);\n            if (targetNode) {\n                const targetPos = document.positionAt(targetNode.offset);\n                links.push({\n                    target: `${document.uri}#${targetPos.line + 1},${targetPos.character + 1}`,\n                    range: createRange(document, node.valueNode)\n                });\n            }\n        }\n        return true;\n    });\n    return Promise.resolve(links);\n}\nfunction createRange(document, node) {\n    return Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));\n}\nfunction findTargetNode(doc, path) {\n    const tokens = parseJSONPointer(path);\n    if (!tokens) {\n        return null;\n    }\n    return findNode(tokens, doc.root);\n}\nfunction findNode(pointer, node) {\n    if (!node) {\n        return null;\n    }\n    if (pointer.length === 0) {\n        return node;\n    }\n    const token = pointer.shift();\n    if (node && node.type === 'object') {\n        const propertyNode = node.properties.find((propertyNode) => propertyNode.keyNode.value === token);\n        if (!propertyNode) {\n            return null;\n        }\n        return findNode(pointer, propertyNode.valueNode);\n    }\n    else if (node && node.type === 'array') {\n        if (token.match(/^(0|[1-9][0-9]*)$/)) {\n            const index = Number.parseInt(token);\n            const arrayItem = node.items[index];\n            if (!arrayItem) {\n                return null;\n            }\n            return findNode(pointer, arrayItem);\n        }\n    }\n    return null;\n}\nfunction parseJSONPointer(path) {\n    if (path === \"#\") {\n        return [];\n    }\n    if (path[0] !== '#' || path[1] !== '/') {\n        return null;\n    }\n    return path.substring(2).split(/\\//).map(unescape);\n}\nfunction unescape(str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { JSONCompletion } from './services/jsonCompletion';\nimport { JSONHover } from './services/jsonHover';\nimport { JSONValidation } from './services/jsonValidation';\nimport { JSONDocumentSymbols } from './services/jsonDocumentSymbols';\nimport { parse as parseJSON, newJSONDocument } from './parser/jsonParser';\nimport { schemaContributions } from './services/configuration';\nimport { JSONSchemaService } from './services/jsonSchemaService';\nimport { getFoldingRanges } from './services/jsonFolding';\nimport { getSelectionRanges } from './services/jsonSelectionRanges';\nimport { sort } from './utils/sort';\nimport { format } from './utils/format';\nimport { findLinks } from './services/jsonLinks';\nexport * from './jsonLanguageTypes';\nexport function getLanguageService(params) {\n    const promise = params.promiseConstructor || Promise;\n    const jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\n    jsonSchemaService.setSchemaContributions(schemaContributions);\n    const jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\n    const jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\n    const jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\n    const jsonValidation = new JSONValidation(jsonSchemaService, promise);\n    return {\n        configure: (settings) => {\n            jsonSchemaService.clearExternalSchemas();\n            settings.schemas?.forEach(jsonSchemaService.registerExternalSchema.bind(jsonSchemaService));\n            jsonValidation.configure(settings);\n        },\n        resetSchema: (uri) => jsonSchemaService.onResourceChange(uri),\n        doValidation: jsonValidation.doValidation.bind(jsonValidation),\n        getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),\n        parseJSONDocument: (document) => parseJSON(document, { collectComments: true }),\n        newJSONDocument: (root, diagnostics) => newJSONDocument(root, diagnostics),\n        getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\n        doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\n        doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\n        findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\n        findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\n        findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\n        getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\n        doHover: jsonHover.doHover.bind(jsonHover),\n        getFoldingRanges,\n        getSelectionRanges,\n        findDefinition: () => Promise.resolve([]),\n        findLinks,\n        format: (document, range, options) => format(document, options, range),\n        sort: (document, options) => sort(document, options)\n    };\n}\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/browser/main');","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;\nconst ril_1 = require(\"./ril\");\n// Install the browser runtime abstract.\nril_1.default.install();\nconst api_1 = require(\"../common/api\");\n__exportStar(require(\"../common/api\"), exports);\nclass BrowserMessageReader extends api_1.AbstractMessageReader {\n    constructor(port) {\n        super();\n        this._onData = new api_1.Emitter();\n        this._messageListener = (event) => {\n            this._onData.fire(event.data);\n        };\n        port.addEventListener('error', (event) => this.fireError(event));\n        port.onmessage = this._messageListener;\n    }\n    listen(callback) {\n        return this._onData.event(callback);\n    }\n}\nexports.BrowserMessageReader = BrowserMessageReader;\nclass BrowserMessageWriter extends api_1.AbstractMessageWriter {\n    constructor(port) {\n        super();\n        this.port = port;\n        this.errorCount = 0;\n        port.addEventListener('error', (event) => this.fireError(event));\n    }\n    write(msg) {\n        try {\n            this.port.postMessage(msg);\n            return Promise.resolve();\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n    end() {\n    }\n}\nexports.BrowserMessageWriter = BrowserMessageWriter;\nfunction createMessageConnection(reader, writer, logger, options) {\n    if (logger === undefined) {\n        logger = api_1.NullLogger;\n    }\n    if (api_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return (0, api_1.createMessageConnection)(reader, writer, logger, options);\n}\nexports.createMessageConnection = createMessageConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst api_1 = require(\"../common/api\");\nclass MessageBuffer extends api_1.AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        super(encoding);\n        this.asciiDecoder = new TextDecoder('ascii');\n    }\n    emptyBuffer() {\n        return MessageBuffer.emptyBuffer;\n    }\n    fromString(value, _encoding) {\n        return (new TextEncoder()).encode(value);\n    }\n    toString(value, encoding) {\n        if (encoding === 'ascii') {\n            return this.asciiDecoder.decode(value);\n        }\n        else {\n            return (new TextDecoder(encoding)).decode(value);\n        }\n    }\n    asNative(buffer, length) {\n        if (length === undefined) {\n            return buffer;\n        }\n        else {\n            return buffer.slice(0, length);\n        }\n    }\n    allocNative(length) {\n        return new Uint8Array(length);\n    }\n}\nMessageBuffer.emptyBuffer = new Uint8Array(0);\nclass ReadableStreamWrapper {\n    constructor(socket) {\n        this.socket = socket;\n        this._onData = new api_1.Emitter();\n        this._messageListener = (event) => {\n            const blob = event.data;\n            blob.arrayBuffer().then((buffer) => {\n                this._onData.fire(new Uint8Array(buffer));\n            }, () => {\n                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);\n            });\n        };\n        this.socket.addEventListener('message', this._messageListener);\n    }\n    onClose(listener) {\n        this.socket.addEventListener('close', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));\n    }\n    onError(listener) {\n        this.socket.addEventListener('error', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));\n    }\n    onEnd(listener) {\n        this.socket.addEventListener('end', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));\n    }\n    onData(listener) {\n        return this._onData.event(listener);\n    }\n}\nclass WritableStreamWrapper {\n    constructor(socket) {\n        this.socket = socket;\n    }\n    onClose(listener) {\n        this.socket.addEventListener('close', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));\n    }\n    onError(listener) {\n        this.socket.addEventListener('error', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));\n    }\n    onEnd(listener) {\n        this.socket.addEventListener('end', listener);\n        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));\n    }\n    write(data, encoding) {\n        if (typeof data === 'string') {\n            if (encoding !== undefined && encoding !== 'utf-8') {\n                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);\n            }\n            this.socket.send(data);\n        }\n        else {\n            this.socket.send(data);\n        }\n        return Promise.resolve();\n    }\n    end() {\n        this.socket.close();\n    }\n}\nconst _textEncoder = new TextEncoder();\nconst _ril = Object.freeze({\n    messageBuffer: Object.freeze({\n        create: (encoding) => new MessageBuffer(encoding)\n    }),\n    applicationJson: Object.freeze({\n        encoder: Object.freeze({\n            name: 'application/json',\n            encode: (msg, options) => {\n                if (options.charset !== 'utf-8') {\n                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);\n                }\n                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));\n            }\n        }),\n        decoder: Object.freeze({\n            name: 'application/json',\n            decode: (buffer, options) => {\n                if (!(buffer instanceof Uint8Array)) {\n                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);\n                }\n                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));\n            }\n        })\n    }),\n    stream: Object.freeze({\n        asReadableStream: (socket) => new ReadableStreamWrapper(socket),\n        asWritableStream: (socket) => new WritableStreamWrapper(socket)\n    }),\n    console: console,\n    timer: Object.freeze({\n        setTimeout(callback, ms, ...args) {\n            const handle = setTimeout(callback, ms, ...args);\n            return { dispose: () => clearTimeout(handle) };\n        },\n        setImmediate(callback, ...args) {\n            const handle = setTimeout(callback, 0, ...args);\n            return { dispose: () => clearTimeout(handle) };\n        },\n        setInterval(callback, ms, ...args) {\n            const handle = setInterval(callback, ms, ...args);\n            return { dispose: () => clearInterval(handle) };\n        },\n    })\n});\nfunction RIL() {\n    return _ril;\n}\n(function (RIL) {\n    function install() {\n        api_1.RAL.install(_ril);\n    }\n    RIL.install = install;\n})(RIL || (RIL = {}));\nexports.default = RIL;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;\nexports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;\nconst messages_1 = require(\"./messages\");\nObject.defineProperty(exports, \"Message\", { enumerable: true, get: function () { return messages_1.Message; } });\nObject.defineProperty(exports, \"RequestType\", { enumerable: true, get: function () { return messages_1.RequestType; } });\nObject.defineProperty(exports, \"RequestType0\", { enumerable: true, get: function () { return messages_1.RequestType0; } });\nObject.defineProperty(exports, \"RequestType1\", { enumerable: true, get: function () { return messages_1.RequestType1; } });\nObject.defineProperty(exports, \"RequestType2\", { enumerable: true, get: function () { return messages_1.RequestType2; } });\nObject.defineProperty(exports, \"RequestType3\", { enumerable: true, get: function () { return messages_1.RequestType3; } });\nObject.defineProperty(exports, \"RequestType4\", { enumerable: true, get: function () { return messages_1.RequestType4; } });\nObject.defineProperty(exports, \"RequestType5\", { enumerable: true, get: function () { return messages_1.RequestType5; } });\nObject.defineProperty(exports, \"RequestType6\", { enumerable: true, get: function () { return messages_1.RequestType6; } });\nObject.defineProperty(exports, \"RequestType7\", { enumerable: true, get: function () { return messages_1.RequestType7; } });\nObject.defineProperty(exports, \"RequestType8\", { enumerable: true, get: function () { return messages_1.RequestType8; } });\nObject.defineProperty(exports, \"RequestType9\", { enumerable: true, get: function () { return messages_1.RequestType9; } });\nObject.defineProperty(exports, \"ResponseError\", { enumerable: true, get: function () { return messages_1.ResponseError; } });\nObject.defineProperty(exports, \"ErrorCodes\", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });\nObject.defineProperty(exports, \"NotificationType\", { enumerable: true, get: function () { return messages_1.NotificationType; } });\nObject.defineProperty(exports, \"NotificationType0\", { enumerable: true, get: function () { return messages_1.NotificationType0; } });\nObject.defineProperty(exports, \"NotificationType1\", { enumerable: true, get: function () { return messages_1.NotificationType1; } });\nObject.defineProperty(exports, \"NotificationType2\", { enumerable: true, get: function () { return messages_1.NotificationType2; } });\nObject.defineProperty(exports, \"NotificationType3\", { enumerable: true, get: function () { return messages_1.NotificationType3; } });\nObject.defineProperty(exports, \"NotificationType4\", { enumerable: true, get: function () { return messages_1.NotificationType4; } });\nObject.defineProperty(exports, \"NotificationType5\", { enumerable: true, get: function () { return messages_1.NotificationType5; } });\nObject.defineProperty(exports, \"NotificationType6\", { enumerable: true, get: function () { return messages_1.NotificationType6; } });\nObject.defineProperty(exports, \"NotificationType7\", { enumerable: true, get: function () { return messages_1.NotificationType7; } });\nObject.defineProperty(exports, \"NotificationType8\", { enumerable: true, get: function () { return messages_1.NotificationType8; } });\nObject.defineProperty(exports, \"NotificationType9\", { enumerable: true, get: function () { return messages_1.NotificationType9; } });\nObject.defineProperty(exports, \"ParameterStructures\", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });\nconst linkedMap_1 = require(\"./linkedMap\");\nObject.defineProperty(exports, \"LinkedMap\", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });\nObject.defineProperty(exports, \"LRUCache\", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });\nObject.defineProperty(exports, \"Touch\", { enumerable: true, get: function () { return linkedMap_1.Touch; } });\nconst disposable_1 = require(\"./disposable\");\nObject.defineProperty(exports, \"Disposable\", { enumerable: true, get: function () { return disposable_1.Disposable; } });\nconst events_1 = require(\"./events\");\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return events_1.Event; } });\nObject.defineProperty(exports, \"Emitter\", { enumerable: true, get: function () { return events_1.Emitter; } });\nconst cancellation_1 = require(\"./cancellation\");\nObject.defineProperty(exports, \"CancellationTokenSource\", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });\nconst sharedArrayCancellation_1 = require(\"./sharedArrayCancellation\");\nObject.defineProperty(exports, \"SharedArraySenderStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });\nObject.defineProperty(exports, \"SharedArrayReceiverStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });\nconst messageReader_1 = require(\"./messageReader\");\nObject.defineProperty(exports, \"MessageReader\", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });\nObject.defineProperty(exports, \"AbstractMessageReader\", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });\nObject.defineProperty(exports, \"ReadableStreamMessageReader\", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });\nconst messageWriter_1 = require(\"./messageWriter\");\nObject.defineProperty(exports, \"MessageWriter\", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });\nObject.defineProperty(exports, \"AbstractMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });\nObject.defineProperty(exports, \"WriteableStreamMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });\nconst messageBuffer_1 = require(\"./messageBuffer\");\nObject.defineProperty(exports, \"AbstractMessageBuffer\", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });\nconst connection_1 = require(\"./connection\");\nObject.defineProperty(exports, \"ConnectionStrategy\", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });\nObject.defineProperty(exports, \"ConnectionOptions\", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });\nObject.defineProperty(exports, \"NullLogger\", { enumerable: true, get: function () { return connection_1.NullLogger; } });\nObject.defineProperty(exports, \"createMessageConnection\", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });\nObject.defineProperty(exports, \"ProgressToken\", { enumerable: true, get: function () { return connection_1.ProgressToken; } });\nObject.defineProperty(exports, \"ProgressType\", { enumerable: true, get: function () { return connection_1.ProgressType; } });\nObject.defineProperty(exports, \"Trace\", { enumerable: true, get: function () { return connection_1.Trace; } });\nObject.defineProperty(exports, \"TraceValues\", { enumerable: true, get: function () { return connection_1.TraceValues; } });\nObject.defineProperty(exports, \"TraceFormat\", { enumerable: true, get: function () { return connection_1.TraceFormat; } });\nObject.defineProperty(exports, \"SetTraceNotification\", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });\nObject.defineProperty(exports, \"LogTraceNotification\", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });\nObject.defineProperty(exports, \"ConnectionErrors\", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });\nObject.defineProperty(exports, \"ConnectionError\", { enumerable: true, get: function () { return connection_1.ConnectionError; } });\nObject.defineProperty(exports, \"CancellationReceiverStrategy\", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });\nObject.defineProperty(exports, \"CancellationSenderStrategy\", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });\nObject.defineProperty(exports, \"CancellationStrategy\", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });\nObject.defineProperty(exports, \"MessageStrategy\", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });\nconst ral_1 = require(\"./ral\");\nexports.RAL = ral_1.default;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressToken;\n(function (ProgressToken) {\n    function is(value) {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n    ProgressToken.is = is;\n})(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Compact\"] = 2] = \"Compact\";\n    Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\n})(Trace = exports.Trace || (exports.Trace = {}));\nvar TraceValues;\n(function (TraceValues) {\n    /**\n     * Turn tracing off.\n     */\n    TraceValues.Off = 'off';\n    /**\n     * Trace messages only.\n     */\n    TraceValues.Messages = 'messages';\n    /**\n     * Compact message tracing.\n     */\n    TraceValues.Compact = 'compact';\n    /**\n     * Verbose message tracing.\n     */\n    TraceValues.Verbose = 'verbose';\n})(TraceValues = exports.TraceValues || (exports.TraceValues = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'compact':\n                return Trace.Compact;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Compact:\n                return 'compact';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace = exports.Trace || (exports.Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return TraceFormat.Text;\n        }\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\nvar IdCancellationReceiverStrategy;\n(function (IdCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    IdCancellationReceiverStrategy.is = is;\n})(IdCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = {}));\nvar RequestCancellationReceiverStrategy;\n(function (RequestCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    RequestCancellationReceiverStrategy.is = is;\n})(RequestCancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            return conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));\nvar MessageStrategy;\n(function (MessageStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.handleMessage);\n    }\n    MessageStrategy.is = is;\n})(MessageStrategy = exports.MessageStrategy || (exports.MessageStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSequenceNumber = 0;\n    let unknownResponseSequenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = new Map();\n    let starNotificationHandler = undefined;\n    const notificationHandlers = new Map();\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = new Map();\n    let knownCanceledRequests = new Set();\n    let requestTokens = new Map();\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSequenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.Message.isRequest(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = (0, ral_1.default)().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function handleMessage(message) {\n        if (messages_1.Message.isRequest(message)) {\n            handleRequest(message);\n        }\n        else if (messages_1.Message.isNotification(message)) {\n            handleNotification(message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            handleResponse(message);\n        }\n        else {\n            handleInvalidMessage(message);\n        }\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            const messageStrategy = options?.messageStrategy;\n            if (MessageStrategy.is(messageStrategy)) {\n                messageStrategy.handleMessage(message, handleMessage);\n            }\n            else {\n                handleMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\n                const cancelId = message.params.id;\n                const key = createRequestQueueKey(cancelId);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.Message.isRequest(toCancel)) {\n                    const strategy = options?.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        requestTokens.delete(cancelId);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\n                        return;\n                    }\n                }\n                const cancellationToken = requestTokens.get(cancelId);\n                // The request is already running. Cancel the token\n                if (cancellationToken !== undefined) {\n                    cancellationToken.cancel();\n                    traceReceivedNotification(message);\n                    return;\n                }\n                else {\n                    // Remember the cancel but still queue the message to\n                    // clean up state in process message.\n                    knownCanceledRequests.add(cancelId);\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers.get(requestMessage.method);\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = requestMessage.id ?? String(Date.now()); //\n            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)\n                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)\n                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\n            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\n                cancellationSource.cancel();\n            }\n            if (requestMessage.id !== null) {\n                requestTokens.set(tokenKey, cancellationSource);\n            }\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    requestTokens.delete(tokenKey);\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        requestTokens.delete(tokenKey);\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        requestTokens.delete(tokenKey);\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    requestTokens.delete(tokenKey);\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                requestTokens.delete(tokenKey);\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = responseMessage.id;\n            const responsePromise = responsePromises.get(key);\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise !== undefined) {\n                responsePromises.delete(key);\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            const cancelId = message.params.id;\n            knownCanceledRequests.delete(cancelId);\n            traceReceivedNotification(message);\n            return;\n        }\n        else {\n            const element = notificationHandlers.get(message.method);\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        // There are JSON-RPC libraries that send progress message as positional params although\n                        // specified as named. So convert them if this is the case.\n                        const params = message.params;\n                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\n                            notificationHandler({ token: params[0], value: params[1] });\n                        }\n                        else {\n                            if (type !== undefined) {\n                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                                }\n                                if (type.numberOfParams !== message.params.length) {\n                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\n                                }\n                            }\n                            notificationHandler(...params);\n                        }\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = responseMessage.id;\n            const responseHandler = responsePromises.get(key);\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function stringifyTrace(params) {\n        if (params === undefined || params === null) {\n            return undefined;\n        }\n        switch (trace) {\n            case Trace.Verbose:\n                return JSON.stringify(params, null, 4);\n            case Trace.Compact:\n                return JSON.stringify(params);\n            default:\n                return undefined;\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Received parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            return messageWriter.write(notificationMessage).catch((error) => {\n                logger.error(`Sending notification failed.`);\n                throw error;\n            });\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method;\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    method = type;\n                    notificationHandlers.set(type, { type: undefined, handler });\n                }\n                else {\n                    method = type.method;\n                    notificationHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method !== undefined) {\n                        notificationHandlers.delete(method);\n                    }\n                    else {\n                        starNotificationHandler = undefined;\n                    }\n                }\n            };\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            // This should not await but simple return to ensure that we don't have another\n            // async scheduling. Otherwise one send could overtake another send.\n            return connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    const p = cancellationStrategy.sender.sendCancellation(connection, id);\n                    if (p === undefined) {\n                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\n                        return Promise.resolve();\n                    }\n                    else {\n                        return p.catch(() => {\n                            logger.log(`Sending cancellation messages for id ${id} failed`);\n                        });\n                    }\n                });\n            }\n            const requestMessage = {\n                jsonrpc: version,\n                id: id,\n                method: method,\n                params: messageParams\n            };\n            traceSendingRequest(requestMessage);\n            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\n                cancellationStrategy.sender.enableCancellation(requestMessage);\n            }\n            return new Promise(async (resolve, reject) => {\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                try {\n                    await messageWriter.write(requestMessage);\n                    responsePromises.set(id, responsePromise);\n                }\n                catch (error) {\n                    logger.error(`Sending request failed.`);\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\n                    throw error;\n                }\n            });\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method = null;\n            if (StarRequestHandler.is(type)) {\n                method = undefined;\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                method = null;\n                if (handler !== undefined) {\n                    method = type;\n                    requestHandlers.set(type, { handler: handler, type: undefined });\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    method = type.method;\n                    requestHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method === null) {\n                        return;\n                    }\n                    if (method !== undefined) {\n                        requestHandlers.delete(method);\n                    }\n                    else {\n                        starRequestHandler = undefined;\n                    }\n                }\n            };\n        },\n        hasPendingResponse: () => {\n            return responsePromises.size > 0;\n        },\n        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        end: () => {\n            messageWriter.end();\n        },\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\n            for (const promise of responsePromises.values()) {\n                promise.reject(error);\n            }\n            responsePromises = new Map();\n            requestTokens = new Map();\n            knownCanceledRequests = new Set();\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            (0, ral_1.default)().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        const verbose = trace === Trace.Verbose || trace === Trace.Compact;\n        tracer.log(params.message, verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Disposable = void 0;\nvar Disposable;\n(function (Disposable) {\n    function create(func) {\n        return {\n            dispose: func\n        };\n    }\n    Disposable.create = create;\n})(Disposable = exports.Disposable || (exports.Disposable = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event = exports.Event || (exports.Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n(function (Touch) {\n    Touch.None = 0;\n    Touch.First = 1;\n    Touch.AsOld = Touch.First;\n    Touch.Last = 2;\n    Touch.AsNew = Touch.Last;\n})(Touch = exports.Touch || (exports.Touch = {}));\nclass LinkedMap {\n    constructor() {\n        this[_a] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        return this._head?.value;\n    }\n    get last() {\n        return this._tail?.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = Touch.None) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = Touch.None) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.First:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.Last:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\n            return;\n        }\n        if (touch === Touch.First) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === Touch.Last) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = Touch.AsNew) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, Touch.None);\n    }\n    set(key, value) {\n        super.set(key, value, Touch.Last);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n        this._chunks.push(toAppend);\n        this._totalLength += toAppend.byteLength;\n    }\n    tryReadHeaders(lowerCaseKeys = false) {\n        if (this._chunks.length === 0) {\n            return undefined;\n        }\n        let state = 0;\n        let chunkIndex = 0;\n        let offset = 0;\n        let chunkBytesRead = 0;\n        row: while (chunkIndex < this._chunks.length) {\n            const chunk = this._chunks[chunkIndex];\n            offset = 0;\n            column: while (offset < chunk.length) {\n                const value = chunk[offset];\n                switch (value) {\n                    case CR:\n                        switch (state) {\n                            case 0:\n                                state = 1;\n                                break;\n                            case 2:\n                                state = 3;\n                                break;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    case LF:\n                        switch (state) {\n                            case 1:\n                                state = 2;\n                                break;\n                            case 3:\n                                state = 4;\n                                offset++;\n                                break row;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    default:\n                        state = 0;\n                }\n                offset++;\n            }\n            chunkBytesRead += chunk.byteLength;\n            chunkIndex++;\n        }\n        if (state !== 4) {\n            return undefined;\n        }\n        // The buffer contains the two CRLF at the end. So we will\n        // have two empty lines after the split at the end as well.\n        const buffer = this._read(chunkBytesRead + offset);\n        const result = new Map();\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\n        if (headers.length < 2) {\n            return result;\n        }\n        for (let i = 0; i < headers.length - 2; i++) {\n            const header = headers[i];\n            const index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error('Message header must separate key and value using :');\n            }\n            const key = header.substr(0, index);\n            const value = header.substr(index + 1).trim();\n            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\n        }\n        return result;\n    }\n    tryReadBody(length) {\n        if (this._totalLength < length) {\n            return undefined;\n        }\n        return this._read(length);\n    }\n    get numberOfBytes() {\n        return this._totalLength;\n    }\n    _read(byteCount) {\n        if (byteCount === 0) {\n            return this.emptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(`Cannot read so many bytes!`);\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            const chunk = this._chunks[0];\n            this._chunks.shift();\n            this._totalLength -= byteCount;\n            return this.asNative(chunk);\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            const chunk = this._chunks[0];\n            const result = this.asNative(chunk, byteCount);\n            this._chunks[0] = chunk.slice(byteCount);\n            this._totalLength -= byteCount;\n            return result;\n        }\n        const result = this.allocNative(byteCount);\n        let resultOffset = 0;\n        let chunkIndex = 0;\n        while (byteCount > 0) {\n            const chunk = this._chunks[chunkIndex];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                const chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._chunks.shift();\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nconst semaphore_1 = require(\"./semaphore\");\nvar MessageReader;\n(function (MessageReader) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n    }\n    MessageReader.is = is;\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\nclass AbstractMessageReader {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.partialMessageEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error) {\n        this.errorEmitter.fire(this.asError(error));\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    get onPartialMessage() {\n        return this.partialMessageEmitter.event;\n    }\n    firePartialMessage(info) {\n        this.partialMessageEmitter.fire(info);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n    function fromOptions(options) {\n        let charset;\n        let result;\n        let contentDecoder;\n        const contentDecoders = new Map();\n        let contentTypeDecoder;\n        const contentTypeDecoders = new Map();\n        if (options === undefined || typeof options === 'string') {\n            charset = options ?? 'utf-8';\n        }\n        else {\n            charset = options.charset ?? 'utf-8';\n            if (options.contentDecoder !== undefined) {\n                contentDecoder = options.contentDecoder;\n                contentDecoders.set(contentDecoder.name, contentDecoder);\n            }\n            if (options.contentDecoders !== undefined) {\n                for (const decoder of options.contentDecoders) {\n                    contentDecoders.set(decoder.name, decoder);\n                }\n            }\n            if (options.contentTypeDecoder !== undefined) {\n                contentTypeDecoder = options.contentTypeDecoder;\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n            }\n            if (options.contentTypeDecoders !== undefined) {\n                for (const decoder of options.contentTypeDecoders) {\n                    contentTypeDecoders.set(decoder.name, decoder);\n                }\n            }\n        }\n        if (contentTypeDecoder === undefined) {\n            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n        }\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\n    }\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n    constructor(readable, options) {\n        super();\n        this.readable = readable;\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\n        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\n        this._partialMessageTimeout = 10000;\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.readSemaphore = new semaphore_1.Semaphore(1);\n    }\n    set partialMessageTimeout(timeout) {\n        this._partialMessageTimeout = timeout;\n    }\n    get partialMessageTimeout() {\n        return this._partialMessageTimeout;\n    }\n    listen(callback) {\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.partialMessageTimer = undefined;\n        this.callback = callback;\n        const result = this.readable.onData((data) => {\n            this.onData(data);\n        });\n        this.readable.onError((error) => this.fireError(error));\n        this.readable.onClose(() => this.fireClose());\n        return result;\n    }\n    onData(data) {\n        this.buffer.append(data);\n        while (true) {\n            if (this.nextMessageLength === -1) {\n                const headers = this.buffer.tryReadHeaders(true);\n                if (!headers) {\n                    return;\n                }\n                const contentLength = headers.get('content-length');\n                if (!contentLength) {\n                    this.fireError(new Error('Header must provide a Content-Length property.'));\n                    return;\n                }\n                const length = parseInt(contentLength);\n                if (isNaN(length)) {\n                    this.fireError(new Error('Content-Length value must be a number.'));\n                    return;\n                }\n                this.nextMessageLength = length;\n            }\n            const body = this.buffer.tryReadBody(this.nextMessageLength);\n            if (body === undefined) {\n                /** We haven't received the full message yet. */\n                this.setPartialMessageTimer();\n                return;\n            }\n            this.clearPartialMessageTimer();\n            this.nextMessageLength = -1;\n            // Make sure that we convert one received message after the\n            // other. Otherwise it could happen that a decoding of a second\n            // smaller message finished before the decoding of a first larger\n            // message and then we would deliver the second message first.\n            this.readSemaphore.lock(async () => {\n                const bytes = this.options.contentDecoder !== undefined\n                    ? await this.options.contentDecoder.decode(body)\n                    : body;\n                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\n                this.callback(message);\n            }).catch((error) => {\n                this.fireError(error);\n            });\n        }\n    }\n    clearPartialMessageTimer() {\n        if (this.partialMessageTimer) {\n            this.partialMessageTimer.dispose();\n            this.partialMessageTimer = undefined;\n        }\n    }\n    setPartialMessageTimer() {\n        this.clearPartialMessageTimer();\n        if (this._partialMessageTimeout <= 0) {\n            return;\n        }\n        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\n            this.partialMessageTimer = undefined;\n            if (token === this.messageToken) {\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\n                this.setPartialMessageTimer();\n            }\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n    }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst semaphore_1 = require(\"./semaphore\");\nconst events_1 = require(\"./events\");\nconst ContentLength = 'Content-Length: ';\nconst CRLF = '\\r\\n';\nvar MessageWriter;\n(function (MessageWriter) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\n            Is.func(candidate.onError) && Is.func(candidate.write);\n    }\n    MessageWriter.is = is;\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\nclass AbstractMessageWriter {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error, message, count) {\n        this.errorEmitter.fire([this.asError(error), message, count]);\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageWriter = AbstractMessageWriter;\nvar ResolvedMessageWriterOptions;\n(function (ResolvedMessageWriterOptions) {\n    function fromOptions(options) {\n        if (options === undefined || typeof options === 'string') {\n            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };\n        }\n        else {\n            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };\n        }\n    }\n    ResolvedMessageWriterOptions.fromOptions = fromOptions;\n})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));\nclass WriteableStreamMessageWriter extends AbstractMessageWriter {\n    constructor(writable, options) {\n        super();\n        this.writable = writable;\n        this.options = ResolvedMessageWriterOptions.fromOptions(options);\n        this.errorCount = 0;\n        this.writeSemaphore = new semaphore_1.Semaphore(1);\n        this.writable.onError((error) => this.fireError(error));\n        this.writable.onClose(() => this.fireClose());\n    }\n    async write(msg) {\n        return this.writeSemaphore.lock(async () => {\n            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {\n                if (this.options.contentEncoder !== undefined) {\n                    return this.options.contentEncoder.encode(buffer);\n                }\n                else {\n                    return buffer;\n                }\n            });\n            return payload.then((buffer) => {\n                const headers = [];\n                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);\n                headers.push(CRLF);\n                return this.doWrite(msg, headers, buffer);\n            }, (error) => {\n                this.fireError(error);\n                throw error;\n            });\n        });\n    }\n    async doWrite(msg, headers, data) {\n        try {\n            await this.writable.write(headers.join(''), 'ascii');\n            return this.writable.write(data);\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n    end() {\n        this.writable.end();\n    }\n}\nexports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;\nconst is = require(\"./is\");\n/**\n * Predefined error codes.\n */\nvar ErrorCodes;\n(function (ErrorCodes) {\n    // Defined by JSON RPC\n    ErrorCodes.ParseError = -32700;\n    ErrorCodes.InvalidRequest = -32600;\n    ErrorCodes.MethodNotFound = -32601;\n    ErrorCodes.InvalidParams = -32602;\n    ErrorCodes.InternalError = -32603;\n    /**\n     * This is the start range of JSON RPC reserved error codes.\n     * It doesn't denote a real error code. No application error codes should\n     * be defined between the start and end range. For backwards\n     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`\n     * are left in the range.\n     *\n     * @since 3.16.0\n    */\n    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;\n    /** @deprecated use  jsonrpcReservedErrorRangeStart */\n    ErrorCodes.serverErrorStart = -32099;\n    /**\n     * An error occurred when write a message to the transport layer.\n     */\n    ErrorCodes.MessageWriteError = -32099;\n    /**\n     * An error occurred when reading a message from the transport layer.\n     */\n    ErrorCodes.MessageReadError = -32098;\n    /**\n     * The connection got disposed or lost and all pending responses got\n     * rejected.\n     */\n    ErrorCodes.PendingResponseRejected = -32097;\n    /**\n     * The connection is inactive and a use of it failed.\n     */\n    ErrorCodes.ConnectionInactive = -32096;\n    /**\n     * Error code indicating that a server received a notification or\n     * request before the server has received the `initialize` request.\n     */\n    ErrorCodes.ServerNotInitialized = -32002;\n    ErrorCodes.UnknownErrorCode = -32001;\n    /**\n     * This is the end range of JSON RPC reserved error codes.\n     * It doesn't denote a real error code.\n     *\n     * @since 3.16.0\n    */\n    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;\n    /** @deprecated use  jsonrpcReservedErrorRangeEnd */\n    ErrorCodes.serverErrorEnd = -32000;\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\n/**\n * An error object return in a response in case a request\n * has failed.\n */\nclass ResponseError extends Error {\n    constructor(code, message, data) {\n        super(message);\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\n        this.data = data;\n        Object.setPrototypeOf(this, ResponseError.prototype);\n    }\n    toJson() {\n        const result = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            result.data = this.data;\n        }\n        return result;\n    }\n}\nexports.ResponseError = ResponseError;\nclass ParameterStructures {\n    constructor(kind) {\n        this.kind = kind;\n    }\n    static is(value) {\n        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;\n    }\n    toString() {\n        return this.kind;\n    }\n}\nexports.ParameterStructures = ParameterStructures;\n/**\n * The parameter structure is automatically inferred on the number of parameters\n * and the parameter type in case of a single param.\n */\nParameterStructures.auto = new ParameterStructures('auto');\n/**\n * Forces `byPosition` parameter structure. This is useful if you have a single\n * parameter which has a literal type.\n */\nParameterStructures.byPosition = new ParameterStructures('byPosition');\n/**\n * Forces `byName` parameter structure. This is only useful when having a single\n * parameter. The library will report errors if used with a different number of\n * parameters.\n */\nParameterStructures.byName = new ParameterStructures('byName');\n/**\n * An abstract implementation of a MessageType.\n */\nclass AbstractMessageSignature {\n    constructor(method, numberOfParams) {\n        this.method = method;\n        this.numberOfParams = numberOfParams;\n    }\n    get parameterStructures() {\n        return ParameterStructures.auto;\n    }\n}\nexports.AbstractMessageSignature = AbstractMessageSignature;\n/**\n * Classes to type request response pairs\n */\nclass RequestType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.RequestType0 = RequestType0;\nclass RequestType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType = RequestType;\nclass RequestType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType1 = RequestType1;\nclass RequestType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.RequestType2 = RequestType2;\nclass RequestType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.RequestType3 = RequestType3;\nclass RequestType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.RequestType4 = RequestType4;\nclass RequestType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.RequestType5 = RequestType5;\nclass RequestType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.RequestType6 = RequestType6;\nclass RequestType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.RequestType7 = RequestType7;\nclass RequestType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.RequestType8 = RequestType8;\nclass RequestType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.RequestType9 = RequestType9;\nclass NotificationType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType = NotificationType;\nclass NotificationType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.NotificationType0 = NotificationType0;\nclass NotificationType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType1 = NotificationType1;\nclass NotificationType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.NotificationType2 = NotificationType2;\nclass NotificationType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.NotificationType3 = NotificationType3;\nclass NotificationType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.NotificationType4 = NotificationType4;\nclass NotificationType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.NotificationType5 = NotificationType5;\nclass NotificationType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.NotificationType6 = NotificationType6;\nclass NotificationType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.NotificationType7 = NotificationType7;\nclass NotificationType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.NotificationType8 = NotificationType8;\nclass NotificationType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.NotificationType9 = NotificationType9;\nvar Message;\n(function (Message) {\n    /**\n     * Tests if the given message is a request message\n     */\n    function isRequest(message) {\n        const candidate = message;\n        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\n    }\n    Message.isRequest = isRequest;\n    /**\n     * Tests if the given message is a notification message\n     */\n    function isNotification(message) {\n        const candidate = message;\n        return candidate && is.string(candidate.method) && message.id === void 0;\n    }\n    Message.isNotification = isNotification;\n    /**\n     * Tests if the given message is a response message\n     */\n    function isResponse(message) {\n        const candidate = message;\n        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\n    }\n    Message.isResponse = isResponse;\n})(Message = exports.Message || (exports.Message = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Semaphore = void 0;\nconst ral_1 = require(\"./ral\");\nclass Semaphore {\n    constructor(capacity = 1) {\n        if (capacity <= 0) {\n            throw new Error('Capacity must be greater than 0');\n        }\n        this._capacity = capacity;\n        this._active = 0;\n        this._waiting = [];\n    }\n    lock(thunk) {\n        return new Promise((resolve, reject) => {\n            this._waiting.push({ thunk, resolve, reject });\n            this.runNext();\n        });\n    }\n    get active() {\n        return this._active;\n    }\n    runNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());\n    }\n    doRunNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        const next = this._waiting.shift();\n        this._active++;\n        if (this._active > this._capacity) {\n            throw new Error(`To many thunks active`);\n        }\n        try {\n            const result = next.thunk();\n            if (result instanceof Promise) {\n                result.then((value) => {\n                    this._active--;\n                    next.resolve(value);\n                    this.runNext();\n                }, (err) => {\n                    this._active--;\n                    next.reject(err);\n                    this.runNext();\n                });\n            }\n            else {\n                this._active--;\n                next.resolve(result);\n                this.runNext();\n            }\n        }\n        catch (err) {\n            this._active--;\n            next.reject(err);\n            this.runNext();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;\nconst cancellation_1 = require(\"./cancellation\");\nvar CancellationState;\n(function (CancellationState) {\n    CancellationState.Continue = 0;\n    CancellationState.Cancelled = 1;\n})(CancellationState || (CancellationState = {}));\nclass SharedArraySenderStrategy {\n    constructor() {\n        this.buffers = new Map();\n    }\n    enableCancellation(request) {\n        if (request.id === null) {\n            return;\n        }\n        const buffer = new SharedArrayBuffer(4);\n        const data = new Int32Array(buffer, 0, 1);\n        data[0] = CancellationState.Continue;\n        this.buffers.set(request.id, buffer);\n        request.$cancellationData = buffer;\n    }\n    async sendCancellation(_conn, id) {\n        const buffer = this.buffers.get(id);\n        if (buffer === undefined) {\n            return;\n        }\n        const data = new Int32Array(buffer, 0, 1);\n        Atomics.store(data, 0, CancellationState.Cancelled);\n    }\n    cleanup(id) {\n        this.buffers.delete(id);\n    }\n    dispose() {\n        this.buffers.clear();\n    }\n}\nexports.SharedArraySenderStrategy = SharedArraySenderStrategy;\nclass SharedArrayBufferCancellationToken {\n    constructor(buffer) {\n        this.data = new Int32Array(buffer, 0, 1);\n    }\n    get isCancellationRequested() {\n        return Atomics.load(this.data, 0) === CancellationState.Cancelled;\n    }\n    get onCancellationRequested() {\n        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);\n    }\n}\nclass SharedArrayBufferCancellationTokenSource {\n    constructor(buffer) {\n        this.token = new SharedArrayBufferCancellationToken(buffer);\n    }\n    cancel() {\n    }\n    dispose() {\n    }\n}\nclass SharedArrayReceiverStrategy {\n    constructor() {\n        this.kind = 'request';\n    }\n    createCancellationTokenSource(request) {\n        const buffer = request.$cancellationData;\n        if (buffer === undefined) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n        return new SharedArrayBufferCancellationTokenSource(buffer);\n    }\n}\nexports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/browser/main');","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProtocolConnection = void 0;\nconst browser_1 = require(\"vscode-jsonrpc/browser\");\n__exportStar(require(\"vscode-jsonrpc/browser\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nfunction createProtocolConnection(reader, writer, logger, options) {\n    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LSPErrorCodes = exports.createProtocolConnection = void 0;\n__exportStar(require(\"vscode-jsonrpc\"), exports);\n__exportStar(require(\"vscode-languageserver-types\"), exports);\n__exportStar(require(\"./messages\"), exports);\n__exportStar(require(\"./protocol\"), exports);\nvar connection_1 = require(\"./connection\");\nObject.defineProperty(exports, \"createProtocolConnection\", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });\nvar LSPErrorCodes;\n(function (LSPErrorCodes) {\n    /**\n    * This is the start range of LSP reserved error codes.\n    * It doesn't denote a real error code.\n    *\n    * @since 3.16.0\n    */\n    LSPErrorCodes.lspReservedErrorRangeStart = -32899;\n    /**\n     * A request failed but it was syntactically correct, e.g the\n     * method name was known and the parameters were valid. The error\n     * message should contain human readable information about why\n     * the request failed.\n     *\n     * @since 3.17.0\n     */\n    LSPErrorCodes.RequestFailed = -32803;\n    /**\n     * The server cancelled the request. This error code should\n     * only be used for requests that explicitly support being\n     * server cancellable.\n     *\n     * @since 3.17.0\n     */\n    LSPErrorCodes.ServerCancelled = -32802;\n    /**\n     * The server detected that the content of a document got\n     * modified outside normal conditions. A server should\n     * NOT send this error code if it detects a content change\n     * in it unprocessed messages. The result even computed\n     * on an older state might still be useful for the client.\n     *\n     * If a client decides that a result is not of any use anymore\n     * the client should cancel the request.\n     */\n    LSPErrorCodes.ContentModified = -32801;\n    /**\n     * The client has canceled a request and a server as detected\n     * the cancel.\n     */\n    LSPErrorCodes.RequestCancelled = -32800;\n    /**\n    * This is the end range of LSP reserved error codes.\n    * It doesn't denote a real error code.\n    *\n    * @since 3.16.0\n    */\n    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;\n})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProtocolConnection = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nfunction createProtocolConnection(input, output, logger, options) {\n    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nvar MessageDirection;\n(function (MessageDirection) {\n    MessageDirection[\"clientToServer\"] = \"clientToServer\";\n    MessageDirection[\"serverToClient\"] = \"serverToClient\";\n    MessageDirection[\"both\"] = \"both\";\n})(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));\nclass RegistrationType {\n    constructor(method) {\n        this.method = method;\n    }\n}\nexports.RegistrationType = RegistrationType;\nclass ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolRequestType0 = ProtocolRequestType0;\nclass ProtocolRequestType extends vscode_jsonrpc_1.RequestType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolRequestType = ProtocolRequestType;\nclass ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolNotificationType0 = ProtocolNotificationType0;\nclass ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolNotificationType = ProtocolNotificationType;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to result a `CallHierarchyItem` in a document at a given position.\n * Can be used as an input to an incoming or outgoing call hierarchy.\n *\n * @since 3.16.0\n */\nvar CallHierarchyPrepareRequest;\n(function (CallHierarchyPrepareRequest) {\n    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';\n    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);\n})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));\n/**\n * A request to resolve the incoming calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyIncomingCallsRequest;\n(function (CallHierarchyIncomingCallsRequest) {\n    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';\n    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);\n})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));\n/**\n * A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyOutgoingCallsRequest;\n(function (CallHierarchyOutgoingCallsRequest) {\n    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';\n    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);\n})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to list all color symbols found in a given text document. The request's\n * parameter is of type {@link DocumentColorParams} the\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n * that resolves to such.\n */\nvar DocumentColorRequest;\n(function (DocumentColorRequest) {\n    DocumentColorRequest.method = 'textDocument/documentColor';\n    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);\n})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));\n/**\n * A request to list all presentation for a color. The request's\n * parameter is of type {@link ColorPresentationParams} the\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n * that resolves to such.\n */\nvar ColorPresentationRequest;\n(function (ColorPresentationRequest) {\n    ColorPresentationRequest.method = 'textDocument/colorPresentation';\n    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);\n})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n//---- Get Configuration request ----\n/**\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\n * configuration setting.\n *\n * This pull model replaces the old push model were the client signaled configuration change via an\n * event. If the server still needs to react to configuration changes (since the server caches the\n * result of `workspace/configuration` requests) the server should register for an empty configuration\n * change event and empty the cache if such an event is received.\n */\nvar ConfigurationRequest;\n(function (ConfigurationRequest) {\n    ConfigurationRequest.method = 'workspace/configuration';\n    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);\n})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeclarationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositionParams]\n * (#TextDocumentPositionParams) the response is of type {@link Declaration}\n * or a typed array of {@link DeclarationLink} or a Thenable that resolves\n * to such.\n */\nvar DeclarationRequest;\n(function (DeclarationRequest) {\n    DeclarationRequest.method = 'textDocument/declaration';\n    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);\n})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nconst Is = require(\"./utils/is\");\nconst messages_1 = require(\"./messages\");\n/**\n * @since 3.17.0\n */\nvar DiagnosticServerCancellationData;\n(function (DiagnosticServerCancellationData) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.boolean(candidate.retriggerRequest);\n    }\n    DiagnosticServerCancellationData.is = is;\n})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));\n/**\n * The document diagnostic report kinds.\n *\n * @since 3.17.0\n */\nvar DocumentDiagnosticReportKind;\n(function (DocumentDiagnosticReportKind) {\n    /**\n     * A diagnostic report with a full\n     * set of problems.\n     */\n    DocumentDiagnosticReportKind.Full = 'full';\n    /**\n     * A report indicating that the last\n     * returned report is still accurate.\n     */\n    DocumentDiagnosticReportKind.Unchanged = 'unchanged';\n})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));\n/**\n * The document diagnostic request definition.\n *\n * @since 3.17.0\n */\nvar DocumentDiagnosticRequest;\n(function (DocumentDiagnosticRequest) {\n    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';\n    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);\n    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\n})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));\n/**\n * The workspace diagnostic request definition.\n *\n * @since 3.17.0\n */\nvar WorkspaceDiagnosticRequest;\n(function (WorkspaceDiagnosticRequest) {\n    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';\n    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);\n    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\n})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));\n/**\n * The diagnostic refresh request definition.\n *\n * @since 3.17.0\n */\nvar DiagnosticRefreshRequest;\n(function (DiagnosticRefreshRequest) {\n    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;\n    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);\n})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A pattern kind describing if a glob pattern matches a file a folder or\n * both.\n *\n * @since 3.16.0\n */\nvar FileOperationPatternKind;\n(function (FileOperationPatternKind) {\n    /**\n     * The pattern matches a file only.\n     */\n    FileOperationPatternKind.file = 'file';\n    /**\n     * The pattern matches a folder only.\n     */\n    FileOperationPatternKind.folder = 'folder';\n})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));\n/**\n * The will create files request is sent from the client to the server before files are actually\n * created as long as the creation is triggered from within the client.\n *\n * The request can return a `WorkspaceEdit` which will be applied to workspace before the\n * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file\n * to be created.\n *\n * @since 3.16.0\n */\nvar WillCreateFilesRequest;\n(function (WillCreateFilesRequest) {\n    WillCreateFilesRequest.method = 'workspace/willCreateFiles';\n    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);\n})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));\n/**\n * The did create files notification is sent from the client to the server when\n * files were created from within the client.\n *\n * @since 3.16.0\n */\nvar DidCreateFilesNotification;\n(function (DidCreateFilesNotification) {\n    DidCreateFilesNotification.method = 'workspace/didCreateFiles';\n    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);\n})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));\n/**\n * The will rename files request is sent from the client to the server before files are actually\n * renamed as long as the rename is triggered from within the client.\n *\n * @since 3.16.0\n */\nvar WillRenameFilesRequest;\n(function (WillRenameFilesRequest) {\n    WillRenameFilesRequest.method = 'workspace/willRenameFiles';\n    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);\n})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));\n/**\n * The did rename files notification is sent from the client to the server when\n * files were renamed from within the client.\n *\n * @since 3.16.0\n */\nvar DidRenameFilesNotification;\n(function (DidRenameFilesNotification) {\n    DidRenameFilesNotification.method = 'workspace/didRenameFiles';\n    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);\n})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));\n/**\n * The will delete files request is sent from the client to the server before files are actually\n * deleted as long as the deletion is triggered from within the client.\n *\n * @since 3.16.0\n */\nvar DidDeleteFilesNotification;\n(function (DidDeleteFilesNotification) {\n    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';\n    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);\n})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));\n/**\n * The did delete files notification is sent from the client to the server when\n * files were deleted from within the client.\n *\n * @since 3.16.0\n */\nvar WillDeleteFilesRequest;\n(function (WillDeleteFilesRequest) {\n    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';\n    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);\n})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FoldingRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide folding ranges in a document. The request's\n * parameter is of type {@link FoldingRangeParams}, the\n * response is of type {@link FoldingRangeList} or a Thenable\n * that resolves to such.\n */\nvar FoldingRangeRequest;\n(function (FoldingRangeRequest) {\n    FoldingRangeRequest.method = 'textDocument/foldingRange';\n    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);\n})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImplementationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the implementation locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositionParams]\n * (#TextDocumentPositionParams) the response is of type {@link Definition} or a\n * Thenable that resolves to such.\n */\nvar ImplementationRequest;\n(function (ImplementationRequest) {\n    ImplementationRequest.method = 'textDocument/implementation';\n    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);\n})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide inlay hints in a document. The request's parameter is of\n * type {@link InlayHintsParams}, the response is of type\n * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlayHintRequest;\n(function (InlayHintRequest) {\n    InlayHintRequest.method = 'textDocument/inlayHint';\n    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);\n})(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));\n/**\n * A request to resolve additional properties for an inlay hint.\n * The request's parameter is of type {@link InlayHint}, the response is\n * of type {@link InlayHint} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlayHintResolveRequest;\n(function (InlayHintResolveRequest) {\n    InlayHintResolveRequest.method = 'inlayHint/resolve';\n    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);\n})(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));\n/**\n * @since 3.17.0\n */\nvar InlayHintRefreshRequest;\n(function (InlayHintRefreshRequest) {\n    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;\n    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);\n})(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide inline values in a document. The request's parameter is of\n * type {@link InlineValueParams}, the response is of type\n * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlineValueRequest;\n(function (InlineValueRequest) {\n    InlineValueRequest.method = 'textDocument/inlineValue';\n    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);\n})(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));\n/**\n * @since 3.17.0\n */\nvar InlineValueRefreshRequest;\n(function (InlineValueRefreshRequest) {\n    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;\n    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);\n})(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;\nexports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;\nexports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;\nconst messages_1 = require(\"./messages\");\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst Is = require(\"./utils/is\");\nconst protocol_implementation_1 = require(\"./protocol.implementation\");\nObject.defineProperty(exports, \"ImplementationRequest\", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });\nconst protocol_typeDefinition_1 = require(\"./protocol.typeDefinition\");\nObject.defineProperty(exports, \"TypeDefinitionRequest\", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });\nconst protocol_workspaceFolder_1 = require(\"./protocol.workspaceFolder\");\nObject.defineProperty(exports, \"WorkspaceFoldersRequest\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });\nObject.defineProperty(exports, \"DidChangeWorkspaceFoldersNotification\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });\nconst protocol_configuration_1 = require(\"./protocol.configuration\");\nObject.defineProperty(exports, \"ConfigurationRequest\", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });\nconst protocol_colorProvider_1 = require(\"./protocol.colorProvider\");\nObject.defineProperty(exports, \"DocumentColorRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });\nObject.defineProperty(exports, \"ColorPresentationRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });\nconst protocol_foldingRange_1 = require(\"./protocol.foldingRange\");\nObject.defineProperty(exports, \"FoldingRangeRequest\", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });\nconst protocol_declaration_1 = require(\"./protocol.declaration\");\nObject.defineProperty(exports, \"DeclarationRequest\", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });\nconst protocol_selectionRange_1 = require(\"./protocol.selectionRange\");\nObject.defineProperty(exports, \"SelectionRangeRequest\", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });\nconst protocol_progress_1 = require(\"./protocol.progress\");\nObject.defineProperty(exports, \"WorkDoneProgress\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });\nObject.defineProperty(exports, \"WorkDoneProgressCreateRequest\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });\nObject.defineProperty(exports, \"WorkDoneProgressCancelNotification\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });\nconst protocol_callHierarchy_1 = require(\"./protocol.callHierarchy\");\nObject.defineProperty(exports, \"CallHierarchyIncomingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });\nObject.defineProperty(exports, \"CallHierarchyOutgoingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });\nObject.defineProperty(exports, \"CallHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });\nconst protocol_semanticTokens_1 = require(\"./protocol.semanticTokens\");\nObject.defineProperty(exports, \"TokenFormat\", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });\nObject.defineProperty(exports, \"SemanticTokensRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });\nObject.defineProperty(exports, \"SemanticTokensDeltaRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRangeRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRefreshRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRegistrationType\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });\nconst protocol_showDocument_1 = require(\"./protocol.showDocument\");\nObject.defineProperty(exports, \"ShowDocumentRequest\", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });\nconst protocol_linkedEditingRange_1 = require(\"./protocol.linkedEditingRange\");\nObject.defineProperty(exports, \"LinkedEditingRangeRequest\", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });\nconst protocol_fileOperations_1 = require(\"./protocol.fileOperations\");\nObject.defineProperty(exports, \"FileOperationPatternKind\", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });\nObject.defineProperty(exports, \"DidCreateFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });\nObject.defineProperty(exports, \"WillCreateFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });\nObject.defineProperty(exports, \"DidRenameFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });\nObject.defineProperty(exports, \"WillRenameFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });\nObject.defineProperty(exports, \"DidDeleteFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });\nObject.defineProperty(exports, \"WillDeleteFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });\nconst protocol_moniker_1 = require(\"./protocol.moniker\");\nObject.defineProperty(exports, \"UniquenessLevel\", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });\nObject.defineProperty(exports, \"MonikerKind\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });\nObject.defineProperty(exports, \"MonikerRequest\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });\nconst protocol_typeHierarchy_1 = require(\"./protocol.typeHierarchy\");\nObject.defineProperty(exports, \"TypeHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });\nObject.defineProperty(exports, \"TypeHierarchySubtypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });\nObject.defineProperty(exports, \"TypeHierarchySupertypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });\nconst protocol_inlineValue_1 = require(\"./protocol.inlineValue\");\nObject.defineProperty(exports, \"InlineValueRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });\nObject.defineProperty(exports, \"InlineValueRefreshRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });\nconst protocol_inlayHint_1 = require(\"./protocol.inlayHint\");\nObject.defineProperty(exports, \"InlayHintRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });\nObject.defineProperty(exports, \"InlayHintResolveRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });\nObject.defineProperty(exports, \"InlayHintRefreshRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });\nconst protocol_diagnostic_1 = require(\"./protocol.diagnostic\");\nObject.defineProperty(exports, \"DiagnosticServerCancellationData\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });\nObject.defineProperty(exports, \"DocumentDiagnosticReportKind\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });\nObject.defineProperty(exports, \"DocumentDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });\nObject.defineProperty(exports, \"WorkspaceDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });\nObject.defineProperty(exports, \"DiagnosticRefreshRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });\nconst protocol_notebook_1 = require(\"./protocol.notebook\");\nObject.defineProperty(exports, \"NotebookCellKind\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });\nObject.defineProperty(exports, \"ExecutionSummary\", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });\nObject.defineProperty(exports, \"NotebookCell\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });\nObject.defineProperty(exports, \"NotebookDocument\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });\nObject.defineProperty(exports, \"NotebookDocumentSyncRegistrationType\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });\nObject.defineProperty(exports, \"DidOpenNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"NotebookCellArrayChange\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });\nObject.defineProperty(exports, \"DidChangeNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"DidSaveNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"DidCloseNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * The TextDocumentFilter namespace provides helper functions to work with\n * {@link TextDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar TextDocumentFilter;\n(function (TextDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);\n    }\n    TextDocumentFilter.is = is;\n})(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));\n/**\n * The NotebookDocumentFilter namespace provides helper functions to work with\n * {@link NotebookDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar NotebookDocumentFilter;\n(function (NotebookDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));\n    }\n    NotebookDocumentFilter.is = is;\n})(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));\n/**\n * The NotebookCellTextDocumentFilter namespace provides helper functions to work with\n * {@link NotebookCellTextDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar NotebookCellTextDocumentFilter;\n(function (NotebookCellTextDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))\n            && (candidate.language === undefined || Is.string(candidate.language));\n    }\n    NotebookCellTextDocumentFilter.is = is;\n})(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));\n/**\n * The DocumentSelector namespace provides helper functions to work with\n * {@link DocumentSelector}s.\n */\nvar DocumentSelector;\n(function (DocumentSelector) {\n    function is(value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        for (let elem of value) {\n            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    DocumentSelector.is = is;\n})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));\n/**\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\n * handler on the client side.\n */\nvar RegistrationRequest;\n(function (RegistrationRequest) {\n    RegistrationRequest.method = 'client/registerCapability';\n    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);\n})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));\n/**\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\n * handler on the client side.\n */\nvar UnregistrationRequest;\n(function (UnregistrationRequest) {\n    UnregistrationRequest.method = 'client/unregisterCapability';\n    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);\n})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));\nvar ResourceOperationKind;\n(function (ResourceOperationKind) {\n    /**\n     * Supports creating new files and folders.\n     */\n    ResourceOperationKind.Create = 'create';\n    /**\n     * Supports renaming existing files and folders.\n     */\n    ResourceOperationKind.Rename = 'rename';\n    /**\n     * Supports deleting existing files and folders.\n     */\n    ResourceOperationKind.Delete = 'delete';\n})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));\nvar FailureHandlingKind;\n(function (FailureHandlingKind) {\n    /**\n     * Applying the workspace change is simply aborted if one of the changes provided\n     * fails. All operations executed before the failing operation stay executed.\n     */\n    FailureHandlingKind.Abort = 'abort';\n    /**\n     * All operations are executed transactional. That means they either all\n     * succeed or no changes at all are applied to the workspace.\n     */\n    FailureHandlingKind.Transactional = 'transactional';\n    /**\n     * If the workspace edit contains only textual file changes they are executed transactional.\n     * If resource changes (create, rename or delete file) are part of the change the failure\n     * handling strategy is abort.\n     */\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\n    /**\n     * The client tries to undo the operations already executed. But there is no\n     * guarantee that this is succeeding.\n     */\n    FailureHandlingKind.Undo = 'undo';\n})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));\n/**\n * A set of predefined position encoding kinds.\n *\n * @since 3.17.0\n */\nvar PositionEncodingKind;\n(function (PositionEncodingKind) {\n    /**\n     * Character offsets count UTF-8 code units (e.g. bytes).\n     */\n    PositionEncodingKind.UTF8 = 'utf-8';\n    /**\n     * Character offsets count UTF-16 code units.\n     *\n     * This is the default and must always be supported\n     * by servers\n     */\n    PositionEncodingKind.UTF16 = 'utf-16';\n    /**\n     * Character offsets count UTF-32 code units.\n     *\n     * Implementation note: these are the same as Unicode codepoints,\n     * so this `PositionEncodingKind` may also be used for an\n     * encoding-agnostic representation of character offsets.\n     */\n    PositionEncodingKind.UTF32 = 'utf-32';\n})(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));\n/**\n * The StaticRegistrationOptions namespace provides helper functions to work with\n * {@link StaticRegistrationOptions} literals.\n */\nvar StaticRegistrationOptions;\n(function (StaticRegistrationOptions) {\n    function hasId(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.id) && candidate.id.length > 0;\n    }\n    StaticRegistrationOptions.hasId = hasId;\n})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));\n/**\n * The TextDocumentRegistrationOptions namespace provides helper functions to work with\n * {@link TextDocumentRegistrationOptions} literals.\n */\nvar TextDocumentRegistrationOptions;\n(function (TextDocumentRegistrationOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));\n    }\n    TextDocumentRegistrationOptions.is = is;\n})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));\n/**\n * The WorkDoneProgressOptions namespace provides helper functions to work with\n * {@link WorkDoneProgressOptions} literals.\n */\nvar WorkDoneProgressOptions;\n(function (WorkDoneProgressOptions) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));\n    }\n    WorkDoneProgressOptions.is = is;\n    function hasWorkDoneProgress(value) {\n        const candidate = value;\n        return candidate && Is.boolean(candidate.workDoneProgress);\n    }\n    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;\n})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));\n/**\n * The initialize request is sent from the client to the server.\n * It is sent once as the request after starting up the server.\n * The requests parameter is of type {@link InitializeParams}\n * the response if of type {@link InitializeResult} of a Thenable that\n * resolves to such.\n */\nvar InitializeRequest;\n(function (InitializeRequest) {\n    InitializeRequest.method = 'initialize';\n    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);\n})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));\n/**\n * Known error codes for an `InitializeErrorCodes`;\n */\nvar InitializeErrorCodes;\n(function (InitializeErrorCodes) {\n    /**\n     * If the protocol version provided by the client can't be handled by the server.\n     *\n     * @deprecated This initialize error got replaced by client capabilities. There is\n     * no version handshake in version 3.0x\n     */\n    InitializeErrorCodes.unknownProtocolVersion = 1;\n})(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));\n/**\n * The initialized notification is sent from the client to the\n * server after the client is fully initialized and the server\n * is allowed to send requests from the server to the client.\n */\nvar InitializedNotification;\n(function (InitializedNotification) {\n    InitializedNotification.method = 'initialized';\n    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);\n})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));\n//---- Shutdown Method ----\n/**\n * A shutdown request is sent from the client to the server.\n * It is sent once when the client decides to shutdown the\n * server. The only notification that is sent after a shutdown request\n * is the exit event.\n */\nvar ShutdownRequest;\n(function (ShutdownRequest) {\n    ShutdownRequest.method = 'shutdown';\n    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);\n})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));\n//---- Exit Notification ----\n/**\n * The exit event is sent from the client to the server to\n * ask the server to exit its process.\n */\nvar ExitNotification;\n(function (ExitNotification) {\n    ExitNotification.method = 'exit';\n    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);\n})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));\n/**\n * The configuration change notification is sent from the client to the server\n * when the client's configuration has changed. The notification contains\n * the changed configuration as defined by the language client.\n */\nvar DidChangeConfigurationNotification;\n(function (DidChangeConfigurationNotification) {\n    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';\n    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);\n})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));\n//---- Message show and log notifications ----\n/**\n * The message type\n */\nvar MessageType;\n(function (MessageType) {\n    /**\n     * An error message.\n     */\n    MessageType.Error = 1;\n    /**\n     * A warning message.\n     */\n    MessageType.Warning = 2;\n    /**\n     * An information message.\n     */\n    MessageType.Info = 3;\n    /**\n     * A log message.\n     */\n    MessageType.Log = 4;\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\n/**\n * The show message notification is sent from a server to a client to ask\n * the client to display a particular message in the user interface.\n */\nvar ShowMessageNotification;\n(function (ShowMessageNotification) {\n    ShowMessageNotification.method = 'window/showMessage';\n    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);\n})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));\n/**\n * The show message request is sent from the server to the client to show a message\n * and a set of options actions to the user.\n */\nvar ShowMessageRequest;\n(function (ShowMessageRequest) {\n    ShowMessageRequest.method = 'window/showMessageRequest';\n    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);\n})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));\n/**\n * The log message notification is sent from the server to the client to ask\n * the client to log a particular message.\n */\nvar LogMessageNotification;\n(function (LogMessageNotification) {\n    LogMessageNotification.method = 'window/logMessage';\n    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);\n})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));\n//---- Telemetry notification\n/**\n * The telemetry event notification is sent from the server to the client to ask\n * the client to log telemetry data.\n */\nvar TelemetryEventNotification;\n(function (TelemetryEventNotification) {\n    TelemetryEventNotification.method = 'telemetry/event';\n    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);\n})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));\n/**\n * Defines how the host (editor) should sync\n * document changes to the language server.\n */\nvar TextDocumentSyncKind;\n(function (TextDocumentSyncKind) {\n    /**\n     * Documents should not be synced at all.\n     */\n    TextDocumentSyncKind.None = 0;\n    /**\n     * Documents are synced by always sending the full content\n     * of the document.\n     */\n    TextDocumentSyncKind.Full = 1;\n    /**\n     * Documents are synced by sending the full content on open.\n     * After that only incremental updates to the document are\n     * send.\n     */\n    TextDocumentSyncKind.Incremental = 2;\n})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));\n/**\n * The document open notification is sent from the client to the server to signal\n * newly opened text documents. The document's truth is now managed by the client\n * and the server must not try to read the document's truth using the document's\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\n * mean that its content is presented in an editor. An open notification must not\n * be sent more than once without a corresponding close notification send before.\n * This means open and close notification must be balanced and the max open count\n * is one.\n */\nvar DidOpenTextDocumentNotification;\n(function (DidOpenTextDocumentNotification) {\n    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';\n    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);\n})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));\nvar TextDocumentContentChangeEvent;\n(function (TextDocumentContentChangeEvent) {\n    /**\n     * Checks whether the information describes a delta event.\n     */\n    function isIncremental(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    TextDocumentContentChangeEvent.isIncremental = isIncremental;\n    /**\n     * Checks whether the information describes a full replacement event.\n     */\n    function isFull(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n    TextDocumentContentChangeEvent.isFull = isFull;\n})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));\n/**\n * The document change notification is sent from the client to the server to signal\n * changes to a text document.\n */\nvar DidChangeTextDocumentNotification;\n(function (DidChangeTextDocumentNotification) {\n    DidChangeTextDocumentNotification.method = 'textDocument/didChange';\n    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);\n})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));\n/**\n * The document close notification is sent from the client to the server when\n * the document got closed in the client. The document's truth now exists where\n * the document's uri points to (e.g. if the document's uri is a file uri the\n * truth now exists on disk). As with the open notification the close notification\n * is about managing the document's content. Receiving a close notification\n * doesn't mean that the document was open in an editor before. A close\n * notification requires a previous open notification to be sent.\n */\nvar DidCloseTextDocumentNotification;\n(function (DidCloseTextDocumentNotification) {\n    DidCloseTextDocumentNotification.method = 'textDocument/didClose';\n    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);\n})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));\n/**\n * The document save notification is sent from the client to the server when\n * the document got saved in the client.\n */\nvar DidSaveTextDocumentNotification;\n(function (DidSaveTextDocumentNotification) {\n    DidSaveTextDocumentNotification.method = 'textDocument/didSave';\n    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);\n})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));\n/**\n * Represents reasons why a text document is saved.\n */\nvar TextDocumentSaveReason;\n(function (TextDocumentSaveReason) {\n    /**\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\n     * or by an API call.\n     */\n    TextDocumentSaveReason.Manual = 1;\n    /**\n     * Automatic after a delay.\n     */\n    TextDocumentSaveReason.AfterDelay = 2;\n    /**\n     * When the editor lost focus.\n     */\n    TextDocumentSaveReason.FocusOut = 3;\n})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));\n/**\n * A document will save notification is sent from the client to the server before\n * the document is actually saved.\n */\nvar WillSaveTextDocumentNotification;\n(function (WillSaveTextDocumentNotification) {\n    WillSaveTextDocumentNotification.method = 'textDocument/willSave';\n    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);\n})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));\n/**\n * A document will save request is sent from the client to the server before\n * the document is actually saved. The request can return an array of TextEdits\n * which will be applied to the text document before it is saved. Please note that\n * clients might drop results if computing the text edits took too long or if a\n * server constantly fails on this request. This is done to keep the save fast and\n * reliable.\n */\nvar WillSaveTextDocumentWaitUntilRequest;\n(function (WillSaveTextDocumentWaitUntilRequest) {\n    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';\n    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);\n})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));\n/**\n * The watched files notification is sent from the client to the server when\n * the client detects changes to file watched by the language client.\n */\nvar DidChangeWatchedFilesNotification;\n(function (DidChangeWatchedFilesNotification) {\n    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';\n    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);\n})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));\n/**\n * The file event type\n */\nvar FileChangeType;\n(function (FileChangeType) {\n    /**\n     * The file got created.\n     */\n    FileChangeType.Created = 1;\n    /**\n     * The file got changed.\n     */\n    FileChangeType.Changed = 2;\n    /**\n     * The file got deleted.\n     */\n    FileChangeType.Deleted = 3;\n})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\nvar RelativePattern;\n(function (RelativePattern) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);\n    }\n    RelativePattern.is = is;\n})(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));\nvar WatchKind;\n(function (WatchKind) {\n    /**\n     * Interested in create events.\n     */\n    WatchKind.Create = 1;\n    /**\n     * Interested in change events\n     */\n    WatchKind.Change = 2;\n    /**\n     * Interested in delete events\n     */\n    WatchKind.Delete = 4;\n})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));\n/**\n * Diagnostics notification are sent from the server to the client to signal\n * results of validation runs.\n */\nvar PublishDiagnosticsNotification;\n(function (PublishDiagnosticsNotification) {\n    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';\n    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);\n})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));\n/**\n * How a completion was triggered\n */\nvar CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    /**\n     * Completion was triggered by typing an identifier (24x7 code\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\n     */\n    CompletionTriggerKind.Invoked = 1;\n    /**\n     * Completion was triggered by a trigger character specified by\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n     */\n    CompletionTriggerKind.TriggerCharacter = 2;\n    /**\n     * Completion was re-triggered as current completion list is incomplete\n     */\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\n})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));\n/**\n * Request to request completion at a given text document position. The request's\n * parameter is of type {@link TextDocumentPosition} the response\n * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}\n * or a Thenable that resolves to such.\n *\n * The request can delay the computation of the {@link CompletionItem.detail `detail`}\n * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\n */\nvar CompletionRequest;\n(function (CompletionRequest) {\n    CompletionRequest.method = 'textDocument/completion';\n    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);\n})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));\n/**\n * Request to resolve additional information for a given completion item.The request's\n * parameter is of type {@link CompletionItem} the response\n * is of type {@link CompletionItem} or a Thenable that resolves to such.\n */\nvar CompletionResolveRequest;\n(function (CompletionResolveRequest) {\n    CompletionResolveRequest.method = 'completionItem/resolve';\n    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);\n})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));\n/**\n * Request to request hover information at a given text document position. The request's\n * parameter is of type {@link TextDocumentPosition} the response is of\n * type {@link Hover} or a Thenable that resolves to such.\n */\nvar HoverRequest;\n(function (HoverRequest) {\n    HoverRequest.method = 'textDocument/hover';\n    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);\n})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));\n/**\n * How a signature help was triggered.\n *\n * @since 3.15.0\n */\nvar SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    /**\n     * Signature help was invoked manually by the user or by a command.\n     */\n    SignatureHelpTriggerKind.Invoked = 1;\n    /**\n     * Signature help was triggered by a trigger character.\n     */\n    SignatureHelpTriggerKind.TriggerCharacter = 2;\n    /**\n     * Signature help was triggered by the cursor moving or by the document content changing.\n     */\n    SignatureHelpTriggerKind.ContentChange = 3;\n})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));\nvar SignatureHelpRequest;\n(function (SignatureHelpRequest) {\n    SignatureHelpRequest.method = 'textDocument/signatureHelp';\n    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);\n})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));\n/**\n * A request to resolve the definition location of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPosition]\n * (#TextDocumentPosition) the response is of either type {@link Definition}\n * or a typed array of {@link DefinitionLink} or a Thenable that resolves\n * to such.\n */\nvar DefinitionRequest;\n(function (DefinitionRequest) {\n    DefinitionRequest.method = 'textDocument/definition';\n    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);\n})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));\n/**\n * A request to resolve project-wide references for the symbol denoted\n * by the given text document position. The request's parameter is of\n * type {@link ReferenceParams} the response is of type\n * {@link Location Location[]} or a Thenable that resolves to such.\n */\nvar ReferencesRequest;\n(function (ReferencesRequest) {\n    ReferencesRequest.method = 'textDocument/references';\n    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);\n})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));\n/**\n * Request to resolve a {@link DocumentHighlight} for a given\n * text document position. The request's parameter is of type [TextDocumentPosition]\n * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]\n * (#DocumentHighlight) or a Thenable that resolves to such.\n */\nvar DocumentHighlightRequest;\n(function (DocumentHighlightRequest) {\n    DocumentHighlightRequest.method = 'textDocument/documentHighlight';\n    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);\n})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));\n/**\n * A request to list all symbols found in a given text document. The request's\n * parameter is of type {@link TextDocumentIdentifier} the\n * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable\n * that resolves to such.\n */\nvar DocumentSymbolRequest;\n(function (DocumentSymbolRequest) {\n    DocumentSymbolRequest.method = 'textDocument/documentSymbol';\n    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);\n})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));\n/**\n * A request to provide commands for the given text document and range.\n */\nvar CodeActionRequest;\n(function (CodeActionRequest) {\n    CodeActionRequest.method = 'textDocument/codeAction';\n    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);\n})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));\n/**\n * Request to resolve additional information for a given code action.The request's\n * parameter is of type {@link CodeAction} the response\n * is of type {@link CodeAction} or a Thenable that resolves to such.\n */\nvar CodeActionResolveRequest;\n(function (CodeActionResolveRequest) {\n    CodeActionResolveRequest.method = 'codeAction/resolve';\n    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);\n})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));\n/**\n * A request to list project-wide symbols matching the query string given\n * by the {@link WorkspaceSymbolParams}. The response is\n * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that\n * resolves to such.\n *\n * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients\n *  need to advertise support for WorkspaceSymbols via the client capability\n *  `workspace.symbol.resolveSupport`.\n *\n */\nvar WorkspaceSymbolRequest;\n(function (WorkspaceSymbolRequest) {\n    WorkspaceSymbolRequest.method = 'workspace/symbol';\n    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);\n})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));\n/**\n * A request to resolve the range inside the workspace\n * symbol's location.\n *\n * @since 3.17.0\n */\nvar WorkspaceSymbolResolveRequest;\n(function (WorkspaceSymbolResolveRequest) {\n    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';\n    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);\n})(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));\n/**\n * A request to provide code lens for the given text document.\n */\nvar CodeLensRequest;\n(function (CodeLensRequest) {\n    CodeLensRequest.method = 'textDocument/codeLens';\n    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);\n})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));\n/**\n * A request to resolve a command for a given code lens.\n */\nvar CodeLensResolveRequest;\n(function (CodeLensResolveRequest) {\n    CodeLensResolveRequest.method = 'codeLens/resolve';\n    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);\n})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));\n/**\n * A request to refresh all code actions\n *\n * @since 3.16.0\n */\nvar CodeLensRefreshRequest;\n(function (CodeLensRefreshRequest) {\n    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;\n    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);\n})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));\n/**\n * A request to provide document links\n */\nvar DocumentLinkRequest;\n(function (DocumentLinkRequest) {\n    DocumentLinkRequest.method = 'textDocument/documentLink';\n    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);\n})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));\n/**\n * Request to resolve additional information for a given document link. The request's\n * parameter is of type {@link DocumentLink} the response\n * is of type {@link DocumentLink} or a Thenable that resolves to such.\n */\nvar DocumentLinkResolveRequest;\n(function (DocumentLinkResolveRequest) {\n    DocumentLinkResolveRequest.method = 'documentLink/resolve';\n    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);\n})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));\n/**\n * A request to to format a whole document.\n */\nvar DocumentFormattingRequest;\n(function (DocumentFormattingRequest) {\n    DocumentFormattingRequest.method = 'textDocument/formatting';\n    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);\n})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));\n/**\n * A request to to format a range in a document.\n */\nvar DocumentRangeFormattingRequest;\n(function (DocumentRangeFormattingRequest) {\n    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';\n    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);\n})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));\n/**\n * A request to format a document on type.\n */\nvar DocumentOnTypeFormattingRequest;\n(function (DocumentOnTypeFormattingRequest) {\n    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';\n    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);\n})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));\n//---- Rename ----------------------------------------------\nvar PrepareSupportDefaultBehavior;\n(function (PrepareSupportDefaultBehavior) {\n    /**\n     * The client's default behavior is to select the identifier\n     * according the to language's syntax rule.\n     */\n    PrepareSupportDefaultBehavior.Identifier = 1;\n})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));\n/**\n * A request to rename a symbol.\n */\nvar RenameRequest;\n(function (RenameRequest) {\n    RenameRequest.method = 'textDocument/rename';\n    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);\n})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));\n/**\n * A request to test and perform the setup necessary for a rename.\n *\n * @since 3.16 - support for default behavior\n */\nvar PrepareRenameRequest;\n(function (PrepareRenameRequest) {\n    PrepareRenameRequest.method = 'textDocument/prepareRename';\n    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);\n})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));\n/**\n * A request send from the client to the server to execute a command. The request might return\n * a workspace edit which the client will apply to the workspace.\n */\nvar ExecuteCommandRequest;\n(function (ExecuteCommandRequest) {\n    ExecuteCommandRequest.method = 'workspace/executeCommand';\n    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);\n})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));\n/**\n * A request sent from the server to the client to modified certain resources.\n */\nvar ApplyWorkspaceEditRequest;\n(function (ApplyWorkspaceEditRequest) {\n    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';\n    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');\n})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide ranges that can be edited together.\n *\n * @since 3.16.0\n */\nvar LinkedEditingRangeRequest;\n(function (LinkedEditingRangeRequest) {\n    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';\n    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);\n})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * Moniker uniqueness level to define scope of the moniker.\n *\n * @since 3.16.0\n */\nvar UniquenessLevel;\n(function (UniquenessLevel) {\n    /**\n     * The moniker is only unique inside a document\n     */\n    UniquenessLevel.document = 'document';\n    /**\n     * The moniker is unique inside a project for which a dump got created\n     */\n    UniquenessLevel.project = 'project';\n    /**\n     * The moniker is unique inside the group to which a project belongs\n     */\n    UniquenessLevel.group = 'group';\n    /**\n     * The moniker is unique inside the moniker scheme.\n     */\n    UniquenessLevel.scheme = 'scheme';\n    /**\n     * The moniker is globally unique\n     */\n    UniquenessLevel.global = 'global';\n})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));\n/**\n * The moniker kind.\n *\n * @since 3.16.0\n */\nvar MonikerKind;\n(function (MonikerKind) {\n    /**\n     * The moniker represent a symbol that is imported into a project\n     */\n    MonikerKind.$import = 'import';\n    /**\n     * The moniker represents a symbol that is exported from a project\n     */\n    MonikerKind.$export = 'export';\n    /**\n     * The moniker represents a symbol that is local to a project (e.g. a local\n     * variable of a function, a class not visible outside the project, ...)\n     */\n    MonikerKind.local = 'local';\n})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));\n/**\n * A request to get the moniker of a symbol at a given text document position.\n * The request parameter is of type {@link TextDocumentPositionParams}.\n * The response is of type {@link Moniker Moniker[]} or `null`.\n */\nvar MonikerRequest;\n(function (MonikerRequest) {\n    MonikerRequest.method = 'textDocument/moniker';\n    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);\n})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst Is = require(\"./utils/is\");\nconst messages_1 = require(\"./messages\");\n/**\n * A notebook cell kind.\n *\n * @since 3.17.0\n */\nvar NotebookCellKind;\n(function (NotebookCellKind) {\n    /**\n     * A markup-cell is formatted source that is used for display.\n     */\n    NotebookCellKind.Markup = 1;\n    /**\n     * A code-cell is source code.\n     */\n    NotebookCellKind.Code = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    NotebookCellKind.is = is;\n})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));\nvar ExecutionSummary;\n(function (ExecutionSummary) {\n    function create(executionOrder, success) {\n        const result = { executionOrder };\n        if (success === true || success === false) {\n            result.success = success;\n        }\n        return result;\n    }\n    ExecutionSummary.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));\n    }\n    ExecutionSummary.is = is;\n    function equals(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        return one.executionOrder === other.executionOrder && one.success === other.success;\n    }\n    ExecutionSummary.equals = equals;\n})(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));\nvar NotebookCell;\n(function (NotebookCell) {\n    function create(kind, document) {\n        return { kind, document };\n    }\n    NotebookCell.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&\n            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));\n    }\n    NotebookCell.is = is;\n    function diff(one, two) {\n        const result = new Set();\n        if (one.document !== two.document) {\n            result.add('document');\n        }\n        if (one.kind !== two.kind) {\n            result.add('kind');\n        }\n        if (one.executionSummary !== two.executionSummary) {\n            result.add('executionSummary');\n        }\n        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {\n            result.add('metadata');\n        }\n        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {\n            result.add('executionSummary');\n        }\n        return result;\n    }\n    NotebookCell.diff = diff;\n    function equalsMetadata(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        if (typeof one !== typeof other) {\n            return false;\n        }\n        if (typeof one !== 'object') {\n            return false;\n        }\n        const oneArray = Array.isArray(one);\n        const otherArray = Array.isArray(other);\n        if (oneArray !== otherArray) {\n            return false;\n        }\n        if (oneArray && otherArray) {\n            if (one.length !== other.length) {\n                return false;\n            }\n            for (let i = 0; i < one.length; i++) {\n                if (!equalsMetadata(one[i], other[i])) {\n                    return false;\n                }\n            }\n        }\n        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {\n            const oneKeys = Object.keys(one);\n            const otherKeys = Object.keys(other);\n            if (oneKeys.length !== otherKeys.length) {\n                return false;\n            }\n            oneKeys.sort();\n            otherKeys.sort();\n            if (!equalsMetadata(oneKeys, otherKeys)) {\n                return false;\n            }\n            for (let i = 0; i < oneKeys.length; i++) {\n                const prop = oneKeys[i];\n                if (!equalsMetadata(one[prop], other[prop])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n})(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));\nvar NotebookDocument;\n(function (NotebookDocument) {\n    function create(uri, notebookType, version, cells) {\n        return { uri, notebookType, version, cells };\n    }\n    NotebookDocument.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);\n    }\n    NotebookDocument.is = is;\n})(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));\nvar NotebookDocumentSyncRegistrationType;\n(function (NotebookDocumentSyncRegistrationType) {\n    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';\n    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;\n    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);\n})(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));\n/**\n * A notification sent when a notebook opens.\n *\n * @since 3.17.0\n */\nvar DidOpenNotebookDocumentNotification;\n(function (DidOpenNotebookDocumentNotification) {\n    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';\n    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);\n    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));\nvar NotebookCellArrayChange;\n(function (NotebookCellArrayChange) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));\n    }\n    NotebookCellArrayChange.is = is;\n    function create(start, deleteCount, cells) {\n        const result = { start, deleteCount };\n        if (cells !== undefined) {\n            result.cells = cells;\n        }\n        return result;\n    }\n    NotebookCellArrayChange.create = create;\n})(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));\nvar DidChangeNotebookDocumentNotification;\n(function (DidChangeNotebookDocumentNotification) {\n    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';\n    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);\n    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));\n/**\n * A notification sent when a notebook document is saved.\n *\n * @since 3.17.0\n */\nvar DidSaveNotebookDocumentNotification;\n(function (DidSaveNotebookDocumentNotification) {\n    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';\n    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);\n    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));\n/**\n * A notification sent when a notebook closes.\n *\n * @since 3.17.0\n */\nvar DidCloseNotebookDocumentNotification;\n(function (DidCloseNotebookDocumentNotification) {\n    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';\n    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);\n    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nconst messages_1 = require(\"./messages\");\nvar WorkDoneProgress;\n(function (WorkDoneProgress) {\n    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();\n    function is(value) {\n        return value === WorkDoneProgress.type;\n    }\n    WorkDoneProgress.is = is;\n})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));\n/**\n * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress\n * reporting from the server.\n */\nvar WorkDoneProgressCreateRequest;\n(function (WorkDoneProgressCreateRequest) {\n    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';\n    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);\n})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));\n/**\n * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\n * initiated on the server side.\n */\nvar WorkDoneProgressCancelNotification;\n(function (WorkDoneProgressCancelNotification) {\n    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';\n    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);\n})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SelectionRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide selection ranges in a document. The request's\n * parameter is of type {@link SelectionRangeParams}, the\n * response is of type {@link SelectionRange SelectionRange[]} or a Thenable\n * that resolves to such.\n */\nvar SelectionRangeRequest;\n(function (SelectionRangeRequest) {\n    SelectionRangeRequest.method = 'textDocument/selectionRange';\n    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);\n})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;\nconst messages_1 = require(\"./messages\");\n//------- 'textDocument/semanticTokens' -----\nvar TokenFormat;\n(function (TokenFormat) {\n    TokenFormat.Relative = 'relative';\n})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));\nvar SemanticTokensRegistrationType;\n(function (SemanticTokensRegistrationType) {\n    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';\n    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);\n})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRequest;\n(function (SemanticTokensRequest) {\n    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';\n    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);\n    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensDeltaRequest;\n(function (SemanticTokensDeltaRequest) {\n    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';\n    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);\n    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRangeRequest;\n(function (SemanticTokensRangeRequest) {\n    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';\n    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);\n    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRefreshRequest;\n(function (SemanticTokensRefreshRequest) {\n    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;\n    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);\n})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShowDocumentRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to show a document. This request might open an\n * external program depending on the value of the URI to open.\n * For example a request to open `https://code.visualstudio.com/`\n * will very likely open the URI in a WEB browser.\n *\n * @since 3.16.0\n*/\nvar ShowDocumentRequest;\n(function (ShowDocumentRequest) {\n    ShowDocumentRequest.method = 'window/showDocument';\n    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);\n})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeDefinitionRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositionParams]\n * (#TextDocumentPositionParams) the response is of type {@link Definition} or a\n * Thenable that resolves to such.\n */\nvar TypeDefinitionRequest;\n(function (TypeDefinitionRequest) {\n    TypeDefinitionRequest.method = 'textDocument/typeDefinition';\n    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);\n})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to result a `TypeHierarchyItem` in a document at a given position.\n * Can be used as an input to a subtypes or supertypes type hierarchy.\n *\n * @since 3.17.0\n */\nvar TypeHierarchyPrepareRequest;\n(function (TypeHierarchyPrepareRequest) {\n    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';\n    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);\n})(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));\n/**\n * A request to resolve the supertypes for a given `TypeHierarchyItem`.\n *\n * @since 3.17.0\n */\nvar TypeHierarchySupertypesRequest;\n(function (TypeHierarchySupertypesRequest) {\n    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';\n    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);\n})(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));\n/**\n * A request to resolve the subtypes for a given `TypeHierarchyItem`.\n *\n * @since 3.17.0\n */\nvar TypeHierarchySubtypesRequest;\n(function (TypeHierarchySubtypesRequest) {\n    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';\n    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);\n})(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\n */\nvar WorkspaceFoldersRequest;\n(function (WorkspaceFoldersRequest) {\n    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';\n    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);\n})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));\n/**\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\n * folder configuration changes.\n */\nvar DidChangeWorkspaceFoldersNotification;\n(function (DidChangeWorkspaceFoldersNotification) {\n    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';\n    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);\n})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction objectLiteral(value) {\n    // Strictly speaking class instances pass this check as well. Since the LSP\n    // doesn't use classes we ignore this for now. If we do we need to add something\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n    return value !== null && typeof value === 'object';\n}\nexports.objectLiteral = objectLiteral;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        var candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        var result = { label: label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range: range, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range: range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'create',\n            uri: uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        var result = {\n            kind: 'rename',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'delete',\n            uri: uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.delete = function (range, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n        if (value === undefined) {\n            throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        }\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A helper class\n */\nvar ChangeAnnotations = /** @class */ (function () {\n    function ChangeAnnotations(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    ChangeAnnotations.prototype.all = function () {\n        return this._annotations;\n    };\n    Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n        var id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(\"Id \".concat(id, \" is already in use.\"));\n        }\n        if (annotation === undefined) {\n            throw new Error(\"No annotation provided for id \".concat(id));\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    };\n    ChangeAnnotations.prototype.nextId = function () {\n        this._counter++;\n        return this._counter.toString();\n    };\n    return ChangeAnnotations;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n        /**\n         * Returns the underlying {@link WorkspaceEdit} literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            this.initDocumentChanges();\n            if (this._changeAnnotations !== undefined) {\n                if (this._changeAnnotations.size === 0) {\n                    this._workspaceEdit.changeAnnotations = undefined;\n                }\n                else {\n                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var textDocument = { uri: key.uri, version: key.version };\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.initDocumentChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    };\n    WorkspaceChange.prototype.initChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    return WorkspaceChange;\n}());\nexport { WorkspaceChange };\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        var candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name: name, kind: kind, location: { uri: uri, range: range } }\n            : { name: name, kind: kind, location: { uri: uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        var result = { diagnostics: diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        var result = { title: title };\n        var checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range: range, text: text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range: range, expression: expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId: frameId, stoppedLocation: stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value: value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        var result = { position: position, label: label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport var EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/browser/main');","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = void 0;\nconst api_1 = require(\"../common/api\");\n__exportStar(require(\"vscode-languageserver-protocol/browser\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nlet _shutdownReceived = false;\nconst watchDog = {\n    initialize: (_params) => {\n    },\n    get shutdownReceived() {\n        return _shutdownReceived;\n    },\n    set shutdownReceived(value) {\n        _shutdownReceived = value;\n    },\n    exit: (_code) => {\n    }\n};\nfunction createConnection(arg1, arg2, arg3, arg4) {\n    let factories;\n    let reader;\n    let writer;\n    let options;\n    if (arg1 !== void 0 && arg1.__brand === 'features') {\n        factories = arg1;\n        arg1 = arg2;\n        arg2 = arg3;\n        arg3 = arg4;\n    }\n    if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {\n        options = arg1;\n    }\n    else {\n        reader = arg1;\n        writer = arg2;\n        options = arg3;\n    }\n    const connectionFactory = (logger) => {\n        return (0, api_1.createProtocolConnection)(reader, writer, logger, options);\n    };\n    return (0, api_1.createConnection)(connectionFactory, watchDog, factories);\n}\nexports.createConnection = createConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;\nconst semanticTokens_1 = require(\"./semanticTokens\");\nObject.defineProperty(exports, \"SemanticTokensBuilder\", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });\n__exportStar(require(\"vscode-languageserver-protocol/\"), exports);\nconst textDocuments_1 = require(\"./textDocuments\");\nObject.defineProperty(exports, \"TextDocuments\", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });\nconst notebook_1 = require(\"./notebook\");\nObject.defineProperty(exports, \"NotebookDocuments\", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });\n__exportStar(require(\"./server\"), exports);\nvar ProposedFeatures;\n(function (ProposedFeatures) {\n    ProposedFeatures.all = {\n        __brand: 'features',\n    };\n})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst CallHierarchyFeature = (Base) => {\n    return class extends Base {\n        get callHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onIncomingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onOutgoingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.CallHierarchyFeature = CallHierarchyFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurationFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst ConfigurationFeature = (Base) => {\n    return class extends Base {\n        getConfiguration(arg) {\n            if (!arg) {\n                return this._getConfiguration({});\n            }\n            else if (Is.string(arg)) {\n                return this._getConfiguration({ section: arg });\n            }\n            else {\n                return this._getConfiguration(arg);\n            }\n        }\n        _getConfiguration(arg) {\n            let params = {\n                items: Array.isArray(arg) ? arg : [arg]\n            };\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {\n                if (Array.isArray(result)) {\n                    return Array.isArray(arg) ? result : result[0];\n                }\n                else {\n                    return Array.isArray(arg) ? [] : null;\n                }\n            });\n        }\n    };\n};\nexports.ConfigurationFeature = ConfigurationFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst DiagnosticFeature = (Base) => {\n    return class extends Base {\n        get diagnostics() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));\n                    });\n                },\n                onWorkspace: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.DiagnosticFeature = DiagnosticFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileOperationsFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst FileOperationsFeature = (Base) => {\n    return class extends Base {\n        onDidCreateFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidRenameFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidDeleteFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onWillCreateFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillRenameFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillDeleteFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n    };\n};\nexports.FileOperationsFeature = FileOperationsFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlayHintFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlayHintFeature = (Base) => {\n    return class extends Base {\n        get inlayHint() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                },\n                resolve: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {\n                        return handler(params, cancel);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlayHintFeature = InlayHintFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineValueFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlineValueFeature = (Base) => {\n    return class extends Base {\n        get inlineValue() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlineValueFeature = InlineValueFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangeFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst LinkedEditingRangeFeature = (Base) => {\n    return class extends Base {\n        onLinkedEditingRange(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {\n                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n            });\n        }\n    };\n};\nexports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonikerFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst MonikerFeature = (Base) => {\n    return class extends Base {\n        get moniker() {\n            return {\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n            };\n        }\n    };\n};\nexports.MonikerFeature = MonikerFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NotebookDocuments = exports.NotebookSyncFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst textDocuments_1 = require(\"./textDocuments\");\nconst NotebookSyncFeature = (Base) => {\n    return class extends Base {\n        get synchronization() {\n            return {\n                onDidOpenNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidChangeNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidSaveNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidCloseNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.NotebookSyncFeature = NotebookSyncFeature;\nclass CellTextDocumentConnection {\n    onDidOpenTextDocument(handler) {\n        this.openHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });\n    }\n    openTextDocument(params) {\n        this.openHandler && this.openHandler(params);\n    }\n    onDidChangeTextDocument(handler) {\n        this.changeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });\n    }\n    changeTextDocument(params) {\n        this.changeHandler && this.changeHandler(params);\n    }\n    onDidCloseTextDocument(handler) {\n        this.closeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });\n    }\n    closeTextDocument(params) {\n        this.closeHandler && this.closeHandler(params);\n    }\n    onWillSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onWillSaveTextDocumentWaitUntil() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onDidSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n}\nCellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });\nclass NotebookDocuments {\n    constructor(configurationOrTextDocuments) {\n        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {\n            this._cellTextDocuments = configurationOrTextDocuments;\n        }\n        else {\n            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);\n        }\n        this.notebookDocuments = new Map();\n        this.notebookCellMap = new Map();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n    }\n    get cellTextDocuments() {\n        return this._cellTextDocuments;\n    }\n    getCellTextDocument(cell) {\n        return this._cellTextDocuments.get(cell.document);\n    }\n    getNotebookDocument(uri) {\n        return this.notebookDocuments.get(uri);\n    }\n    getNotebookCell(uri) {\n        const value = this.notebookCellMap.get(uri);\n        return value && value[0];\n    }\n    findNotebookDocumentForCell(cell) {\n        const key = typeof cell === 'string' ? cell : cell.document;\n        const value = this.notebookCellMap.get(key);\n        return value && value[1];\n    }\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the notebook documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,\n     *  and `onDidCloseNotebookDocument`.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        const cellTextDocumentConnection = new CellTextDocumentConnection();\n        const disposables = [];\n        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));\n        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {\n            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });\n            }\n            this.updateCellMap(params.notebookDocument);\n            this._onDidOpen.fire(params.notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            notebookDocument.version = params.notebookDocument.version;\n            const oldMetadata = notebookDocument.metadata;\n            let metadataChanged = false;\n            const change = params.change;\n            if (change.metadata !== undefined) {\n                metadataChanged = true;\n                notebookDocument.metadata = change.metadata;\n            }\n            const opened = [];\n            const closed = [];\n            const data = [];\n            const text = [];\n            if (change.cells !== undefined) {\n                const changedCells = change.cells;\n                if (changedCells.structure !== undefined) {\n                    const array = changedCells.structure.array;\n                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));\n                    // Additional open cell text documents.\n                    if (changedCells.structure.didOpen !== undefined) {\n                        for (const open of changedCells.structure.didOpen) {\n                            cellTextDocumentConnection.openTextDocument({ textDocument: open });\n                            opened.push(open.uri);\n                        }\n                    }\n                    // Additional closed cell test documents.\n                    if (changedCells.structure.didClose) {\n                        for (const close of changedCells.structure.didClose) {\n                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });\n                            closed.push(close.uri);\n                        }\n                    }\n                }\n                if (changedCells.data !== undefined) {\n                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));\n                    for (let i = 0; i <= notebookDocument.cells.length; i++) {\n                        const change = cellUpdates.get(notebookDocument.cells[i].document);\n                        if (change !== undefined) {\n                            const old = notebookDocument.cells.splice(i, 1, change);\n                            data.push({ old: old[0], new: change });\n                            cellUpdates.delete(change.document);\n                            if (cellUpdates.size === 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (changedCells.textContent !== undefined) {\n                    for (const cellTextDocument of changedCells.textContent) {\n                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });\n                        text.push(cellTextDocument.document.uri);\n                    }\n                }\n            }\n            // Update internal data structure.\n            this.updateCellMap(notebookDocument);\n            const changeEvent = { notebookDocument };\n            if (metadataChanged) {\n                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };\n            }\n            const added = [];\n            for (const open of opened) {\n                added.push(this.getNotebookCell(open));\n            }\n            const removed = [];\n            for (const close of closed) {\n                removed.push(this.getNotebookCell(close));\n            }\n            const textContent = [];\n            for (const change of text) {\n                textContent.push(this.getNotebookCell(change));\n            }\n            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {\n                changeEvent.cells = { added, removed, changed: { data, textContent } };\n            }\n            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {\n                this._onDidChange.fire(changeEvent);\n            }\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidSave.fire(notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidClose.fire(notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });\n            }\n            this.notebookDocuments.delete(params.notebookDocument.uri);\n            for (const cell of notebookDocument.cells) {\n                this.notebookCellMap.delete(cell.document);\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n    updateCellMap(notebookDocument) {\n        for (const cell of notebookDocument.cells) {\n            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);\n        }\n    }\n}\nexports.NotebookDocuments = NotebookDocuments;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst uuid_1 = require(\"./utils/uuid\");\nclass WorkDoneProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n        WorkDoneProgressReporterImpl.Instances.set(this._token, this);\n    }\n    begin(title, percentage, message, cancellable) {\n        let param = {\n            kind: 'begin',\n            title,\n            percentage,\n            message,\n            cancellable\n        };\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    report(arg0, arg1) {\n        let param = {\n            kind: 'report'\n        };\n        if (typeof arg0 === 'number') {\n            param.percentage = arg0;\n            if (arg1 !== undefined) {\n                param.message = arg1;\n            }\n        }\n        else {\n            param.message = arg0;\n        }\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    done() {\n        WorkDoneProgressReporterImpl.Instances.delete(this._token);\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });\n    }\n}\nWorkDoneProgressReporterImpl.Instances = new Map();\nclass WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {\n    constructor(connection, token) {\n        super(connection, token);\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n        super.done();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nclass NullProgressReporter {\n    constructor() {\n    }\n    begin() {\n    }\n    report() {\n    }\n    done() {\n    }\n}\nclass NullProgressServerReporter extends NullProgressReporter {\n    constructor() {\n        super();\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nfunction attachWorkDone(connection, params) {\n    if (params === undefined || params.workDoneToken === undefined) {\n        return new NullProgressReporter();\n    }\n    const token = params.workDoneToken;\n    delete params.workDoneToken;\n    return new WorkDoneProgressReporterImpl(connection, token);\n}\nexports.attachWorkDone = attachWorkDone;\nconst ProgressFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._progressSupported = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            if (capabilities?.window?.workDoneProgress === true) {\n                this._progressSupported = true;\n                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {\n                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);\n                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {\n                        progress.cancel();\n                    }\n                });\n            }\n        }\n        attachWorkDoneProgress(token) {\n            if (token === undefined) {\n                return new NullProgressReporter();\n            }\n            else {\n                return new WorkDoneProgressReporterImpl(this.connection, token);\n            }\n        }\n        createWorkDoneProgress() {\n            if (this._progressSupported) {\n                const token = (0, uuid_1.generateUuid)();\n                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {\n                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);\n                    return result;\n                });\n            }\n            else {\n                return Promise.resolve(new NullProgressServerReporter());\n            }\n        }\n    };\n};\nexports.ProgressFeature = ProgressFeature;\nvar ResultProgress;\n(function (ResultProgress) {\n    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();\n})(ResultProgress || (ResultProgress = {}));\nclass ResultProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n    }\n    report(data) {\n        this._connection.sendProgress(ResultProgress.type, this._token, data);\n    }\n}\nfunction attachPartialResult(connection, params) {\n    if (params === undefined || params.partialResultToken === undefined) {\n        return undefined;\n    }\n    const token = params.partialResultToken;\n    delete params.partialResultToken;\n    return new ResultProgressReporterImpl(connection, token);\n}\nexports.attachPartialResult = attachPartialResult;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst SemanticTokensFeature = (Base) => {\n    return class extends Base {\n        get semanticTokens() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);\n                },\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onDelta: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onRange: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.SemanticTokensFeature = SemanticTokensFeature;\nclass SemanticTokensDiff {\n    constructor(originalSequence, modifiedSequence) {\n        this.originalSequence = originalSequence;\n        this.modifiedSequence = modifiedSequence;\n    }\n    computeDiff() {\n        const originalLength = this.originalSequence.length;\n        const modifiedLength = this.modifiedSequence.length;\n        let startIndex = 0;\n        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {\n            startIndex++;\n        }\n        if (startIndex < modifiedLength && startIndex < originalLength) {\n            let originalEndIndex = originalLength - 1;\n            let modifiedEndIndex = modifiedLength - 1;\n            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {\n                originalEndIndex--;\n                modifiedEndIndex--;\n            }\n            // if one moved behind the start index move them forward again\n            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {\n                originalEndIndex++;\n                modifiedEndIndex++;\n            }\n            const deleteCount = originalEndIndex - startIndex + 1;\n            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);\n            // If we moved behind the start index we could have missed a simple delete.\n            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {\n                return [\n                    { start: startIndex, deleteCount: deleteCount - 1 }\n                ];\n            }\n            else {\n                return [\n                    { start: startIndex, deleteCount, data: newData }\n                ];\n            }\n        }\n        else if (startIndex < modifiedLength) {\n            return [\n                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }\n            ];\n        }\n        else if (startIndex < originalLength) {\n            return [\n                { start: startIndex, deleteCount: originalLength - startIndex }\n            ];\n        }\n        else {\n            // The two arrays are the same.\n            return [];\n        }\n    }\n}\nexports.SemanticTokensDiff = SemanticTokensDiff;\nclass SemanticTokensBuilder {\n    constructor() {\n        this._prevData = undefined;\n        this.initialize();\n    }\n    initialize() {\n        this._id = Date.now();\n        this._prevLine = 0;\n        this._prevChar = 0;\n        this._data = [];\n        this._dataLen = 0;\n    }\n    push(line, char, length, tokenType, tokenModifiers) {\n        let pushLine = line;\n        let pushChar = char;\n        if (this._dataLen > 0) {\n            pushLine -= this._prevLine;\n            if (pushLine === 0) {\n                pushChar -= this._prevChar;\n            }\n        }\n        this._data[this._dataLen++] = pushLine;\n        this._data[this._dataLen++] = pushChar;\n        this._data[this._dataLen++] = length;\n        this._data[this._dataLen++] = tokenType;\n        this._data[this._dataLen++] = tokenModifiers;\n        this._prevLine = line;\n        this._prevChar = char;\n    }\n    get id() {\n        return this._id.toString();\n    }\n    previousResult(id) {\n        if (this.id === id) {\n            this._prevData = this._data;\n        }\n        this.initialize();\n    }\n    build() {\n        this._prevData = undefined;\n        return {\n            resultId: this.id,\n            data: this._data\n        };\n    }\n    canBuildEdits() {\n        return this._prevData !== undefined;\n    }\n    buildEdits() {\n        if (this._prevData !== undefined) {\n            return {\n                resultId: this.id,\n                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()\n            };\n        }\n        else {\n            return this.build();\n        }\n    }\n}\nexports.SemanticTokensBuilder = SemanticTokensBuilder;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst UUID = require(\"./utils/uuid\");\nconst progress_1 = require(\"./progress\");\nconst configuration_1 = require(\"./configuration\");\nconst workspaceFolder_1 = require(\"./workspaceFolder\");\nconst callHierarchy_1 = require(\"./callHierarchy\");\nconst semanticTokens_1 = require(\"./semanticTokens\");\nconst showDocument_1 = require(\"./showDocument\");\nconst fileOperations_1 = require(\"./fileOperations\");\nconst linkedEditingRange_1 = require(\"./linkedEditingRange\");\nconst typeHierarchy_1 = require(\"./typeHierarchy\");\nconst inlineValue_1 = require(\"./inlineValue\");\nconst inlayHint_1 = require(\"./inlayHint\");\nconst diagnostic_1 = require(\"./diagnostic\");\nconst notebook_1 = require(\"./notebook\");\nconst moniker_1 = require(\"./moniker\");\nfunction null2Undefined(value) {\n    if (value === null) {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Helps tracking error message. Equal occurrences of the same\n * message are only stored once. This class is for example\n * useful if text documents are validated in a loop and equal\n * error message should be folded into one.\n */\nclass ErrorMessageTracker {\n    constructor() {\n        this._messages = Object.create(null);\n    }\n    /**\n     * Add a message to the tracker.\n     *\n     * @param message The message to add.\n     */\n    add(message) {\n        let count = this._messages[message];\n        if (!count) {\n            count = 0;\n        }\n        count++;\n        this._messages[message] = count;\n    }\n    /**\n     * Send all tracked messages to the connection's window.\n     *\n     * @param connection The connection established between client and server.\n     */\n    sendErrors(connection) {\n        Object.keys(this._messages).forEach(message => {\n            connection.window.showErrorMessage(message);\n        });\n    }\n}\nexports.ErrorMessageTracker = ErrorMessageTracker;\nclass RemoteConsoleImpl {\n    constructor() {\n    }\n    rawAttach(connection) {\n        this._rawConnection = connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    initialize(_capabilities) {\n    }\n    error(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);\n    }\n    warn(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);\n    }\n    info(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);\n    }\n    log(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);\n    }\n    send(type, message) {\n        if (this._rawConnection) {\n            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {\n                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);\n            });\n        }\n    }\n}\nclass _RemoteWindowImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    showErrorMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showWarningMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showInformationMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n}\nconst RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));\nvar BulkRegistration;\n(function (BulkRegistration) {\n    /**\n     * Creates a new bulk registration.\n     * @return an empty bulk registration.\n     */\n    function create() {\n        return new BulkRegistrationImpl();\n    }\n    BulkRegistration.create = create;\n})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));\nclass BulkRegistrationImpl {\n    constructor() {\n        this._registrations = [];\n        this._registered = new Set();\n    }\n    add(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        if (this._registered.has(method)) {\n            throw new Error(`${method} is already added to this registration`);\n        }\n        const id = UUID.generateUuid();\n        this._registrations.push({\n            id: id,\n            method: method,\n            registerOptions: registerOptions || {}\n        });\n        this._registered.add(method);\n    }\n    asRegistrationParams() {\n        return {\n            registrations: this._registrations\n        };\n    }\n}\nvar BulkUnregistration;\n(function (BulkUnregistration) {\n    function create() {\n        return new BulkUnregistrationImpl(undefined, []);\n    }\n    BulkUnregistration.create = create;\n})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));\nclass BulkUnregistrationImpl {\n    constructor(_connection, unregistrations) {\n        this._connection = _connection;\n        this._unregistrations = new Map();\n        unregistrations.forEach(unregistration => {\n            this._unregistrations.set(unregistration.method, unregistration);\n        });\n    }\n    get isAttached() {\n        return !!this._connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    add(unregistration) {\n        this._unregistrations.set(unregistration.method, unregistration);\n    }\n    dispose() {\n        let unregistrations = [];\n        for (let unregistration of this._unregistrations.values()) {\n            unregistrations.push(unregistration);\n        }\n        let params = {\n            unregisterations: unregistrations\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this._connection.console.info(`Bulk unregistration failed.`);\n        });\n    }\n    disposeSingle(arg) {\n        const method = Is.string(arg) ? arg : arg.method;\n        const unregistration = this._unregistrations.get(method);\n        if (!unregistration) {\n            return false;\n        }\n        let params = {\n            unregisterations: [unregistration]\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {\n            this._unregistrations.delete(method);\n        }, (_error) => {\n            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);\n        });\n        return true;\n    }\n}\nclass RemoteClientImpl {\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {\n        if (typeOrRegistrations instanceof BulkRegistrationImpl) {\n            return this.registerMany(typeOrRegistrations);\n        }\n        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {\n            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);\n        }\n        else {\n            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);\n        }\n    }\n    registerSingle1(unregistration, type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        if (!unregistration.isAttached) {\n            unregistration.attach(this.connection);\n        }\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            unregistration.add({ id: id, method: method });\n            return unregistration;\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    registerSingle2(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            return vscode_languageserver_protocol_1.Disposable.create(() => {\n                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });\n            });\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    unregisterSingle(id, method) {\n        let params = {\n            unregisterations: [{ id, method }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this.connection.console.info(`Un-registering request handler for ${id} failed.`);\n        });\n    }\n    registerMany(registrations) {\n        let params = registrations.asRegistrationParams();\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {\n            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));\n        }, (_error) => {\n            this.connection.console.info(`Bulk registration failed.`);\n            return Promise.reject(_error);\n        });\n    }\n}\nclass _RemoteWorkspaceImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    applyEdit(paramOrEdit) {\n        function isApplyWorkspaceEditParams(value) {\n            return value && !!value.edit;\n        }\n        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);\n    }\n}\nconst RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));\nclass TracerImpl {\n    constructor() {\n        this._trace = vscode_languageserver_protocol_1.Trace.Off;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    set trace(value) {\n        this._trace = value;\n    }\n    log(message, verbose) {\n        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {\n            return;\n        }\n        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {\n            message: message,\n            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined\n        }).catch(() => {\n            // Very hard to decide what to do. We tried to send a log\n            // message which failed so we can't simply send another :-(.\n        });\n    }\n}\nclass TelemetryImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    logEvent(data) {\n        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {\n            this.connection.console.log(`Sending TelemetryEventNotification failed`);\n        });\n    }\n}\nclass _LanguagesImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._LanguagesImpl = _LanguagesImpl;\nconst LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));\nclass _NotebooksImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._NotebooksImpl = _NotebooksImpl;\nconst NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);\nfunction combineConsoleFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineConsoleFeatures = combineConsoleFeatures;\nfunction combineTelemetryFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTelemetryFeatures = combineTelemetryFeatures;\nfunction combineTracerFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTracerFeatures = combineTracerFeatures;\nfunction combineClientFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineClientFeatures = combineClientFeatures;\nfunction combineWindowFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWindowFeatures = combineWindowFeatures;\nfunction combineWorkspaceFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWorkspaceFeatures = combineWorkspaceFeatures;\nfunction combineLanguagesFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineLanguagesFeatures = combineLanguagesFeatures;\nfunction combineNotebooksFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineNotebooksFeatures = combineNotebooksFeatures;\nfunction combineFeatures(one, two) {\n    function combine(one, two, func) {\n        if (one && two) {\n            return func(one, two);\n        }\n        else if (one) {\n            return one;\n        }\n        else {\n            return two;\n        }\n    }\n    let result = {\n        __brand: 'features',\n        console: combine(one.console, two.console, combineConsoleFeatures),\n        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),\n        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),\n        client: combine(one.client, two.client, combineClientFeatures),\n        window: combine(one.window, two.window, combineWindowFeatures),\n        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),\n        languages: combine(one.languages, two.languages, combineLanguagesFeatures),\n        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)\n    };\n    return result;\n}\nexports.combineFeatures = combineFeatures;\nfunction createConnection(connectionFactory, watchDog, factories) {\n    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());\n    const connection = connectionFactory(logger);\n    logger.rawAttach(connection);\n    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());\n    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());\n    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());\n    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());\n    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());\n    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());\n    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());\n    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];\n    function asPromise(value) {\n        if (value instanceof Promise) {\n            return value;\n        }\n        else if (Is.thenable(value)) {\n            return new Promise((resolve, reject) => {\n                value.then((resolved) => resolve(resolved), (error) => reject(error));\n            });\n        }\n        else {\n            return Promise.resolve(value);\n        }\n    }\n    let shutdownHandler = undefined;\n    let initializeHandler = undefined;\n    let exitHandler = undefined;\n    let protocolConnection = {\n        listen: () => connection.listen(),\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\n        onRequest: (type, handler) => connection.onRequest(type, handler),\n        sendNotification: (type, param) => {\n            const method = Is.string(type) ? type : type.method;\n            if (arguments.length === 1) {\n                return connection.sendNotification(method);\n            }\n            else {\n                return connection.sendNotification(method, param);\n            }\n        },\n        onNotification: (type, handler) => connection.onNotification(type, handler),\n        onProgress: connection.onProgress,\n        sendProgress: connection.sendProgress,\n        onInitialize: (handler) => {\n            initializeHandler = handler;\n            return {\n                dispose: () => {\n                    initializeHandler = undefined;\n                }\n            };\n        },\n        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),\n        onShutdown: (handler) => {\n            shutdownHandler = handler;\n            return {\n                dispose: () => {\n                    shutdownHandler = undefined;\n                }\n            };\n        },\n        onExit: (handler) => {\n            exitHandler = handler;\n            return {\n                dispose: () => {\n                    exitHandler = undefined;\n                }\n            };\n        },\n        get console() { return logger; },\n        get telemetry() { return telemetry; },\n        get tracer() { return tracer; },\n        get client() { return client; },\n        get window() { return remoteWindow; },\n        get workspace() { return workspace; },\n        get languages() { return languages; },\n        get notebooks() { return notebooks; },\n        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),\n        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),\n        __textDocumentSync: undefined,\n        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),\n        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),\n        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),\n        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),\n        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),\n        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),\n        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),\n        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),\n        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),\n        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        dispose: () => connection.dispose()\n    };\n    for (let remote of allRemotes) {\n        remote.attach(protocolConnection);\n    }\n    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {\n        watchDog.initialize(params);\n        if (Is.string(params.trace)) {\n            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);\n        }\n        for (let remote of allRemotes) {\n            remote.initialize(params.capabilities);\n        }\n        if (initializeHandler) {\n            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);\n            return asPromise(result).then((value) => {\n                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {\n                    return value;\n                }\n                let result = value;\n                if (!result) {\n                    result = { capabilities: {} };\n                }\n                let capabilities = result.capabilities;\n                if (!capabilities) {\n                    capabilities = {};\n                    result.capabilities = capabilities;\n                }\n                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {\n                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {\n                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                for (let remote of allRemotes) {\n                    remote.fillServerCapabilities(capabilities);\n                }\n                return result;\n            });\n        }\n        else {\n            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };\n            for (let remote of allRemotes) {\n                remote.fillServerCapabilities(result.capabilities);\n            }\n            return result;\n        }\n    });\n    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {\n        watchDog.shutdownReceived = true;\n        if (shutdownHandler) {\n            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);\n        }\n        else {\n            return undefined;\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {\n        try {\n            if (exitHandler) {\n                exitHandler();\n            }\n        }\n        finally {\n            if (watchDog.shutdownReceived) {\n                watchDog.exit(0);\n            }\n            else {\n                watchDog.exit(1);\n            }\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {\n        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);\n    });\n    return protocolConnection;\n}\nexports.createConnection = createConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShowDocumentFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst ShowDocumentFeature = (Base) => {\n    return class extends Base {\n        showDocument(params) {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);\n        }\n    };\n};\nexports.ShowDocumentFeature = ShowDocumentFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextDocuments = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\n/**\n * A manager for simple text documents. The manager requires at a minimum that\n * the server registered for the following text document sync events in the\n * initialize handler or via dynamic registration:\n *\n * - open and close events.\n * - change events.\n *\n * Registering for save and will save events is optional.\n */\nclass TextDocuments {\n    /**\n     * Create a new text document manager.\n     */\n    constructor(configuration) {\n        this._configuration = configuration;\n        this._syncedDocuments = new Map();\n        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened.\n     */\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened or the content changes.\n     */\n    get onDidChangeContent() {\n        return this._onDidChangeContent.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * will be saved.\n     */\n    get onWillSave() {\n        return this._onWillSave.event;\n    }\n    /**\n     * Sets a handler that will be called if a participant wants to provide\n     * edits during a text document save.\n     */\n    onWillSaveWaitUntil(handler) {\n        this._willSaveWaitUntil = handler;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been saved.\n     */\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been closed.\n     */\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Returns the document for the given URI. Returns undefined if\n     * the document is not managed by this instance.\n     *\n     * @param uri The text document's URI to retrieve.\n     * @return the text document or `undefined`.\n     */\n    get(uri) {\n        return this._syncedDocuments.get(uri);\n    }\n    /**\n     * Returns all text documents managed by this instance.\n     *\n     * @return all text documents.\n     */\n    all() {\n        return Array.from(this._syncedDocuments.values());\n    }\n    /**\n     * Returns the URIs of all text documents managed by this instance.\n     *\n     * @return the URI's of all text documents.\n     */\n    keys() {\n        return Array.from(this._syncedDocuments.keys());\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the text documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,\n     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.\n     *\n     * Use the corresponding events on the TextDocuments instance instead.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;\n        const disposables = [];\n        disposables.push(connection.onDidOpenTextDocument((event) => {\n            const td = event.textDocument;\n            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);\n            this._syncedDocuments.set(td.uri, document);\n            const toFire = Object.freeze({ document });\n            this._onDidOpen.fire(toFire);\n            this._onDidChangeContent.fire(toFire);\n        }));\n        disposables.push(connection.onDidChangeTextDocument((event) => {\n            const td = event.textDocument;\n            const changes = event.contentChanges;\n            if (changes.length === 0) {\n                return;\n            }\n            const { version } = td;\n            if (version === null || version === undefined) {\n                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);\n            }\n            let syncedDocument = this._syncedDocuments.get(td.uri);\n            if (syncedDocument !== undefined) {\n                syncedDocument = this._configuration.update(syncedDocument, changes, version);\n                this._syncedDocuments.set(td.uri, syncedDocument);\n                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onDidCloseTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._syncedDocuments.delete(event.textDocument.uri);\n                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined && this._willSaveWaitUntil) {\n                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);\n            }\n            else {\n                return [];\n            }\n        }));\n        disposables.push(connection.onDidSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n}\nexports.TextDocuments = TextDocuments;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst TypeHierarchyFeature = (Base) => {\n    return class extends Base {\n        get typeHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onSupertypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onSubtypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.TypeHierarchyFeature = TypeHierarchyFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction thenable(value) {\n    return value && func(value.then);\n}\nexports.thenable = thenable;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;\nclass ValueUUID {\n    constructor(_value) {\n        this._value = _value;\n        // empty\n    }\n    asHex() {\n        return this._value;\n    }\n    equals(other) {\n        return this.asHex() === other.asHex();\n    }\n}\nclass V4UUID extends ValueUUID {\n    constructor() {\n        super([\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            '4',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._oneOf(V4UUID._timeHighBits),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n        ].join(''));\n    }\n    static _oneOf(array) {\n        return array[Math.floor(array.length * Math.random())];\n    }\n    static _randomHex() {\n        return V4UUID._oneOf(V4UUID._chars);\n    }\n}\nV4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nV4UUID._timeHighBits = ['8', '9', 'a', 'b'];\n/**\n * An empty UUID that contains only zeros.\n */\nexports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');\nfunction v4() {\n    return new V4UUID();\n}\nexports.v4 = v4;\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction isUUID(value) {\n    return _UUIDPattern.test(value);\n}\nexports.isUUID = isUUID;\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nfunction parse(value) {\n    if (!isUUID(value)) {\n        throw new Error('invalid uuid');\n    }\n    return new ValueUUID(value);\n}\nexports.parse = parse;\nfunction generateUuid() {\n    return v4().asHex();\n}\nexports.generateUuid = generateUuid;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkspaceFoldersFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst WorkspaceFoldersFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._notificationIsAutoRegistered = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            let workspaceCapabilities = capabilities.workspace;\n            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {\n                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();\n                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {\n                    this._onDidChangeWorkspaceFolders.fire(params.event);\n                });\n            }\n        }\n        fillServerCapabilities(capabilities) {\n            super.fillServerCapabilities(capabilities);\n            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;\n            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';\n        }\n        getWorkspaceFolders() {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);\n        }\n        get onDidChangeWorkspaceFolders() {\n            if (!this._onDidChangeWorkspaceFolders) {\n                throw new Error('Client doesn\\'t support sending workspace folder change events.');\n            }\n            if (!this._notificationIsAutoRegistered && !this._unregistration) {\n                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);\n            }\n            return this._onDidChangeWorkspaceFolders.event;\n        }\n    };\n};\nexports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)(\"object\"==typeof exports?exports:t)[n]=r[n]}}(this,(()=>(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else{if(47===r)break;r=47}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf(\"/\");if(h!==n.length-1){-1===h?(n=\"\",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf(\"/\"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=a,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u)}var d=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+=\"..\":d+=\"/..\");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===h&&(s=!1,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h))}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===i&&(o=!1,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,a=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return-1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n},674:(t,e)=>{if(Object.defineProperty(e,\"__esModule\",{value:!0}),e.isWindows=void 0,\"object\"==typeof process)e.isWindows=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf(\"Windows\")>=0}},796:(t,e,r)=>{Object.defineProperty(e,\"__esModule\",{value:!0}),e.uriToFsPath=e.URI=void 0;const n=r(674),i=/^\\w[\\w\\d+.-]*$/,o=/^\\//,s=/^\\/\\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!i.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",c=\"/\",f=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==c&&(e=c+e):e=c}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o))}get fsPath(){return v(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=!1){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c)}return new d(\"file\",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&\"file\"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\\//g,\"\\\\\")),r}function y(t,e){const r=e?m:g;let n=\"\",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=c,n+=c),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return a&&(n+=\"?\",n+=r(a,!1,!1)),h&&(n+=\"#\",n+=e?h:g(h,!1,!1)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},679:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)\"default\"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.Utils=void 0;const s=o(r(470)),a=s.posix||s,h=\"/\";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==h&&(r=h+r,n=!0);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)}}(c||(e.Utils=c={}))}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,\"__esModule\",{value:!0}),t.Utils=t.URI=void 0;const e=r(796);Object.defineProperty(t,\"URI\",{enumerable:!0,get:function(){return e.URI}});const i=r(679);Object.defineProperty(t,\"Utils\",{enumerable:!0,get:function(){return i.Utils}})})(),n})()));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getConditionalComment = void 0;\nconst commentRegex = /(<!--\\[if[^\\]]*]>)((.|\\n)*)(<!\\[endif\\]-->)$/;\nconst getConditionalComment = (comment) => {\n    const matches = comment.match(commentRegex);\n    if (matches) {\n        return {\n            startTag: matches[1],\n            body: matches[2].trim(),\n            endTag: matches[4],\n        };\n    }\n};\nexports.getConditionalComment = getConditionalComment;\n//# sourceMappingURL=conditional-comment.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidHTMLASTParsingError = exports.LiquidHTMLCSTParsingError = void 0;\nconst line_column_1 = __importDefault(require(\"line-column\"));\nclass LiquidHTMLCSTParsingError extends SyntaxError {\n    constructor(ohm) {\n        super(ohm.shortMessage);\n        this.name = 'LiquidHTMLParsingError';\n        const input = ohm.input;\n        const errorPos = ohm._rightmostFailurePosition;\n        const lineCol = (0, line_column_1.default)(input).fromIndex(Math.min(errorPos, input.length - 1));\n        // Plugging ourselves into @babel/code-frame since this is how\n        // the babel parser can print where the parsing error occured.\n        // https://github.com/prettier/prettier/blob/cd4a57b113177c105a7ceb94e71f3a5a53535b81/src/main/parser.js\n        if (lineCol) {\n            this.loc = {\n                start: {\n                    line: lineCol.line,\n                    column: lineCol.col,\n                },\n                end: {\n                    line: lineCol.line,\n                    column: lineCol.col,\n                },\n            };\n        }\n    }\n}\nexports.LiquidHTMLCSTParsingError = LiquidHTMLCSTParsingError;\nclass LiquidHTMLASTParsingError extends SyntaxError {\n    constructor(message, source, startIndex, endIndex, unclosed) {\n        super(message);\n        this.name = 'LiquidHTMLParsingError';\n        this.unclosed = unclosed !== null && unclosed !== void 0 ? unclosed : null;\n        const lc = (0, line_column_1.default)(source);\n        const start = lc.fromIndex(startIndex);\n        const end = lc.fromIndex(Math.min(endIndex, source.length - 1));\n        // Plugging ourselves into @babel/code-frame since this is how\n        // the babel parser can print where the parsing error occured.\n        // https://github.com/prettier/prettier/blob/cd4a57b113177c105a7ceb94e71f3a5a53535b81/src/main/parser.js\n        this.loc = {\n            start: {\n                line: start.line,\n                column: start.col,\n            },\n            end: {\n                line: end.line,\n                column: end.col,\n            },\n        };\n    }\n}\nexports.LiquidHTMLASTParsingError = LiquidHTMLASTParsingError;\n//# sourceMappingURL=errors.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TAGS_WITHOUT_MARKUP = exports.VOID_ELEMENTS = exports.RAW_TAGS = exports.BLOCKS = exports.placeholderGrammars = exports.tolerantGrammars = exports.strictGrammars = exports.LiquidDocGrammar = exports.TextNodeGrammar = exports.liquidHtmlGrammars = void 0;\nconst ohm_js_1 = __importDefault(require(\"ohm-js\"));\nexports.liquidHtmlGrammars = ohm_js_1.default.grammars(require('../grammar/liquid-html.ohm.js'));\nexports.TextNodeGrammar = exports.liquidHtmlGrammars['Helpers'];\nexports.LiquidDocGrammar = exports.liquidHtmlGrammars['LiquidDoc'];\nexports.strictGrammars = {\n    Liquid: exports.liquidHtmlGrammars['StrictLiquid'],\n    LiquidHTML: exports.liquidHtmlGrammars['StrictLiquidHTML'],\n    LiquidStatement: exports.liquidHtmlGrammars['StrictLiquidStatement'],\n};\nexports.tolerantGrammars = {\n    Liquid: exports.liquidHtmlGrammars['Liquid'],\n    LiquidHTML: exports.liquidHtmlGrammars['LiquidHTML'],\n    LiquidStatement: exports.liquidHtmlGrammars['LiquidStatement'],\n};\nexports.placeholderGrammars = {\n    Liquid: exports.liquidHtmlGrammars['WithPlaceholderLiquid'],\n    LiquidHTML: exports.liquidHtmlGrammars['WithPlaceholderLiquidHTML'],\n    LiquidStatement: exports.liquidHtmlGrammars['WithPlaceholderLiquidStatement'],\n};\n// see ../../grammar/liquid-html.ohm for full list\nexports.BLOCKS = exports.strictGrammars.LiquidHTML.rules.blockName.body.factors[0].terms.map((x) => x.obj);\n// see ../../grammar/liquid-html.ohm for full list\nexports.RAW_TAGS = exports.strictGrammars.LiquidHTML.rules.liquidRawTag.body.terms\n    .map((term) => term.args[0].obj)\n    .concat('comment');\n// see ../../grammar/liquid-html.ohm for full list\nexports.VOID_ELEMENTS = exports.strictGrammars.LiquidHTML.rules.voidElementName.body.factors[0].terms.map((x) => x.args[0].obj);\nexports.TAGS_WITHOUT_MARKUP = [\n    'style',\n    'schema',\n    'javascript',\n    'else',\n    'break',\n    'continue',\n    'comment',\n    'raw',\n    'doc',\n];\n//# sourceMappingURL=grammar.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getConditionalComment = exports.BLOCKS = exports.VOID_ELEMENTS = exports.RAW_TAGS = exports.TAGS_WITHOUT_MARKUP = void 0;\n__exportStar(require(\"./stage-2-ast\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./errors\"), exports);\nvar grammar_1 = require(\"./grammar\");\nObject.defineProperty(exports, \"TAGS_WITHOUT_MARKUP\", { enumerable: true, get: function () { return grammar_1.TAGS_WITHOUT_MARKUP; } });\nObject.defineProperty(exports, \"RAW_TAGS\", { enumerable: true, get: function () { return grammar_1.RAW_TAGS; } });\nObject.defineProperty(exports, \"VOID_ELEMENTS\", { enumerable: true, get: function () { return grammar_1.VOID_ELEMENTS; } });\nObject.defineProperty(exports, \"BLOCKS\", { enumerable: true, get: function () { return grammar_1.BLOCKS; } });\nvar conditional_comment_1 = require(\"./conditional-comment\");\nObject.defineProperty(exports, \"getConditionalComment\", { enumerable: true, get: function () { return conditional_comment_1.getConditionalComment; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * This is the first stage of the parser.\n *\n * Input:\n *   Source code: string\n *\n * Output:\n *   Concrete Syntax Tree (CST): LiquidHtmlCST\n *\n * We use OhmJS's toAST method to turn the OhmJS nodes into an \"almost-AST.\" We\n * call that a Concrete Syntax Tree because it considers Open and Close nodes as\n * separate nodes.\n *\n * It is mostly \"flat.\"\n *\n * e.g.\n * {% if cond %}hi <em>there!</em>{% endif %}\n *\n * becomes\n * - LiquidTagOpen/if\n *   condition: LiquidVariableExpression/cond\n * - TextNode/\"hi \"\n * - HtmlTagOpen/em\n * - TextNode/\"there!\"\n * - HtmlTagClose/em\n * - LiquidTagClose/if\n *\n * In the Concrete Syntax Tree, all nodes are siblings instead of having a\n * parent/children relationship.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toLiquidCST = exports.toLiquidHtmlCST = exports.LiquidLiteralValues = exports.ConcreteNodeTypes = void 0;\nconst extras_1 = require(\"ohm-js/extras\");\nconst grammar_1 = require(\"./grammar\");\nconst errors_1 = require(\"./errors\");\nconst types_1 = require(\"./types\");\nvar ConcreteNodeTypes;\n(function (ConcreteNodeTypes) {\n    ConcreteNodeTypes[\"HtmlDoctype\"] = \"HtmlDoctype\";\n    ConcreteNodeTypes[\"HtmlComment\"] = \"HtmlComment\";\n    ConcreteNodeTypes[\"HtmlRawTag\"] = \"HtmlRawTag\";\n    ConcreteNodeTypes[\"HtmlVoidElement\"] = \"HtmlVoidElement\";\n    ConcreteNodeTypes[\"HtmlSelfClosingElement\"] = \"HtmlSelfClosingElement\";\n    ConcreteNodeTypes[\"HtmlTagOpen\"] = \"HtmlTagOpen\";\n    ConcreteNodeTypes[\"HtmlTagClose\"] = \"HtmlTagClose\";\n    ConcreteNodeTypes[\"AttrSingleQuoted\"] = \"AttrSingleQuoted\";\n    ConcreteNodeTypes[\"AttrDoubleQuoted\"] = \"AttrDoubleQuoted\";\n    ConcreteNodeTypes[\"AttrUnquoted\"] = \"AttrUnquoted\";\n    ConcreteNodeTypes[\"AttrEmpty\"] = \"AttrEmpty\";\n    ConcreteNodeTypes[\"LiquidVariableOutput\"] = \"LiquidVariableOutput\";\n    ConcreteNodeTypes[\"LiquidRawTag\"] = \"LiquidRawTag\";\n    ConcreteNodeTypes[\"LiquidTag\"] = \"LiquidTag\";\n    ConcreteNodeTypes[\"LiquidTagOpen\"] = \"LiquidTagOpen\";\n    ConcreteNodeTypes[\"LiquidTagClose\"] = \"LiquidTagClose\";\n    ConcreteNodeTypes[\"TextNode\"] = \"TextNode\";\n    ConcreteNodeTypes[\"YAMLFrontmatter\"] = \"YAMLFrontmatter\";\n    ConcreteNodeTypes[\"LiquidVariable\"] = \"LiquidVariable\";\n    ConcreteNodeTypes[\"LiquidFilter\"] = \"LiquidFilter\";\n    ConcreteNodeTypes[\"NamedArgument\"] = \"NamedArgument\";\n    ConcreteNodeTypes[\"LiquidLiteral\"] = \"LiquidLiteral\";\n    ConcreteNodeTypes[\"VariableLookup\"] = \"VariableLookup\";\n    ConcreteNodeTypes[\"String\"] = \"String\";\n    ConcreteNodeTypes[\"Number\"] = \"Number\";\n    ConcreteNodeTypes[\"Range\"] = \"Range\";\n    ConcreteNodeTypes[\"Comparison\"] = \"Comparison\";\n    ConcreteNodeTypes[\"Condition\"] = \"Condition\";\n    ConcreteNodeTypes[\"AssignMarkup\"] = \"AssignMarkup\";\n    ConcreteNodeTypes[\"ContentForMarkup\"] = \"ContentForMarkup\";\n    ConcreteNodeTypes[\"CycleMarkup\"] = \"CycleMarkup\";\n    ConcreteNodeTypes[\"ForMarkup\"] = \"ForMarkup\";\n    ConcreteNodeTypes[\"RenderMarkup\"] = \"RenderMarkup\";\n    ConcreteNodeTypes[\"PaginateMarkup\"] = \"PaginateMarkup\";\n    ConcreteNodeTypes[\"RenderVariableExpression\"] = \"RenderVariableExpression\";\n    ConcreteNodeTypes[\"ContentForNamedArgument\"] = \"ContentForNamedArgument\";\n    ConcreteNodeTypes[\"LiquidDocParamNode\"] = \"LiquidDocParamNode\";\n    ConcreteNodeTypes[\"LiquidDocParamNameNode\"] = \"LiquidDocParamNameNode\";\n    ConcreteNodeTypes[\"LiquidDocDescriptionNode\"] = \"LiquidDocDescriptionNode\";\n    ConcreteNodeTypes[\"LiquidDocExampleNode\"] = \"LiquidDocExampleNode\";\n})(ConcreteNodeTypes = exports.ConcreteNodeTypes || (exports.ConcreteNodeTypes = {}));\nexports.LiquidLiteralValues = {\n    nil: null,\n    null: null,\n    true: true,\n    false: false,\n    blank: '',\n    empty: '',\n};\nconst markup = (i) => (tokens) => tokens[i].sourceString.trim();\nconst markupTrimEnd = (i) => (tokens) => tokens[i].sourceString.trimEnd();\nconst Grammars = {\n    strict: grammar_1.strictGrammars,\n    tolerant: grammar_1.tolerantGrammars,\n    completion: grammar_1.placeholderGrammars,\n};\nfunction toLiquidHtmlCST(source, options = { mode: 'tolerant' }) {\n    const grammars = Grammars[options.mode];\n    const grammar = grammars.LiquidHTML;\n    return toCST(source, grammars, grammar, [\n        'HelperMappings',\n        'LiquidMappings',\n        'LiquidHTMLMappings',\n    ]);\n}\nexports.toLiquidHtmlCST = toLiquidHtmlCST;\nfunction toLiquidCST(source, options = { mode: 'tolerant' }) {\n    const grammars = Grammars[options.mode];\n    const grammar = grammars.Liquid;\n    return toCST(source, grammars, grammar, ['HelperMappings', 'LiquidMappings']);\n}\nexports.toLiquidCST = toLiquidCST;\nfunction toCST(source /* the original file */, grammars, grammar, cstMappings, matchingSource = source /* for subtree parsing */, offset = 0 /* for subtree parsing location offsets */) {\n    // When we switch parser, our locStart and locEnd functions must account\n    // for the offset of the {% liquid %} markup\n    const locStart = (tokens) => offset + tokens[0].source.startIdx;\n    const locEnd = (tokens) => offset + tokens[tokens.length - 1].source.endIdx;\n    const locEndSecondToLast = (tokens) => offset + tokens[tokens.length - 2].source.endIdx;\n    const textNode = {\n        type: ConcreteNodeTypes.TextNode,\n        value: function () {\n            return this.sourceString;\n        },\n        locStart,\n        locEnd,\n        source,\n    };\n    const res = grammar.match(matchingSource, 'Node');\n    if (res.failed()) {\n        throw new errors_1.LiquidHTMLCSTParsingError(res);\n    }\n    const HelperMappings = {\n        Node: 0,\n        TextNode: textNode,\n        orderedListOf: 0,\n        listOf: 0,\n        empty: () => null,\n        emptyListOf: () => [],\n        nonemptyListOf(first, _sep, rest) {\n            const self = this;\n            return [first.toAST(self.args.mapping)].concat(rest.toAST(self.args.mapping));\n        },\n        nonemptyOrderedListOf: 0,\n        nonemptyOrderedListOfBoth(nonemptyListOfA, _sep, nonemptyListOfB) {\n            const self = this;\n            return nonemptyListOfA\n                .toAST(self.args.mapping)\n                .concat(nonemptyListOfB.toAST(self.args.mapping));\n        },\n    };\n    const LiquidMappings = {\n        liquidNode: 0,\n        liquidRawTag: 0,\n        liquidRawTagImpl: {\n            type: ConcreteNodeTypes.LiquidRawTag,\n            name: 3,\n            body: 9,\n            children: (tokens) => {\n                const nameNode = tokens[3];\n                const rawMarkupStringNode = tokens[9];\n                switch (nameNode.sourceString) {\n                    // {% raw %} accepts syntax errors, we shouldn't try to parse that\n                    case 'raw': {\n                        return toCST(source, grammars, grammar_1.TextNodeGrammar, ['HelperMappings'], rawMarkupStringNode.sourceString, offset + rawMarkupStringNode.source.startIdx);\n                    }\n                    // {% javascript %}, {% style %}\n                    default: {\n                        return toCST(source, grammars, grammars.Liquid, ['HelperMappings', 'LiquidMappings'], rawMarkupStringNode.sourceString, offset + rawMarkupStringNode.source.startIdx);\n                    }\n                }\n            },\n            markup: 6,\n            whitespaceStart: 1,\n            whitespaceEnd: 7,\n            delimiterWhitespaceStart: 11,\n            delimiterWhitespaceEnd: 17,\n            locStart,\n            locEnd,\n            source,\n            blockStartLocStart: (tokens) => tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => tokens[8].source.endIdx,\n            blockEndLocStart: (tokens) => tokens[10].source.startIdx,\n            blockEndLocEnd: (tokens) => tokens[18].source.endIdx,\n        },\n        liquidBlockComment: {\n            type: ConcreteNodeTypes.LiquidRawTag,\n            name: 'comment',\n            body: (tokens) => tokens[1].sourceString,\n            children: (tokens) => {\n                return toCST(source, grammars, grammar_1.TextNodeGrammar, ['HelperMappings'], tokens[1].sourceString, offset + tokens[1].source.startIdx);\n            },\n            whitespaceStart: (tokens) => tokens[0].children[1].sourceString,\n            whitespaceEnd: (tokens) => tokens[0].children[7].sourceString,\n            delimiterWhitespaceStart: (tokens) => tokens[2].children[1].sourceString,\n            delimiterWhitespaceEnd: (tokens) => tokens[2].children[7].sourceString,\n            locStart,\n            locEnd,\n            source,\n            blockStartLocStart: (tokens) => tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => tokens[0].source.endIdx,\n            blockEndLocStart: (tokens) => tokens[2].source.startIdx,\n            blockEndLocEnd: (tokens) => tokens[2].source.endIdx,\n        },\n        liquidDoc: {\n            type: ConcreteNodeTypes.LiquidRawTag,\n            name: 'doc',\n            body: (tokens) => tokens[1].sourceString,\n            children: (tokens) => {\n                const contentNode = tokens[1];\n                return toLiquidDocAST(source, contentNode.sourceString, offset + contentNode.source.startIdx);\n            },\n            whitespaceStart: (tokens) => tokens[0].children[1].sourceString,\n            whitespaceEnd: (tokens) => tokens[0].children[7].sourceString,\n            delimiterWhitespaceStart: (tokens) => { var _a; return ((_a = tokens[2].children[1]) === null || _a === void 0 ? void 0 : _a.sourceString) || ''; },\n            delimiterWhitespaceEnd: (tokens) => { var _a; return ((_a = tokens[2].children[7]) === null || _a === void 0 ? void 0 : _a.sourceString) || ''; },\n            locStart,\n            locEnd,\n            source,\n            blockStartLocStart: (tokens) => tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => tokens[0].source.endIdx,\n            blockEndLocStart: (tokens) => tokens[2].source.startIdx,\n            blockEndLocEnd: (tokens) => tokens[2].source.endIdx,\n        },\n        liquidInlineComment: {\n            type: ConcreteNodeTypes.LiquidTag,\n            name: 3,\n            markup: markupTrimEnd(5),\n            whitespaceStart: 1,\n            whitespaceEnd: 6,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagOpen: 0,\n        liquidTagOpenStrict: 0,\n        liquidTagOpenBaseCase: 0,\n        liquidTagOpenRule: {\n            type: ConcreteNodeTypes.LiquidTagOpen,\n            name: 3,\n            markup(nodes) {\n                const markupNode = nodes[6];\n                const nameNode = nodes[3];\n                if (types_1.NamedTags.hasOwnProperty(nameNode.sourceString)) {\n                    return markupNode.toAST(this.args.mapping);\n                }\n                return markupNode.sourceString.trim();\n            },\n            whitespaceStart: 1,\n            whitespaceEnd: 7,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagOpenCapture: 0,\n        liquidTagOpenForm: 0,\n        liquidTagOpenFormMarkup: 0,\n        liquidTagOpenFor: 0,\n        liquidTagOpenForMarkup: {\n            type: ConcreteNodeTypes.ForMarkup,\n            variableName: 0,\n            collection: 4,\n            reversed: 6,\n            args: 8,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagBreak: 0,\n        liquidTagContinue: 0,\n        liquidTagOpenTablerow: 0,\n        liquidTagOpenPaginate: 0,\n        liquidTagOpenPaginateMarkup: {\n            type: ConcreteNodeTypes.PaginateMarkup,\n            collection: 0,\n            pageSize: 4,\n            args: 6,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagOpenCase: 0,\n        liquidTagOpenCaseMarkup: 0,\n        liquidTagWhen: 0,\n        liquidTagWhenMarkup: 0,\n        liquidTagOpenIf: 0,\n        liquidTagOpenUnless: 0,\n        liquidTagElsif: 0,\n        liquidTagElse: 0,\n        liquidTagOpenConditionalMarkup: 0,\n        condition: {\n            type: ConcreteNodeTypes.Condition,\n            relation: 0,\n            expression: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        comparison: {\n            type: ConcreteNodeTypes.Comparison,\n            comparator: 2,\n            left: 0,\n            right: 4,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagClose: {\n            type: ConcreteNodeTypes.LiquidTagClose,\n            name: 4,\n            whitespaceStart: 1,\n            whitespaceEnd: 7,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTag: 0,\n        liquidTagStrict: 0,\n        liquidTagBaseCase: 0,\n        liquidTagAssign: 0,\n        liquidTagEcho: 0,\n        liquidTagContentFor: 0,\n        liquidTagCycle: 0,\n        liquidTagIncrement: 0,\n        liquidTagDecrement: 0,\n        liquidTagRender: 0,\n        liquidTagInclude: 0,\n        liquidTagSection: 0,\n        liquidTagSections: 0,\n        liquidTagLayout: 0,\n        liquidTagRule: {\n            type: ConcreteNodeTypes.LiquidTag,\n            name: 3,\n            markup(nodes) {\n                const markupNode = nodes[6];\n                const nameNode = nodes[3];\n                if (types_1.NamedTags.hasOwnProperty(nameNode.sourceString)) {\n                    return markupNode.toAST(this.args.mapping);\n                }\n                return markupNode.sourceString.trim();\n            },\n            whitespaceStart: 1,\n            whitespaceEnd: 7,\n            source,\n            locStart,\n            locEnd,\n        },\n        liquidTagLiquid: 0,\n        liquidTagLiquidMarkup(tagMarkup) {\n            return toCST(source, grammars, grammars.LiquidStatement, ['HelperMappings', 'LiquidMappings', 'LiquidStatement'], tagMarkup.sourceString, offset + tagMarkup.source.startIdx);\n        },\n        liquidTagEchoMarkup: 0,\n        liquidTagSectionMarkup: 0,\n        liquidTagSectionsMarkup: 0,\n        liquidTagLayoutMarkup: 0,\n        liquidTagAssignMarkup: {\n            type: ConcreteNodeTypes.AssignMarkup,\n            name: 0,\n            value: 4,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagCycleMarkup: {\n            type: ConcreteNodeTypes.CycleMarkup,\n            groupName: 0,\n            args: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidTagContentForMarkup: {\n            type: ConcreteNodeTypes.ContentForMarkup,\n            contentForType: 0,\n            args: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        contentForType: 0,\n        liquidTagRenderMarkup: {\n            type: ConcreteNodeTypes.RenderMarkup,\n            snippet: 0,\n            variable: 1,\n            alias: 2,\n            renderArguments: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        renderArguments: 1,\n        completionModeRenderArguments: function (_0, namedArguments, _2, _3, _4, _5, variableLookup, _7) {\n            const self = this;\n            // variableLookup.sourceString can be '' when there are no incomplete params\n            return namedArguments\n                .toAST(self.args.mapping)\n                .concat(variableLookup.sourceString === '' ? [] : variableLookup.toAST(self.args.mapping));\n        },\n        snippetExpression: 0,\n        renderVariableExpression: {\n            type: ConcreteNodeTypes.RenderVariableExpression,\n            kind: 1,\n            name: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        renderAliasExpression: 3,\n        liquidDrop: {\n            type: ConcreteNodeTypes.LiquidVariableOutput,\n            markup: 3,\n            whitespaceStart: 1,\n            whitespaceEnd: 4,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidDropCases: 0,\n        liquidExpression: 0,\n        liquidDropBaseCase: (sw) => sw.sourceString.trimEnd(),\n        liquidVariable: {\n            type: ConcreteNodeTypes.LiquidVariable,\n            expression: 0,\n            filters: 1,\n            rawSource: (tokens) => source.slice(locStart(tokens), tokens[tokens.length - 2].source.endIdx).trimEnd(),\n            locStart,\n            // The last node of this rule is a positive lookahead, we don't\n            // want its endIdx, we want the endIdx of the previous one.\n            locEnd: locEndSecondToLast,\n            source,\n        },\n        liquidFilter: {\n            type: ConcreteNodeTypes.LiquidFilter,\n            name: 3,\n            locStart,\n            locEnd,\n            source,\n            args(nodes) {\n                // Traditinally, this would get transformed into null or array. But\n                // it's better if we have an empty array instead of null here.\n                if (nodes[7].sourceString === '') {\n                    return [];\n                }\n                else {\n                    return nodes[7].toAST(this.args.mapping);\n                }\n            },\n        },\n        filterArguments: 0,\n        arguments: 0,\n        complexArguments: function (completeParams, _space1, _comma, _space2, incompleteParam) {\n            const self = this;\n            return completeParams\n                .toAST(self.args.mapping)\n                .concat(incompleteParam.sourceString === '' ? [] : incompleteParam.toAST(self.args.mapping));\n        },\n        simpleArgument: 0,\n        tagArguments: 0,\n        contentForTagArgument: 0,\n        completionModeContentForTagArgument: function (namedArguments, _separator, variableLookup) {\n            const self = this;\n            return namedArguments\n                .toAST(self.args.mapping)\n                .concat(variableLookup.sourceString === '' ? [] : variableLookup.toAST(self.args.mapping));\n        },\n        positionalArgument: 0,\n        namedArgument: {\n            type: ConcreteNodeTypes.NamedArgument,\n            name: 0,\n            value: 4,\n            locStart,\n            locEnd,\n            source,\n        },\n        contentForNamedArgument: {\n            type: ConcreteNodeTypes.NamedArgument,\n            name: (node) => node[0].sourceString + node[1].sourceString,\n            value: 6,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidString: 0,\n        liquidDoubleQuotedString: {\n            type: ConcreteNodeTypes.String,\n            single: () => false,\n            value: 1,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidSingleQuotedString: {\n            type: ConcreteNodeTypes.String,\n            single: () => true,\n            value: 1,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidNumber: {\n            type: ConcreteNodeTypes.Number,\n            value: 0,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidLiteral: {\n            type: ConcreteNodeTypes.LiquidLiteral,\n            value: (tokens) => {\n                const keyword = tokens[0].sourceString;\n                return exports.LiquidLiteralValues[keyword];\n            },\n            keyword: 0,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidRange: {\n            type: ConcreteNodeTypes.Range,\n            start: 2,\n            end: 6,\n            locStart,\n            locEnd,\n            source,\n        },\n        liquidVariableLookup: {\n            type: ConcreteNodeTypes.VariableLookup,\n            name: 0,\n            lookups: 1,\n            locStart,\n            locEnd,\n            source,\n        },\n        variableSegmentAsLookupMarkup: 0,\n        variableSegmentAsLookup: {\n            type: ConcreteNodeTypes.VariableLookup,\n            name: 0,\n            lookups: () => [],\n            locStart,\n            locEnd,\n            source,\n        },\n        lookup: 0,\n        indexLookup: 3,\n        dotLookup: {\n            type: ConcreteNodeTypes.String,\n            value: 3,\n            locStart: (nodes) => offset + nodes[2].source.startIdx,\n            locEnd: (nodes) => offset + nodes[nodes.length - 1].source.endIdx,\n            source,\n        },\n        // trim on both sides\n        tagMarkup: (n) => n.sourceString.trim(),\n    };\n    const LiquidStatement = {\n        LiquidStatement: 0,\n        liquidTagOpenRule: {\n            type: ConcreteNodeTypes.LiquidTagOpen,\n            name: 0,\n            markup(nodes) {\n                const markupNode = nodes[2];\n                const nameNode = nodes[0];\n                if (types_1.NamedTags.hasOwnProperty(nameNode.sourceString)) {\n                    return markupNode.toAST(this.args.mapping);\n                }\n                return markupNode.sourceString.trim();\n            },\n            whitespaceStart: null,\n            whitespaceEnd: null,\n            locStart,\n            locEnd: locEndSecondToLast,\n            source,\n        },\n        liquidTagClose: {\n            type: ConcreteNodeTypes.LiquidTagClose,\n            name: 1,\n            whitespaceStart: null,\n            whitespaceEnd: null,\n            locStart,\n            locEnd: locEndSecondToLast,\n            source,\n        },\n        liquidTagRule: {\n            type: ConcreteNodeTypes.LiquidTag,\n            name: 0,\n            markup(nodes) {\n                const markupNode = nodes[2];\n                const nameNode = nodes[0];\n                if (types_1.NamedTags.hasOwnProperty(nameNode.sourceString)) {\n                    return markupNode.toAST(this.args.mapping);\n                }\n                return markupNode.sourceString.trim();\n            },\n            whitespaceStart: null,\n            whitespaceEnd: null,\n            locStart,\n            locEnd: locEndSecondToLast,\n            source,\n        },\n        liquidRawTagImpl: {\n            type: ConcreteNodeTypes.LiquidRawTag,\n            name: 0,\n            body: 4,\n            children(nodes) {\n                return toCST(source, grammars, grammar_1.TextNodeGrammar, ['HelperMappings'], nodes[4].sourceString, offset + nodes[4].source.startIdx);\n            },\n            whitespaceStart: null,\n            whitespaceEnd: null,\n            delimiterWhitespaceStart: null,\n            delimiterWhitespaceEnd: null,\n            locStart,\n            locEnd: locEndSecondToLast,\n            source,\n            blockStartLocStart: (tokens) => offset + tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => offset + tokens[2].source.endIdx,\n            blockEndLocStart: (tokens) => offset + tokens[5].source.startIdx,\n            blockEndLocEnd: (tokens) => offset + tokens[5].source.endIdx,\n        },\n        liquidBlockComment: {\n            type: ConcreteNodeTypes.LiquidRawTag,\n            name: 'comment',\n            body: (tokens) => \n            // We want this to behave like LiquidRawTag, so we have to do some\n            // shenanigans to make it behave the same while also supporting\n            // nested comments\n            //\n            // We're stripping the newline from the statementSep, that's why we\n            // slice(1). Since statementSep = newline (space | newline)*\n            tokens[1].sourceString.slice(1) + tokens[2].sourceString,\n            children(tokens) {\n                const commentSource = tokens[1].sourceString.slice(1) + tokens[2].sourceString;\n                return toCST(source, grammars, grammar_1.TextNodeGrammar, ['HelperMappings'], commentSource, offset + tokens[1].source.startIdx + 1);\n            },\n            whitespaceStart: '',\n            whitespaceEnd: '',\n            delimiterWhitespaceStart: '',\n            delimiterWhitespaceEnd: '',\n            locStart,\n            locEnd,\n            source,\n            blockStartLocStart: (tokens) => offset + tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => offset + tokens[0].source.endIdx,\n            blockEndLocStart: (tokens) => offset + tokens[4].source.startIdx,\n            blockEndLocEnd: (tokens) => offset + tokens[4].source.endIdx,\n        },\n        liquidInlineComment: {\n            type: ConcreteNodeTypes.LiquidTag,\n            name: 0,\n            markup: markupTrimEnd(2),\n            whitespaceStart: null,\n            whitespaceEnd: null,\n            locStart,\n            locEnd: locEndSecondToLast,\n            source,\n        },\n    };\n    const LiquidHTMLMappings = {\n        Node(frontmatter, nodes) {\n            const self = this;\n            const frontmatterNode = frontmatter.sourceString.length === 0 ? [] : [frontmatter.toAST(self.args.mapping)];\n            return frontmatterNode.concat(nodes.toAST(self.args.mapping));\n        },\n        yamlFrontmatter: {\n            type: ConcreteNodeTypes.YAMLFrontmatter,\n            body: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlDoctype: {\n            type: ConcreteNodeTypes.HtmlDoctype,\n            legacyDoctypeString: 4,\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlComment: {\n            type: ConcreteNodeTypes.HtmlComment,\n            body: markup(1),\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlRawTagImpl: {\n            type: ConcreteNodeTypes.HtmlRawTag,\n            name: (tokens) => tokens[0].children[1].sourceString,\n            attrList(tokens) {\n                const mappings = this.args.mapping;\n                return tokens[0].children[2].toAST(mappings);\n            },\n            body: (tokens) => source.slice(tokens[0].source.endIdx, tokens[2].source.startIdx),\n            children: (tokens) => {\n                const rawMarkup = source.slice(tokens[0].source.endIdx, tokens[2].source.startIdx);\n                return toCST(source, grammars, grammars.Liquid, ['HelperMappings', 'LiquidMappings'], rawMarkup, tokens[0].source.endIdx);\n            },\n            locStart,\n            locEnd,\n            source,\n            blockStartLocStart: (tokens) => tokens[0].source.startIdx,\n            blockStartLocEnd: (tokens) => tokens[0].source.endIdx,\n            blockEndLocStart: (tokens) => tokens[2].source.startIdx,\n            blockEndLocEnd: (tokens) => tokens[2].source.endIdx,\n        },\n        HtmlVoidElement: {\n            type: ConcreteNodeTypes.HtmlVoidElement,\n            name: 1,\n            attrList: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlSelfClosingElement: {\n            type: ConcreteNodeTypes.HtmlSelfClosingElement,\n            name: 1,\n            attrList: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlTagOpen: {\n            type: ConcreteNodeTypes.HtmlTagOpen,\n            name: 1,\n            attrList: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        HtmlTagClose: {\n            type: ConcreteNodeTypes.HtmlTagClose,\n            name: 1,\n            locStart,\n            locEnd,\n            source,\n        },\n        leadingTagNamePart: 0,\n        leadingTagNameTextNode: textNode,\n        trailingTagNamePart: 0,\n        trailingTagNameTextNode: textNode,\n        tagName(leadingPart, trailingParts) {\n            const mappings = this.args.mapping;\n            return [leadingPart.toAST(mappings)].concat(trailingParts.toAST(mappings));\n        },\n        AttrUnquoted: {\n            type: ConcreteNodeTypes.AttrUnquoted,\n            name: 0,\n            value: 2,\n            locStart,\n            locEnd,\n            source,\n        },\n        AttrSingleQuoted: {\n            type: ConcreteNodeTypes.AttrSingleQuoted,\n            name: 0,\n            value: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        AttrDoubleQuoted: {\n            type: ConcreteNodeTypes.AttrDoubleQuoted,\n            name: 0,\n            value: 3,\n            locStart,\n            locEnd,\n            source,\n        },\n        attrEmpty: {\n            type: ConcreteNodeTypes.AttrEmpty,\n            name: 0,\n            locStart,\n            locEnd,\n            source,\n        },\n        attrName: 0,\n        attrNameTextNode: textNode,\n        attrDoubleQuotedValue: 0,\n        attrSingleQuotedValue: 0,\n        attrUnquotedValue: 0,\n        attrDoubleQuotedTextNode: textNode,\n        attrSingleQuotedTextNode: textNode,\n        attrUnquotedTextNode: textNode,\n    };\n    const defaultMappings = {\n        HelperMappings,\n        LiquidMappings,\n        LiquidHTMLMappings,\n        LiquidStatement,\n    };\n    const selectedMappings = cstMappings.reduce((mappings, key) => ({\n        ...mappings,\n        ...defaultMappings[key],\n    }), {});\n    return (0, extras_1.toAST)(res, selectedMappings);\n}\n/**\n * Builds an AST for LiquidDoc content.\n *\n * `toCST` includes mappings and logic that are not needed for LiquidDoc so we're separating this logic\n */\nfunction toLiquidDocAST(source, matchingSource, offset) {\n    // When we switch parser, our locStart and locEnd functions must account\n    // for the offset of the {% doc %} markup\n    const locStart = (tokens) => offset + tokens[0].source.startIdx;\n    const locEnd = (tokens) => offset + tokens[tokens.length - 1].source.endIdx;\n    const res = grammar_1.LiquidDocGrammar.match(matchingSource, 'Node');\n    if (res.failed()) {\n        throw new errors_1.LiquidHTMLCSTParsingError(res);\n    }\n    /**\n     * Reusable text node type\n     */\n    const textNode = {\n        type: ConcreteNodeTypes.TextNode,\n        value: function () {\n            return this.sourceString;\n        },\n        locStart,\n        locEnd,\n        source,\n    };\n    const LiquidDocMappings = {\n        Node: 0,\n        TextNode: textNode,\n        paramNode: {\n            type: ConcreteNodeTypes.LiquidDocParamNode,\n            name: 'param',\n            locStart,\n            locEnd,\n            source,\n            paramType: 2,\n            paramName: 4,\n            paramDescription: 8,\n        },\n        descriptionNode: {\n            type: ConcreteNodeTypes.LiquidDocDescriptionNode,\n            name: 'description',\n            locStart,\n            locEnd,\n            source,\n            content: 2,\n        },\n        descriptionContent: textNode,\n        paramType: 2,\n        paramTypeContent: textNode,\n        paramName: {\n            type: ConcreteNodeTypes.LiquidDocParamNameNode,\n            content: 0,\n            locStart,\n            locEnd,\n            source,\n            required: true,\n        },\n        optionalParamName: {\n            type: ConcreteNodeTypes.LiquidDocParamNameNode,\n            content: 2,\n            locStart,\n            locEnd,\n            source,\n            required: false,\n        },\n        paramDescription: textNode,\n        exampleNode: {\n            type: ConcreteNodeTypes.LiquidDocExampleNode,\n            name: 'example',\n            locStart,\n            locEnd,\n            source,\n            content: 2,\n        },\n        exampleContent: textNode,\n        textValue: textNode,\n        fallbackNode: textNode,\n    };\n    return (0, extras_1.toAST)(res, LiquidDocMappings);\n}\n//# sourceMappingURL=stage-1-cst.js.map","\"use strict\";\n/**\n * This is the second stage of the parser.\n *\n * Input:\n *  - A Concrete Syntax Tree (CST)\n *\n * Output:\n *  - An Abstract Syntax Tree (AST)\n *\n * This stage traverses the flat tree we get from the previous stage and\n * establishes the parent/child relationship between the nodes.\n *\n * Recall the Liquid example we had in the first stage:\n *   {% if cond %}hi <em>there!</em>{% endif %}\n *\n * Whereas the previous stage gives us this CST:\n *   - LiquidTagOpen/if\n *     condition: LiquidVariableExpression/cond\n *   - TextNode/\"hi \"\n *   - HtmlTagOpen/em\n *   - TextNode/\"there!\"\n *   - HtmlTagClose/em\n *   - LiquidTagClose/if\n *\n * We now traverse all the nodes and turn that into a proper AST:\n *   - LiquidTag/if\n *     condition: LiquidVariableExpression\n *     children:\n *       - TextNode/\"hi \"\n *       - HtmlElement/em\n *         children:\n *           - TextNode/\"there!\"\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLiquidHtmlNode = exports.walk = exports.cstToAst = exports.getName = exports.toLiquidHtmlAST = exports.toLiquidAST = exports.isBranchedTag = exports.RawMarkupKinds = void 0;\nconst stage_1_cst_1 = require(\"./stage-1-cst\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst grammar_1 = require(\"./grammar\");\nconst stage_1_cst_2 = require(\"./stage-1-cst\");\n/**\n * The infered kind of raw markup\n * - `<script>` is javascript\n * - `<script type=\"application/json\">` is JSON\n * - `<style>` is css\n * - etc.\n */\nvar RawMarkupKinds;\n(function (RawMarkupKinds) {\n    RawMarkupKinds[\"css\"] = \"css\";\n    RawMarkupKinds[\"html\"] = \"html\";\n    RawMarkupKinds[\"javascript\"] = \"javascript\";\n    RawMarkupKinds[\"json\"] = \"json\";\n    RawMarkupKinds[\"markdown\"] = \"markdown\";\n    RawMarkupKinds[\"typescript\"] = \"typescript\";\n    RawMarkupKinds[\"text\"] = \"text\";\n})(RawMarkupKinds = exports.RawMarkupKinds || (exports.RawMarkupKinds = {}));\nfunction isBranchedTag(node) {\n    return node.type === types_1.NodeTypes.LiquidTag && ['if', 'for', 'unless', 'case'].includes(node.name);\n}\nexports.isBranchedTag = isBranchedTag;\nfunction isConcreteLiquidBranchDisguisedAsTag(node) {\n    return node.type === stage_1_cst_1.ConcreteNodeTypes.LiquidTag && ['else', 'elsif', 'when'].includes(node.name);\n}\nfunction toLiquidAST(source, options = {\n    allowUnclosedDocumentNode: true,\n    mode: 'tolerant',\n}) {\n    const cst = (0, stage_1_cst_2.toLiquidCST)(source, { mode: options.mode });\n    const root = {\n        type: types_1.NodeTypes.Document,\n        source: source,\n        _source: source,\n        children: cstToAst(cst, options),\n        name: '#document',\n        position: {\n            start: 0,\n            end: source.length,\n        },\n    };\n    return root;\n}\nexports.toLiquidAST = toLiquidAST;\nfunction toLiquidHtmlAST(source, options = {\n    allowUnclosedDocumentNode: false,\n    mode: 'tolerant',\n}) {\n    const cst = (0, stage_1_cst_1.toLiquidHtmlCST)(source, { mode: options.mode });\n    const root = {\n        type: types_1.NodeTypes.Document,\n        source: source,\n        _source: source,\n        children: cstToAst(cst, options),\n        name: '#document',\n        position: {\n            start: 0,\n            end: source.length,\n        },\n    };\n    return root;\n}\nexports.toLiquidHtmlAST = toLiquidHtmlAST;\nclass ASTBuilder {\n    constructor(source) {\n        this.ast = [];\n        this.cursor = [];\n        this.source = source;\n    }\n    // Returns the array to push nodes to.\n    get current() {\n        return (0, utils_1.deepGet)(this.cursor, this.ast);\n    }\n    // Returns the position of the current node in the array\n    get currentPosition() {\n        return (this.current || []).length - 1;\n    }\n    get parent() {\n        if (this.cursor.length == 0)\n            return undefined;\n        return (0, utils_1.deepGet)((0, utils_1.dropLast)(1, this.cursor), this.ast);\n    }\n    get grandparent() {\n        if (this.cursor.length < 4)\n            return undefined;\n        return (0, utils_1.deepGet)((0, utils_1.dropLast)(3, this.cursor), this.ast);\n    }\n    open(node) {\n        this.current.push(node);\n        this.cursor.push(this.currentPosition);\n        this.cursor.push('children');\n        if (isBranchedTag(node)) {\n            this.open(toUnnamedLiquidBranch(node));\n        }\n    }\n    push(node) {\n        if (node.type === types_1.NodeTypes.LiquidBranch) {\n            const previousBranch = this.findCloseableParentBranch(node);\n            if (previousBranch) {\n                previousBranch.blockEndPosition = { start: node.position.start, end: node.position.start };\n                // close dangling open HTML nodes\n                while (this.parent &&\n                    this.parent !== previousBranch &&\n                    this.parent.type === types_1.NodeTypes.HtmlElement) {\n                    // 0-length blockEndPosition at the position of the next branch\n                    this.parent.blockEndPosition = { start: node.position.start, end: node.position.start };\n                    this.closeParentWith(node);\n                }\n                // close the previous branch\n                this.closeParentWith(node);\n            }\n            this.open(node);\n        }\n        else {\n            this.current.push(node);\n        }\n    }\n    close(node, nodeType) {\n        var _a, _b;\n        if (isLiquidBranch(this.parent)) {\n            this.parent.blockEndPosition = { start: node.locStart, end: node.locStart };\n            this.closeParentWith(node);\n        }\n        if (!this.parent) {\n            throw new errors_1.LiquidHTMLASTParsingError(`Attempting to close ${nodeType} '${getName(node)}' before it was opened`, this.source, node.locStart, node.locEnd);\n        }\n        if (getName(this.parent) !== getName(node) || this.parent.type !== nodeType) {\n            const suitableParent = this.findCloseableParentNode(node);\n            if (this.parent.type === types_1.NodeTypes.HtmlElement && suitableParent) {\n                // close dangling open HTML nodes\n                while (this.parent !== suitableParent) {\n                    // 0-length end block position\n                    this.parent.blockEndPosition = { start: node.locStart, end: node.locStart };\n                    this.closeParentWith(node);\n                }\n            }\n            else {\n                throw new errors_1.LiquidHTMLASTParsingError(`Attempting to close ${nodeType} '${getName(node)}' before ${this.parent.type} '${getName(this.parent)}' was closed`, this.source, this.parent.position.start, node.locEnd, getUnclosed(this.parent));\n            }\n        }\n        // The parent end is the end of the outer tag.\n        this.parent.position.end = node.locEnd;\n        this.parent.blockEndPosition = position(node);\n        if (this.parent.type == types_1.NodeTypes.LiquidTag && node.type == stage_1_cst_1.ConcreteNodeTypes.LiquidTagClose) {\n            this.parent.delimiterWhitespaceStart = (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '';\n            this.parent.delimiterWhitespaceEnd = (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '';\n        }\n        this.cursor.pop();\n        this.cursor.pop();\n    }\n    // This function performs the following tasks:\n    // - Tries to find a parent branch to close when pushing a new branch.\n    // - This is necessary because we allow unclosed HTML element nodes.\n    // - The function traverses up the tree until it finds a LiquidBranch.\n    // - If it encounters anything other than an Unclosed HTML Element, it throws.\n    findCloseableParentBranch(next) {\n        for (let index = this.cursor.length - 1; index > 0; index -= 2) {\n            const parent = (0, utils_1.deepGet)(this.cursor.slice(0, index), this.ast);\n            const parentProperty = this.cursor[index];\n            const isUnclosedHtmlElement = parent.type === types_1.NodeTypes.HtmlElement && parentProperty === 'children';\n            if (parent.type === types_1.NodeTypes.LiquidBranch) {\n                return parent;\n            }\n            else if (!isUnclosedHtmlElement) {\n                throw new errors_1.LiquidHTMLASTParsingError(`Attempting to open LiquidBranch '${next.name}' before ${parent.type} '${getName(parent)}' was closed`, this.source, parent.position.start, next.position.end);\n            }\n        }\n        return null;\n    }\n    // Check if there's a parent in the ancestry that this node correctly closes\n    findCloseableParentNode(current) {\n        for (let index = this.cursor.length - 1; index > 0; index -= 2) {\n            const parent = (0, utils_1.deepGet)(this.cursor.slice(0, index), this.ast);\n            if (getName(parent) === getName(current) &&\n                parent.type === types_1.NodeTypes.LiquidTag &&\n                ['if', 'unless', 'case'].includes(parent.name)) {\n                return parent;\n            }\n            else if (parent.type === types_1.NodeTypes.LiquidTag) {\n                return null;\n            }\n        }\n        return null;\n    }\n    // sets the parent's end position to the start of the next one.\n    closeParentWith(next) {\n        if (this.parent) {\n            if ('locStart' in next) {\n                this.parent.position.end = next.locStart;\n            }\n            else {\n                this.parent.position.end = next.position.start;\n            }\n        }\n        this.cursor.pop();\n        this.cursor.pop();\n    }\n}\nfunction isLiquidBranch(node) {\n    return !!node && node.type === types_1.NodeTypes.LiquidBranch;\n}\nfunction getName(node) {\n    if (!node)\n        return null;\n    switch (node.type) {\n        case types_1.NodeTypes.HtmlElement:\n        case types_1.NodeTypes.HtmlDanglingMarkerClose:\n        case types_1.NodeTypes.HtmlSelfClosingElement:\n        case stage_1_cst_1.ConcreteNodeTypes.HtmlTagClose:\n            return node.name\n                .map((part) => {\n                if (part.type === types_1.NodeTypes.TextNode || part.type == stage_1_cst_1.ConcreteNodeTypes.TextNode) {\n                    return part.value;\n                }\n                else if (typeof part.markup === 'string') {\n                    return `{{${part.markup.trim()}}}`;\n                }\n                else {\n                    return `{{${part.markup.rawSource}}}`;\n                }\n            })\n                .join('');\n        case types_1.NodeTypes.AttrEmpty:\n        case types_1.NodeTypes.AttrUnquoted:\n        case types_1.NodeTypes.AttrDoubleQuoted:\n        case types_1.NodeTypes.AttrSingleQuoted:\n            // <a href=\"{{ hello }}\">\n            return node.name\n                .map((part) => {\n                if (typeof part === 'string') {\n                    return part;\n                }\n                else {\n                    return part.source.slice(part.position.start, part.position.end);\n                }\n            })\n                .join('');\n        default:\n            return node.name;\n    }\n}\nexports.getName = getName;\nfunction cstToAst(cst, options) {\n    var _a;\n    if (cst.length === 0)\n        return [];\n    const builder = buildAst(cst, options);\n    if (!options.allowUnclosedDocumentNode && builder.cursor.length !== 0) {\n        throw new errors_1.LiquidHTMLASTParsingError(`Attempting to end parsing before ${(_a = builder.parent) === null || _a === void 0 ? void 0 : _a.type} '${getName(builder.parent)}' was closed`, builder.source, builder.source.length - 1, builder.source.length, getUnclosed(builder.parent, builder.grandparent));\n    }\n    return builder.ast;\n}\nexports.cstToAst = cstToAst;\nfunction buildAst(cst, options) {\n    var _a, _b, _c, _d;\n    const builder = new ASTBuilder(cst[0].source);\n    for (let i = 0; i < cst.length; i++) {\n        const node = cst[i];\n        switch (node.type) {\n            case stage_1_cst_1.ConcreteNodeTypes.TextNode: {\n                builder.push(toTextNode(node));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidVariableOutput: {\n                builder.push(toLiquidVariableOutput(node));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidTagOpen: {\n                builder.open(toLiquidTag(node, { ...options, isBlockTag: true }));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidTagClose: {\n                builder.close(node, types_1.NodeTypes.LiquidTag);\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidTag: {\n                builder.push(toLiquidTag(node, { ...options, isBlockTag: false }));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidRawTag: {\n                builder.push({\n                    type: types_1.NodeTypes.LiquidRawTag,\n                    markup: markup(node.name, node.markup),\n                    name: node.name,\n                    body: toRawMarkup(node, options),\n                    whitespaceStart: (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '',\n                    whitespaceEnd: (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '',\n                    delimiterWhitespaceStart: (_c = node.delimiterWhitespaceStart) !== null && _c !== void 0 ? _c : '',\n                    delimiterWhitespaceEnd: (_d = node.delimiterWhitespaceEnd) !== null && _d !== void 0 ? _d : '',\n                    position: position(node),\n                    blockStartPosition: {\n                        start: node.blockStartLocStart,\n                        end: node.blockStartLocEnd,\n                    },\n                    blockEndPosition: {\n                        start: node.blockEndLocStart,\n                        end: node.blockEndLocEnd,\n                    },\n                    source: node.source,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlTagOpen: {\n                builder.open(toHtmlElement(node, options));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlTagClose: {\n                if (isAcceptableDanglingMarkerClose(builder, cst, i, options.mode)) {\n                    builder.push(toHtmlDanglingMarkerClose(node, options));\n                }\n                else {\n                    builder.close(node, types_1.NodeTypes.HtmlElement);\n                }\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlVoidElement: {\n                builder.push(toHtmlVoidElement(node, options));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlSelfClosingElement: {\n                builder.push(toHtmlSelfClosingElement(node, options));\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlDoctype: {\n                builder.push({\n                    type: types_1.NodeTypes.HtmlDoctype,\n                    legacyDoctypeString: node.legacyDoctypeString,\n                    position: position(node),\n                    source: node.source,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlComment: {\n                builder.push({\n                    type: types_1.NodeTypes.HtmlComment,\n                    body: node.body,\n                    position: position(node),\n                    source: node.source,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.HtmlRawTag: {\n                builder.push({\n                    type: types_1.NodeTypes.HtmlRawNode,\n                    name: node.name,\n                    body: toRawMarkup(node, options),\n                    attributes: toAttributes(node.attrList || [], options),\n                    position: position(node),\n                    source: node.source,\n                    blockStartPosition: {\n                        start: node.blockStartLocStart,\n                        end: node.blockStartLocEnd,\n                    },\n                    blockEndPosition: {\n                        start: node.blockEndLocStart,\n                        end: node.blockEndLocEnd,\n                    },\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.AttrEmpty: {\n                builder.push({\n                    type: types_1.NodeTypes.AttrEmpty,\n                    name: cstToAst(node.name, options),\n                    position: position(node),\n                    source: node.source,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.AttrSingleQuoted:\n            case stage_1_cst_1.ConcreteNodeTypes.AttrDoubleQuoted:\n            case stage_1_cst_1.ConcreteNodeTypes.AttrUnquoted: {\n                const abstractNode = {\n                    type: node.type,\n                    name: cstToAst(node.name, options),\n                    position: position(node),\n                    source: node.source,\n                    // placeholders\n                    attributePosition: { start: -1, end: -1 },\n                    value: [],\n                };\n                const value = toAttributeValue(node.value, options);\n                abstractNode.value = value;\n                abstractNode.attributePosition = toAttributePosition(node, value);\n                builder.push(abstractNode);\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.YAMLFrontmatter: {\n                builder.push({\n                    type: types_1.NodeTypes.YAMLFrontmatter,\n                    body: node.body,\n                    position: position(node),\n                    source: node.source,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidDocParamNode: {\n                builder.push({\n                    type: types_1.NodeTypes.LiquidDocParamNode,\n                    name: node.name,\n                    position: position(node),\n                    source: node.source,\n                    paramName: toTextNode(node.paramName.content),\n                    paramDescription: toNullableTextNode(node.paramDescription),\n                    paramType: toNullableTextNode(node.paramType),\n                    required: node.paramName.required,\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidDocDescriptionNode: {\n                builder.push({\n                    type: types_1.NodeTypes.LiquidDocDescriptionNode,\n                    name: node.name,\n                    position: position(node),\n                    source: node.source,\n                    content: toTextNode(node.content),\n                });\n                break;\n            }\n            case stage_1_cst_1.ConcreteNodeTypes.LiquidDocExampleNode: {\n                builder.push({\n                    type: types_1.NodeTypes.LiquidDocExampleNode,\n                    name: node.name,\n                    position: position(node),\n                    source: node.source,\n                    content: toTextNode(node.content),\n                });\n                break;\n            }\n            default: {\n                (0, utils_1.assertNever)(node);\n            }\n        }\n    }\n    return builder;\n}\nfunction nameLength(names) {\n    const start = names.at(0);\n    const end = names.at(-1);\n    return end.locEnd - start.locStart;\n}\nfunction toAttributePosition(node, value) {\n    if (value.length === 0) {\n        // This is bugged when there's whitespace on either side. But I don't\n        // think it's worth solving.\n        return {\n            start: node.locStart + nameLength(node.name) + '='.length + '\"'.length,\n            // name=\"\"\n            // 012345678\n            // 0 + 4 + 1 + 1\n            // = 6\n            end: node.locStart + nameLength(node.name) + '='.length + '\"'.length,\n            // name=\"\"\n            // 012345678\n            // 0 + 4 + 1 + 2\n            // = 6\n        };\n    }\n    return {\n        start: value[0].position.start,\n        end: value[value.length - 1].position.end,\n    };\n}\nfunction toAttributeValue(value, options) {\n    return cstToAst(value, options);\n}\nfunction toAttributes(attrList, options) {\n    return cstToAst(attrList, options);\n}\nfunction liquidTagBaseAttributes(node) {\n    var _a, _b;\n    return {\n        type: types_1.NodeTypes.LiquidTag,\n        position: position(node),\n        whitespaceStart: (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '',\n        whitespaceEnd: (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '',\n        blockStartPosition: position(node),\n        source: node.source,\n    };\n}\nfunction liquidBranchBaseAttributes(node) {\n    var _a, _b;\n    return {\n        type: types_1.NodeTypes.LiquidBranch,\n        children: [],\n        position: position(node),\n        whitespaceStart: (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '',\n        whitespaceEnd: (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '',\n        blockStartPosition: position(node),\n        blockEndPosition: { start: -1, end: -1 },\n        source: node.source,\n    };\n}\nfunction toLiquidTag(node, options) {\n    if (typeof node.markup !== 'string') {\n        return toNamedLiquidTag(node, options);\n    }\n    else if (isConcreteLiquidBranchDisguisedAsTag(node)) {\n        // `elsif`, `else`, `case`, but with unparseable markup.\n        return toNamedLiquidBranchBaseCase(node);\n    }\n    else if (options.isBlockTag) {\n        return {\n            name: node.name,\n            markup: markup(node.name, node.markup),\n            children: options.isBlockTag ? [] : undefined,\n            ...liquidTagBaseAttributes(node),\n        };\n    }\n    return {\n        name: node.name,\n        markup: markup(node.name, node.markup),\n        ...liquidTagBaseAttributes(node),\n    };\n}\nfunction toNamedLiquidTag(node, options) {\n    switch (node.name) {\n        case types_1.NamedTags.echo: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: types_1.NamedTags.echo,\n                markup: toLiquidVariable(node.markup),\n            };\n        }\n        case types_1.NamedTags.assign: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: types_1.NamedTags.assign,\n                markup: toAssignMarkup(node.markup),\n            };\n        }\n        case types_1.NamedTags.cycle: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toCycleMarkup(node.markup),\n            };\n        }\n        case types_1.NamedTags.increment:\n        case types_1.NamedTags.decrement: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toExpression(node.markup),\n            };\n        }\n        case types_1.NamedTags.capture: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toExpression(node.markup),\n                children: [],\n            };\n        }\n        case types_1.NamedTags.content_for: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toContentForMarkup(node.markup),\n            };\n        }\n        case types_1.NamedTags.include:\n        case types_1.NamedTags.render: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toRenderMarkup(node.markup),\n            };\n        }\n        case types_1.NamedTags.layout:\n        case types_1.NamedTags.section: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toExpression(node.markup),\n            };\n        }\n        case types_1.NamedTags.sections: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toExpression(node.markup),\n            };\n        }\n        case types_1.NamedTags.form: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: node.markup.map(toLiquidArgument),\n                children: [],\n            };\n        }\n        case types_1.NamedTags.tablerow:\n        case types_1.NamedTags.for: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toForMarkup(node.markup),\n                children: [],\n            };\n        }\n        case types_1.NamedTags.paginate: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toPaginateMarkup(node.markup),\n                children: [],\n            };\n        }\n        case types_1.NamedTags.if:\n        case types_1.NamedTags.unless: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toConditionalExpression(node.markup),\n                blockEndPosition: { start: -1, end: -1 },\n                children: [],\n            };\n        }\n        case types_1.NamedTags.elsif: {\n            return {\n                ...liquidBranchBaseAttributes(node),\n                name: node.name,\n                markup: toConditionalExpression(node.markup),\n            };\n        }\n        case types_1.NamedTags.case: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: toExpression(node.markup),\n                children: [],\n            };\n        }\n        case types_1.NamedTags.when: {\n            return {\n                ...liquidBranchBaseAttributes(node),\n                name: node.name,\n                markup: node.markup.map(toExpression),\n            };\n        }\n        case types_1.NamedTags.liquid: {\n            return {\n                ...liquidTagBaseAttributes(node),\n                name: node.name,\n                markup: cstToAst(node.markup, options),\n            };\n        }\n        default: {\n            return (0, utils_1.assertNever)(node);\n        }\n    }\n}\nfunction toNamedLiquidBranchBaseCase(node) {\n    var _a, _b;\n    return {\n        name: node.name,\n        type: types_1.NodeTypes.LiquidBranch,\n        markup: node.name !== 'else' ? node.markup : '',\n        position: { start: node.locStart, end: node.locEnd },\n        children: [],\n        blockStartPosition: { start: node.locStart, end: node.locEnd },\n        blockEndPosition: { start: -1, end: -1 },\n        whitespaceStart: (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '',\n        whitespaceEnd: (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '',\n        source: node.source,\n    };\n}\nfunction toUnnamedLiquidBranch(parentNode) {\n    return {\n        type: types_1.NodeTypes.LiquidBranch,\n        name: null,\n        markup: '',\n        position: { start: parentNode.position.end, end: parentNode.position.end },\n        blockStartPosition: { start: parentNode.position.end, end: parentNode.position.end },\n        blockEndPosition: { start: -1, end: -1 },\n        children: [],\n        whitespaceStart: '',\n        whitespaceEnd: '',\n        source: parentNode.source,\n    };\n}\nfunction toAssignMarkup(node) {\n    return {\n        type: types_1.NodeTypes.AssignMarkup,\n        name: node.name,\n        value: toLiquidVariable(node.value),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toCycleMarkup(node) {\n    return {\n        type: types_1.NodeTypes.CycleMarkup,\n        groupName: node.groupName ? toExpression(node.groupName) : null,\n        args: node.args.map(toExpression),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toForMarkup(node) {\n    return {\n        type: types_1.NodeTypes.ForMarkup,\n        variableName: node.variableName,\n        collection: toExpression(node.collection),\n        args: node.args.map(toNamedArgument),\n        reversed: !!node.reversed,\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toPaginateMarkup(node) {\n    return {\n        type: types_1.NodeTypes.PaginateMarkup,\n        collection: toExpression(node.collection),\n        pageSize: toExpression(node.pageSize),\n        position: position(node),\n        args: node.args ? node.args.map(toNamedArgument) : [],\n        source: node.source,\n    };\n}\nfunction toRawMarkup(node, options) {\n    return {\n        type: types_1.NodeTypes.RawMarkup,\n        kind: toRawMarkupKind(node),\n        nodes: cstToAst(node.children, options),\n        value: node.body,\n        position: {\n            start: node.blockStartLocEnd,\n            end: node.blockEndLocStart,\n        },\n        source: node.source,\n    };\n}\nfunction toRawMarkupKind(node) {\n    switch (node.type) {\n        case stage_1_cst_1.ConcreteNodeTypes.HtmlRawTag:\n            return toRawMarkupKindFromHtmlNode(node);\n        case stage_1_cst_1.ConcreteNodeTypes.LiquidRawTag:\n            return toRawMarkupKindFromLiquidNode(node);\n        default:\n            return (0, utils_1.assertNever)(node);\n    }\n}\nconst liquidToken = /(\\{%|\\{\\{)-?/g;\nfunction toRawMarkupKindFromHtmlNode(node) {\n    var _a;\n    switch (node.name) {\n        case 'script': {\n            const scriptAttr = (_a = node.attrList) === null || _a === void 0 ? void 0 : _a.find((attr) => 'name' in attr &&\n                typeof attr.name !== 'string' &&\n                attr.name.length === 1 &&\n                attr.name[0].type === stage_1_cst_1.ConcreteNodeTypes.TextNode &&\n                attr.name[0].value === 'type');\n            if (!scriptAttr ||\n                !('value' in scriptAttr) ||\n                scriptAttr.value.length === 0 ||\n                scriptAttr.value[0].type !== stage_1_cst_1.ConcreteNodeTypes.TextNode) {\n                return RawMarkupKinds.javascript;\n            }\n            const type = scriptAttr.value[0].value;\n            if (type === 'text/markdown') {\n                return RawMarkupKinds.markdown;\n            }\n            if (type === 'application/x-typescript') {\n                return RawMarkupKinds.typescript;\n            }\n            if (type === 'text/html') {\n                return RawMarkupKinds.html;\n            }\n            if ((type && (type.endsWith('json') || type.endsWith('importmap'))) ||\n                type === 'speculationrules') {\n                return RawMarkupKinds.json;\n            }\n            return RawMarkupKinds.javascript;\n        }\n        case 'style':\n            if (liquidToken.test(node.body)) {\n                return RawMarkupKinds.text;\n            }\n            return RawMarkupKinds.css;\n        default:\n            return RawMarkupKinds.text;\n    }\n}\nfunction toRawMarkupKindFromLiquidNode(node) {\n    switch (node.name) {\n        case 'javascript':\n            return RawMarkupKinds.javascript;\n        case 'stylesheet':\n        case 'style':\n            if (liquidToken.test(node.body)) {\n                return RawMarkupKinds.text;\n            }\n            return RawMarkupKinds.css;\n        case 'schema':\n            return RawMarkupKinds.json;\n        default:\n            return RawMarkupKinds.text;\n    }\n}\nfunction toContentForMarkup(node) {\n    return {\n        type: types_1.NodeTypes.ContentForMarkup,\n        contentForType: toExpression(node.contentForType),\n        /**\n         * When we're in completion mode we won't necessarily have valid named\n         * arguments so we need to call toLiquidArgument instead of toNamedArgument.\n         * We cast using `as` so that this doesn't affect the type system used in\n         * other areas (like theme check) for a scenario that only occurs in\n         * completion mode. This means that our types are *wrong* in completion mode\n         * but this is the compromise we're making to get completions to work.\n         */\n        args: node.args.map(toLiquidArgument),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toRenderMarkup(node) {\n    return {\n        type: types_1.NodeTypes.RenderMarkup,\n        snippet: toExpression(node.snippet),\n        alias: node.alias,\n        variable: toRenderVariableExpression(node.variable),\n        /**\n         * When we're in completion mode we won't necessarily have valid named\n         * arguments so we need to call toLiquidArgument instead of toNamedArgument.\n         * We cast using `as` so that this doesn't affect the type system used in\n         * other areas (like theme check) for a scenario that only occurs in\n         * completion mode. This means that our types are *wrong* in completion mode\n         * but this is the compromise we're making to get completions to work.\n         */\n        args: node.renderArguments.map(toLiquidArgument),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toRenderVariableExpression(node) {\n    if (!node)\n        return null;\n    return {\n        type: types_1.NodeTypes.RenderVariableExpression,\n        kind: node.kind,\n        name: toExpression(node.name),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toConditionalExpression(nodes) {\n    if (nodes.length === 1) {\n        return toComparisonOrExpression(nodes[0]);\n    }\n    const [first, second] = nodes;\n    const [, ...rest] = nodes;\n    return {\n        type: types_1.NodeTypes.LogicalExpression,\n        relation: second.relation,\n        left: toComparisonOrExpression(first),\n        right: toConditionalExpression(rest),\n        position: {\n            start: first.locStart,\n            end: nodes[nodes.length - 1].locEnd,\n        },\n        source: first.source,\n    };\n}\nfunction toComparisonOrExpression(node) {\n    const expression = node.expression;\n    switch (expression.type) {\n        case stage_1_cst_1.ConcreteNodeTypes.Comparison:\n            return toComparison(expression);\n        default:\n            return toExpression(expression);\n    }\n}\nfunction toComparison(node) {\n    return {\n        type: types_1.NodeTypes.Comparison,\n        comparator: node.comparator,\n        left: toExpression(node.left),\n        right: toExpression(node.right),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toLiquidVariableOutput(node) {\n    var _a, _b;\n    return {\n        type: types_1.NodeTypes.LiquidVariableOutput,\n        markup: typeof node.markup === 'string' ? node.markup : toLiquidVariable(node.markup),\n        whitespaceStart: (_a = node.whitespaceStart) !== null && _a !== void 0 ? _a : '',\n        whitespaceEnd: (_b = node.whitespaceEnd) !== null && _b !== void 0 ? _b : '',\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toLiquidVariable(node) {\n    return {\n        type: types_1.NodeTypes.LiquidVariable,\n        expression: toExpression(node.expression),\n        filters: node.filters.map(toFilter),\n        position: position(node),\n        rawSource: node.rawSource,\n        source: node.source,\n    };\n}\nfunction toExpression(node) {\n    switch (node.type) {\n        case stage_1_cst_1.ConcreteNodeTypes.String: {\n            return {\n                type: types_1.NodeTypes.String,\n                position: position(node),\n                single: node.single,\n                value: node.value,\n                source: node.source,\n            };\n        }\n        case stage_1_cst_1.ConcreteNodeTypes.Number: {\n            return {\n                type: types_1.NodeTypes.Number,\n                position: position(node),\n                value: node.value,\n                source: node.source,\n            };\n        }\n        case stage_1_cst_1.ConcreteNodeTypes.LiquidLiteral: {\n            return {\n                type: types_1.NodeTypes.LiquidLiteral,\n                position: position(node),\n                value: node.value,\n                keyword: node.keyword,\n                source: node.source,\n            };\n        }\n        case stage_1_cst_1.ConcreteNodeTypes.Range: {\n            return {\n                type: types_1.NodeTypes.Range,\n                start: toExpression(node.start),\n                end: toExpression(node.end),\n                position: position(node),\n                source: node.source,\n            };\n        }\n        case stage_1_cst_1.ConcreteNodeTypes.VariableLookup: {\n            return {\n                type: types_1.NodeTypes.VariableLookup,\n                name: node.name,\n                lookups: node.lookups.map(toExpression),\n                position: position(node),\n                source: node.source,\n            };\n        }\n        default: {\n            return (0, utils_1.assertNever)(node);\n        }\n    }\n}\nfunction toFilter(node) {\n    return {\n        type: types_1.NodeTypes.LiquidFilter,\n        name: node.name,\n        args: node.args.map(toLiquidArgument),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toLiquidArgument(node) {\n    switch (node.type) {\n        case stage_1_cst_1.ConcreteNodeTypes.NamedArgument: {\n            return toNamedArgument(node);\n        }\n        default: {\n            return toExpression(node);\n        }\n    }\n}\nfunction toNamedArgument(node) {\n    return {\n        type: types_1.NodeTypes.NamedArgument,\n        name: node.name,\n        value: toExpression(node.value),\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction toHtmlElement(node, options) {\n    return {\n        type: types_1.NodeTypes.HtmlElement,\n        name: cstToAst(node.name, options),\n        attributes: toAttributes(node.attrList || [], options),\n        position: position(node),\n        blockStartPosition: position(node),\n        blockEndPosition: { start: -1, end: -1 },\n        children: [],\n        source: node.source,\n    };\n}\nfunction toHtmlDanglingMarkerClose(node, options) {\n    return {\n        type: types_1.NodeTypes.HtmlDanglingMarkerClose,\n        name: cstToAst(node.name, options),\n        position: position(node),\n        blockStartPosition: position(node),\n        source: node.source,\n    };\n}\nfunction toHtmlVoidElement(node, options) {\n    return {\n        type: types_1.NodeTypes.HtmlVoidElement,\n        name: node.name,\n        attributes: toAttributes(node.attrList || [], options),\n        position: position(node),\n        blockStartPosition: position(node),\n        source: node.source,\n    };\n}\nfunction toHtmlSelfClosingElement(node, options) {\n    return {\n        type: types_1.NodeTypes.HtmlSelfClosingElement,\n        name: cstToAst(node.name, options),\n        attributes: toAttributes(node.attrList || [], options),\n        position: position(node),\n        blockStartPosition: position(node),\n        source: node.source,\n    };\n}\nfunction toNullableTextNode(node) {\n    if (!node || node.value === '')\n        return null;\n    return toTextNode(node);\n}\nfunction toTextNode(node) {\n    return {\n        type: types_1.NodeTypes.TextNode,\n        value: node.value,\n        position: position(node),\n        source: node.source,\n    };\n}\nfunction isAcceptableDanglingMarkerClose(builder, cst, currIndex, mode) {\n    if (mode === 'completion') {\n        const current = cst[currIndex];\n        const parentIsOfCorrectName = builder.parent &&\n            builder.parent.type === types_1.NodeTypes.HtmlElement &&\n            getName(builder.parent) === getName(current);\n        return !parentIsOfCorrectName;\n    }\n    return isAcceptableDanglingMarker(builder);\n}\n// This function checks that the builder.current node accepts dangling nodes.\n//\n// The current logic is:\n//  - Grandparent node must be an if-like statement\n//  - Parent node must be a LiquidBranch\nfunction isAcceptableDanglingMarker(builder) {\n    const { parent, grandparent } = builder;\n    if (!parent || !grandparent)\n        return false;\n    return (parent.type === types_1.NodeTypes.LiquidBranch &&\n        grandparent.type === types_1.NodeTypes.LiquidTag &&\n        ['if', 'unless', 'case'].includes(grandparent.name));\n}\n// checking that is a {% else %} or {% endif %}\nfunction isConcreteExceptionEnd(node) {\n    return (!node ||\n        node.type === stage_1_cst_1.ConcreteNodeTypes.LiquidTagClose ||\n        isConcreteLiquidBranchDisguisedAsTag(node));\n}\nfunction markup(name, markup) {\n    if (grammar_1.TAGS_WITHOUT_MARKUP.includes(name))\n        return '';\n    return markup;\n}\nfunction position(node) {\n    return {\n        start: node.locStart,\n        end: node.locEnd,\n    };\n}\nfunction walk(ast, fn, parentNode) {\n    for (const key of Object.keys(ast)) {\n        if (types_1.nonTraversableProperties.has(key)) {\n            continue;\n        }\n        const value = ast[key];\n        if (Array.isArray(value)) {\n            value.filter(isLiquidHtmlNode).forEach((node) => walk(node, fn, ast));\n        }\n        else if (isLiquidHtmlNode(value)) {\n            walk(value, fn, ast);\n        }\n    }\n    fn(ast, parentNode);\n}\nexports.walk = walk;\nfunction isLiquidHtmlNode(value) {\n    return (value !== null &&\n        typeof value === 'object' &&\n        'type' in value &&\n        types_1.NodeTypes.hasOwnProperty(value.type));\n}\nexports.isLiquidHtmlNode = isLiquidHtmlNode;\nfunction getUnclosed(node, parentNode) {\n    var _a;\n    if (!node)\n        return undefined;\n    if (getName(node) === null && parentNode) {\n        node = parentNode;\n    }\n    return {\n        type: node.type,\n        name: (_a = getName(node)) !== null && _a !== void 0 ? _a : '',\n        blockStartPosition: 'blockStartPosition' in node ? node.blockStartPosition : node.position,\n    };\n}\n//# sourceMappingURL=stage-2-ast.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nonTraversableProperties = exports.LiquidNodeTypes = exports.HtmlNodeTypes = exports.Comparators = exports.NamedTags = exports.NodeTypes = void 0;\nvar NodeTypes;\n(function (NodeTypes) {\n    NodeTypes[\"Document\"] = \"Document\";\n    NodeTypes[\"LiquidRawTag\"] = \"LiquidRawTag\";\n    NodeTypes[\"LiquidTag\"] = \"LiquidTag\";\n    NodeTypes[\"LiquidBranch\"] = \"LiquidBranch\";\n    NodeTypes[\"LiquidVariableOutput\"] = \"LiquidVariableOutput\";\n    NodeTypes[\"HtmlSelfClosingElement\"] = \"HtmlSelfClosingElement\";\n    NodeTypes[\"HtmlVoidElement\"] = \"HtmlVoidElement\";\n    NodeTypes[\"HtmlDoctype\"] = \"HtmlDoctype\";\n    NodeTypes[\"HtmlComment\"] = \"HtmlComment\";\n    NodeTypes[\"HtmlElement\"] = \"HtmlElement\";\n    NodeTypes[\"HtmlDanglingMarkerClose\"] = \"HtmlDanglingMarkerClose\";\n    NodeTypes[\"HtmlRawNode\"] = \"HtmlRawNode\";\n    NodeTypes[\"AttrSingleQuoted\"] = \"AttrSingleQuoted\";\n    NodeTypes[\"AttrDoubleQuoted\"] = \"AttrDoubleQuoted\";\n    NodeTypes[\"AttrUnquoted\"] = \"AttrUnquoted\";\n    NodeTypes[\"AttrEmpty\"] = \"AttrEmpty\";\n    NodeTypes[\"TextNode\"] = \"TextNode\";\n    NodeTypes[\"YAMLFrontmatter\"] = \"YAMLFrontmatter\";\n    NodeTypes[\"LiquidVariable\"] = \"LiquidVariable\";\n    NodeTypes[\"LiquidFilter\"] = \"LiquidFilter\";\n    NodeTypes[\"NamedArgument\"] = \"NamedArgument\";\n    NodeTypes[\"LiquidLiteral\"] = \"LiquidLiteral\";\n    NodeTypes[\"String\"] = \"String\";\n    NodeTypes[\"Number\"] = \"Number\";\n    NodeTypes[\"Range\"] = \"Range\";\n    NodeTypes[\"VariableLookup\"] = \"VariableLookup\";\n    NodeTypes[\"Comparison\"] = \"Comparison\";\n    NodeTypes[\"LogicalExpression\"] = \"LogicalExpression\";\n    NodeTypes[\"AssignMarkup\"] = \"AssignMarkup\";\n    NodeTypes[\"ContentForMarkup\"] = \"ContentForMarkup\";\n    NodeTypes[\"CycleMarkup\"] = \"CycleMarkup\";\n    NodeTypes[\"ForMarkup\"] = \"ForMarkup\";\n    NodeTypes[\"PaginateMarkup\"] = \"PaginateMarkup\";\n    NodeTypes[\"RawMarkup\"] = \"RawMarkup\";\n    NodeTypes[\"RenderMarkup\"] = \"RenderMarkup\";\n    NodeTypes[\"RenderVariableExpression\"] = \"RenderVariableExpression\";\n    NodeTypes[\"LiquidDocDescriptionNode\"] = \"LiquidDocDescriptionNode\";\n    NodeTypes[\"LiquidDocParamNode\"] = \"LiquidDocParamNode\";\n    NodeTypes[\"LiquidDocExampleNode\"] = \"LiquidDocExampleNode\";\n})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));\n// These are officially supported with special node types\nvar NamedTags;\n(function (NamedTags) {\n    NamedTags[\"assign\"] = \"assign\";\n    NamedTags[\"capture\"] = \"capture\";\n    NamedTags[\"case\"] = \"case\";\n    NamedTags[\"content_for\"] = \"content_for\";\n    NamedTags[\"cycle\"] = \"cycle\";\n    NamedTags[\"decrement\"] = \"decrement\";\n    NamedTags[\"echo\"] = \"echo\";\n    NamedTags[\"elsif\"] = \"elsif\";\n    NamedTags[\"for\"] = \"for\";\n    NamedTags[\"form\"] = \"form\";\n    NamedTags[\"if\"] = \"if\";\n    NamedTags[\"include\"] = \"include\";\n    NamedTags[\"increment\"] = \"increment\";\n    NamedTags[\"layout\"] = \"layout\";\n    NamedTags[\"liquid\"] = \"liquid\";\n    NamedTags[\"paginate\"] = \"paginate\";\n    NamedTags[\"render\"] = \"render\";\n    NamedTags[\"section\"] = \"section\";\n    NamedTags[\"sections\"] = \"sections\";\n    NamedTags[\"tablerow\"] = \"tablerow\";\n    NamedTags[\"unless\"] = \"unless\";\n    NamedTags[\"when\"] = \"when\";\n})(NamedTags = exports.NamedTags || (exports.NamedTags = {}));\nvar Comparators;\n(function (Comparators) {\n    Comparators[\"CONTAINS\"] = \"contains\";\n    Comparators[\"EQUAL\"] = \"==\";\n    Comparators[\"GREATER_THAN\"] = \">\";\n    Comparators[\"GREATER_THAN_OR_EQUAL\"] = \">=\";\n    Comparators[\"LESS_THAN\"] = \"<\";\n    Comparators[\"LESS_THAN_OR_EQUAL\"] = \"<=\";\n    Comparators[\"NOT_EQUAL\"] = \"!=\";\n})(Comparators = exports.Comparators || (exports.Comparators = {}));\nexports.HtmlNodeTypes = [\n    NodeTypes.HtmlElement,\n    NodeTypes.HtmlDanglingMarkerClose,\n    NodeTypes.HtmlRawNode,\n    NodeTypes.HtmlVoidElement,\n    NodeTypes.HtmlSelfClosingElement,\n];\nexports.LiquidNodeTypes = [\n    NodeTypes.LiquidTag,\n    NodeTypes.LiquidVariableOutput,\n    NodeTypes.LiquidBranch,\n    NodeTypes.LiquidRawTag,\n];\n// Those properties create loops that would make walking infinite\nexports.nonTraversableProperties = new Set([\n    'parentNode',\n    'prev',\n    'next',\n    'firstChild',\n    'lastChild',\n]);\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dropLast = exports.deepGet = exports.locEnd = exports.locStart = exports.assertNever = void 0;\nfunction assertNever(x) {\n    throw new Error(`Unexpected object: ${x.type}`);\n}\nexports.assertNever = assertNever;\nfunction locStart(node) {\n    return node.position.start;\n}\nexports.locStart = locStart;\nfunction locEnd(node) {\n    return node.position.end;\n}\nexports.locEnd = locEnd;\nfunction deepGet(path, obj) {\n    return path.reduce((curr, k) => {\n        if (curr && curr[k] !== undefined)\n            return curr[k];\n        return undefined;\n    }, obj);\n}\nexports.deepGet = deepGet;\nfunction dropLast(n, xs) {\n    const result = [...xs];\n    for (let i = 0; i < n; i++) {\n        result.pop();\n    }\n    return result;\n}\nexports.dropLast = dropLast;\n//# sourceMappingURL=utils.js.map","module.exports = String.raw`Helpers {\n  Node = TextNode*\n  TextNode = AnyExceptPlus<openControl>\n  openControl = end\n\n  empty = /* nothing */\n  anyExcept<lit> = (~ lit any)\n  anyExceptStar<lit> = (~ lit any)*\n  anyExceptPlus<lit> = (~ lit any)+\n  AnyExcept<lit> = (~ lit any)\n  AnyExceptPlus<lit> = (~ lit any)+\n  AnyExceptStar<lit> = (~ lit any)*\n  identifierCharacter = alnum | \"_\" | \"-\"\n\n  orderedListOf<a, b, sep> =\n    | nonemptyOrderedListOf<a, b, sep>\n    | emptyListOf<a, sep>\n  nonemptyOrderedListOf<a, b, sep> =\n    | nonemptyListOf<b, sep>\n    | nonemptyOrderedListOfBoth<a, b, sep>\n    | nonemptyListOf<a, sep>\n  nonemptyOrderedListOfBoth<a, b, sep> =\n    nonemptyListOf<a, sep> (sep nonemptyListOf<b, sep>)\n\n  singleQuote = \"'\" | \"\" | \"\"\n  doubleQuote = \"\\\"\" | \"\" | \"\"\n  controls = \"\\u{007F}\"..\"\\u{009F}\"\n  noncharacters = \"\\u{FDD0}\"..\"\\u{FDEF}\"\n  newline = \"\\r\"? \"\\n\"\n}\n\nLiquid <: Helpers {\n  Node := (liquidNode | TextNode)*\n  openControl := \"{{\" | \"{%\"\n  endOfTagName = &(\"-%}\" | \"-}}\" | \"%}\" | \"}}\")\n  endOfVarName = ~identifierCharacter\n  endOfIdentifier = endOfTagName | endOfVarName\n\n  liquidNode =\n  \t| liquidDoc\n    | liquidBlockComment\n    | liquidRawTag\n    | liquidDrop\n    | liquidTagClose\n    | liquidTagOpen\n    | liquidTag\n    | liquidInlineComment\n\n  liquidTagStrict =\n    | liquidTagAssign\n    | liquidTagBreak\n    | liquidTagContinue\n    | liquidTagCycle\n    | liquidTagContentFor\n    | liquidTagDecrement\n    | liquidTagEcho\n    | liquidTagElse\n    | liquidTagElsif\n    | liquidTagInclude\n    | liquidTagIncrement\n    | liquidTagLayout\n    | liquidTagLiquid\n    | liquidTagRender\n    | liquidTagSection\n    | liquidTagSections\n    | liquidTagWhen\n\n  liquidTag =\n    | liquidTagStrict\n    | liquidTagBaseCase\n\n  liquidTagOpenStrict =\n    | liquidTagOpenCase\n    | liquidTagOpenCapture\n    | liquidTagOpenForm\n    | liquidTagOpenFor\n    | liquidTagOpenTablerow\n    | liquidTagOpenIf\n    | liquidTagOpenPaginate\n    | liquidTagOpenUnless\n\n  liquidTagOpen =\n    | liquidTagOpenStrict\n    | liquidTagOpenBaseCase\n\n  liquidTagClose = \"{%\" \"-\"? space* \"end\" blockName space* tagMarkup \"-\"? \"%}\"\n\n  // These two are the same but transformed differently\n  liquidTagRule<name, markup> =\n    \"{%\" \"-\"? space* (name endOfIdentifier) space* markup \"-\"? \"%}\"\n  liquidTagOpenRule<name, markup> =\n    \"{%\" \"-\"? space* (name endOfIdentifier) space* markup \"-\"? \"%}\"\n\n  liquidTagBaseCase = liquidTagRule<liquidTagName, tagMarkup>\n\n  liquidTagEcho = liquidTagRule<\"echo\", liquidTagEchoMarkup>\n  liquidTagEchoMarkup = liquidVariable<delimTag>\n\n  liquidTagAssign = liquidTagRule<\"assign\", liquidTagAssignMarkup>\n  liquidTagAssignMarkup = variableSegment space* \"=\" space* liquidVariable<delimTag>\n\n  liquidTagCycle = liquidTagRule<\"cycle\", liquidTagCycleMarkup>\n  liquidTagCycleMarkup = (liquidExpression<delimTag> \":\")? space* nonemptyListOf<liquidExpression<delimTag>, argumentSeparator> space*\n\n  liquidTagIncrement = liquidTagRule<\"increment\", variableSegmentAsLookupMarkup>\n  liquidTagDecrement = liquidTagRule<\"decrement\", variableSegmentAsLookupMarkup>\n  liquidTagOpenCapture = liquidTagOpenRule<\"capture\", variableSegmentAsLookupMarkup>\n  variableSegmentAsLookupMarkup = variableSegmentAsLookup space*\n\n  liquidTagSection = liquidTagRule<\"section\", liquidTagSectionMarkup>\n  liquidTagSectionMarkup = liquidString<delimTag> space*\n\n  liquidTagSections = liquidTagRule<\"sections\", liquidTagSectionsMarkup>\n  liquidTagSectionsMarkup = liquidString<delimTag> space*\n\n  liquidTagLayout = liquidTagRule<\"layout\", liquidTagLayoutMarkup>\n  liquidTagLayoutMarkup = liquidExpression<delimTag> space*\n\n  // We'll black hole the statement and switch parser in the cst builder\n  // We do this because it's technically the same grammar (with minor redefinitions)\n  // and it would be a huge chore and maintenance hell to rewrite all the rules with\n  // hspace = \" \" | \"\\t\"\n  //\n  // The alternative is that this grammar parses the {% liquid tagMarkup %} as its own string,\n  // and then we switch to the LiquidStatement grammar that\n  // redefines liquidTagOpenRule, liquidTagRule, and space.\n  liquidTagLiquid = liquidTagRule<\"liquid\", liquidTagLiquidMarkup>\n  liquidTagLiquidMarkup = tagMarkup\n\n  liquidTagContentFor = liquidTagRule<\"content_for\", liquidTagContentForMarkup>\n\n  liquidTagContentForMarkup =\n    contentForType (argumentSeparatorOptionalComma contentForTagArgument) (space* \",\")? space*\n\n  contentForTagArgument = listOf<contentForNamedArgument<delimTag>, argumentSeparatorOptionalComma>\n  completionModeContentForTagArgument = listOf<contentForNamedArgument<delimTag>, argumentSeparatorOptionalComma> (argumentSeparator? (liquidVariableLookup<delimTag>))?\n  contentForNamedArgument<delim> = (variableSegment (\".\" variableSegment)*) space* \":\" space* (liquidExpression<delim>)\n\n  contentForType = liquidString<delimTag>\n\n  liquidTagInclude = liquidTagRule<\"include\", liquidTagRenderMarkup>\n  liquidTagRender = liquidTagRule<\"render\", liquidTagRenderMarkup>\n  liquidTagRenderMarkup =\n    snippetExpression renderVariableExpression? renderAliasExpression? renderArguments\n\n  renderArguments = (argumentSeparatorOptionalComma tagArguments) (space* \",\")? space*\n  completionModeRenderArguments = (argumentSeparatorOptionalComma tagArguments) (space* \",\")? space* (argumentSeparator? liquidVariableLookup<delimTag> space*)?\n  snippetExpression = liquidString<delimTag> | variableSegmentAsLookup\n  renderVariableExpression = space+ (\"for\" | \"with\") space+ liquidExpression<delimTag>\n  renderAliasExpression = space+ \"as\" space+ variableSegment\n\n  liquidTagOpenBaseCase = liquidTagOpenRule<blockName, tagMarkup>\n\n  liquidTagOpenForm = liquidTagOpenRule<\"form\", liquidTagOpenFormMarkup>\n  liquidTagOpenFormMarkup = arguments<delimTag> (space* \",\")? space*\n\n  liquidTagOpenFor = liquidTagOpenRule<\"for\", liquidTagOpenForMarkup>\n  liquidTagOpenForMarkup =\n    variableSegment space* \"in\" space* liquidExpression<delimTag>\n    (space* \"reversed\")? argumentSeparatorOptionalComma\n    tagArguments (space* \",\")? space*\n\n  // It's the same, the difference is support for different named arguments<delim>\n  liquidTagOpenTablerow = liquidTagOpenRule<\"tablerow\", liquidTagOpenForMarkup>\n\n  liquidTagOpenCase = liquidTagOpenRule<\"case\", liquidTagOpenCaseMarkup>\n  liquidTagOpenCaseMarkup = liquidExpression<delimTag> space*\n\n  liquidTagWhen = liquidTagRule<\"when\", liquidTagWhenMarkup>\n  liquidTagWhenMarkup = nonemptyListOf<liquidExpression<delimTag>, whenMarkupSep> space*\n  whenMarkupSep = space* (\",\" | \"or\" ~identifier) space*\n\n  liquidTagOpenIf = liquidTagOpenRule<\"if\", liquidTagOpenConditionalMarkup>\n  liquidTagOpenUnless = liquidTagOpenRule<\"unless\", liquidTagOpenConditionalMarkup>\n  liquidTagElsif = liquidTagRule<\"elsif\", liquidTagOpenConditionalMarkup>\n\n  liquidTagBreak = liquidTagRule<\"break\", empty>\n  liquidTagContinue = liquidTagRule<\"continue\", empty>\n  liquidTagElse = liquidTagRule<\"else\", empty>\n\n  liquidTagOpenConditionalMarkup = nonemptyListOf<condition<delimTag>, conditionSeparator> space*\n  conditionSeparator = &logicalOperator\n  condition<delim> = logicalOperator? space* (comparison<delim> | liquidExpression<delim>) space*\n  logicalOperator = (\"and\" | \"or\") ~identifier\n  comparison<delim> = liquidExpression<delim> space* comparator space* liquidExpression<delim>\n  comparator =\n    ( \"==\"\n    | \"!=\"\n    | \">=\"\n    | \"<=\"\n    | \">\"\n    | \"<\")\n    | (\"contains\" ~identifier)\n\n  liquidTagOpenPaginate = liquidTagOpenRule<\"paginate\", liquidTagOpenPaginateMarkup>\n  liquidTagOpenPaginateMarkup =\n    liquidExpression<delimTag> space+ \"by\" space+ liquidExpression<delimTag> argumentSeparatorOptionalComma tagArguments (space* \",\")? space*\n\n  liquidDrop = \"{{\" \"-\"? space* liquidDropCases \"-\"? \"}}\"\n  liquidDropCases = liquidVariable<delimVO> | liquidDropBaseCase\n  liquidDropBaseCase = anyExceptStar<delimVO>\n  liquidInlineComment = \"{%\" \"-\"? space* \"#\" space? tagMarkup \"-\"? \"%}\"\n\n  liquidRawTag =\n    | liquidRawTagImpl<\"raw\">\n    | liquidRawTagImpl<\"javascript\">\n    | liquidRawTagImpl<\"schema\">\n    | liquidRawTagImpl<\"stylesheet\">\n    | liquidRawTagImpl<\"style\">\n  liquidRawTagImpl<name> =\n    \"{%\" \"-\"? space* (name endOfIdentifier) space* tagMarkup \"-\"? \"%}\"\n    anyExceptStar<liquidRawTagClose<name>>\n    \"{%\" \"-\"? space* \"end\" (name endOfIdentifier) space* \"-\"? \"%}\"\n  liquidRawTagClose<name> =\n    \"{%\" \"-\"? space* \"end\" (name endOfIdentifier) space* \"-\"? \"%}\"\n\n  liquidBlockComment =\n    commentBlockStart\n      (liquidBlockComment | anyExceptPlus<(commentBlockStart | commentBlockEnd)>)*\n    commentBlockEnd\n  commentBlockStart = \"{%\" \"-\"? space* (\"comment\"    endOfIdentifier) space* tagMarkup \"-\"? \"%}\"\n  commentBlockEnd   = \"{%\" \"-\"? space* (\"endcomment\" endOfIdentifier) space* tagMarkup \"-\"? \"%}\"\n\n  liquidDoc =\n    liquidDocStart\n      liquidDocBody\n    liquidDocEnd\n\n  liquidDocStart = \"{%\" \"-\"? space* (\"doc\" endOfIdentifier) space* tagMarkup \"-\"? \"%}\"\n  liquidDocEnd = \"{%\" \"-\"? space* (\"enddoc\" endOfIdentifier) space* tagMarkup \"-\"? \"%}\"\n  liquidDocBody = anyExceptStar<(liquidDocStart | liquidDocEnd)>\n\n  // In order for the grammar to \"fallback\" to the base case, this\n  // rule must pass if and only if we support what we parse. This\n  // implies thatsince we don't support filters yetwe have a\n  // positive lookahead on \"-}}\" or \"}}\" in the rule. We do this\n  // because we'd otherwise positively match the following string\n  // instead of falling back to the other rule:\n  // {{ 'string' | some_filter }}\n  liquidVariable<delim> = liquidExpression<delim> liquidFilter<delim>* space* &delim\n\n  liquidExpression<delim> =\n    | liquidString<delim>\n    | liquidNumber\n    | liquidLiteral\n    | liquidRange<delim>\n    | liquidVariableLookup<delim>\n\n  liquidString<delim> = liquidSingleQuotedString<delim> | liquidDoubleQuotedString<delim>\n  liquidSingleQuotedString<delim> = \"'\" anyExceptStar<(\"'\"| delim)> \"'\"\n  liquidDoubleQuotedString<delim> = \"\\\"\" anyExceptStar<(\"\\\"\"| delim)> \"\\\"\"\n\n  liquidNumber = liquidFloat | liquidInteger\n  liquidInteger = \"-\"? digit+\n  liquidFloat = \"-\"? digit+ \".\" digit+\n\n  liquidLiteral =\n    ( \"true\"\n    | \"false\"\n    | \"blank\"\n    | \"empty\"\n    | \"nil\"\n    | \"null\"\n    ) endOfIdentifier\n\n  liquidRange<delim> =\n    \"(\" space* liquidExpression<delim> space* \"..\" space* liquidExpression<delim> space* \")\"\n\n  liquidVariableLookup<delim> =\n    | variableSegment lookup<delim>*\n    | empty lookup<delim>+\n  lookup<delim> =\n    | indexLookup<delim>\n    | dotLookup\n  indexLookup<delim> = space* \"[\" space* liquidExpression<delim> space* \"]\"\n  dotLookup = space* \".\" space* identifier\n\n  liquidFilter<delim> = space* \"|\" space* identifier (space* \":\" space* arguments<delim> (space* \",\")?)?\n\n  arguments<delim> = nonemptyOrderedListOf<positionalArgument<delim>, namedArgument<delim>, argumentSeparator>\n  argumentSeparator = space* \",\" space*\n  argumentSeparatorOptionalComma = space* \",\"? space*\n  positionalArgument<delim> = liquidExpression<delim> ~(space* \":\")\n  namedArgument<delim> = variableSegment space* \":\" space* liquidExpression<delim>\n  tagArguments = listOf<namedArgument<delimTag>, argumentSeparatorOptionalComma>\n  filterArguments<delim> =\n    | complexArguments<delim>\n    | simpleArgument<delim>\n  complexArguments<delim> = arguments<delim> (space* \",\" space* simpleArgument<delim>)?\n  simpleArgument<delim> = liquidVariableLookup<delim>\n\n  variableSegment = (letter | \"_\") (~endOfTagName identifierCharacter)*\n  variableSegmentAsLookup = variableSegment\n  identifier = variableSegment \"?\"?\n\n  tagMarkup = anyExceptStar<delimTag>\n\n  liquidTagName =\n    letter (alnum | \"_\")*\n\n  blockName =\n    // Shopify blocks\n    ( \"form\"\n    | \"paginate\"\n    // Base blocks\n    | \"capture\"\n    | \"case\"\n    | \"for\"\n    | \"ifchanged\"\n    | \"if\"\n    | \"unless\"\n    | \"tablerow\"\n    ) endOfIdentifier\n\n  delimTag = \"-%}\" | \"%}\"\n  delimVO = \"-}}\" | \"}}\"\n}\n\nLiquidStatement <: Liquid {\n  Node := listOf<LiquidStatement, statementSep> (space | newline)*\n\n  // This is the big brains moment: we redefine space to exclude newlines.\n  //\n  // Which means that all our other Liquid rules can be reused\n  // without modification(!)\n  //\n  // We don't need to maintain rules like this:\n  // - liquidVariable<space>\n  // - liquidExpression<space>\n  // - variableLookup<space>\n  // - ... long list of stuff that takes space as param\n  // - liquidString<space>\n  //\n  // All we need is this little, VERY IMPORTANT, part right here that\n  // make it so we can parse the same way in Liquid tags.\n  //\n  // I'm putting in this huge comment so that it's more obvious.\n  space := \" \" | \"\\t\"\n\n  LiquidStatement =\n    | liquidBlockComment\n    | liquidRawTag\n    | liquidTagClose\n    | liquidTagOpen\n    | liquidTag\n    | liquidInlineComment\n\n  liquidTagOpenRule<name, markup>\n    := (name ~identifierCharacter) space* markup &liquidStatementEnd\n\n  liquidTagRule<name, markup>\n    := (name ~identifierCharacter) space* markup &liquidStatementEnd\n\n  liquidTagClose\n    := \"end\" (blockName ~identifierCharacter) space* tagMarkup &liquidStatementEnd\n\n  liquidRawTagImpl<name>\n    := (name ~identifierCharacter) space* tagMarkup newline\n      anyExceptStar<liquidRawTagClose<name>>\n      \"end\" name space* &liquidStatementEnd\n\n  liquidRawTagClose<name>\n    := \"end\" name space* &liquidStatementEnd\n\n  liquidBlockComment :=\n    commentBlockStart statementSep\n      (listOf<liquidCommentBlockStatement, statementSep> statementSep)?\n    commentBlockEnd\n\n  liquidCommentBlockStatement =\n    | liquidBlockComment\n    | nonTerminalCommentLine\n\n  commentBlockStart\n    := (\"comment\" ~identifierCharacter) space* tagMarkup\n\n  commentBlockEnd\n    := (\"endcomment\" ~identifierCharacter) space* tagMarkup\n\n  nonTerminalCommentLine\n    = ~commentBlockEnd anyExceptPlus<newline>\n\n  liquidInlineComment\n    := \"#\" space? tagMarkup &liquidStatementEnd\n\n  tagMarkup := anyExceptStar<liquidStatementEnd>\n\n  // trailing whitespace, newline, + anything else before the next tag\n  statementSep = space* newline (space | newline)*\n\n  liquidStatementEnd = newline | end\n  delimTag := liquidStatementEnd\n}\n\nLiquidDoc <: Helpers {\n  Node := (LiquidDocNode | TextNode)*\n  LiquidDocNode =\n    | paramNode\n    | exampleNode\n    | descriptionNode\n    | fallbackNode\n    \n  // By default, space matches new lines as well. We override it here to make writing rules easier.\n  strictSpace = \" \" | \"\\t\"\n  // We use this as an escape hatch to stop matching TextNode and try again when one of these characters is encountered\n  openControl:= \"@\" | end\n\n  descriptionNode = \"@description\" strictSpace* descriptionContent\n  descriptionContent = anyExceptStar<endOfDescription>\n  endOfDescription = strictSpace* openControl\n\n  paramNode = \"@param\" strictSpace* paramType? strictSpace* (optionalParamName | paramName) (strictSpace* \"-\")? strictSpace* paramDescription\n  paramType = \"{\" strictSpace* paramTypeContent strictSpace* \"}\"\n  paramTypeContent = anyExceptStar<(\"}\"| strictSpace)>\n\n  paramName = textValue\n  optionalParamName = \"[\" strictSpace* textValue strictSpace* \"]\"\n  textValue = identifierCharacter+\n\n  paramDescription = (~\"]\" anyExceptStar<endOfParam>)\n  endOfParam = strictSpace* (newline | end)\n\n  exampleNode = \"@example\" strictSpace* exampleContent\n  exampleContent = anyExceptStar<endOfExample>\n  endOfExample =  strictSpace* (\"@\" | end)\n\n  fallbackNode = \"@\" anyExceptStar<endOfParam>\n}\n\nLiquidHTML <: Liquid {\n  Node := yamlFrontmatter? (HtmlNode | liquidNode | TextNode)*\n  openControl += \"<\"\n\n  yamlFrontmatter =\n    \"---\" newline anyExceptStar<\"---\"> \"---\" newline\n\n  HtmlNode =\n    | HtmlDoctype\n    | HtmlComment\n    | HtmlRawTag\n    | HtmlVoidElement\n    | HtmlSelfClosingElement\n    | HtmlTagClose\n    | HtmlTagOpen\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#the-doctype\n  HtmlDoctype =\n    #(\"<!\" caseInsensitive<\"doctype\"> space+ caseInsensitive<\"html\">) legacyDoctypeString? \">\"\n  legacyDoctypeString\n    = anyExceptPlus<\">\">\n\n  HtmlComment = \"<!--\" #(anyExceptStar<\"-->\"> \"-->\")\n\n  // These are black holes, we'll ignore what's in them\n  HtmlRawTag =\n    | HtmlRawTagImpl<\"script\">\n    | HtmlRawTagImpl<\"style\">\n    | HtmlRawTagImpl<\"svg\">\n\n  HtmlRawTagImpl<name> =\n    TagStart<name>\n      (HtmlRawTagImpl<name> | AnyExceptPlus<(TagStart<name> | TagEnd<name>)>)*\n    TagEnd<name>\n  TagStart<name> = \"<\" name AttrList \">\"\n  TagEnd<name> = \"</\" name \">\"\n\n  HtmlVoidElement =\n    #(\"<\" voidElementName &(space | \"/\" | \">\")) AttrList \"/\"? \">\"\n\n  HtmlSelfClosingElement =\n    #(\"<\" tagName) AttrList \"/>\"\n\n  HtmlTagOpen =\n    #(\"<\" tagName) AttrList \">\"\n\n  HtmlTagClose =\n    #(\"</\" tagName) \">\"\n\n  tagName = leadingTagNamePart trailingTagNamePart*\n\n  // The difference here is that the first text part must start\n  // with a letter, but trailing text parts don't have that\n  // requirement\n  leadingTagNamePart =\n    | liquidDrop\n    | leadingTagNameTextNode\n\n  trailingTagNamePart =\n    | liquidDrop\n    | trailingTagNameTextNode\n\n  leadingTagNameTextNode = letter (alnum | \"-\" | \":\")*\n  trailingTagNameTextNode = (alnum | \"-\" | \":\")+\n\n  AttrList = Attr*\n\n  Attr =\n    AttrSingleQuoted | AttrDoubleQuoted | AttrUnquoted | liquidNode | attrEmpty\n\n  attrEmpty = attrName\n\n  AttrUnquoted = attrName \"=\" attrUnquotedValue\n  AttrSingleQuoted = attrName \"=\" singleQuote #(attrSingleQuotedValue singleQuote)\n  AttrDoubleQuoted = attrName \"=\" doubleQuote #(attrDoubleQuotedValue doubleQuote)\n\n  attrName = (liquidDrop | attrNameTextNode)+\n\n  // https://html.spec.whatwg.org/#attributes-2\n  attrNameTextNode = anyExceptPlus<(space | quotes | \"=\" | \">\" | \"/>\" | \"{{\" | \"{%\" | controls | noncharacters)>\n  attrUnquotedValue = (liquidDrop | attrUnquotedTextNode)*\n  attrSingleQuotedValue = (liquidNode | attrSingleQuotedTextNode)*\n  attrDoubleQuotedValue = (liquidNode | attrDoubleQuotedTextNode)*\n\n  attrUnquotedTextNode = anyExceptPlus<(space | quotes | \"=\" | \"<\" | \">\" | \"${\"`\"}\" | \"{{\" | \"{%\")>\n  attrSingleQuotedTextNode = anyExceptPlus<(singleQuote | \"{{\" | \"{%\")>\n  attrDoubleQuotedTextNode = anyExceptPlus<(doubleQuote | \"{{\" | \"{%\")>\n\n  quotes = singleQuote | doubleQuote\n\n  // https://www.w3.org/TR/2011/WD-html-markup-20110113/syntax.html#void-element\n  voidElementName =\n    ( caseInsensitive<\"area\">\n    | caseInsensitive<\"base\">\n    | caseInsensitive<\"br\">\n    | caseInsensitive<\"col\">\n    | caseInsensitive<\"command\">\n    | caseInsensitive<\"embed\">\n    | caseInsensitive<\"hr\">\n    | caseInsensitive<\"img\">\n    | caseInsensitive<\"input\">\n    | caseInsensitive<\"keygen\">\n    | caseInsensitive<\"link\">\n    | caseInsensitive<\"meta\">\n    | caseInsensitive<\"param\">\n    | caseInsensitive<\"source\">\n    | caseInsensitive<\"track\">\n    | caseInsensitive<\"wbr\">\n    ) ~identifierCharacter\n}\n\nStrictLiquid <: Liquid {\n  liquidTag := liquidTagStrict\n  liquidTagOpen := liquidTagOpenStrict\n}\n\nStrictLiquidStatement <: LiquidStatement {\n  liquidTag := liquidTagStrict\n  liquidTagOpen := liquidTagOpenStrict\n}\n\nStrictLiquidHTML <: LiquidHTML {\n  liquidTag := liquidTagStrict\n  liquidTagOpen := liquidTagOpenStrict\n}\n\nWithPlaceholderLiquid <: Liquid {\n  liquidFilter<delim> := space* \"|\" space* identifier (space* \":\" space* filterArguments<delim> (space* \",\")?)?\n  liquidTagContentForMarkup :=\n    contentForType (argumentSeparatorOptionalComma completionModeContentForTagArgument) (space* \",\")? space*\n  liquidTagRenderMarkup :=\n    snippetExpression renderVariableExpression? renderAliasExpression? completionModeRenderArguments\n  liquidTagName := (letter | \"\") (alnum | \"_\")*\n  variableSegment := (letter | \"_\" | \"\") (identifierCharacter | \"\")*\n  liquidDoc :=\n    liquidDocStart\n      liquidDocBody\n    liquidDocEnd?\n}\n\nWithPlaceholderLiquidStatement <: LiquidStatement {\n  liquidFilter<delim> := space* \"|\" space* identifier (space* \":\" space* filterArguments<delim> (space* \",\")?)?\n  liquidTagContentForMarkup :=\n    contentForType (argumentSeparatorOptionalComma completionModeContentForTagArgument) (space* \",\")? space*\n  liquidTagRenderMarkup :=\n    snippetExpression renderVariableExpression? renderAliasExpression? completionModeRenderArguments\n  liquidTagName := (letter | \"\") (alnum | \"_\")*\n  variableSegment := (letter | \"_\" | \"\") (identifierCharacter | \"\")*\n  liquidDoc :=\n    liquidDocStart\n      liquidDocBody\n    liquidDocEnd?\n}\n\nWithPlaceholderLiquidHTML <: LiquidHTML {\n  liquidFilter<delim> := space* \"|\" space* identifier (space* \":\" space* filterArguments<delim> (space* \",\")?)?\n  liquidTagContentForMarkup :=\n    contentForType (argumentSeparatorOptionalComma completionModeContentForTagArgument) (space* \",\")? space*\n  liquidTagRenderMarkup :=\n    snippetExpression renderVariableExpression? renderAliasExpression? completionModeRenderArguments\n  liquidTagName := (letter | \"\") (alnum | \"_\")*\n  variableSegment := (letter | \"_\" | \"\") (identifierCharacter | \"\")*\n  leadingTagNameTextNode := (letter | \"\") (alnum | \"-\" | \":\" | \"\")*\n  trailingTagNameTextNode := (alnum | \"-\" | \":\" | \"\")+\n  liquidDoc :=\n    liquidDocStart\n      liquidDocBody\n    liquidDocEnd?\n}\n`;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileType = void 0;\nvar FileType;\n(function (FileType) {\n    FileType[FileType[\"Unknown\"] = 0] = \"Unknown\";\n    FileType[FileType[\"File\"] = 1] = \"File\";\n    FileType[FileType[\"Directory\"] = 2] = \"Directory\";\n    FileType[FileType[\"SymbolicLink\"] = 64] = \"SymbolicLink\";\n})(FileType = exports.FileType || (exports.FileType = {}));\n//# sourceMappingURL=AbstractFileSystem.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AugmentedThemeDocset = void 0;\nconst utils_1 = require(\"./utils\");\nconst toFilterEntry = (name) => ({ name });\nconst aliasedFilters = ['camelcase', 'handle', 't'];\nconst undocumentedFilters = [\n    '_online_store_editor_live_setting',\n    'addresses_url',\n    'app_block_path?',\n    'app_block_path_for',\n    'app_extension_path?',\n    'app_snippet_path?',\n    'cancel_customer_order_link',\n    'debug',\n    'delete_customer_address_link',\n    'dev_shop?',\n    'distance_from',\n    'edit_customer_address_link',\n    'encode_url_component',\n    'excerpt',\n    'format_code',\n    'global_block_type?',\n    'h',\n    'handle_from',\n    'installments_pricing',\n    'link_to_theme',\n    'login_button',\n    'login_url',\n    'logout_url',\n    'pad_spaces',\n    'paragraphize',\n    'recover_password_link',\n    'recover_url',\n    'register_url',\n    'registration_uuid_from',\n    'root_account_url',\n    'sentence',\n    'theme_url',\n    'unit',\n    'weight',\n];\nconst undocumentedObjectEntryKeys = [\n    'locale',\n    'direction',\n    'skip_to_content_link',\n    'checkout_html_classes',\n    'checkout_stylesheets',\n    'checkout_scripts',\n    'content_for_logo',\n    'breadcrumb',\n    'order_summary_toggle',\n    'content_for_order_summary',\n    'alternative_payment_methods',\n    'content_for_footer',\n    'tracking_code',\n];\nconst toObjectEntry = (name, access, returnType) => ({\n    name,\n    ...(access && { access }),\n    ...(returnType && { return_type: returnType }),\n});\nconst undocumentedObjects = ['customer_address', 'product_variant'];\nconst legacyCheckoutEntries = undocumentedObjectEntryKeys.map((objectKey) => toObjectEntry(objectKey, { global: false, parents: [], template: [] }, [\n    { type: 'string', name: '' },\n]));\nconst toTagEntry = (name) => ({ name });\nconst undocumentedTags = ['elsif', 'ifchanged', 'when', 'schema'];\nclass AugmentedThemeDocset {\n    constructor(themeDocset) {\n        this.themeDocset = themeDocset;\n        this.isAugmented = true;\n        this.filters = (0, utils_1.memo)(async () => {\n            return [\n                ...(await this.themeDocset.filters()),\n                ...aliasedFilters.map(toFilterEntry),\n                ...undocumentedFilters.map(toFilterEntry),\n            ];\n        });\n        this.objects = (0, utils_1.memo)(async () => {\n            return [\n                ...(await this.themeDocset.objects()),\n                ...undocumentedObjects.map((obj) => toObjectEntry(obj)),\n                ...legacyCheckoutEntries,\n            ];\n        });\n        this.tags = (0, utils_1.memo)(async () => {\n            return [...(await this.themeDocset.tags()), ...undocumentedTags.map(toTagEntry)];\n        });\n        this.systemTranslations = (0, utils_1.memo)(async () => {\n            return this.themeDocset.systemTranslations();\n        });\n    }\n}\nexports.AugmentedThemeDocset = AugmentedThemeDocset;\n//# sourceMappingURL=AugmentedThemeDocset.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValid = exports.JSONValidator = void 0;\nconst vscode_json_languageservice_1 = require(\"vscode-json-languageservice\");\nconst utils_1 = require(\"./utils\");\nclass JSONValidator {\n    static async create(jsonValidationSet, config) {\n        if (!jsonValidationSet)\n            return;\n        return new JSONValidator(await jsonValidationSet.schemas(config.context));\n    }\n    constructor(schemas) {\n        /**\n         * Will return an array of diagnostics for the given source code and JSON string.\n         *\n         * It's up to the caller to determine where in the file those should be.\n         * (presumably by doing some offset logic)\n         */\n        this.validate = async (uri, jsonString) => {\n            const jsonTextDocument = vscode_json_languageservice_1.TextDocument.create(uri, 'json', 0, jsonString);\n            const diagnostics = await this.getOffsetDiagnostics(jsonTextDocument);\n            return diagnostics.map((diagnostic) => ({\n                message: diagnostic.message,\n                startIndex: jsonTextDocument.offsetAt(diagnostic.range.start),\n                endIndex: jsonTextDocument.offsetAt(diagnostic.range.end),\n            }));\n        };\n        this.isValid = async (uri, jsonString) => {\n            return isValid(this.service, uri, jsonString);\n        };\n        this.schemas = (0, utils_1.indexBy)((x) => x.uri, schemas);\n        this.service = (0, vscode_json_languageservice_1.getLanguageService)({\n            schemaRequestService: this.getSchemaForURI.bind(this),\n            workspaceContext: {\n                resolveRelativePath: (relativePath, resource) => {\n                    const url = new URL(relativePath, resource);\n                    return url.toString();\n                },\n            },\n        });\n        this.service.configure({\n            schemas: schemas.map((schemaDefinition) => ({\n                uri: schemaDefinition.uri,\n                fileMatch: schemaDefinition.fileMatch,\n            })),\n        });\n    }\n    async getOffsetDiagnostics(jsonTextDocument) {\n        const jsonDocument = this.service.parseJSONDocument(jsonTextDocument);\n        return this.service.doValidation(jsonTextDocument, jsonDocument, {\n            schemaValidation: 'error',\n            trailingCommas: 'ignore',\n            comments: 'ignore',\n        });\n    }\n    async getSchemaForURI(uri) {\n        var _a;\n        const schema = (_a = this.schemas[uri]) === null || _a === void 0 ? void 0 : _a.schema;\n        if (!schema)\n            return `No schema for '${uri}' found`;\n        return schema;\n    }\n}\nexports.JSONValidator = JSONValidator;\n/** We'll reuse this in the language server */\nasync function isValid(service, uri, jsonString) {\n    const jsonTextDocument = vscode_json_languageservice_1.TextDocument.create(uri, 'json', 0, jsonString);\n    const jsonDocument = service.parseJSONDocument(jsonTextDocument);\n    const diagnostics = await service.doValidation(jsonTextDocument, jsonDocument, {\n        schemaValidation: 'error',\n        trailingCommas: 'ignore',\n        comments: 'ignore',\n    });\n    return diagnostics.every((diagnostic) => diagnostic.severity !== 1);\n}\nexports.isValid = isValid;\n//# sourceMappingURL=JSONValidator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppBlockMissingSchema = void 0;\nconst types_1 = require(\"../../types\");\nexports.AppBlockMissingSchema = {\n    meta: {\n        code: 'AppBlockMissingSchema',\n        name: 'Missing schema definitions in theme app extensions app blocks should be avoided',\n        docs: {\n            description: 'Report missing schema definitions in theme app extensions app blocks',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/app-block-missing-schema',\n        },\n        severity: types_1.Severity.ERROR,\n        type: types_1.SourceCodeType.LiquidHtml,\n        schema: {},\n        targets: [types_1.ConfigTarget.ThemeAppExtension],\n    },\n    create(context) {\n        let foundSchema = false;\n        const relativePath = context.toRelativePath(context.file.uri);\n        /**\n         * Theme app extension blocks are the only types of files that can have a\n         * schema defined in them.\n         */\n        if (!relativePath.startsWith('blocks/')) {\n            return {};\n        }\n        return {\n            async LiquidRawTag(node) {\n                if (node.name == 'schema')\n                    foundSchema = true;\n            },\n            async onCodePathEnd() {\n                if (!foundSchema) {\n                    context.report({\n                        message: `The schema does not exist`,\n                        startIndex: 0,\n                        endIndex: 0,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppBlockValidTags = exports.ForbiddenTag = void 0;\nconst types_1 = require(\"../../types\");\nvar ForbiddenTag;\n(function (ForbiddenTag) {\n    ForbiddenTag[\"JavaScript\"] = \"javascript\";\n    ForbiddenTag[\"StyleSheet\"] = \"stylesheet\";\n    ForbiddenTag[\"Include\"] = \"include\";\n    ForbiddenTag[\"Layout\"] = \"layout\";\n    ForbiddenTag[\"Section\"] = \"section\";\n    ForbiddenTag[\"Sections\"] = \"sections\";\n})(ForbiddenTag = exports.ForbiddenTag || (exports.ForbiddenTag = {}));\nconst isForbiddenTag = (value) => {\n    return Object.values(ForbiddenTag).includes(value);\n};\nconst buildErrorMessage = (tag) => `Theme app extension blocks cannot contain '${tag}' tags`;\nexports.AppBlockValidTags = {\n    meta: {\n        code: 'AppBlockValidTags',\n        name: 'App Block Valid Tags',\n        docs: {\n            description: 'Identifies forbidden Liquid tags in theme app extension app block and app embed block code.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/app-block-valid-tags',\n            recommended: false,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [types_1.ConfigTarget.ThemeAppExtension],\n    },\n    create(context) {\n        const handleForbiddenTags = async (node) => {\n            if (isForbiddenTag(node.name)) {\n                // When a forbidden tag is used to define a block section\n                // with an end tag, highlight the whole section\n                const endIndex = node.blockEndPosition ? node.blockEndPosition.end : node.position.end;\n                const startIndex = node.blockStartPosition.start;\n                const message = buildErrorMessage(node.name);\n                return context.report({ message, startIndex, endIndex });\n            }\n        };\n        return {\n            LiquidRawTag: handleForbiddenTags,\n            LiquidTag: handleForbiddenTags,\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetPreload = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nfunction isPreload(attr) {\n    return ((0, utils_1.isAttr)(attr, 'rel') &&\n        attr.value.some((node) => node.type === liquid_html_parser_1.NodeTypes.TextNode && node.value === 'preload'));\n}\nexports.AssetPreload = {\n    meta: {\n        code: 'AssetPreload',\n        name: 'Prevent Manual Preloading of Assets',\n        docs: {\n            description: 'This check is aimed at discouraging the manual preloading of assets and encourages the use of appropriate Shopify filters.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/asset-preload',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async HtmlVoidElement(node) {\n                var _a;\n                const preloadLinkAttr = node.attributes.find((attr) => (0, utils_1.isValuedHtmlAttribute)(attr) && isPreload(attr));\n                if (node.name === 'link' && preloadLinkAttr) {\n                    const asAttr = node.attributes\n                        .filter(utils_1.isValuedHtmlAttribute)\n                        .find((attr) => (0, utils_1.isAttr)(attr, 'as'));\n                    const assetType = (_a = asAttr === null || asAttr === void 0 ? void 0 : asAttr.value.find((node) => (0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.TextNode, node))) === null || _a === void 0 ? void 0 : _a.value;\n                    let message = '';\n                    if (assetType === 'style') {\n                        message =\n                            'For better performance, prefer using the preload argument of the stylesheet_tag filter';\n                    }\n                    else if (assetType === 'image') {\n                        message =\n                            'For better performance, prefer using the preload argument of the image_tag filter';\n                    }\n                    else {\n                        message = 'For better performance, prefer using the preload_tag filter';\n                    }\n                    context.report({\n                        message,\n                        startIndex: node.position.start,\n                        endIndex: node.position.end,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetSizeAppBlockCSS = void 0;\nconst json_1 = require(\"../../json\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst schema = {\n    thresholdInBytes: types_1.SchemaProp.number(100000),\n};\nexports.AssetSizeAppBlockCSS = {\n    meta: {\n        code: 'AssetSizeAppBlockCSS',\n        name: 'Asset Size App Block CSS',\n        docs: {\n            description: 'This check is aimed at preventing large CSS bundles from being included via Theme App Extensions.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/asset-size-app-block-css',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema,\n        targets: [types_1.ConfigTarget.ThemeAppExtension],\n    },\n    create(context) {\n        if (!context.fileSize) {\n            return {};\n        }\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema')\n                    return;\n                const schema = (0, json_1.parseJSON)(node.body.value);\n                if ((0, utils_1.isError)(schema))\n                    return;\n                const stylesheet = schema.stylesheet;\n                if (!stylesheet)\n                    return;\n                const relativePath = `assets/${stylesheet}`;\n                const thresholdInBytes = context.settings.thresholdInBytes;\n                const startIndex = node.body.position.start + node.body.value.indexOf(stylesheet);\n                const endIndex = startIndex + stylesheet.length;\n                const fileExists = await (0, file_utils_1.doesFileExist)(context, relativePath);\n                if (!fileExists) {\n                    context.report({\n                        message: `'${stylesheet}' does not exist.`,\n                        startIndex: startIndex,\n                        endIndex: endIndex,\n                    });\n                    return;\n                }\n                const [fileExceedsThreshold, fileSize] = await (0, file_utils_1.doesFileExceedThreshold)(context, relativePath, thresholdInBytes);\n                if (fileExceedsThreshold) {\n                    context.report({\n                        message: `The file size for '${stylesheet}' (${fileSize} B) exceeds the configured threshold (${thresholdInBytes} B)`,\n                        startIndex: startIndex,\n                        endIndex: endIndex,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetSizeAppBlockJavaScript = void 0;\nconst json_1 = require(\"../../json\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst schema = {\n    thresholdInBytes: types_1.SchemaProp.number(10000),\n};\nexports.AssetSizeAppBlockJavaScript = {\n    meta: {\n        code: 'AssetSizeAppBlockJavaScript',\n        name: 'Asset Size App Block JavaScript',\n        docs: {\n            description: 'This check is aimed at preventing large JavaScript bundles from being included via Theme App Extensions.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/asset-size-app-block-javascript',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema,\n        targets: [types_1.ConfigTarget.ThemeAppExtension],\n    },\n    create(context) {\n        if (!context.fileSize) {\n            return {};\n        }\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema')\n                    return;\n                const schema = (0, json_1.parseJSON)(node.body.value);\n                if ((0, utils_1.isError)(schema))\n                    return;\n                const javascript = schema.javascript;\n                if (!javascript)\n                    return;\n                const relativePath = `assets/${javascript}`;\n                const thresholdInBytes = context.settings.thresholdInBytes;\n                const startIndex = node.body.position.start + node.body.value.indexOf(javascript);\n                const endIndex = startIndex + javascript.length;\n                const fileExists = await (0, file_utils_1.doesFileExist)(context, relativePath);\n                if (!fileExists) {\n                    context.report({\n                        message: `'${javascript}' does not exist.`,\n                        startIndex: startIndex,\n                        endIndex: endIndex,\n                    });\n                    return;\n                }\n                const [fileExceedsThreshold, fileSize] = await (0, file_utils_1.doesFileExceedThreshold)(context, relativePath, thresholdInBytes);\n                if (fileExceedsThreshold) {\n                    context.report({\n                        message: `The file size for '${javascript}' (${fileSize} B) exceeds the configured threshold (${thresholdInBytes} B)`,\n                        startIndex: startIndex,\n                        endIndex: endIndex,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetSizeCSS = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst utils_2 = require(\"../utils\");\nconst schema = {\n    thresholdInBytes: types_1.SchemaProp.number(100000),\n};\nfunction isTextNode(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.TextNode;\n}\nfunction isLiquidVariableOutput(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidVariableOutput;\n}\nfunction isLiquidVariable(node) {\n    return typeof node !== 'string' && node.type === liquid_html_parser_1.NodeTypes.LiquidVariable;\n}\nfunction isString(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.String;\n}\nexports.AssetSizeCSS = {\n    meta: {\n        code: 'AssetSizeCSS',\n        aliases: ['AssetSizeCSSStylesheetTag'],\n        name: 'Prevent Large CSS bundles',\n        docs: {\n            description: 'This check is aimed at preventing large CSS bundles for speed.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/asset-size-css',\n            recommended: false,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema,\n        targets: [],\n    },\n    create(context) {\n        if (!context.fileSize) {\n            return {};\n        }\n        const thresholdInBytes = context.settings.thresholdInBytes;\n        async function checkRemoteAssetSize(url, position) {\n            if (await (0, file_utils_1.hasRemoteAssetSizeExceededThreshold)(url, thresholdInBytes)) {\n                context.report({\n                    message: `The CSS file size exceeds the threshold of ${thresholdInBytes} bytes`,\n                    startIndex: position.start,\n                    endIndex: position.end,\n                });\n            }\n        }\n        async function checkThemeAssetSize(srcValue, position) {\n            if (await (0, file_utils_1.hasLocalAssetSizeExceededThreshold)(context, `assets/${srcValue}`, thresholdInBytes)) {\n                context.report({\n                    message: `The CSS file size exceeds the threshold of ${thresholdInBytes} bytes`,\n                    startIndex: position.start,\n                    endIndex: position.end,\n                });\n            }\n        }\n        return {\n            async HtmlVoidElement(node) {\n                if (node.name !== 'link')\n                    return;\n                const relIsStylesheet = node.attributes\n                    .filter(utils_2.isValuedHtmlAttribute)\n                    .find((attr) => (0, utils_2.isAttr)(attr, 'rel') && (0, utils_2.valueIncludes)(attr, 'stylesheet'));\n                if (!relIsStylesheet)\n                    return;\n                const href = node.attributes\n                    .filter(utils_2.isValuedHtmlAttribute)\n                    .find((attr) => (0, utils_2.isAttr)(attr, 'href'));\n                if (!href)\n                    return;\n                if (href.value.length !== 1)\n                    return;\n                /* This ensures that the link entered is a text and not anything else like http//..{}\n                   This also checks if the value starts with 'http://', 'https://' or '//' to ensure its a valid link. */\n                if (isTextNode(href.value[0]) && /(https?:)?\\/\\//.test(href.value[0].value)) {\n                    const url = href.value[0].value;\n                    await checkRemoteAssetSize(url, href.attributePosition);\n                }\n                /* This code checks if we have a link with a liquid variable\n                and that its a string with one filter, `asset_url`. This is done to ensure our .css link is\n                entered with a 'asset_url' to produce valid output. */\n                if (isLiquidVariableOutput(href.value[0]) &&\n                    isLiquidVariable(href.value[0].markup) &&\n                    isString(href.value[0].markup.expression) &&\n                    href.value[0].markup.filters.length === 1 &&\n                    href.value[0].markup.filters[0].name === 'asset_url') {\n                    const assetName = href.value[0].markup.expression.value;\n                    await checkThemeAssetSize(assetName, href.attributePosition);\n                }\n            },\n            async LiquidFilter(node, ancestors) {\n                if (node.name !== 'stylesheet_tag')\n                    return;\n                const liquidVariableParent = (0, utils_1.last)(ancestors);\n                if (!liquidVariableParent || !(0, utils_2.isNodeOfType)(liquid_html_parser_1.NodeTypes.LiquidVariable, liquidVariableParent))\n                    return;\n                if (liquidVariableParent.expression.type !== liquid_html_parser_1.NodeTypes.String)\n                    return;\n                /* This code ensures we have a liquid variable with 1 expression, 1 filter, and that it is a valid http link.\n                   This is done to ensure a valid http link is entered with 1 filter being the `stylesheet_tag` for valid output. */\n                if (liquidVariableParent.expression.value[0].length == 1 &&\n                    liquidVariableParent.filters.length == 1 &&\n                    /(https?:)?\\/\\//.test(liquidVariableParent.expression.value)) {\n                    const url = liquidVariableParent.expression.value;\n                    await checkRemoteAssetSize(url, liquidVariableParent.expression.position);\n                }\n                /* This code ensures we have a liquid variable with 1 expression, 2 filters being asset_url and stylesheet_tag\n                   This is done to ensure a .css file has the 'asset_url' and 'stylesheet_tag' to produce the appropriate output. */\n                if (liquidVariableParent.expression.value[0].length == 1 &&\n                    liquidVariableParent.filters.length == 2 &&\n                    liquidVariableParent.filters[0].name === 'asset_url' &&\n                    liquidVariableParent.filters[1].name === 'stylesheet_tag') {\n                    const css = liquidVariableParent.expression.value;\n                    await checkThemeAssetSize(css, liquidVariableParent.position);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetSizeJavaScript = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst utils_2 = require(\"../utils\");\nconst schema = {\n    thresholdInBytes: types_1.SchemaProp.number(10000),\n};\nfunction isTextNode(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.TextNode;\n}\nfunction isLiquidVariableOutput(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidVariableOutput;\n}\nfunction isLiquidVariable(node) {\n    return typeof node !== 'string' && node.type === liquid_html_parser_1.NodeTypes.LiquidVariable;\n}\nfunction isString(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.String;\n}\nexports.AssetSizeJavaScript = {\n    meta: {\n        code: 'AssetSizeJavaScript',\n        name: 'Prevent Large JavaScript bundles',\n        docs: {\n            description: 'This check is aimed at preventing large JavaScript bundles for speed.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/asset-size-javascript',\n            recommended: false,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema,\n        targets: [],\n    },\n    create(context) {\n        if (!context.fileSize) {\n            return {};\n        }\n        const thresholdInBytes = context.settings.thresholdInBytes;\n        async function checkRemoteAssetSize(url, position) {\n            if (await (0, file_utils_1.hasRemoteAssetSizeExceededThreshold)(url, thresholdInBytes)) {\n                context.report({\n                    message: `JavaScript on every page load exceeds compressed size threshold (${thresholdInBytes} Bytes), consider using the import on interaction pattern.`,\n                    startIndex: position.start,\n                    endIndex: position.end,\n                });\n            }\n        }\n        async function checkThemeAssetSize(srcValue, position) {\n            if (await (0, file_utils_1.hasLocalAssetSizeExceededThreshold)(context, `assets/${srcValue}`, thresholdInBytes)) {\n                context.report({\n                    message: `JavaScript on every page load exceeds compressed size threshold (${thresholdInBytes} Bytes), consider using the import on interaction pattern.`,\n                    startIndex: position.start,\n                    endIndex: position.end,\n                });\n            }\n        }\n        return {\n            async HtmlRawNode(node) {\n                if (node.name !== 'script')\n                    return;\n                const src = node.attributes\n                    .filter(utils_2.isValuedHtmlAttribute)\n                    .find((attr) => (0, utils_2.isAttr)(attr, 'src'));\n                if (!src)\n                    return;\n                if (src.value.length !== 1)\n                    return;\n                if (isTextNode(src.value[0]) && /(https?:)?\\/\\//.test(src.value[0].value)) {\n                    const url = src.value[0].value;\n                    await checkRemoteAssetSize(url, src.attributePosition);\n                }\n                if (isLiquidVariableOutput(src.value[0]) &&\n                    isLiquidVariable(src.value[0].markup) &&\n                    isString(src.value[0].markup.expression) &&\n                    src.value[0].markup.filters.length === 1 &&\n                    src.value[0].markup.filters[0].name === 'asset_url') {\n                    const assetName = src.value[0].markup.expression.value;\n                    await checkThemeAssetSize(assetName, src.attributePosition);\n                }\n            },\n            async LiquidFilter(node, ancestors) {\n                if (node.name !== 'script_tag')\n                    return;\n                const liquidVariableParent = (0, utils_1.last)(ancestors);\n                if (!liquidVariableParent || !(0, utils_2.isNodeOfType)(liquid_html_parser_1.NodeTypes.LiquidVariable, liquidVariableParent))\n                    return;\n                if (liquidVariableParent.expression.type !== liquid_html_parser_1.NodeTypes.String)\n                    return;\n                if (liquidVariableParent.expression.value[0].length == 1 &&\n                    liquidVariableParent.filters.length == 1 &&\n                    /(https?:)?\\/\\//.test(liquidVariableParent.expression.value)) {\n                    const url = liquidVariableParent.expression.value;\n                    await checkRemoteAssetSize(url, liquidVariableParent.expression.position);\n                }\n                if (liquidVariableParent.expression.value[0].length == 1 &&\n                    liquidVariableParent.filters.length == 2 &&\n                    liquidVariableParent.filters[0].name === 'asset_url' &&\n                    liquidVariableParent.filters[1].name === 'script_tag') {\n                    const js = liquidVariableParent.expression.value;\n                    await checkThemeAssetSize(js, liquidVariableParent.position);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockIdUsage = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nexports.BlockIdUsage = {\n    meta: {\n        code: 'BlockIdUsage',\n        name: 'Do not rely on `block.id` in if/else/unless/case',\n        docs: {\n            description: 'The ID is dynamically generated by Shopify and is subject to change. You should avoid relying on a literal value of this ID.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/block_id_usage',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            // BAD: {% if block.id == \"123\" %}\n            // BAD: {% if block.id == some_variable %}\n            // BAD: {% if block[id] == \"id\" or block.id %}\n            // FINE: <div data-block-id=\"{{ block.id }}\">\n            // FINE: document.querySelector(`[data-block-id=\"${block.id}\"]`)\n            async Comparison(node, ancesors) {\n                if (node.comparator === '==' &&\n                    node.left.type === liquid_html_parser_1.NodeTypes.VariableLookup &&\n                    isUsingBlockId(node.left)) {\n                    reportWarning(context, node.position);\n                }\n            },\n            // BAD {% case block.id %}\n            async VariableLookup(node, ancestors) {\n                const parentNode = ancestors.at(-1);\n                if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.LiquidTag && parentNode.name === 'case') {\n                    if (isUsingBlockId(node)) {\n                        reportWarning(context, node.position);\n                    }\n                }\n            },\n        };\n    },\n};\nfunction isUsingBlockId(node) {\n    return (node.type == liquid_html_parser_1.NodeTypes.VariableLookup &&\n        node.name === 'block' &&\n        node.lookups[0] &&\n        node.lookups[0].type === liquid_html_parser_1.NodeTypes.String &&\n        node.lookups[0].value === 'id');\n}\nfunction reportWarning(context, position) {\n    context.report({\n        message: 'The ID is dynamically generated by Shopify and is subject to change. You should avoid relying on a literal value of this ID.',\n        startIndex: position.start,\n        endIndex: position.end,\n    });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CaptureOnContentForBlock = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nexports.CaptureOnContentForBlock = {\n    meta: {\n        code: 'CaptureOnContentForBlock',\n        name: 'Do not capture `content_for \"block\"`',\n        docs: {\n            description: 'Capture of content_for \"block\" is restricted to enforce static block rendering at its expected location.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/content_for_block',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidTag(node, ancestors) {\n                if (node.name !== liquid_html_parser_1.NamedTags.content_for)\n                    return;\n                if (typeof node.markup === 'string')\n                    return;\n                if (node.markup.contentForType.value !== 'block')\n                    return;\n                for (const parentNode of ancestors) {\n                    if ((0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.LiquidTag, parentNode) &&\n                        parentNode.name === liquid_html_parser_1.NamedTags.capture) {\n                        context.report({\n                            message: 'Do not capture `content_for \"block\"`',\n                            startIndex: node.position.start,\n                            endIndex: node.position.end,\n                        });\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CdnPreconnect = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nexports.CdnPreconnect = {\n    meta: {\n        code: 'CdnPreconnect',\n        name: 'CDN Preconnect',\n        docs: {\n            description: \"This check is aimed at signaling the redundant preconnect to Shopify's CDN\",\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/cdn-preconnect',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async HtmlVoidElement(node) {\n                if (node.name !== 'link')\n                    return;\n                const isPreconnect = node.attributes\n                    .filter(utils_1.isValuedHtmlAttribute)\n                    .some((attr) => (0, utils_1.isAttr)(attr, 'rel') && (0, utils_1.valueIncludes)(attr, 'preconnect'));\n                if (!isPreconnect)\n                    return;\n                const isShopifyCdn = node.attributes\n                    .filter(utils_1.isValuedHtmlAttribute)\n                    .some((attr) => (0, utils_1.isAttr)(attr, 'href') && (0, utils_1.valueIncludes)(attr, '.+cdn.shopify.com.+'));\n                if (!isShopifyCdn)\n                    return;\n                context.report({\n                    message: 'Preconnecting to cdn.shopify.com is unnecessary and can lead to worse performance',\n                    startIndex: node.position.start,\n                    endIndex: node.position.end,\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentForHeaderModification = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nfunction isLiquidTagAssign(node) {\n    return node.name === 'assign' && typeof node.markup !== 'string';\n}\nfunction isLiquidTagCapture(node) {\n    return node.name === 'capture' && typeof node.markup !== 'string';\n}\nfunction isLiquidTagEcho(node) {\n    return node.name === 'echo' && typeof node.markup !== 'string';\n}\nexports.ContentForHeaderModification = {\n    meta: {\n        code: 'ContentForHeaderModification',\n        name: 'Do not depend on the content of content_for_header',\n        docs: {\n            description: 'Do not rely on the content of content_for_header as it might change in the future, which could cause your Liquid code behavior to change.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/content-for-header-modification',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        function checkContentForHeader(node, position) {\n            if ((0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.VariableLookup, node) && node.name === 'content_for_header') {\n                context.report({\n                    message: 'Do not rely on the content of `content_for_header`',\n                    startIndex: position.start,\n                    endIndex: position.end,\n                });\n            }\n        }\n        return {\n            async LiquidTag(node) {\n                if (isLiquidTagAssign(node)) {\n                    checkContentForHeader(node.markup.value.expression, node.position);\n                }\n                else if (isLiquidTagEcho(node)) {\n                    checkContentForHeader(node.markup.expression, node.position);\n                }\n                else if (isLiquidTagCapture(node) && node.children) {\n                    for (const child of node.children) {\n                        if (child.type === liquid_html_parser_1.NodeTypes.LiquidVariableOutput && typeof child.markup !== 'string') {\n                            checkContentForHeader(child.markup.expression, child.position);\n                        }\n                    }\n                }\n            },\n            async LiquidVariableOutput(node) {\n                if (typeof node.markup === 'string')\n                    return;\n                if (node.markup.filters.length) {\n                    checkContentForHeader(node.markup.expression, node.position);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeprecateBgsizes = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nexports.DeprecateBgsizes = {\n    meta: {\n        code: 'DeprecateBgsizes',\n        name: 'Deprecate Bgsizes',\n        docs: {\n            description: 'This check is aimed at discouraging the use of the lazySizes bgset plugin.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/deprecate-bgsizes',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async HtmlElement(node) {\n                const classAttributeWithLazyload = node.attributes\n                    .filter(utils_1.isValuedHtmlAttribute)\n                    .find((attr) => (0, utils_1.isAttr)(attr, 'class') && (0, utils_1.valueIncludes)(attr, 'lazyload'));\n                if (classAttributeWithLazyload) {\n                    const attr = classAttributeWithLazyload;\n                    context.report({\n                        message: 'Use the native loading=\"lazy\" attribute instead of lazysizes',\n                        startIndex: attr.attributePosition.start,\n                        endIndex: attr.attributePosition.end,\n                    });\n                }\n                const dataBgsetAttr = node.attributes.find((attr) => (0, utils_1.isValuedHtmlAttribute)(attr) && (0, utils_1.isAttr)(attr, 'data-bgset'));\n                if (dataBgsetAttr) {\n                    context.report({\n                        message: 'Use the CSS imageset attribute instead of data-bgset',\n                        startIndex: dataBgsetAttr.position.start,\n                        endIndex: dataBgsetAttr.position.end,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeprecateLazysizes = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nfunction showsLazysizesUsage(attr) {\n    return (0, utils_1.isAttr)(attr, 'data-srcset') || (0, utils_1.isAttr)(attr, 'data-sizes');\n}\nexports.DeprecateLazysizes = {\n    meta: {\n        code: 'DeprecateLazysizes',\n        name: 'Deprecate Lazysizes',\n        docs: {\n            description: 'This check is aimed at discouraging the use of the lazysizes JavaScript library',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/deprecate-lazysizes',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async HtmlVoidElement(node) {\n                if (node.name !== 'img')\n                    return;\n                const attributes = node.attributes.filter(utils_1.isHtmlAttribute);\n                const hasSrc = attributes.some((attr) => (0, utils_1.isAttr)(attr, 'src'));\n                const hasNativeLoading = attributes.some((attr) => (0, utils_1.isAttr)(attr, 'loading'));\n                if (hasSrc && hasNativeLoading)\n                    return;\n                const hasLazyloadClass = node.attributes\n                    .filter(utils_1.isValuedHtmlAttribute)\n                    .some((attr) => (0, utils_1.isAttr)(attr, 'class') && (0, utils_1.valueIncludes)(attr, 'lazyload'));\n                if (!hasLazyloadClass)\n                    return;\n                const hasLazysizesAttribute = node.attributes\n                    .filter(utils_1.isValuedHtmlAttribute)\n                    .some(showsLazysizesUsage);\n                if (!hasLazysizesAttribute)\n                    return;\n                context.report({\n                    message: 'Use the native loading=\"lazy\" attribute instead of lazysizes',\n                    startIndex: node.position.start,\n                    endIndex: node.position.end,\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.suggestImageUrlFix = exports.suggestImgUrlFix = exports.suggestImgTagFix = exports.fixHexToRgba = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst utils_1 = require(\"../utils\");\n/**\n * Width and height values cannot exceed this maximum size.\n */\nconst MAX_SIZE = 5760;\nconst NAMED_SIZES = {\n    pico: 16,\n    icon: 32,\n    thumb: 50,\n    small: 100,\n    compact: 160,\n    medium: 240,\n    large: 480,\n    grande: 600,\n    original: 1024,\n};\nfunction fixHexToRgba(node) {\n    /**\n     * Cannot fix invalid usage.\n     *\n     * The `hex_to_rgba` filter is only valid with zero or one argument (`alpha`).\n     */\n    if (node.args.length > 1)\n        return;\n    const { start, end } = getFilterSourceStartAndEnd(node);\n    const alpha = getExpressionArgumentValue(node, 0);\n    let fixedFilter;\n    if (alpha) {\n        fixedFilter = ` color_to_rgb | color_modify: 'alpha', ${alpha}`;\n    }\n    else {\n        fixedFilter = ' color_to_rgb';\n    }\n    return (corrector) => corrector.replace(start, end, fixedFilter);\n}\nexports.fixHexToRgba = fixHexToRgba;\nfunction suggestImgTagFix(node) {\n    const message = \"Replace 'img_tag' with 'image_tag'.\";\n    const alt = getExpressionArgumentValue(node, 0);\n    const cssClass = getExpressionArgumentValue(node, 1);\n    const sizeStr = getExpressionArgumentValue(node, 2);\n    const { width, height } = getImageSize(sizeStr, { width: -1, height: -1 });\n    const { start, end } = getFilterSourceStartAndEnd(node);\n    const imageUrlParameters = ensureImageValue({ width, height });\n    const imageTagParameters = {\n        width,\n        height,\n        alt: strValue(alt),\n        class: strValue(cssClass),\n    };\n    const imageUrlFilter = buildFilterString('image_url', imageUrlParameters);\n    const imageTagFilter = buildFilterString('image_tag', imageTagParameters);\n    return [\n        {\n            message,\n            fix: (corrector) => {\n                const insert = `${imageUrlFilter} |${imageTagFilter}`;\n                corrector.replace(start, end, insert);\n            },\n        },\n    ];\n}\nexports.suggestImgTagFix = suggestImgTagFix;\nfunction suggestImgUrlFix(node) {\n    const message = \"Replace 'img_url' with 'image_url'.\";\n    const cropNode = getNamedArgumentNode(node, 'crop');\n    const formatNode = getNamedArgumentNode(node, 'format');\n    const scaleNode = getNamedArgumentNode(node, 'scale');\n    const sizeStr = getExpressionArgumentValue(node, 0);\n    const sizeNode = node.args.at(0);\n    /**\n     * Cannot fix when 'scale' or 'size' node are variable lookups.\n     */\n    if (isVariableLookup(scaleNode === null || scaleNode === void 0 ? void 0 : scaleNode.value) || isVariableLookup(sizeNode)) {\n        return;\n    }\n    const { width, height } = ensureImageValue(scaleImage(node, getImageSize(sizeStr)));\n    const { start, end } = getFilterSourceStartAndEnd(node);\n    const parameters = { width, height };\n    if (isStringLiteral(cropNode === null || cropNode === void 0 ? void 0 : cropNode.value)) {\n        parameters['crop'] = strValue(cropNode.value.value);\n    }\n    if (isStringLiteral(formatNode === null || formatNode === void 0 ? void 0 : formatNode.value)) {\n        parameters['format'] = strValue(formatNode.value.value);\n    }\n    if (isVariableLookup(formatNode === null || formatNode === void 0 ? void 0 : formatNode.value)) {\n        parameters['format'] = formatNode.value.name;\n    }\n    return [\n        {\n            message,\n            fix: (corrector) => {\n                const insert = buildFilterString('image_url', parameters);\n                corrector.replace(start, end, insert);\n            },\n        },\n    ];\n}\nexports.suggestImgUrlFix = suggestImgUrlFix;\nfunction suggestImageUrlFix(filter, node) {\n    const message = `Replace '${filter}' with 'image_url'.`;\n    const sizeStr = getExpressionArgumentValue(node, 0);\n    const { width, height } = ensureImageValue(getImageSize(sizeStr));\n    const { start, end } = getFilterSourceStartAndEnd(node);\n    return [\n        {\n            message,\n            fix: (corrector) => {\n                const insert = buildFilterString('image_url', { width, height });\n                corrector.replace(start, end, insert);\n            },\n        },\n    ];\n}\nexports.suggestImageUrlFix = suggestImageUrlFix;\nfunction getImageSize(size, imageSize = { width: 100, height: 100 }) {\n    if (!size)\n        return { ...imageSize };\n    if (size in NAMED_SIZES) {\n        const s = NAMED_SIZES[size];\n        return { width: s, height: s };\n    }\n    const [width, height] = size.split('x').map((s) => parseInt(s));\n    return ensureImageSizeLimit({ width, height });\n}\nfunction scaleImage(node, imageSize) {\n    const scale = parseInt(getNamedArgumentValue(node, 'scale') || '0') || 1;\n    return ensureImageSizeLimit({\n        width: imageSize.width * scale,\n        height: imageSize.height * scale,\n    });\n}\nfunction ensureImageSizeLimit(imageSize) {\n    return {\n        width: Math.min(imageSize.width, MAX_SIZE),\n        height: Math.min(imageSize.height, MAX_SIZE),\n    };\n}\nfunction ensureImageValue(imageSize) {\n    let { width, height } = imageSize;\n    const isImageSizeUnset = (!height || height === -1) && (!width || width === -1);\n    /**\n     * If `image_url` is missing a width or height, we default to width=100, as\n     * the documentation mention an error is returned if neither are specified\n     * (interestingly, `image_url` doesn't actually fail during runtime tests).\n     *\n     * That default value is widely mentioned in the documentation and we've\n     * confirmed that in runtime tests.\n     */\n    if (isImageSizeUnset) {\n        width = 100;\n    }\n    return { width, height };\n}\nfunction getExpressionArgumentValue(node, index) {\n    const arg = node.args.at(index);\n    if (isNumberLiteral(arg) || isStringLiteral(arg)) {\n        return arg.value;\n    }\n}\nfunction getNamedArgumentValue(node, propertyName) {\n    const argumentNode = getNamedArgumentNode(node, propertyName);\n    const valueNode = argumentNode === null || argumentNode === void 0 ? void 0 : argumentNode.value;\n    if (isNumberLiteral(valueNode) || isStringLiteral(valueNode)) {\n        return valueNode.value;\n    }\n}\nfunction getNamedArgumentNode(node, argName) {\n    const args = node.args;\n    return args.find((arg) => (0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.NamedArgument, arg) && arg.name === argName);\n}\nfunction buildFilterString(filter, filterParameters) {\n    const parameters = Object.entries(filterParameters)\n        .filter(([_key, value]) => value && value !== -1)\n        .map(([key, value]) => `${key}: ${value}`)\n        .join(', ');\n    if (!parameters) {\n        return ` ${filter}`;\n    }\n    return ` ${filter}: ${parameters}`;\n}\nfunction getFilterSourceStartAndEnd(node) {\n    const position = node.position;\n    const pipePosition = node.source.slice(position.start).indexOf('|');\n    return {\n        start: position.start + pipePosition + 1,\n        end: position.end,\n    };\n}\nfunction strValue(value) {\n    return value ? `'${value}'` : null;\n}\nfunction isVariableLookup(exp) {\n    return (0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.VariableLookup, exp);\n}\nfunction isStringLiteral(exp) {\n    return (0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.String, exp);\n}\nfunction isNumberLiteral(exp) {\n    return (0, utils_1.isNodeOfType)(liquid_html_parser_1.NodeTypes.Number, exp);\n}\n//# sourceMappingURL=fixes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeprecatedFilter = void 0;\nconst types_1 = require(\"../../types\");\nconst fixes_1 = require(\"./fixes\");\nexports.DeprecatedFilter = {\n    meta: {\n        code: 'DeprecatedFilter',\n        aliases: ['DeprecatedFilters'],\n        name: 'Deprecated Filter',\n        docs: {\n            description: 'Discourages using deprecated filters in themes.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/deprecated-filter',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        if (!context.themeDocset) {\n            return {};\n        }\n        return {\n            LiquidFilter: async (node) => {\n                const filters = await context.themeDocset.filters();\n                const deprecatedFilter = filters.find((f) => {\n                    return f.deprecated && f.name === node.name;\n                });\n                if (!deprecatedFilter) {\n                    return;\n                }\n                const recommendedFilterName = findRecommendedAlternative(deprecatedFilter);\n                const recommendedFilter = filters.find((f) => f.name === recommendedFilterName);\n                const message = deprecatedFilterMessage(deprecatedFilter, recommendedFilter);\n                const suggest = deprecatedFilterSuggestion(node);\n                const fix = deprecatedFilterFix(node);\n                context.report({\n                    message,\n                    suggest,\n                    fix,\n                    startIndex: node.position.start + 1,\n                    endIndex: node.position.end,\n                });\n            },\n        };\n    },\n};\nfunction deprecatedFilterSuggestion(node) {\n    const filter = node.name;\n    switch (filter) {\n        case 'img_tag':\n            return (0, fixes_1.suggestImgTagFix)(node);\n        case 'img_url':\n            return (0, fixes_1.suggestImgUrlFix)(node);\n        case 'article_img_url':\n        case 'collection_img_url':\n        case 'product_img_url':\n            /**\n             * These filters rely on the usage of the `image_url`\n             * filter as the fix.\n             */\n            return (0, fixes_1.suggestImageUrlFix)(filter, node);\n        case 'currency_selector':\n            /**\n             * Cannot be fixed.\n             *\n             * Deprecated without a direct replacement because the\n             * currency form has also been deprecated. The currency\n             * form was replaced by the localization form.\n             */\n            return;\n    }\n}\nfunction deprecatedFilterFix(node) {\n    const filter = node.name;\n    if (filter === 'hex_to_rgba') {\n        return (0, fixes_1.fixHexToRgba)(node);\n    }\n}\nfunction deprecatedFilterMessage(deprecated, recommended) {\n    if (recommended) {\n        return `Deprecated filter '${deprecated.name}', consider using '${recommended.name}'.`;\n    }\n    return `Deprecated filter '${deprecated.name}'.`;\n}\nfunction findRecommendedAlternative(deprecatedFilter) {\n    const reason = deprecatedFilter.deprecation_reason;\n    const match = reason === null || reason === void 0 ? void 0 : reason.match(/replaced by \\[`(.+?)`\\]/);\n    return match === null || match === void 0 ? void 0 : match[1];\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeprecatedTag = void 0;\nconst types_1 = require(\"../../types\");\nexports.DeprecatedTag = {\n    meta: {\n        code: 'DeprecatedTag',\n        aliases: ['DeprecatedTags'],\n        name: 'Deprecated Tag',\n        docs: {\n            description: 'This check is aimed at eliminating the use of deprecated tags.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/deprecated-tag',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidTag(node) {\n                if (node.name === 'include') {\n                    const start = node.source.substring(node.position.start);\n                    const includeStartIndex = start.indexOf('include');\n                    const includeEndIndex = includeStartIndex + 'include'.length;\n                    const includeStart = node.position.start + includeStartIndex;\n                    const includeEnd = node.position.start + includeEndIndex;\n                    context.report({\n                        message: `Use the 'render' tag instead of 'include'`,\n                        startIndex: includeStart,\n                        endIndex: includeEnd,\n                        suggest: [\n                            {\n                                message: `Replace 'include' with 'render'`,\n                                fix: (corrector) => {\n                                    corrector.replace(includeStart, includeEnd, 'render');\n                                },\n                            },\n                        ],\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EmptyBlockContent = void 0;\nconst types_1 = require(\"../../types\");\nconst to_schema_1 = require(\"../../to-schema\");\nexports.EmptyBlockContent = {\n    meta: {\n        code: 'EmptyBlockContent',\n        name: 'Prevent empty block content',\n        docs: {\n            description: 'This check exists to warn you when the blocks array at the root level of the schema is empty.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/empty-block-content',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        let isContentForBlocksLocationSet = false;\n        let contentForBlocksLocation = { start: 0, end: 0 };\n        return {\n            async LiquidTag(node) {\n                if (node.name !== 'content_for')\n                    return;\n                const nodeMarkup = node.markup;\n                if (typeof nodeMarkup === 'object' && nodeMarkup.contentForType.value === 'blocks') {\n                    contentForBlocksLocation.start = node.blockStartPosition.start;\n                    contentForBlocksLocation.end = node.blockStartPosition.end;\n                    isContentForBlocksLocationSet = true;\n                }\n            },\n            async onCodePathEnd() {\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                const blocks = validSchema.blocks;\n                if (isContentForBlocksLocationSet && !blocks) {\n                    context.report({\n                        message: `The 'content_for \"blocks\"' tag is present, but the blocks array is not defined.`,\n                        startIndex: contentForBlocksLocation.start,\n                        endIndex: contentForBlocksLocation.end,\n                    });\n                }\n                else if (isContentForBlocksLocationSet && blocks && blocks.length === 0) {\n                    context.report({\n                        message: `The 'content_for \"blocks\"' tag is present, but the blocks array is empty.`,\n                        startIndex: contentForBlocksLocation.start,\n                        endIndex: contentForBlocksLocation.end,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImgWidthAndHeight = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nexports.ImgWidthAndHeight = {\n    meta: {\n        code: 'ImgWidthAndHeight',\n        name: 'Width and height attributes on image tags',\n        docs: {\n            description: 'This check is aimed at eliminating content layout shift in themes by enforcing the use of the width and height attributes on img tags.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/img-width-and-height',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async HtmlVoidElement(node) {\n                if (node.name === 'img') {\n                    const widthAttr = node.attributes.find((attr) => (0, utils_1.isValuedHtmlAttribute)(attr) && (0, utils_1.isAttr)(attr, 'width'));\n                    const heightAttr = node.attributes.find((attr) => (0, utils_1.isValuedHtmlAttribute)(attr) && (0, utils_1.isAttr)(attr, 'height'));\n                    let missingAttributes = [];\n                    if (!widthAttr) {\n                        missingAttributes.push('width');\n                    }\n                    if (!heightAttr) {\n                        missingAttributes.push('height');\n                    }\n                    if (missingAttributes.length > 0) {\n                        const attributeWord = missingAttributes.length === 1 ? 'attribute' : 'attributes';\n                        context.report({\n                            message: `Missing ${missingAttributes.join(' and ')} ${attributeWord} on img tag`,\n                            startIndex: node.position.start,\n                            endIndex: node.position.end,\n                        });\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recommended = exports.allChecks = void 0;\nconst types_1 = require(\"../types\");\nconst app_block_valid_tags_1 = require(\"./app-block-valid-tags\");\nconst asset_preload_1 = require(\"./asset-preload\");\nconst asset_size_app_block_css_1 = require(\"./asset-size-app-block-css\");\nconst asset_size_app_block_javascript_1 = require(\"./asset-size-app-block-javascript\");\nconst asset_size_css_1 = require(\"./asset-size-css\");\nconst asset_size_javascript_1 = require(\"./asset-size-javascript\");\nconst block_id_usage_1 = require(\"./block-id-usage\");\nconst capture_on_content_for_block_1 = require(\"./capture-on-content-for-block\");\nconst cdn_preconnect_1 = require(\"./cdn-preconnect\");\nconst content_for_header_modification_1 = require(\"./content-for-header-modification\");\nconst deprecate_bgsizes_1 = require(\"./deprecate-bgsizes\");\nconst deprecate_lazysizes_1 = require(\"./deprecate-lazysizes\");\nconst deprecated_filter_1 = require(\"./deprecated-filter\");\nconst deprecated_tag_1 = require(\"./deprecated-tag\");\nconst empty_block_content_1 = require(\"./empty-block-content\");\nconst img_width_and_height_1 = require(\"./img-width-and-height\");\nconst json_missing_block_1 = require(\"./json-missing-block\");\nconst json_syntax_error_1 = require(\"./json-syntax-error\");\nconst liquid_free_settings_1 = require(\"./liquid-free-settings\");\nconst liquid_html_syntax_error_1 = require(\"./liquid-html-syntax-error\");\nconst matching_translations_1 = require(\"./matching-translations\");\nconst missing_asset_1 = require(\"./missing-asset\");\nconst missing_template_1 = require(\"./missing-template\");\nconst pagination_size_1 = require(\"./pagination-size\");\nconst parser_blocking_script_1 = require(\"./parser-blocking-script\");\nconst schema_presets_block_order_1 = require(\"./schema-presets-block-order\");\nconst schema_presets_static_blocks_1 = require(\"./schema-presets-static-blocks\");\nconst remote_asset_1 = require(\"./remote-asset\");\nconst required_layout_theme_object_1 = require(\"./required-layout-theme-object\");\nconst translation_key_exists_1 = require(\"./translation-key-exists\");\nconst unclosed_html_element_1 = require(\"./unclosed-html-element\");\nconst undefined_object_1 = require(\"./undefined-object\");\nconst unique_static_block_id_1 = require(\"./unique-static-block-id\");\nconst unknown_filter_1 = require(\"./unknown-filter\");\nconst unused_assign_1 = require(\"./unused-assign\");\nconst valid_content_for_arguments_1 = require(\"./valid-content-for-arguments\");\nconst valid_block_target_1 = require(\"./valid-block-target\");\nconst valid_html_translation_1 = require(\"./valid-html-translation\");\nconst valid_json_1 = require(\"./valid-json\");\nconst valid_local_blocks_1 = require(\"./valid-local-blocks\");\nconst valid_render_snippet_params_1 = require(\"./valid-render-snippet-params\");\nconst valid_schema_1 = require(\"./valid-schema\");\nconst valid_schema_name_1 = require(\"./valid-schema-name\");\nconst valid_settings_key_1 = require(\"./valid-settings-key\");\nconst valid_static_block_type_1 = require(\"./valid-static-block-type\");\nconst valid_visible_if_1 = require(\"./valid-visible-if\");\nconst variable_name_1 = require(\"./variable-name\");\nconst app_block_missing_schema_1 = require(\"./app-block-missing-schema\");\nconst unique_settings_id_1 = require(\"./unique-settings-id\");\nexports.allChecks = [\n    app_block_valid_tags_1.AppBlockValidTags,\n    asset_preload_1.AssetPreload,\n    asset_size_app_block_css_1.AssetSizeAppBlockCSS,\n    asset_size_app_block_javascript_1.AssetSizeAppBlockJavaScript,\n    asset_size_css_1.AssetSizeCSS,\n    asset_size_javascript_1.AssetSizeJavaScript,\n    block_id_usage_1.BlockIdUsage,\n    capture_on_content_for_block_1.CaptureOnContentForBlock,\n    cdn_preconnect_1.CdnPreconnect,\n    content_for_header_modification_1.ContentForHeaderModification,\n    deprecate_bgsizes_1.DeprecateBgsizes,\n    deprecated_filter_1.DeprecatedFilter,\n    deprecated_tag_1.DeprecatedTag,\n    deprecate_lazysizes_1.DeprecateLazysizes,\n    empty_block_content_1.EmptyBlockContent,\n    img_width_and_height_1.ImgWidthAndHeight,\n    json_missing_block_1.JSONMissingBlock,\n    json_syntax_error_1.JSONSyntaxError,\n    liquid_free_settings_1.LiquidFreeSettings,\n    liquid_html_syntax_error_1.LiquidHTMLSyntaxError,\n    matching_translations_1.MatchingTranslations,\n    missing_asset_1.MissingAsset,\n    missing_template_1.MissingTemplate,\n    app_block_missing_schema_1.AppBlockMissingSchema,\n    pagination_size_1.PaginationSize,\n    parser_blocking_script_1.ParserBlockingScript,\n    schema_presets_block_order_1.SchemaPresetsBlockOrder,\n    schema_presets_static_blocks_1.SchemaPresetsStaticBlocks,\n    remote_asset_1.RemoteAsset,\n    required_layout_theme_object_1.RequiredLayoutThemeObject,\n    translation_key_exists_1.TranslationKeyExists,\n    unclosed_html_element_1.UnclosedHTMLElement,\n    undefined_object_1.UndefinedObject,\n    unique_settings_id_1.UniqueSettingIds,\n    unique_static_block_id_1.UniqueStaticBlockId,\n    unknown_filter_1.UnknownFilter,\n    unused_assign_1.UnusedAssign,\n    valid_block_target_1.ValidBlockTarget,\n    valid_html_translation_1.ValidHTMLTranslation,\n    valid_content_for_arguments_1.ValidContentForArguments,\n    valid_json_1.ValidJSON,\n    valid_local_blocks_1.ValidLocalBlocks,\n    valid_schema_1.ValidSchema,\n    valid_settings_key_1.ValidSettingsKey,\n    valid_static_block_type_1.ValidStaticBlockType,\n    valid_visible_if_1.ValidVisibleIf,\n    valid_visible_if_1.ValidVisibleIfSettingsSchema,\n    variable_name_1.VariableName,\n    valid_render_snippet_params_1.ValidRenderSnippetParams,\n    valid_schema_name_1.ValidSchemaName,\n];\n/**\n * The recommended checks is populated by all checks with the following conditions:\n * - meta.docs.recommended: true\n * - Either no meta.targets list exist or if it does exist then Recommended is a target\n */\nexports.recommended = exports.allChecks.filter((check) => {\n    const isRecommended = check.meta.docs.recommended;\n    const isValidTarget = !check.meta.targets ||\n        !check.meta.targets.length ||\n        check.meta.targets.includes(types_1.ConfigTarget.Recommended);\n    return isRecommended && isValidTarget;\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONMissingBlock = void 0;\nconst to_schema_1 = require(\"../../to-schema\");\nconst types_1 = require(\"../../types\");\nconst missing_block_utils_1 = require(\"./missing-block-utils\");\nexports.JSONMissingBlock = {\n    meta: {\n        code: 'JSONMissingBlock',\n        name: 'Check for missing blocks types in JSON templates',\n        docs: {\n            description: 'This check ensures that JSON templates contain valid block types.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/json-missing-block',\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const relativePath = context.toRelativePath(context.file.uri);\n        if (!relativePath.startsWith('templates/'))\n            return {};\n        return {\n            async onCodePathEnd() {\n                const schema = await (0, to_schema_1.getSchemaFromJSON)(context);\n                const { ast, offset } = schema !== null && schema !== void 0 ? schema : {};\n                if (!ast || ast instanceof Error)\n                    return;\n                if (!schema)\n                    return;\n                const sections = schema.parsed.sections;\n                if (!sections)\n                    return;\n                await Promise.all(Object.entries(sections).map(async ([sectionKey, section]) => {\n                    if ((0, missing_block_utils_1.isPropertyNode)(section) &&\n                        'blocks' in section &&\n                        (0, missing_block_utils_1.isPropertyNode)(section.blocks) &&\n                        'type' in section) {\n                        await (0, missing_block_utils_1.getAllBlocks)(ast, offset, section.type, section.blocks, ['sections', sectionKey, 'blocks'], context);\n                    }\n                }));\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAllBlocks = exports.isPropertyNode = void 0;\nconst json_1 = require(\"../../json\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nfunction isPropertyNode(node) {\n    return typeof node === 'object' && node !== null;\n}\nexports.isPropertyNode = isPropertyNode;\nfunction isNestedBlock(currentPath) {\n    return currentPath.filter((segment) => segment === 'blocks').length > 1;\n}\nfunction reportWarning(message, offset, astNode, context) {\n    context.report({\n        message,\n        startIndex: offset + (0, json_1.getLocStart)(astNode),\n        endIndex: offset + (0, json_1.getLocEnd)(astNode),\n    });\n}\nasync function validateBlockFileExistence(blockType, context) {\n    if (blockType === '@theme' || blockType === '@app') {\n        return true;\n    }\n    const blockPath = `blocks/${blockType}.liquid`;\n    return await (0, file_utils_1.doesFileExist)(context, blockPath);\n}\nasync function getThemeBlocks(sectionType, currentPath, context) {\n    var _a, _b;\n    const themeBlocks = [];\n    if (!sectionType)\n        return themeBlocks;\n    const schema = isNestedBlock(currentPath)\n        ? await ((_a = context.getBlockSchema) === null || _a === void 0 ? void 0 : _a.call(context, sectionType))\n        : await ((_b = context.getSectionSchema) === null || _b === void 0 ? void 0 : _b.call(context, sectionType));\n    if (!schema || schema instanceof Error)\n        return themeBlocks;\n    const { validSchema } = schema;\n    if (!validSchema || validSchema instanceof Error)\n        return themeBlocks;\n    if (Array.isArray(validSchema.blocks)) {\n        validSchema.blocks.forEach((block) => {\n            if (!('name' in block) && block.type !== '@app') {\n                themeBlocks.push(block.type);\n            }\n        });\n    }\n    return themeBlocks;\n}\nasync function validateBlock(blockType, blockPath, ancestorType, currentPath, offset, context) {\n    const themeBlocks = await getThemeBlocks(ancestorType, currentPath, context);\n    if (themeBlocks.length === 0)\n        return;\n    const exists = await validateBlockFileExistence(blockType, context);\n    if (!exists) {\n        reportWarning(`Theme block 'blocks/${blockType}.liquid' does not exist.`, offset, blockPath, context);\n    }\n    else {\n        const isPrivateBlock = blockType.startsWith('_');\n        const isThemeInRootLevel = themeBlocks.includes('@theme');\n        const isPresetInRootLevel = themeBlocks.includes(blockType);\n        if (!isPrivateBlock ? isPresetInRootLevel || isThemeInRootLevel : isPresetInRootLevel) {\n            return;\n        }\n        else {\n            const location = isNestedBlock(currentPath) ? 'blocks' : 'sections';\n            reportWarning(`Block type '${blockType}' is not allowed in '${location}/${ancestorType}.liquid'.`, offset, blockPath, context);\n        }\n    }\n}\nasync function getAllBlocks(ast, offset, ancestorType, blocks, currentPath, context) {\n    await Promise.all(Object.entries(blocks).map(async ([blockKey, block]) => {\n        if (block.type) {\n            const typePath = currentPath.concat(blockKey, 'type');\n            const blockPath = (0, json_1.nodeAtPath)(ast, typePath);\n            if (blockPath) {\n                await validateBlock(block.type, blockPath, ancestorType, currentPath, offset, context);\n            }\n        }\n        if ('blocks' in block) {\n            await getAllBlocks(ast, offset, block.type, block.blocks, currentPath.concat(blockKey, 'blocks'), context);\n        }\n    }));\n}\nexports.getAllBlocks = getAllBlocks;\n//# sourceMappingURL=missing-block-utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONSyntaxError = void 0;\nconst parse_1 = require(\"../../jsonc/parse\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nfunction cleanErrorMessage(error) {\n    const message = 'rawMessage' in error ? error.rawMessage : error.message;\n    return message.replace(/\\s+at \\d+:\\d+/, '');\n}\nexports.JSONSyntaxError = {\n    meta: {\n        code: 'JSONSyntaxError',\n        name: 'Enforce valid JSON',\n        docs: {\n            description: 'This check exists to prevent invalid JSON files in themes.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/json-syntax-error',\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n        deprecated: true,\n    },\n    create(context) {\n        if (context.validateJSON)\n            return {}; // If available, we'll use the JSON validator instead\n        const error = context.file.ast;\n        if (!(0, utils_1.isError)(error))\n            return {};\n        return {\n            async onCodePathStart(file) {\n                if (file.ast instanceof parse_1.JSONCParseErrors) {\n                    for (const error of file.ast.errors) {\n                        context.report({\n                            message: jsoncParseErrorMessage(error.error),\n                            startIndex: error.offset,\n                            endIndex: error.offset + error.length,\n                        });\n                    }\n                }\n                else {\n                    context.report({\n                        message: cleanErrorMessage(error),\n                        startIndex: 0,\n                        endIndex: file.source.length,\n                    });\n                }\n            },\n        };\n    },\n};\nfunction jsoncParseErrorMessage(errorType) {\n    switch (errorType) {\n        case 1 /* ParseErrorCode.InvalidSymbol */:\n            return 'Invalid symbol';\n        case 2 /* ParseErrorCode.InvalidNumberFormat */:\n            return 'Invalid number format';\n        case 3 /* ParseErrorCode.PropertyNameExpected */:\n            return 'Property name expected';\n        case 4 /* ParseErrorCode.ValueExpected */:\n            return 'Expecting a value';\n        case 5 /* ParseErrorCode.ColonExpected */:\n            return 'Expecting a colon after a property name (:)';\n        case 6 /* ParseErrorCode.CommaExpected */:\n            return 'Expecting a comma';\n        case 7 /* ParseErrorCode.CloseBraceExpected */:\n            return 'Expecting a closing brace (})';\n        case 8 /* ParseErrorCode.CloseBracketExpected */:\n            return 'Expecting a closing bracket (])';\n        case 9 /* ParseErrorCode.EndOfFileExpected */:\n            return 'Expecting end of file';\n        case 10 /* ParseErrorCode.InvalidCommentToken */:\n            return 'Invalid comment token';\n        case 11 /* ParseErrorCode.UnexpectedEndOfComment */:\n            return 'Unexpected end of comment';\n        case 12 /* ParseErrorCode.UnexpectedEndOfString */:\n            return 'Unexpected end of string';\n        case 13 /* ParseErrorCode.UnexpectedEndOfNumber */:\n            return 'Unexpected end of number';\n        case 14 /* ParseErrorCode.InvalidUnicode */:\n            return 'Invalid unicode';\n        case 15 /* ParseErrorCode.InvalidEscapeCharacter */:\n            return 'Invalid escape character';\n        case 16 /* ParseErrorCode.InvalidCharacter */:\n            return 'Invalid character';\n        default:\n            return 'Something went wrong with this JSON';\n    }\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidFreeSettings = void 0;\nconst to_source_code_1 = require(\"../../to-source-code\");\nconst types_1 = require(\"../../types\");\nconst visitor_1 = require(\"../../visitor\");\nexports.LiquidFreeSettings = {\n    meta: {\n        code: 'LiquidFreeSettings',\n        name: 'Check for liquid free settings values',\n        docs: {\n            description: 'Ensures settings values are liquid free.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/themes/tools/theme-check/checks/liquid-free-settings',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json') {\n                    return;\n                }\n                const jsonString = node.source.slice(node.blockStartPosition.end, node.blockEndPosition.start);\n                const jsonFile = (0, to_source_code_1.toJSONAST)(jsonString);\n                if (jsonFile instanceof Error)\n                    return;\n                (0, visitor_1.visit)(jsonFile, {\n                    Property(schemaNode, ancestors) {\n                        if (isInArrayWithParentKey(ancestors, 'settings') && isLiteralNode(schemaNode.value)) {\n                            const { value, loc } = schemaNode.value;\n                            const propertyValue = schemaNode.key.value;\n                            if (typeof value === 'string' &&\n                                propertyValue !== 'visible_if' &&\n                                value.includes('{%') &&\n                                value.includes('%}')) {\n                                context.report({\n                                    message: 'Settings values cannot contain liquid logic.',\n                                    startIndex: node.blockStartPosition.end + loc.start.offset,\n                                    endIndex: node.blockStartPosition.end + loc.end.offset,\n                                });\n                            }\n                        }\n                    },\n                });\n            },\n        };\n    },\n};\nfunction isLiteralNode(node) {\n    return node.type === 'Literal';\n}\nfunction isInArrayWithParentKey(ancestors, parentKey) {\n    return ancestors.some((ancestor, index) => {\n        var _a;\n        const parent = ancestors[index - 1];\n        return ((ancestor.type === 'Array' || ancestor.type === 'Object') &&\n            (parent === null || parent === void 0 ? void 0 : parent.type) === 'Property' &&\n            ((_a = parent.key) === null || _a === void 0 ? void 0 : _a.value) === parentKey);\n    });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidHTMLSyntaxError = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nfunction isParsingErrorWithLocation(error) {\n    return 'name' in error && error.name === 'LiquidHTMLParsingError' && 'loc' in error;\n}\nfunction cleanErrorMessage(message, highlight) {\n    return message\n        .replace(/Line \\d+, col \\d+:\\s+/, 'SyntaxError: ')\n        .replace(/(?!<expected \".+\",) not .*/, ` not \"${highlight}\"`);\n}\nexports.LiquidHTMLSyntaxError = {\n    meta: {\n        code: 'LiquidHTMLSyntaxError',\n        aliases: ['SyntaxError', 'HtmlParsingError'],\n        name: 'Prevent LiquidHTML Syntax Errors',\n        docs: {\n            description: 'This check exists to inform the user of Liquid HTML syntax errors.',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const error = context.file.ast;\n        if (!(0, utils_1.isError)(error))\n            return {};\n        return {\n            async onCodePathStart(file) {\n                if (isParsingErrorWithLocation(error)) {\n                    const { start, end } = error.loc;\n                    const startIndex = (0, utils_1.getOffset)(file.source, start.line, start.column);\n                    let endIndex = (0, utils_1.getOffset)(file.source, end.line, end.column);\n                    if (startIndex === endIndex)\n                        endIndex += 1;\n                    const highlight = file.source.slice(startIndex, endIndex);\n                    context.report({\n                        message: cleanErrorMessage(error.message, highlight),\n                        startIndex,\n                        endIndex: endIndex,\n                    });\n                }\n                else {\n                    context.report({\n                        message: error.message,\n                        startIndex: 0,\n                        endIndex: file.source.length,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatchingTranslations = void 0;\nconst types_1 = require(\"../../types\");\nconst PLURALIZATION_KEYS = new Set(['zero', 'one', 'two', 'few', 'many', 'other']);\nexports.MatchingTranslations = {\n    meta: {\n        code: 'MatchingTranslations',\n        name: 'Translation files should have the same keys',\n        docs: {\n            description: 'TODO',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/matching-translations',\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        // State\n        const defaultTranslations = new Set();\n        const missingTranslations = new Set();\n        const nodesByPath = new Map();\n        const file = context.file;\n        const fileUri = file.uri;\n        const relativePath = context.toRelativePath(fileUri);\n        const ast = file.ast;\n        const isLocaleFile = relativePath.startsWith('locales/');\n        const isDefaultTranslationsFile = fileUri.endsWith('.default.json') || fileUri.endsWith('.default.schema.json');\n        const isSchemaTranslationFile = fileUri.endsWith('.schema.json');\n        if (!isLocaleFile || isDefaultTranslationsFile || ast instanceof Error) {\n            // No need to lint a file that isn't a translation file, we return an\n            // empty object as the check for those.\n            return {};\n        }\n        // Helpers\n        const hasDefaultTranslations = () => defaultTranslations.size > 0;\n        const isTerminalNode = ({ type }) => type === 'Literal';\n        const isPluralizationNode = (node) => PLURALIZATION_KEYS.has(node.key.value);\n        const isShopifyPath = (path) => path.startsWith('shopify.');\n        const hasDefaultTranslation = (translationPath) => { var _a; return (_a = defaultTranslations.has(translationPath)) !== null && _a !== void 0 ? _a : false; };\n        const isPluralizationPath = (path) => [...PLURALIZATION_KEYS].some((key) => path.endsWith(key));\n        const jsonPaths = (json) => {\n            const keys = Object.keys(json);\n            return keys.reduce((acc, key) => {\n                if (typeof json[key] !== 'object') {\n                    return acc.concat(key);\n                }\n                const childJson = json[key];\n                const childPaths = jsonPaths(childJson);\n                return acc.concat(childPaths.map((path) => `${key}.${path}`));\n            }, []);\n        };\n        const objectPath = (nodes) => {\n            return nodes\n                .filter((node) => node.type === 'Property')\n                .reduce((acc, val) => acc.concat(val.key.value), [])\n                .join('.');\n        };\n        const countCommonParts = (arrayA, arrayB) => {\n            const minLength = Math.min(arrayA.length, arrayB.length);\n            for (let i = 0; i < minLength; i++) {\n                if (arrayA[i] !== arrayB[i]) {\n                    return i;\n                }\n            }\n            return minLength;\n        };\n        const closestTranslationKey = (translationKey) => {\n            var _a;\n            const translationKeyParts = translationKey.split('.');\n            let closestMatch = '';\n            let maxCommonParts = 0;\n            for (const path of nodesByPath.keys()) {\n                const pathParts = path.split('.');\n                const commonParts = countCommonParts(pathParts, translationKeyParts);\n                if (commonParts > maxCommonParts) {\n                    maxCommonParts = commonParts;\n                    closestMatch = path;\n                }\n            }\n            return (_a = nodesByPath.get(closestMatch)) !== null && _a !== void 0 ? _a : ast;\n        };\n        return {\n            async onCodePathStart() {\n                const getDefaultTranslations = isSchemaTranslationFile\n                    ? context.getDefaultSchemaTranslations\n                    : context.getDefaultTranslations;\n                const defaultTranslationPaths = await getDefaultTranslations().then(jsonPaths);\n                defaultTranslationPaths.forEach(Set.prototype.add, defaultTranslations);\n                // At the `onCodePathStart`, we assume that all translations are missing,\n                // and remove translation paths while traversing through the file.\n                defaultTranslationPaths.forEach(Set.prototype.add, missingTranslations);\n            },\n            async Property(node, ancestors) {\n                const path = objectPath(ancestors.concat(node));\n                nodesByPath.set(path, node);\n                if (!hasDefaultTranslations())\n                    return;\n                if (isPluralizationNode(node))\n                    return;\n                if (!isTerminalNode(node.value))\n                    return;\n                if (isShopifyPath(path))\n                    return;\n                if (hasDefaultTranslation(path)) {\n                    // As `path` is present, we remove it from the\n                    // `missingTranslationsPerFile` bucket.\n                    missingTranslations.delete(path);\n                    return;\n                }\n                context.report({\n                    message: `A default translation for '${path}' does not exist`,\n                    startIndex: node.loc.start.offset,\n                    endIndex: node.loc.end.offset,\n                    suggest: [\n                        {\n                            message: 'Delete unneeded translation key',\n                            fix(corrector) {\n                                corrector.remove(path);\n                            },\n                        },\n                    ],\n                });\n            },\n            async onCodePathEnd() {\n                missingTranslations.forEach((path) => {\n                    const closest = closestTranslationKey(path);\n                    if (isPluralizationPath(path))\n                        return;\n                    if (isShopifyPath(path))\n                        return;\n                    context.report({\n                        message: `The translation for '${path}' is missing`,\n                        startIndex: closest.loc.start.offset,\n                        endIndex: closest.loc.end.offset,\n                        fix(corrector) {\n                            corrector.add(path, 'TODO');\n                        },\n                    });\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingAsset = void 0;\nconst types_1 = require(\"../../types\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst utils_1 = require(\"../utils\");\nexports.MissingAsset = {\n    meta: {\n        code: 'MissingAsset',\n        name: 'Avoid rendering missing asset files',\n        docs: {\n            description: 'Reports missing asset files',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/missing-asset',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidVariable(node) {\n                if (node.filters.length === 0 || node.filters[0].name !== 'asset_url') {\n                    return;\n                }\n                if (!(0, utils_1.isLiquidString)(node.expression))\n                    return;\n                let expression = node.expression;\n                let originalAssetPath = `assets/${expression.value}`;\n                let assetPath = originalAssetPath;\n                let fileExists = await (0, file_utils_1.doesFileExist)(context, assetPath);\n                if (fileExists)\n                    return;\n                if (assetPath.endsWith('.scss.css')) {\n                    assetPath = assetPath.replace('.scss.css', '.scss.liquid');\n                    fileExists = await (0, file_utils_1.doesFileExist)(context, assetPath);\n                    if (fileExists)\n                        return;\n                }\n                if (assetPath.endsWith('.js') || assetPath.endsWith('.css')) {\n                    assetPath += '.liquid';\n                    fileExists = await (0, file_utils_1.doesFileExist)(context, assetPath);\n                    if (fileExists)\n                        return;\n                }\n                context.report({\n                    message: `'${originalAssetPath}' does not exist`,\n                    startIndex: expression.position.start,\n                    endIndex: expression.position.end,\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingTemplate = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst minimatch_1 = require(\"minimatch\");\nconst types_1 = require(\"../../types\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst schema = {\n    ignoreMissing: types_1.SchemaProp.array(types_1.SchemaProp.string(), []),\n};\nexports.MissingTemplate = {\n    meta: {\n        code: 'MissingTemplate',\n        name: 'Avoid rendering missing templates',\n        docs: {\n            description: 'Reports missing include/render/section liquid file',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/missing-template',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema,\n        targets: [],\n    },\n    create(context) {\n        const isNamedLiquidTag = (tag) => typeof tag.markup !== 'string';\n        function isIgnored(relativePath) {\n            return context.settings.ignoreMissing.some((pattern) => (0, minimatch_1.minimatch)(relativePath, pattern));\n        }\n        async function maybeReportMissing(relativePath, { position }) {\n            const fileExists = await (0, file_utils_1.doesFileExist)(context, relativePath);\n            if (fileExists || isIgnored(relativePath))\n                return;\n            context.report({\n                message: `'${relativePath}' does not exist`,\n                startIndex: position.start,\n                endIndex: position.end,\n            });\n        }\n        return {\n            async RenderMarkup(node) {\n                if (node.snippet.type === liquid_html_parser_1.NodeTypes.VariableLookup)\n                    return;\n                const snippet = node.snippet;\n                const relativePath = `snippets/${snippet.value}.liquid`;\n                await maybeReportMissing(relativePath, snippet);\n            },\n            async LiquidTag(node) {\n                if (!isNamedLiquidTag(node))\n                    return;\n                if (node.name !== liquid_html_parser_1.NamedTags.section)\n                    return;\n                const markup = node.markup;\n                const relativePath = `sections/${markup.value}.liquid`;\n                await maybeReportMissing(relativePath, markup);\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaginationSize = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst utils_2 = require(\"../utils\");\nconst json_1 = require(\"../../json\");\nconst schema = {\n    minSize: types_1.SchemaProp.number(1),\n    maxSize: types_1.SchemaProp.number(50),\n};\nexports.PaginationSize = {\n    meta: {\n        code: 'PaginationSize',\n        name: 'Ensure paginate tags are used with performant sizes',\n        docs: {\n            description: 'This check is aimed at keeping response times low.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/pagination-size',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema,\n        targets: [],\n    },\n    create(context) {\n        const minSize = context.settings.minSize;\n        const maxSize = context.settings.maxSize;\n        let schemaSettings = [];\n        const pageSizeLookups = [];\n        function checkPageSize(pageSizeNode, value, message = `Pagination size must be a positive integer between ${minSize} and ${maxSize}.`) {\n            if (minSize <= value && value <= maxSize)\n                return;\n            context.report({\n                message,\n                startIndex: pageSizeNode.position.start,\n                endIndex: pageSizeNode.position.end,\n            });\n        }\n        return {\n            async LiquidTag(node) {\n                if (typeof node.markup === 'string' || node.name !== 'paginate')\n                    return;\n                const pageSizeNode = node.markup.pageSize;\n                if ((0, utils_2.isNodeOfType)(liquid_html_parser_1.NodeTypes.VariableLookup, pageSizeNode)) {\n                    pageSizeLookups.push(pageSizeNode);\n                }\n                else if ((0, utils_2.isNodeOfType)(liquid_html_parser_1.NodeTypes.Number, pageSizeNode)) {\n                    checkPageSize(pageSizeNode, Number(pageSizeNode.value));\n                }\n            },\n            async LiquidRawTag(node) {\n                if (node.name === 'schema') {\n                    const schema = (0, json_1.parseJSON)(node.body.value);\n                    if ((0, utils_1.isError)(schema))\n                        return;\n                    if (schema.settings && Array.isArray(schema.settings)) {\n                        schemaSettings = schema.settings;\n                    }\n                }\n            },\n            async onCodePathEnd() {\n                pageSizeLookups.forEach((pageSizeVariableLookup) => {\n                    // Kind of assumes that you're using settings of some sort.\n                    const lastLookup = (0, utils_1.last)(pageSizeVariableLookup.lookups);\n                    if (lastLookup === undefined)\n                        return;\n                    if (lastLookup.type !== liquid_html_parser_1.NodeTypes.String)\n                        return;\n                    const settingId = lastLookup.value;\n                    const setting = schemaSettings.find((setting) => setting.id === settingId);\n                    if (setting === undefined)\n                        return;\n                    if (setting.default === undefined) {\n                        context.report({\n                            message: `Default pagination size should be defined in the section settings.`,\n                            startIndex: pageSizeVariableLookup.position.start,\n                            endIndex: pageSizeVariableLookup.position.end,\n                        });\n                        return;\n                    }\n                    checkPageSize(pageSizeVariableLookup, setting.default, `This setting's default value should be between ${minSize} and ${maxSize} but is currently ${setting.default}.`);\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserBlockingScript = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst utils_2 = require(\"../utils\");\nconst suggestions_1 = require(\"./suggestions\");\nexports.ParserBlockingScript = {\n    meta: {\n        code: 'ParserBlockingScript',\n        aliases: ['ParserBlockingScriptTag'],\n        name: 'Avoid parser blocking scripts',\n        docs: {\n            description: 'They are bad ok?',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/parser-blocking-javascript',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            // {{ 'asset' | asset_url | script_tag }}\n            LiquidFilter: async (node, ancestors) => {\n                if (node.name !== 'script_tag')\n                    return;\n                const filterString = node.source.slice(node.position.start, node.position.end);\n                const offset = filterString.indexOf('script_tag');\n                const parentNode = (0, utils_1.last)(ancestors);\n                const grandParentNode = (0, utils_1.last)(ancestors, -1);\n                context.report({\n                    message: 'The script_tag filter is parser-blocking. Use a <script> tag with async or defer for better performance',\n                    startIndex: node.position.start + offset,\n                    endIndex: node.position.end,\n                    suggest: grandParentNode &&\n                        grandParentNode.type === liquid_html_parser_1.NodeTypes.LiquidVariableOutput &&\n                        parentNode &&\n                        parentNode.type === liquid_html_parser_1.NodeTypes.LiquidVariable &&\n                        (0, utils_1.last)(parentNode.filters) === node\n                        ? [\n                            (0, suggestions_1.liquidFilterSuggestion)('defer', node, parentNode, grandParentNode),\n                            (0, suggestions_1.liquidFilterSuggestion)('async', node, parentNode, grandParentNode),\n                        ]\n                        : undefined,\n                });\n            },\n            // <script src=\"...\">\n            HtmlRawNode: async (node) => {\n                if (node.name !== 'script') {\n                    return;\n                }\n                const hasSrc = node.attributes\n                    .filter(utils_2.isValuedHtmlAttribute)\n                    .some((attr) => (0, utils_2.isAttr)(attr, 'src'));\n                if (!hasSrc) {\n                    return;\n                }\n                const hasDeferOrAsync = node.attributes\n                    .filter(utils_2.isHtmlAttribute)\n                    .some((attr) => (0, utils_2.isAttr)(attr, 'async') || (0, utils_2.isAttr)(attr, 'defer'));\n                const isTypeModule = node.attributes\n                    .filter(utils_2.isValuedHtmlAttribute)\n                    .some((attr) => (0, utils_2.isAttr)(attr, 'type') &&\n                    ((0, utils_2.hasAttributeValueOf)(attr, 'module') || (0, utils_2.hasAttributeValueOf)(attr, 'importmap')));\n                if (hasDeferOrAsync || isTypeModule) {\n                    return;\n                }\n                context.report({\n                    message: 'Avoid parser blocking scripts by adding `defer` or `async` on this tag',\n                    startIndex: node.position.start,\n                    endIndex: node.position.end,\n                    suggest: [(0, suggestions_1.scriptTagSuggestion)('defer', node), (0, suggestions_1.scriptTagSuggestion)('async', node)],\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scriptTagSuggestion = exports.liquidFilterSuggestion = void 0;\nconst utils_1 = require(\"../../utils\");\nconst suggestionMessage = (attr) => `Use an HTML script tag with the ${attr} attribute instead`;\nconst liquidFilterSuggestion = (attr, node, parentNode, grandParentNode) => ({\n    message: suggestionMessage(attr),\n    fix(corrector) {\n        var _a, _b;\n        const expression = node.source.slice(parentNode.expression.position.start, (_b = (_a = (0, utils_1.last)(parentNode.filters, -1)) === null || _a === void 0 ? void 0 : _a.position.end) !== null && _b !== void 0 ? _b : node.position.start);\n        const url = `{{ ${expression} }}`;\n        corrector.replace(grandParentNode.position.start, grandParentNode.position.end, `<script src=\"${url}\" ${attr}></script>`);\n    },\n});\nexports.liquidFilterSuggestion = liquidFilterSuggestion;\nconst scriptTagSuggestion = (attr, node) => ({\n    message: suggestionMessage(attr),\n    fix(corrector) {\n        corrector.insert(node.blockStartPosition.end - 1, ` ${attr}`);\n    },\n});\nexports.scriptTagSuggestion = scriptTagSuggestion;\n//# sourceMappingURL=suggestions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteAsset = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../../utils\");\nconst RESOURCE_TAGS = ['img', 'link', 'source', 'script'];\nconst SHOPIFY_CDN_DOMAINS = ['fonts.shopifycdn.com', 'cdn.shopify.com'];\nconst TAGNAMES = ['stylesheet_tag', 'script_tag', 'image_tag', 'img_tag'];\nconst DEPRECATED = ['product_img_url', 'article_img_url', 'collection_img_url', 'img_url'];\nconst NON_DEPRECATED = [\n    'asset_url',\n    'image_url',\n    'asset_img_url',\n    'file_img_url',\n    'file_url',\n    'global_asset_url',\n    'shopify_asset_url',\n    'external_video_url',\n    'font_url',\n];\nconst LIQUID_OBJECT = 'canonical_url';\nfunction isLiquidVariableOutput(node) {\n    return node.type === types_1.LiquidHtmlNodeTypes.LiquidVariableOutput;\n}\nfunction isLiquidVariable(node) {\n    return typeof node !== 'string' && node.type === types_1.LiquidHtmlNodeTypes.LiquidVariable;\n}\nfunction isUrlHostedbyShopify(url) {\n    const urlObj = new URL(url);\n    return SHOPIFY_CDN_DOMAINS.includes(urlObj.hostname);\n}\nfunction valueIsDefinitelyNotShopifyHosted(attr) {\n    return attr.value.some((node) => {\n        if (node.type === types_1.LiquidHtmlNodeTypes.TextNode && /^(https?:)?\\/\\//.test(node.value)) {\n            if (!isUrlHostedbyShopify(node.value)) {\n                return true;\n            }\n        }\n        if (isLiquidVariableOutput(node)) {\n            const variable = node.markup;\n            if (isLiquidVariable(variable)) {\n                const expression = variable.expression;\n                if (expression.type === types_1.LiquidHtmlNodeTypes.String && /^https?:\\/\\//.test(expression.value)) {\n                    if (!isUrlHostedbyShopify(expression.value)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    });\n}\nfunction valueIsShopifyHosted(attr) {\n    const ASSET_URL_FILTER_NAMES = [...DEPRECATED, ...NON_DEPRECATED];\n    const ASSET_URL_OBJECT_NAMES = [LIQUID_OBJECT];\n    return attr.value.some((node) => {\n        if (!isLiquidVariableOutput(node))\n            return false;\n        if (!isLiquidVariable(node.markup))\n            return false;\n        const includesFilter = node.markup.filters.some((filter) => ASSET_URL_FILTER_NAMES.includes(filter.name));\n        if (includesFilter)\n            return true;\n        if ((0, utils_1.isNodeOfType)(types_1.LiquidHtmlNodeTypes.VariableLookup, node.markup.expression)) {\n            if (node.markup.expression.name\n                ? ASSET_URL_OBJECT_NAMES.includes(node.markup.expression.name)\n                : false)\n                return true;\n        }\n        return false;\n    });\n}\nexports.RemoteAsset = {\n    meta: {\n        code: 'RemoteAsset',\n        aliases: ['AssetUrlFilters'],\n        name: 'Remote Asset',\n        docs: {\n            description: 'This check is aimed at eliminating unnecessary HTTP connections.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/remote-asset',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        function checkHtmlNode(node) {\n            if (!RESOURCE_TAGS.includes(node.name))\n                return;\n            const urlAttribute = node.attributes\n                .filter(utils_1.isValuedHtmlAttribute)\n                .find((attr) => (0, utils_1.isAttr)(attr, 'src') || (0, utils_1.isAttr)(attr, 'href'));\n            if (!urlAttribute)\n                return;\n            const isShopifyUrl = urlAttribute.value\n                .filter((node) => node.type === types_1.LiquidHtmlNodeTypes.TextNode)\n                .some((textNode) => isUrlHostedbyShopify(textNode.value));\n            if (isShopifyUrl)\n                return;\n            const hasDefinitelyARemoteAssetUrl = valueIsDefinitelyNotShopifyHosted(urlAttribute);\n            if (hasDefinitelyARemoteAssetUrl) {\n                context.report({\n                    message: 'Asset should be served by the Shopify CDN for better performance.',\n                    startIndex: urlAttribute.position.start,\n                    endIndex: urlAttribute.position.end,\n                });\n                return;\n            }\n            const hasShopifyHostedValue = valueIsShopifyHosted(urlAttribute);\n            if (hasShopifyHostedValue)\n                return;\n            context.report({\n                message: 'Use one of the asset_url filters to serve assets for better performance.',\n                startIndex: urlAttribute.position.start,\n                endIndex: urlAttribute.position.end,\n            });\n        }\n        function checkLiquidFilter(node, ancestors) {\n            const tagName = node.name;\n            if (!TAGNAMES.includes(tagName))\n                return;\n            const parentNode = (0, utils_2.last)(ancestors);\n            if (!parentNode || !(0, utils_1.isNodeOfType)(types_1.LiquidHtmlNodeTypes.LiquidVariable, parentNode))\n                return;\n            const hasAsset = parentNode.filters.some((filter) => DEPRECATED.includes(filter.name) || NON_DEPRECATED.includes(filter.name));\n            if (hasAsset)\n                return;\n            const urlNode = parentNode.expression;\n            if (urlNode.type === types_1.LiquidHtmlNodeTypes.String && !isUrlHostedbyShopify(urlNode.value)) {\n                context.report({\n                    message: 'Asset should be served by the Shopify CDN for better performance.',\n                    startIndex: urlNode.position.start,\n                    endIndex: urlNode.position.end,\n                });\n            }\n            context.report({\n                message: `Use one of the asset_url filters to serve assets for better performance.`,\n                startIndex: parentNode.expression.position.start,\n                endIndex: node.position.end,\n            });\n        }\n        return {\n            async HtmlVoidElement(node) {\n                checkHtmlNode(node);\n            },\n            async HtmlRawNode(node) {\n                checkHtmlNode(node);\n            },\n            async LiquidFilter(node, ancestors) {\n                checkLiquidFilter(node, ancestors);\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequiredLayoutThemeObject = void 0;\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../utils\");\nexports.RequiredLayoutThemeObject = {\n    meta: {\n        code: 'RequiredLayoutThemeObject',\n        name: 'Prevent missing required objects in theme.liquid',\n        docs: {\n            description: 'This check prevents missing {{ content_for_header }} and {{ content_for_layout }} objects in layout/theme.liquid.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/required-layout-theme-object',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [types_1.ConfigTarget.All, types_1.ConfigTarget.Recommended],\n    },\n    create(context) {\n        if (context.toRelativePath(context.file.uri) !== 'layout/theme.liquid') {\n            return {};\n        }\n        const requiredObjects = ['content_for_header', 'content_for_layout'];\n        const foundObjects = new Set();\n        let headTag;\n        let bodyTag;\n        function checkVariableUsage(node) {\n            if (node.name && requiredObjects.includes(node.name)) {\n                foundObjects.add(node.name);\n            }\n        }\n        return {\n            async VariableLookup(node) {\n                checkVariableUsage(node);\n            },\n            async HtmlElement(node) {\n                if ((0, utils_1.isHtmlTag)(node, 'head')) {\n                    headTag = node;\n                }\n                else if ((0, utils_1.isHtmlTag)(node, 'body')) {\n                    bodyTag = node;\n                }\n            },\n            async onCodePathEnd() {\n                var _a, _b;\n                for (const requiredObject of requiredObjects) {\n                    if (!foundObjects.has(requiredObject)) {\n                        const message = `The required object '{{ ${requiredObject} }}' is missing in layout/theme.liquid`;\n                        const insertionNode = requiredObject === 'content_for_header' ? headTag : bodyTag;\n                        const fixInsertPosition = insertionNode === null || insertionNode === void 0 ? void 0 : insertionNode.blockEndPosition.start;\n                        context.report({\n                            message,\n                            startIndex: (_a = insertionNode === null || insertionNode === void 0 ? void 0 : insertionNode.position.start) !== null && _a !== void 0 ? _a : 0,\n                            endIndex: (_b = insertionNode === null || insertionNode === void 0 ? void 0 : insertionNode.position.end) !== null && _b !== void 0 ? _b : 0,\n                            fix: fixInsertPosition !== undefined\n                                ? (corrector) => corrector.insert(fixInsertPosition, `{{ ${requiredObject} }}`)\n                                : undefined,\n                        });\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaPresetsBlockOrder = void 0;\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst types_1 = require(\"../../types\");\nexports.SchemaPresetsBlockOrder = {\n    meta: {\n        code: 'SchemaPresetsBlockOrder',\n        name: 'Gives recommendations and validations for block_order',\n        docs: {\n            description: 'Gives recommendations and validations for block_order for preset blocks as a hash.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/schema-presets-block-order',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json') {\n                    return;\n                }\n                const offset = node.blockStartPosition.end;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                const presets = validSchema.presets;\n                if (!presets)\n                    return;\n                presets.forEach((preset, index) => {\n                    if ('blocks' in preset && preset.blocks) {\n                        checkBlockOrder(preset, context, offset, ast, ['presets', String(index)]);\n                    }\n                });\n            },\n        };\n    },\n};\nfunction checkBlockOrder(node, context, offset, ast, ast_path) {\n    if ('blocks' in node && typeof node.blocks == 'object' && node.blocks) {\n        const blockOrder = 'block_order' in node ? node.block_order : undefined;\n        // check 1: is block_order missing?\n        if (!blockOrder) {\n            if (shouldHaveBlockOrder(node)) {\n                reportWarning(context, offset, ast, ast_path, `block_order is missing`, false);\n            }\n        }\n        // check 2: are items in block_order present in blocks?\n        blockOrder === null || blockOrder === void 0 ? void 0 : blockOrder.forEach((block_id, index) => {\n            if (!node.blocks || (!Array.isArray(node.blocks) && !node.blocks[block_id])) {\n                const warning_ast_path = ast_path.concat(['block_order']).concat([String(index)]);\n                reportWarning(context, offset, ast, warning_ast_path, `block '${block_id}' is missing from 'blocks'`);\n            }\n        });\n        // check 3: are items in blocks correctly in block_order?\n        for (const [block_id, block] of Object.entries(node.blocks)) {\n            if (block.static) {\n                // if static block is in the block_order, that's an error\n                if (Array.isArray(blockOrder) && blockOrder.includes(block_id)) {\n                    const warning_ast_path = ast_path.concat(['block_order']);\n                    reportWarning(context, offset, ast, warning_ast_path, `static block '${block_id}' cannot be in the block_order`);\n                }\n            }\n            else {\n                // if non-static block is not in the block_order, that's a potential mistake\n                if (Array.isArray(blockOrder) && !blockOrder.includes(block_id)) {\n                    const warning_ast_path = ast_path.concat(['block_order']);\n                    reportWarning(context, offset, ast, warning_ast_path, `block '${block_id}' is missing from the block_order`);\n                }\n            }\n            //recursive check for nested blocks\n            if (block.blocks) {\n                ast_path.push('blocks', block_id); // so we'll get ['presets', 0, 'blocks', 'my_block1'] for example to do nodeAtPath(schema.ast, ast_path)\n                checkBlockOrder(block, context, offset, ast, ast_path);\n            }\n        }\n    }\n}\nfunction shouldHaveBlockOrder(node) {\n    if ('blocks' in node &&\n        typeof node.blocks === 'object' &&\n        node.blocks !== null &&\n        !Array.isArray(node.blocks)) {\n        return Object.entries(node.blocks).some(([_blockId, block]) => {\n            // If static is undefined or false, it's considered non-static\n            return block.static !== true;\n        });\n    }\n    return false;\n}\nfunction reportWarning(context, offset, ast, ast_path, message, fullHighlight = true) {\n    const node = (0, json_1.nodeAtPath)(ast, ast_path);\n    const startIndex = fullHighlight ? offset + (0, json_1.getLocStart)(node) : offset + (0, json_1.getLocEnd)(node) - 1; // start to finish of the node or last char of the node\n    const endIndex = offset + (0, json_1.getLocEnd)(node);\n    context.report({\n        message: message,\n        startIndex,\n        endIndex,\n    });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaPresetsStaticBlocks = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst types_1 = require(\"../../types\");\nconst markup_1 = require(\"../../utils/markup\");\nexports.SchemaPresetsStaticBlocks = {\n    meta: {\n        code: 'SchemaPresetsStaticBlocks',\n        name: 'Ensure the preset static blocks are used in the liquid',\n        docs: {\n            description: 'Warns if a preset static block does not have a corresponding content_for \"block\" tag.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/schema-presets-static-blocks',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        let contentForBlockList = [];\n        let staticBlockList = [];\n        let offset = 0;\n        function checkStaticBlocks() {\n            staticBlockList.forEach((block) => {\n                if (!contentForBlockList.some((contentBlock) => contentBlock.id === block.id && contentBlock.type === block.type)) {\n                    context.report({\n                        message: `Static block ${block.id} is missing a corresponding content_for \"block\" tag.`,\n                        startIndex: block.startIndex,\n                        endIndex: block.endIndex,\n                    });\n                }\n            });\n        }\n        return {\n            async LiquidTag(node) {\n                var _a, _b;\n                // Early return if not a content_for block tag\n                if (node.name !== liquid_html_parser_1.NamedTags.content_for || !(0, markup_1.isContentForBlock)(node.markup))\n                    return;\n                // Extract id and type from markup args\n                const idValue = (_a = node.markup.args.find((arg) => arg.name === 'id')) === null || _a === void 0 ? void 0 : _a.value;\n                const typeArg = (_b = node.markup.args.find((arg) => arg.name === 'type')) === null || _b === void 0 ? void 0 : _b.value;\n                if (!typeArg || typeArg.type !== liquid_html_parser_1.NodeTypes.String) {\n                    return; // covered by VariableContentForArguments\n                }\n                const typeValue = typeArg.value;\n                // Add to list if valid string id\n                if ((idValue === null || idValue === void 0 ? void 0 : idValue.type) === liquid_html_parser_1.NodeTypes.String) {\n                    contentForBlockList.push({ id: idValue.value, type: typeValue });\n                }\n            },\n            async LiquidRawTag(node) {\n                // when we get the schema tag, get the list of static blocks from each preset\n                if (node.name === 'schema' && node.body.kind === 'json') {\n                    offset = node.blockStartPosition.end;\n                    const schema = await (0, to_schema_1.getSchema)(context);\n                    const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                    if (!validSchema || validSchema instanceof Error)\n                        return;\n                    if (!ast || ast instanceof Error)\n                        return;\n                    const presets = validSchema.presets;\n                    if (!presets)\n                        return;\n                    presets.forEach((preset, index) => {\n                        if ('blocks' in preset && preset.blocks) {\n                            let ast_path = ['presets', index, 'blocks'];\n                            // blocks as an array\n                            if (Array.isArray(preset.blocks)) {\n                                preset.blocks.forEach((block, block_index) => {\n                                    if (block.static === true && block.id) {\n                                        let node = (0, json_1.nodeAtPath)(ast, ast_path.concat([block_index]));\n                                        staticBlockList.push({\n                                            id: block.id,\n                                            type: block.type,\n                                            startIndex: offset + (0, json_1.getLocStart)(node),\n                                            endIndex: offset + (0, json_1.getLocEnd)(node),\n                                        });\n                                    }\n                                });\n                            }\n                            // blocks as an object\n                            else if (typeof preset.blocks === 'object') {\n                                Object.entries(preset.blocks).forEach(([block_id, block]) => {\n                                    if (block.static === true) {\n                                        let node = (0, json_1.nodeAtPath)(ast, ast_path.concat(block_id));\n                                        staticBlockList.push({\n                                            id: block_id,\n                                            type: block.type,\n                                            startIndex: offset + (0, json_1.getLocStart)(node),\n                                            endIndex: offset + (0, json_1.getLocEnd)(node),\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n            },\n            async onCodePathEnd() {\n                checkStaticBlocks();\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TranslationKeyExists = void 0;\nconst json_1 = require(\"../../json\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nfunction keyExists(key, pointer) {\n    for (const token of key.split('.')) {\n        if (typeof pointer !== 'object') {\n            return false;\n        }\n        if (!pointer.hasOwnProperty(token)) {\n            return false;\n        }\n        pointer = pointer[token];\n    }\n    return true;\n}\nexports.TranslationKeyExists = {\n    meta: {\n        code: 'TranslationKeyExists',\n        name: 'Reports missing translation keys',\n        docs: {\n            description: 'Reports missing translation keys',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/translation-key-exists',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const nodes = [];\n        let schemaLocales;\n        return {\n            async LiquidVariable(node) {\n                if (node.expression.type !== 'String') {\n                    return;\n                }\n                if (!node.filters.some(({ name }) => ['t', 'translate'].includes(name))) {\n                    return;\n                }\n                nodes.push({\n                    translationKey: node.expression.value,\n                    startIndex: node.expression.position.start,\n                    endIndex: node.expression.position.end,\n                });\n            },\n            async LiquidRawTag(node) {\n                var _a;\n                if (node.name !== 'schema' || node.body.kind !== 'json') {\n                    return;\n                }\n                const defaultLocale = await context.getDefaultLocale();\n                const schema = (0, json_1.parseJSON)(node.body.value);\n                if ((0, utils_1.isError)(schema) && schema instanceof SyntaxError)\n                    return;\n                schemaLocales = (_a = schema.locales) === null || _a === void 0 ? void 0 : _a[defaultLocale];\n            },\n            async onCodePathEnd() {\n                var _a;\n                const defaultTranslations = await context.getDefaultTranslations();\n                const defaultLocale = await context.getDefaultLocale();\n                const systemTranslations = await ((_a = context.themeDocset) === null || _a === void 0 ? void 0 : _a.systemTranslations());\n                const systemTranslationsKeys = Object.keys(systemTranslations !== null && systemTranslations !== void 0 ? systemTranslations : {});\n                if (!defaultTranslations && systemTranslationsKeys.length === 0)\n                    return;\n                nodes.forEach(({ translationKey, startIndex, endIndex }) => {\n                    if (keyExists(translationKey, defaultTranslations) ||\n                        keyExists(translationKey, schemaLocales) ||\n                        systemTranslationsKeys.includes(translationKey)) {\n                        return;\n                    }\n                    let message = `'${translationKey}' does not have a matching entry in 'locales/${defaultLocale}.default.json'`;\n                    if (schemaLocales) {\n                        message += ` or '${context.toRelativePath(context.file.uri)}'`;\n                    }\n                    context.report({\n                        message,\n                        startIndex,\n                        endIndex,\n                    });\n                });\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnclosedHTMLElement = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst utils_2 = require(\"../utils\");\nexports.UnclosedHTMLElement = {\n    meta: {\n        code: 'UnclosedHTMLElement',\n        aliases: ['UnclosedHTMLElement'],\n        name: 'Unclosed HTML Element',\n        docs: {\n            description: 'Warns you of unbalanced HTML tags in branching code',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/unclosed-html-element',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        /**\n         * Algorithm explanation:\n         *\n         * When we have unclosed nodes, we have something a bit like this:\n         *\n         * <grandparent>\n         *   {% if condition %}\n         *     <unclosed1>\n         *   {% else %}\n         *     <unclosed2>\n         *   {% endif %}\n         *\n         *   {% if condition %}\n         *     </unclosed1>\n         *   {% else %}\n         *     </unclosed2>\n         *   {% endif %}\n         * </grandparent>\n         *\n         * When things are proper, we can see the following:\n         *   - unclosed nodes must have the same parent condition,\n         *   - unclosed nodes must have the same grandparent node.\n         *\n         * So what we can do is create stacks of unclosed nodes grouped by\n         *   - parent condition, and\n         *   - grandparent node.\n         *\n         * Thus we have\n         *   - the stackByGrandparent Map which is the index by grandparent node\n         *   - the Stacks object which is a by-condition-identifier index of open/close nodes\n         *\n         * When we're done with the file, we verify that the stacks push and\n         * pop to the empty stack. When it isn't, then we have a problem to\n         * report.\n         */\n        const stacksByGrandparent = new Map();\n        return {\n            async HtmlElement(node, ancestors) {\n                if (isClosed(node))\n                    return;\n                const [branch, index] = (0, utils_1.findLastAndIndex)(ancestors, utils_2.isLiquidBranch);\n                if (!branch)\n                    return;\n                const parent = ancestors[index - 1];\n                const grandparent = ancestors[index - 2];\n                if (!parent || !grandparent || parent.type !== liquid_html_parser_1.NodeTypes.LiquidTag)\n                    return;\n                if (!stacksByGrandparent.has(grandparent)) {\n                    stacksByGrandparent.set(grandparent, {\n                        open: new Map(),\n                        close: new Map(),\n                        identifiers: new Set(),\n                    });\n                }\n                const stacks = stacksByGrandparent.get(grandparent);\n                const identifier = getConditionIdentifier(branch, parent);\n                stacks.identifiers.add(identifier);\n                if (!stacks.open.has(identifier))\n                    stacks.open.set(identifier, []);\n                stacks.open.get(identifier).push(node);\n            },\n            async HtmlDanglingMarkerClose(node, ancestors) {\n                const [branch, index] = (0, utils_1.findLastAndIndex)(ancestors, utils_2.isLiquidBranch);\n                if (!branch)\n                    return;\n                const parent = ancestors[index - 1];\n                const grandparent = ancestors[index - 2];\n                if (!parent || !grandparent || parent.type !== liquid_html_parser_1.NodeTypes.LiquidTag)\n                    return;\n                if (!stacksByGrandparent.has(grandparent)) {\n                    stacksByGrandparent.set(grandparent, {\n                        open: new Map(),\n                        close: new Map(),\n                        identifiers: new Set(),\n                    });\n                }\n                const stacks = stacksByGrandparent.get(grandparent);\n                const identifier = getConditionIdentifier(branch, parent);\n                stacks.identifiers.add(identifier);\n                if (!stacks.close.has(identifier))\n                    stacks.close.set(identifier, []);\n                stacks.close.get(identifier).push(node);\n            },\n            async onCodePathEnd() {\n                var _a, _b;\n                for (const [grandparent, stacks] of stacksByGrandparent) {\n                    for (const identifier of stacks.identifiers) {\n                        const openNodes = (_a = stacks.open.get(identifier)) !== null && _a !== void 0 ? _a : [];\n                        const closeNodes = (_b = stacks.close.get(identifier)) !== null && _b !== void 0 ? _b : [];\n                        // We sort them in the order they are found in the file because we\n                        // otherwise don't have an order guarantee with everything running\n                        // async.\n                        const nodes = []\n                            .concat(openNodes, closeNodes)\n                            .sort((a, b) => a.position.start - b.position.start);\n                        // If everything is balanced,\n                        //   Then we're going to push on open and pop when the close match.\n                        // If a close doesn't match,\n                        //   Then we'll push it onto the stack and everything after won't match.\n                        const stack = [];\n                        for (const node of nodes) {\n                            if (node.type === liquid_html_parser_1.NodeTypes.HtmlElement) {\n                                stack.push(node);\n                            }\n                            else if (stack.length > 0 &&\n                                getName(node) === getName(stack.at(-1)) &&\n                                stack.at(-1).type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n                                node.type === liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose) {\n                                stack.pop();\n                            }\n                            else {\n                                stack.push(node);\n                            }\n                        }\n                        // At the end, whatever is left in the stack is a reported offense.\n                        for (const node of stack) {\n                            if (node.type === liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose) {\n                                context.report({\n                                    message: `Closing tag does not have a matching opening tag for condition \\`${identifier}\\` in ${grandparent.type} '${getName(grandparent)}'`,\n                                    startIndex: node.position.start,\n                                    endIndex: node.position.end,\n                                });\n                            }\n                            else {\n                                context.report({\n                                    message: `Opening tag does not have a matching closing tag for condition \\`${identifier}\\` in ${grandparent.type} '${getName(grandparent)}'`,\n                                    startIndex: node.blockStartPosition.start,\n                                    endIndex: node.blockStartPosition.end,\n                                });\n                            }\n                        }\n                    }\n                }\n            },\n        };\n    },\n};\nfunction isClosed(node) {\n    return node.blockEndPosition.start !== node.blockEndPosition.end;\n}\nfunction getConditionIdentifier(branch, parent) {\n    if (branch.name === null) {\n        switch (parent.name) {\n            case liquid_html_parser_1.NamedTags.if:\n                return getConditionIdentifierForMarkup(parent.markup);\n            case liquid_html_parser_1.NamedTags.unless:\n                return negateIdentifier(getConditionIdentifierForMarkup(parent.markup));\n            default:\n                return '??';\n        }\n    }\n    switch (branch.name) {\n        case 'else':\n            switch (parent.name) {\n                case liquid_html_parser_1.NamedTags.if:\n                    return negateIdentifier(getConditionIdentifierForMarkup(parent.markup));\n                case liquid_html_parser_1.NamedTags.unless:\n                    return getConditionIdentifierForMarkup(parent.markup);\n                case liquid_html_parser_1.NamedTags.case:\n                    return `case ${getConditionIdentifierForMarkup(parent.markup)}`;\n                default:\n                    return '??';\n            }\n        case liquid_html_parser_1.NamedTags.elsif:\n            return getConditionIdentifierForMarkup(branch.markup);\n        case liquid_html_parser_1.NamedTags.when:\n            if (parent.name !== liquid_html_parser_1.NamedTags.case)\n                return '??';\n            return `case ${getConditionIdentifierForMarkup(parent.markup)} == ${getConditionIdentifierForWhenMarkup(branch.markup)}`;\n        default:\n            return '??';\n    }\n}\nfunction getConditionIdentifierForWhenMarkup(conditions) {\n    if (typeof conditions === 'string')\n        return conditions;\n    return conditions.map(getConditionIdentifierForMarkup).join(' or ');\n}\nfunction getConditionIdentifierForMarkup(condition) {\n    var _a;\n    if (typeof condition === 'string')\n        return condition;\n    switch (condition.type) {\n        case liquid_html_parser_1.NodeTypes.String:\n            return `'` + condition.value + `'`;\n        case liquid_html_parser_1.NodeTypes.LiquidLiteral:\n            if (condition.value === null)\n                return 'null';\n            return condition.value.toString();\n        case liquid_html_parser_1.NodeTypes.Number:\n            return condition.value;\n        case liquid_html_parser_1.NodeTypes.VariableLookup:\n            return `${(_a = condition.name) !== null && _a !== void 0 ? _a : ''}${condition.lookups.map((expression) => `[${getConditionIdentifierForMarkup(expression)}]`)}`;\n        case liquid_html_parser_1.NodeTypes.Range:\n            return `(${getConditionIdentifierForMarkup(condition.start)}..${getConditionIdentifierForMarkup(condition.end)})`;\n        case liquid_html_parser_1.NodeTypes.Comparison:\n            return [\n                getConditionIdentifierForMarkup(condition.left),\n                condition.comparator,\n                getConditionIdentifierForMarkup(condition.right),\n            ].join(' ');\n        case liquid_html_parser_1.NodeTypes.LogicalExpression:\n            return [\n                getConditionIdentifierForMarkup(condition.left),\n                condition.relation,\n                getConditionIdentifierForMarkup(condition.right),\n            ].join(' ');\n        default: {\n            return (0, utils_1.assertNever)(condition);\n        }\n    }\n}\nfunction negateIdentifier(conditionIdentifier) {\n    return conditionIdentifier.startsWith('-')\n        ? conditionIdentifier.slice(1)\n        : `-${conditionIdentifier}`;\n}\nfunction getName(node) {\n    if (node.type === liquid_html_parser_1.NodeTypes.HtmlElement || node.type === liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose) {\n        if (node.name.length === 0)\n            return '';\n        return node.source.slice(node.name.at(0).position.start, node.name.at(-1).position.end);\n    }\n    else if (node.type === liquid_html_parser_1.NodeTypes.LiquidTag) {\n        return node.name;\n    }\n    else {\n        return node.type;\n    }\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UndefinedObject = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nexports.UndefinedObject = {\n    meta: {\n        code: 'UndefinedObject',\n        name: 'Undefined Object',\n        docs: {\n            description: 'This check exists to identify references to undefined Liquid objects.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/undefined-object',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        /**\n         * At present, snippet assets are not supported due to the inability of this\n         * check to handle objects defined in other assets.\n         */\n        const relativePath = context.toRelativePath(context.file.uri);\n        if (relativePath.startsWith('snippets/')) {\n            return {};\n        }\n        /**\n         * Skip this check when definitions for global objects are unavailable.\n         */\n        if (!context.themeDocset) {\n            return {};\n        }\n        const themeDocset = context.themeDocset;\n        const variableScopes = new Map();\n        const variables = [];\n        function indexVariableScope(variableName, scope) {\n            var _a;\n            if (!variableName)\n                return;\n            const indexedScope = (_a = variableScopes.get(variableName)) !== null && _a !== void 0 ? _a : [];\n            variableScopes.set(variableName, indexedScope.concat(scope));\n        }\n        return {\n            async LiquidTag(node) {\n                var _a, _b, _c, _d;\n                if (isLiquidTagAssign(node)) {\n                    indexVariableScope(node.markup.name, {\n                        start: node.blockStartPosition.end,\n                    });\n                }\n                if (isLiquidTagCapture(node)) {\n                    indexVariableScope(node.markup.name, {\n                        start: (_a = node.blockEndPosition) === null || _a === void 0 ? void 0 : _a.end,\n                    });\n                }\n                /**\n                 * {% form 'cart', cart %}\n                 *   {{ form }}\n                 * {% endform %}\n                 */\n                if (['form', 'paginate'].includes(node.name)) {\n                    indexVariableScope(node.name, {\n                        start: node.blockStartPosition.end,\n                        end: (_b = node.blockEndPosition) === null || _b === void 0 ? void 0 : _b.start,\n                    });\n                }\n                /* {% layout none %} */\n                if (node.name === 'layout') {\n                    indexVariableScope('none', {\n                        start: node.position.start,\n                        end: node.position.end,\n                    });\n                }\n                /* {% increment var %} */\n                if ((isLiquidTagIncrement(node) || isLiquidTagDecrement(node)) &&\n                    node.markup.name !== null) {\n                    indexVariableScope(node.markup.name, {\n                        start: node.position.start,\n                    });\n                }\n                /**\n                 * {% for x in y %}\n                 *   {{ forloop }}\n                 *   {{ x }}\n                 * {% endfor %}\n                 */\n                if (isLiquidForTag(node) || isLiquidTableRowTag(node)) {\n                    indexVariableScope(node.markup.variableName, {\n                        start: node.blockStartPosition.end,\n                        end: (_c = node.blockEndPosition) === null || _c === void 0 ? void 0 : _c.start,\n                    });\n                    indexVariableScope(node.name === 'for' ? 'forloop' : 'tablerowloop', {\n                        start: node.blockStartPosition.end,\n                        end: (_d = node.blockEndPosition) === null || _d === void 0 ? void 0 : _d.start,\n                    });\n                }\n            },\n            async VariableLookup(node, ancestors) {\n                const parent = (0, utils_1.last)(ancestors);\n                if (isLiquidTag(parent) && isLiquidTagCapture(parent))\n                    return;\n                variables.push(node);\n            },\n            async onCodePathEnd() {\n                const objects = await globalObjects(themeDocset, relativePath);\n                objects.forEach((obj) => variableScopes.set(obj.name, []));\n                variables.forEach((variable) => {\n                    if (!variable.name)\n                        return;\n                    const isVariableDefined = isDefined(variable.name, variable.position, variableScopes);\n                    if (isVariableDefined)\n                        return;\n                    context.report({\n                        message: `Unknown object '${variable.name}' used.`,\n                        startIndex: variable.position.start,\n                        endIndex: variable.position.end,\n                    });\n                });\n            },\n        };\n    },\n};\nasync function globalObjects(themeDocset, relativePath) {\n    const objects = await themeDocset.objects();\n    const contextualObjects = getContextualObjects(relativePath);\n    const globalObjects = objects.filter(({ access, name }) => {\n        return (contextualObjects.includes(name) ||\n            !access ||\n            access.global === true ||\n            access.template.length > 0);\n    });\n    return globalObjects;\n}\nfunction getContextualObjects(relativePath) {\n    if (relativePath.startsWith('layout/checkout.liquid')) {\n        return [\n            'locale',\n            'direction',\n            'skip_to_content_link',\n            'checkout_html_classes',\n            'checkout_stylesheets',\n            'checkout_scripts',\n            'content_for_logo',\n            'breadcrumb',\n            'order_summary_toggle',\n            'content_for_order_summary',\n            'alternative_payment_methods',\n            'content_for_footer',\n            'tracking_code',\n        ];\n    }\n    if (relativePath.startsWith('sections/')) {\n        return ['section', 'predictive_search', 'recommendations', 'comment'];\n    }\n    if (relativePath.startsWith('blocks/')) {\n        return ['app', 'section', 'block'];\n    }\n    if (relativePath.startsWith('snippets/')) {\n        return ['app'];\n    }\n    return [];\n}\nfunction isDefined(variableName, variablePosition, scopedVariables) {\n    const scopes = scopedVariables.get(variableName);\n    /**\n     * If there's no scope, the variable is not defined.\n     */\n    if (!scopes)\n        return false;\n    /**\n     * If there are zero scopes, the variable is globally defined.\n     */\n    if (scopes.length === 0)\n        return true;\n    /**\n     * Checks if a variable is defined within any of the scopes.\n     */\n    return scopes.some((scope) => isDefinedInScope(variablePosition, scope));\n}\nfunction isDefinedInScope(variablePosition, scope) {\n    const start = variablePosition.start;\n    const isVariableAfterScopeStart = !scope.start || start > scope.start;\n    const isVariableBeforeScopeEnd = !scope.end || start < scope.end;\n    return isVariableAfterScopeStart && isVariableBeforeScopeEnd;\n}\nfunction isLiquidTag(node) {\n    return (node === null || node === void 0 ? void 0 : node.type) === liquid_html_parser_1.NodeTypes.LiquidTag;\n}\nfunction isLiquidTagCapture(node) {\n    return node.name === liquid_html_parser_1.NamedTags.capture;\n}\nfunction isLiquidTagAssign(node) {\n    return node.name === liquid_html_parser_1.NamedTags.assign && typeof node.markup !== 'string';\n}\nfunction isLiquidForTag(node) {\n    return node.name === liquid_html_parser_1.NamedTags.for && typeof node.markup !== 'string';\n}\nfunction isLiquidTableRowTag(node) {\n    return node.name === liquid_html_parser_1.NamedTags.tablerow && typeof node.markup !== 'string';\n}\nfunction isLiquidTagIncrement(node) {\n    return node.name === liquid_html_parser_1.NamedTags.increment && typeof node.markup !== 'string';\n}\nfunction isLiquidTagDecrement(node) {\n    return node.name === liquid_html_parser_1.NamedTags.decrement && typeof node.markup !== 'string';\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueSettingIds = void 0;\nconst types_1 = require(\"../../types\");\nexports.UniqueSettingIds = {\n    meta: {\n        code: 'UniqueSettingId',\n        name: 'Prevent duplicate Ids in setting_schema',\n        docs: {\n            description: 'This check is aimed at eliminating duplicate Ids in settings_schema.json',\n            recommended: true,\n            // url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-schema',\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async onCodePathEnd(file) {\n                if ((0, types_1.isArrayNode)(file.ast)) {\n                    const settingIds = [];\n                    /* Find and loop through all of our nodes that have an id value and find their key value */\n                    for (const child of file.ast.children) {\n                        if ((0, types_1.isObjectNode)(child) && child.children) {\n                            const settingsNode = child.children.find((node) => node.key.value === 'settings');\n                            if (settingsNode && settingsNode.value && (0, types_1.isArrayNode)(settingsNode.value)) {\n                                for (const setting of settingsNode.value.children) {\n                                    if ((0, types_1.isObjectNode)(setting) && setting.children) {\n                                        const idNode = setting.children.find((node) => node.key.value === 'id');\n                                        if ((0, types_1.isPropertyNode)(idNode)) {\n                                            settingIds.push(idNode);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    /* Check for dupes */\n                    const idMap = new Map();\n                    for (const node of settingIds) {\n                        if ((0, types_1.isLiteralNode)(node.value)) {\n                            const id = node.value.value;\n                            if (typeof id === 'string') {\n                                if (!idMap.has(id)) {\n                                    idMap.set(id, []);\n                                }\n                                idMap.get(id).push(node);\n                            }\n                        }\n                    }\n                    const duplicates = Array.from(idMap.entries()).filter(([_, nodes]) => nodes.length > 1);\n                    if (duplicates.length > 0) {\n                        for (const [id, nodes] of duplicates) {\n                            const lastNodeFound = nodes[nodes.length - 1];\n                            context.report({\n                                message: `Duplicate setting id found: \"${id}\"`,\n                                startIndex: lastNodeFound.loc.start.offset,\n                                endIndex: lastNodeFound.loc.end.offset,\n                            });\n                        }\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueStaticBlockId = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst markup_1 = require(\"../../utils/markup\");\nexports.UniqueStaticBlockId = {\n    meta: {\n        code: 'UniqueStaticBlockId',\n        name: 'Prevent use of duplicated ids for blocks rendered statically',\n        docs: {\n            description: 'This check is aimed at preventing the use of duplicated ids for blocks rendered statically.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/unique-static-block-id',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const usedIds = new Set();\n        const idRegex = /id:\\s*[\"'](\\S+)[\"']/;\n        return {\n            async LiquidTag(node) {\n                if (node.name !== liquid_html_parser_1.NamedTags.content_for) {\n                    return;\n                }\n                if (!(0, markup_1.isContentForBlock)(node.markup)) {\n                    return;\n                }\n                const idNode = node.markup.args.find((arg) => arg.name === 'id');\n                if (!idNode) {\n                    return; // covered by VariableContentForArguments\n                }\n                const idValueNode = idNode.value;\n                if (idValueNode.type !== liquid_html_parser_1.NodeTypes.String) {\n                    return; // covered by VariableContentForArguments\n                }\n                const id = idValueNode.value;\n                if (usedIds.has(id)) {\n                    context.report({\n                        message: `The id '${id}' is already being used by another static block`,\n                        startIndex: idValueNode.position.start,\n                        endIndex: idValueNode.position.end,\n                        suggest: [],\n                    });\n                }\n                else {\n                    usedIds.add(id);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnknownFilter = void 0;\n// src/checks/unknown-filter/index.ts\nconst types_1 = require(\"../../types\");\nexports.UnknownFilter = {\n    meta: {\n        code: 'UnknownFilter',\n        name: 'Prevent use of unknown filters',\n        docs: {\n            description: 'This check is aimed at preventing the use of unknown filters.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/unknown-filter',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        if (!context.themeDocset) {\n            return {};\n        }\n        return {\n            async LiquidFilter(node) {\n                const knownFilters = await context.themeDocset.filters();\n                if (!knownFilters.some((filter) => filter.name === node.name)) {\n                    context.report({\n                        message: `Unknown filter '${node.name}' used.`,\n                        startIndex: node.position.start + 1,\n                        endIndex: node.position.end,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnusedAssign = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nexports.UnusedAssign = {\n    meta: {\n        code: 'UnusedAssign',\n        name: 'Prevent unused assigns',\n        docs: {\n            description: 'This check exists to prevent bloat in themes by surfacing variable definitions that are not used.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/unused-assign',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const assignedVariables = new Map();\n        const usedVariables = new Set();\n        function checkVariableUsage(node) {\n            if (node.type === liquid_html_parser_1.NodeTypes.VariableLookup) {\n                usedVariables.add(node.name);\n            }\n        }\n        return {\n            async LiquidTag(node) {\n                if (isLiquidTagAssign(node)) {\n                    assignedVariables.set(node.markup.name, node);\n                }\n                else if (isLiquidTagCapture(node) && node.markup.name) {\n                    assignedVariables.set(node.markup.name, node);\n                }\n            },\n            async VariableLookup(node, ancestors) {\n                const parentNode = ancestors.at(-1);\n                if (parentNode && isLiquidTagCapture(parentNode)) {\n                    return;\n                }\n                checkVariableUsage(node);\n            },\n            async onCodePathEnd() {\n                for (const [variable, node] of assignedVariables.entries()) {\n                    if (!usedVariables.has(variable) && !variable.startsWith('_')) {\n                        context.report({\n                            message: `The variable '${variable}' is assigned but not used`,\n                            startIndex: node.position.start,\n                            endIndex: node.position.end,\n                            suggest: [\n                                {\n                                    message: `Remove the unused variable '${variable}'`,\n                                    fix: (corrector) => corrector.remove(node.position.start, node.position.end),\n                                },\n                            ],\n                        });\n                    }\n                }\n            },\n        };\n    },\n};\nfunction isLiquidTagAssign(node) {\n    return node.name === 'assign' && typeof node.markup !== 'string';\n}\nfunction isLiquidTagCapture(node) {\n    return (node.type == liquid_html_parser_1.NodeTypes.LiquidTag && node.name === 'capture' && typeof node.markup !== 'string');\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLiquidString = exports.hasAttributeValueOf = exports.valueIncludes = exports.isValuedHtmlAttribute = exports.isHtmlAttribute = exports.isAttr = exports.isHtmlTag = exports.isLiquidBranch = exports.isNodeOfType = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nfunction isNodeOfType(type, node) {\n    return (node === null || node === void 0 ? void 0 : node.type) === type;\n}\nexports.isNodeOfType = isNodeOfType;\nfunction isLiquidBranch(node) {\n    return isNodeOfType(liquid_html_parser_1.NodeTypes.LiquidBranch, node);\n}\nexports.isLiquidBranch = isLiquidBranch;\nfunction isHtmlTag(node, name) {\n    return (node.name.length === 1 &&\n        node.name[0].type === liquid_html_parser_1.NodeTypes.TextNode &&\n        node.name[0].value === name &&\n        !!node.blockEndPosition);\n}\nexports.isHtmlTag = isHtmlTag;\nfunction isAttr(attr, name) {\n    return (attr.name.length === 1 &&\n        isNodeOfType(liquid_html_parser_1.NodeTypes.TextNode, attr.name[0]) &&\n        attr.name[0].value === name);\n}\nexports.isAttr = isAttr;\nfunction isHtmlAttribute(attr) {\n    return [\n        liquid_html_parser_1.NodeTypes.AttrUnquoted,\n        liquid_html_parser_1.NodeTypes.AttrDoubleQuoted,\n        liquid_html_parser_1.NodeTypes.AttrSingleQuoted,\n        liquid_html_parser_1.NodeTypes.AttrEmpty,\n    ].some((type) => isNodeOfType(type, attr));\n}\nexports.isHtmlAttribute = isHtmlAttribute;\nfunction isValuedHtmlAttribute(attr) {\n    return [liquid_html_parser_1.NodeTypes.AttrUnquoted, liquid_html_parser_1.NodeTypes.AttrDoubleQuoted, liquid_html_parser_1.NodeTypes.AttrSingleQuoted].some((type) => isNodeOfType(type, attr));\n}\nexports.isValuedHtmlAttribute = isValuedHtmlAttribute;\nfunction valueIncludes(attr, word) {\n    const regex = new RegExp(`(^|\\\\s)${word}(\\\\s|$)`, 'g');\n    return attr.value\n        .filter((node) => isNodeOfType(liquid_html_parser_1.NodeTypes.TextNode, node))\n        .some((valueNode) => regex.test(valueNode.value));\n}\nexports.valueIncludes = valueIncludes;\nfunction hasAttributeValueOf(attr, value) {\n    return (attr.value.length === 1 &&\n        isNodeOfType(liquid_html_parser_1.NodeTypes.TextNode, attr.value[0]) &&\n        attr.value[0].value === value);\n}\nexports.hasAttributeValueOf = hasAttributeValueOf;\nfunction isLiquidString(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.String;\n}\nexports.isLiquidString = isLiquidString;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidBlockTarget = void 0;\nconst types_1 = require(\"../../types\");\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst utils_1 = require(\"../../utils\");\nexports.ValidBlockTarget = {\n    meta: {\n        code: 'ValidBlockTarget',\n        name: 'Validate block targeting in presets',\n        docs: {\n            description: 'Ensures block types only reference valid block types and respect parent-child relationships',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-block-target',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json')\n                    return;\n                const offset = node.blockStartPosition.end;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                if (!schema)\n                    return;\n                const { rootLevelThemeBlocks, rootLevelLocalBlocks, presetLevelBlocks } = (0, utils_1.getBlocks)(validSchema);\n                if (rootLevelLocalBlocks.length > 0)\n                    return;\n                let errorsInRootLevelBlocks = false;\n                await Promise.all(rootLevelThemeBlocks.map(async ({ node, path }) => {\n                    const typeNode = (0, json_1.nodeAtPath)(ast, path);\n                    const exists = await (0, utils_1.validateBlockFileExistence)(node.type, context);\n                    if (!exists) {\n                        errorsInRootLevelBlocks = true;\n                        (0, utils_1.reportWarning)(`Theme block 'blocks/${node.type}.liquid' does not exist.`, offset, typeNode, context);\n                    }\n                }));\n                if (errorsInRootLevelBlocks)\n                    return;\n                let errorsInPresetLevelBlocks = false;\n                for (const [depthStr, blocks] of Object.entries(presetLevelBlocks)) {\n                    const depth = parseInt(depthStr, 10);\n                    if (depth === 0) {\n                        await Promise.all(blocks.map(async ({ node, path }) => {\n                            const typeNode = (0, json_1.nodeAtPath)(ast, path);\n                            const isPrivateBlockType = node.type.startsWith('_');\n                            if ((0, utils_1.isInvalidPresetBlock)(node, rootLevelThemeBlocks)) {\n                                errorsInPresetLevelBlocks = true;\n                                const errorMessage = isPrivateBlockType\n                                    ? `Theme block type \"${node.type}\" is a private block so it must be explicitly allowed in \"blocks\" at the root of this schema.`\n                                    : `Theme block type \"${node.type}\" must be allowed in \"blocks\" at the root of this schema.`;\n                                (0, utils_1.reportWarning)(errorMessage, offset, typeNode, context);\n                            }\n                            if ('blocks' in node && node.blocks) {\n                                await (0, utils_1.validateNestedBlocks)(context, node, node.blocks, path.slice(0, -1), offset, ast);\n                            }\n                        }));\n                    }\n                    if (!errorsInPresetLevelBlocks) {\n                        await Promise.all(blocks.map(async ({ node, path }) => {\n                            const typeNode = (0, json_1.nodeAtPath)(ast, path);\n                            const exists = await (0, utils_1.validateBlockFileExistence)(node.type, context);\n                            if (!exists) {\n                                (0, utils_1.reportWarning)(`Theme block 'blocks/${node.type}.liquid' does not exist.`, offset, typeNode, context);\n                            }\n                        }));\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidContentForArguments = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\n// content_for \"block\" and content_for \"blocks\" only allow `closest.*` kwargs.\nconst isClosestArgument = (argName) => argName.startsWith('closest.');\nconst isContextArgument = (argName) => argName.startsWith('context.');\nexports.ValidContentForArguments = {\n    meta: {\n        code: 'ValidContentForArguments',\n        name: 'Prevent the use of invalid arguments to the content_for tag',\n        docs: {\n            description: 'This check is aimed at preventing the use of invalid arguments for the content_for tag.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-content-for-arguments',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        const validationStrategies = {\n            blocks: (node) => {\n                const problematicArguments = node.args.filter((arg) => !isClosestArgument(arg.name));\n                for (const arg of problematicArguments) {\n                    context.report({\n                        message: `{% content_for \"blocks\" %} only accepts 'closest.*' arguments`,\n                        startIndex: arg.position.start,\n                        endIndex: arg.position.end,\n                    });\n                }\n                const deprecatedArguments = node.args.filter((arg) => isContextArgument(arg.name));\n                for (const arg of deprecatedArguments) {\n                    context.report({\n                        message: `{% content_for \"blocks\" %} only accepts 'closest.*' arguments. The 'context.*' arguments usage has been deprecated.`,\n                        startIndex: arg.position.start,\n                        endIndex: arg.position.end,\n                    });\n                }\n            },\n            block: (node) => {\n                const requiredArguments = ['id', 'type'];\n                // Make sure the id and string arguments are present and are strings\n                for (const requiredArgumentName of requiredArguments) {\n                    const arg = node.args.find((arg) => arg.name === requiredArgumentName);\n                    if (!arg) {\n                        context.report({\n                            message: `{% content_for \"block\" %} requires a '${requiredArgumentName}' argument`,\n                            startIndex: node.position.start,\n                            endIndex: node.position.end,\n                            suggest: [],\n                        });\n                        continue;\n                    }\n                    const argValueNode = arg.value;\n                    if (argValueNode.type !== liquid_html_parser_1.NodeTypes.String) {\n                        context.report({\n                            message: `The '${requiredArgumentName}' argument should be a string`,\n                            startIndex: argValueNode.position.start,\n                            endIndex: argValueNode.position.end,\n                            suggest: [],\n                        });\n                    }\n                }\n                const problematicArguments = node.args.filter((arg) => !(requiredArguments.includes(arg.name) || isClosestArgument(arg.name)));\n                for (const arg of problematicArguments) {\n                    context.report({\n                        message: `{% content_for \"block\" %} only accepts 'id', 'type' and 'closest.*' arguments`,\n                        startIndex: arg.position.start,\n                        endIndex: arg.position.end,\n                    });\n                }\n                const deprecatedArguments = node.args.filter((arg) => isContextArgument(arg.name));\n                for (const arg of deprecatedArguments) {\n                    context.report({\n                        message: `{% content_for \"block\" %} accepts 'closest.*' arguments. The 'context.*' arguments usage has been deprecated.`,\n                        startIndex: arg.position.start,\n                        endIndex: arg.position.end,\n                    });\n                }\n            },\n        };\n        return {\n            async LiquidTag(node) {\n                if (node.name !== 'content_for' || typeof node.markup === 'string') {\n                    return;\n                }\n                /** \"block\", \"blocks\", etc. */\n                const contentForType = node.markup.contentForType.value;\n                const validate = validationStrategies[contentForType];\n                if (!validate) {\n                    return;\n                }\n                validate(node.markup);\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidHTMLTranslation = void 0;\nconst types_1 = require(\"../../types\");\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nexports.ValidHTMLTranslation = {\n    meta: {\n        code: 'ValidHTMLTranslation',\n        name: 'Valid HTML Translation',\n        docs: {\n            description: 'This check exists to prevent invalid HTML inside translations.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-html-translation',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        // We ignore non-`locales/` json files.\n        const relativePath = context.toRelativePath(context.file.uri);\n        if (!relativePath.startsWith('locales/'))\n            return {};\n        return {\n            async Literal(node) {\n                const htmlRegex = /<[^>]+>/;\n                if (typeof node.value !== 'string' || !htmlRegex.test(node.value))\n                    return;\n                try {\n                    (0, liquid_html_parser_1.toLiquidHtmlAST)(node.value);\n                }\n                catch (error) {\n                    const loc = node.loc;\n                    const problem = {\n                        message: `${error}.`,\n                        startIndex: loc.start.offset,\n                        endIndex: loc.end.offset,\n                    };\n                    context.report(problem);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidJSON = void 0;\nconst types_1 = require(\"../../types\");\nexports.ValidJSON = {\n    meta: {\n        code: 'ValidJSON',\n        aliases: ['ValidJson'],\n        name: 'Enforce valid JSON',\n        docs: {\n            description: 'This check exists to prevent invalid JSON files in themes. Will check against schema if available.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/json-syntax-error',\n        },\n        type: types_1.SourceCodeType.JSON,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        if (!context.validateJSON)\n            return {};\n        const validateJSON = context.validateJSON;\n        return {\n            async onCodePathStart(file) {\n                const problems = await validateJSON(file.uri, file.source);\n                if (!problems)\n                    return;\n                for (const problem of problems) {\n                    context.report(problem);\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidLocalBlocks = void 0;\nconst types_1 = require(\"../../types\");\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst to_schema_2 = require(\"../../to-schema\");\nconst valid_block_utils_1 = require(\"./valid-block-utils\");\nexports.ValidLocalBlocks = {\n    meta: {\n        code: 'ValidLocalBlocks',\n        name: 'Prevent mixing static and local blocks in non-theme sections',\n        docs: {\n            description: 'Ensures sections without theme block support do not mix static and local blocks',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-local-blocks',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json')\n                    return;\n                const offset = node.blockStartPosition.end;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                if (!schema)\n                    return;\n                const { staticBlockNameLocations, staticBlockLocations, localBlockLocations, themeBlockLocations, hasRootLevelThemeBlocks, } = (0, valid_block_utils_1.getBlocks)(validSchema);\n                if ((0, to_schema_2.isSection)(context.file.uri)) {\n                    staticBlockNameLocations.forEach((blockWithPath) => {\n                        const astNode = (0, json_1.nodeAtPath)(ast, blockWithPath.path);\n                        (0, valid_block_utils_1.reportWarning)('Static theme blocks cannot have a name property.', offset, astNode, context);\n                    });\n                    if (staticBlockLocations.length > 0 && localBlockLocations.length > 0) {\n                        staticBlockLocations.forEach((blockWithPath) => {\n                            const astNode = (0, json_1.nodeAtPath)(ast, blockWithPath.path);\n                            (0, valid_block_utils_1.reportWarning)(`Sections cannot use static theme blocks together with locally scoped blocks.`, offset, astNode, context);\n                        });\n                    }\n                    if (hasRootLevelThemeBlocks &&\n                        localBlockLocations.length > 0 &&\n                        themeBlockLocations.length > 0) {\n                        localBlockLocations.forEach((blockWithPath) => {\n                            const astNode = (0, json_1.nodeAtPath)(ast, blockWithPath.path);\n                            (0, valid_block_utils_1.reportWarning)('Sections cannot use theme blocks together with locally scoped blocks.', offset, astNode, context);\n                        });\n                    }\n                }\n                if ((0, to_schema_2.isBlock)(context.file.uri)) {\n                    if (localBlockLocations.length > 0) {\n                        localBlockLocations.forEach((blockWithPath) => {\n                            const astNode = (0, json_1.nodeAtPath)(ast, blockWithPath.path);\n                            (0, valid_block_utils_1.reportWarning)('Local scoped blocks are not supported in theme blocks.', offset, astNode, context);\n                        });\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportWarning = exports.getBlocks = void 0;\nconst json_1 = require(\"../../json\");\nfunction getBlocks(validSchema) {\n    const staticBlockNameLocations = [];\n    const staticBlockLocations = [];\n    const localBlockLocations = [];\n    const themeBlockLocations = [];\n    const rootLevelBlocks = validSchema.blocks;\n    const presets = validSchema.presets;\n    function categorizeBlock(block, currentPath) {\n        if (!block)\n            return;\n        const hasStatic = 'static' in block;\n        const hasName = 'name' in block;\n        if (hasStatic && hasName) {\n            staticBlockNameLocations.push({ node: block, path: currentPath.concat('type') });\n        }\n        else if (hasStatic) {\n            staticBlockLocations.push({ node: block, path: currentPath.concat('type') });\n        }\n        else if (hasName) {\n            localBlockLocations.push({ node: block, path: currentPath.concat('type') });\n        }\n        else if (block.type !== '@app') {\n            themeBlockLocations.push({ node: block, path: currentPath.concat('type') });\n        }\n        if ('blocks' in block) {\n            if (Array.isArray(block.blocks)) {\n                block.blocks.forEach((nestedBlock, index) => {\n                    categorizeBlock(nestedBlock, currentPath.concat('blocks', String(index)));\n                });\n            }\n            else if (typeof block.blocks === 'object' && block.blocks !== null) {\n                Object.entries(block.blocks).forEach(([key, nestedBlock]) => {\n                    categorizeBlock(nestedBlock, currentPath.concat('blocks', key));\n                });\n            }\n        }\n    }\n    if (Array.isArray(rootLevelBlocks)) {\n        rootLevelBlocks.forEach((block, index) => {\n            categorizeBlock(block, ['blocks', String(index)]);\n        });\n    }\n    if (presets) {\n        presets.forEach((preset, presetIndex) => {\n            if ('blocks' in preset && preset.blocks) {\n                if (Array.isArray(preset.blocks)) {\n                    preset.blocks.forEach((block, blockIndex) => {\n                        categorizeBlock(block, ['presets', String(presetIndex), 'blocks', String(blockIndex)]);\n                    });\n                }\n                else if (typeof preset.blocks === 'object') {\n                    Object.entries(preset.blocks).forEach(([key, block]) => {\n                        categorizeBlock(block, ['presets', String(presetIndex), 'blocks', key]);\n                    });\n                }\n            }\n        });\n    }\n    return {\n        staticBlockNameLocations,\n        staticBlockLocations,\n        localBlockLocations,\n        themeBlockLocations,\n        hasRootLevelThemeBlocks: themeBlockLocations.some((block) => block.path[0] === 'blocks'),\n    };\n}\nexports.getBlocks = getBlocks;\nfunction reportWarning(message, offset, astNode, context) {\n    context.report({\n        message,\n        startIndex: offset + (0, json_1.getLocStart)(astNode),\n        endIndex: offset + (0, json_1.getLocEnd)(astNode),\n    });\n}\nexports.reportWarning = reportWarning;\n//# sourceMappingURL=valid-block-utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidRenderSnippetParams = void 0;\nconst types_1 = require(\"../../types\");\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst liquidDoc_1 = require(\"../../liquid-doc/liquidDoc\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../../liquid-doc/utils\");\nexports.ValidRenderSnippetParams = {\n    meta: {\n        code: 'ValidRenderSnippetParams',\n        name: 'Valid Render Snippet Parameters',\n        docs: {\n            description: 'This check ensures that all required parameters are provided when rendering a snippet and that no unknown parameters are used.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-render-snippet-params',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        function partitionParameters(liquidDocParameters, providedParams) {\n            const providedParameters = new Map(providedParams.map((arg) => [arg.name, arg]));\n            const missingRequiredParams = [];\n            const unknownProvidedParams = [];\n            // Check required params\n            for (const param of liquidDocParameters.values()) {\n                if (param.required && !providedParameters.has(param.name)) {\n                    missingRequiredParams.push(param);\n                }\n            }\n            // Check provided params\n            for (const arg of providedParameters.values()) {\n                const liquidDocParamDef = liquidDocParameters.has(arg.name);\n                if (!liquidDocParamDef) {\n                    unknownProvidedParams.push(arg);\n                }\n            }\n            return {\n                missingRequiredParams,\n                unknownProvidedParams,\n            };\n        }\n        function reportMissingParams(missingRequiredParams, node, snippetName) {\n            for (const param of missingRequiredParams) {\n                context.report({\n                    message: `Missing required parameter '${param.name}' in render tag for snippet '${snippetName}'`,\n                    startIndex: node.position.start,\n                    endIndex: node.position.end,\n                    suggest: [\n                        {\n                            message: `Add required parameter '${param.name}'`,\n                            fix: (fixer) => {\n                                const paramToAdd = `, ${param.name}: ${(0, utils_2.getDefaultValueForType)(param.type)}`;\n                                if (node.args.length == 0) {\n                                    return fixer.insert(node.snippet.position.end, paramToAdd);\n                                }\n                                const lastArg = node.args[node.args.length - 1];\n                                const sourceAfterLastArg = node.source.substring(lastArg.position.end, node.position.end);\n                                const trailingCommaAndWhitespaceMatch = sourceAfterLastArg.match(/\\s*,\\s*/);\n                                if (trailingCommaAndWhitespaceMatch) {\n                                    // IF there is already a trailing comma after the last arg, we want to find it and replace it with our own while stripping whitespace\n                                    return fixer.replace(lastArg.position.end, lastArg.position.end + trailingCommaAndWhitespaceMatch[0].length, `${paramToAdd} `);\n                                }\n                                return fixer.insert(lastArg.position.end, paramToAdd);\n                            },\n                        },\n                    ],\n                });\n            }\n        }\n        function reportUnknownParams(unknownProvidedParams, node, snippetName) {\n            for (const param of unknownProvidedParams) {\n                context.report({\n                    message: `Unknown parameter '${param.name}' in render tag for snippet '${snippetName}'`,\n                    startIndex: param.position.start,\n                    endIndex: param.position.end,\n                    suggest: [\n                        {\n                            message: `Remove '${param.name}'`,\n                            fix: (fixer) => {\n                                // This is a bit messy, but it allows us to strip leading and trailing whitespaces and commas\n                                const sourceBeforeArg = node.source.slice(0, param.position.start);\n                                const matches = sourceBeforeArg.match(/,\\s*/g);\n                                const lastWhitespaceMatch = matches ? matches[matches.length - 1] : null;\n                                let startPos = lastWhitespaceMatch\n                                    ? param.position.start - (lastWhitespaceMatch.length - 1)\n                                    : param.position.start;\n                                if (isLastParam(param)) {\n                                    // Remove the leading comma if it's the last parameter\n                                    startPos -= 1;\n                                }\n                                const sourceAfterArg = node.source.substring(param.position.end, node.position.end);\n                                const trailingCommaMatch = sourceAfterArg.match(/\\s*,/);\n                                if (trailingCommaMatch) {\n                                    return fixer.remove(startPos, param.position.end + trailingCommaMatch[0].length);\n                                }\n                                return fixer.remove(startPos, param.position.end);\n                            },\n                        },\n                    ],\n                });\n            }\n            function isLastParam(param) {\n                return (node.args.length == 1 ||\n                    param.position.start == node.args[node.args.length - 1].position.start);\n            }\n        }\n        return {\n            async RenderMarkup(node) {\n                var _a;\n                if (!(0, utils_1.isLiquidString)(node.snippet) || node.variable) {\n                    return;\n                }\n                const snippetName = node.snippet.value;\n                const snippetPath = `snippets/${snippetName}.liquid`;\n                const snippetUri = context.toUri(snippetPath);\n                const snippetContent = await context.fs.readFile(snippetUri);\n                const snippetAst = (0, liquid_html_parser_1.toLiquidHtmlAST)(snippetContent);\n                const snippetDef = (0, liquidDoc_1.getSnippetDefinition)(snippetAst, snippetName);\n                if (!((_a = snippetDef.liquidDoc) === null || _a === void 0 ? void 0 : _a.parameters)) {\n                    return;\n                }\n                const liquidDocParameters = new Map(snippetDef.liquidDoc.parameters.map((p) => [p.name, p]));\n                const { missingRequiredParams, unknownProvidedParams } = partitionParameters(liquidDocParameters, node.args);\n                reportMissingParams(missingRequiredParams, node, snippetName);\n                reportUnknownParams(unknownProvidedParams, node, snippetName);\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidSchemaName = void 0;\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst types_1 = require(\"../../types\");\nconst utils_1 = require(\"../../utils\");\nconst MAX_SCHEMA_NAME_LENGTH = 25;\nexports.ValidSchemaName = {\n    meta: {\n        code: 'ValidSchemaName',\n        name: 'Enforce valid schema name',\n        docs: {\n            description: 'This check is aimed at ensuring a valid schema name.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-schema-name',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json') {\n                    return;\n                }\n                const offset = node.blockStartPosition.end;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                const name = validSchema.name;\n                if (!name)\n                    return;\n                // We can make this type assertion because we know the schema is valid\n                const nameNode = (0, json_1.nodeAtPath)(ast, ['name']);\n                const startIndex = offset + (0, json_1.getLocStart)(nameNode);\n                const endIndex = offset + (0, json_1.getLocEnd)(nameNode);\n                if (name.startsWith('t:')) {\n                    const defaultLocale = await context.getDefaultLocale();\n                    const key = name.replace('t:', '');\n                    const defaultTranslations = await context.getDefaultSchemaTranslations();\n                    const translation = (0, utils_1.deepGet)(defaultTranslations, key.split('.'));\n                    if (translation === undefined) {\n                        context.report({\n                            message: `'${name}' does not have a matching entry in 'locales/${defaultLocale}.default.schema.json'`,\n                            startIndex,\n                            endIndex,\n                        });\n                    }\n                    if (translation !== undefined && translation.length > MAX_SCHEMA_NAME_LENGTH) {\n                        context.report({\n                            message: `Schema name '${translation}' from 'locales/${defaultLocale}.default.schema.json' is too long (max 25 characters)`,\n                            startIndex,\n                            endIndex,\n                        });\n                    }\n                }\n                else if (name.length > MAX_SCHEMA_NAME_LENGTH) {\n                    context.report({\n                        message: `Schema name '${name}' is too long (max 25 characters)`,\n                        startIndex,\n                        endIndex,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidSchema = void 0;\nconst types_1 = require(\"../../types\");\nexports.ValidSchema = {\n    meta: {\n        code: 'ValidSchema',\n        name: 'Prevent invalid JSON in {% schema %} tags',\n        docs: {\n            description: 'This check is aimed at eliminating JSON errors in schema tags.',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-schema',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                if (node.name !== 'schema' || node.body.kind !== 'json' || !context.validateJSON) {\n                    return;\n                }\n                const jsonString = node.source.slice(node.blockStartPosition.end, node.blockEndPosition.start);\n                const problems = await context.validateJSON(context.file.uri, jsonString);\n                if (!problems)\n                    return;\n                for (const problem of problems) {\n                    context.report({\n                        message: problem.message,\n                        startIndex: node.blockStartPosition.end + problem.startIndex,\n                        endIndex: node.blockStartPosition.end + problem.endIndex,\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidSettingsKey = void 0;\nconst types_1 = require(\"../../types\");\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst utils_1 = require(\"../../utils\");\nexports.ValidSettingsKey = {\n    meta: {\n        code: 'ValidSettingsKey',\n        name: 'Validate settings key in presets',\n        docs: {\n            description: 'Ensures settings key only references valid settings defined in its respective schema',\n            recommended: true,\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-settings-key',\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                var _a;\n                if (node.name !== 'schema' || node.body.kind !== 'json')\n                    return;\n                const offset = node.blockStartPosition.end;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema || validSchema instanceof Error)\n                    return;\n                if (!ast || ast instanceof Error)\n                    return;\n                const { rootLevelLocalBlocks, presetLevelBlocks } = (0, utils_1.getBlocks)(validSchema);\n                // Check if presets settings match schema-level settings\n                if (validSchema.presets) {\n                    for (let i = 0; i < validSchema.presets.length; i++) {\n                        const settingsNode = (0, json_1.nodeAtPath)(ast, ['presets', i, 'settings']);\n                        validateSettingsKey(context, offset, settingsNode, validSchema.settings);\n                    }\n                }\n                if ((0, to_schema_1.isSectionSchema)(schema) && 'default' in validSchema && validSchema.default) {\n                    // Check if default settings match schema-level settings\n                    const settingsNode = (0, json_1.nodeAtPath)(ast, ['default', 'settings']);\n                    validateSettingsKey(context, offset, settingsNode, validSchema.settings);\n                    // Check if default block settings match the settings defined in the block file's schema\n                    (_a = validSchema.default.blocks) === null || _a === void 0 ? void 0 : _a.forEach((block, i) => {\n                        const settingsNode = (0, json_1.nodeAtPath)(ast, ['default', 'blocks', i, 'settings']);\n                        validateReferencedBlock(context, offset, settingsNode, rootLevelLocalBlocks, block);\n                    });\n                }\n                // Check if preset block settings match the settings defined in the block file's schema\n                for (const [_depthStr, blocks] of Object.entries(presetLevelBlocks)) {\n                    blocks.forEach(({ node: blockNode, path }) => {\n                        const settingsNode = (0, json_1.nodeAtPath)(ast, path.slice(0, -1).concat('settings'));\n                        validateReferencedBlock(context, offset, settingsNode, rootLevelLocalBlocks, blockNode);\n                    });\n                }\n            },\n        };\n    },\n};\nasync function validateReferencedBlock(context, offset, settingsNode, localBlocks, referencedBlock) {\n    var _a;\n    if (localBlocks.length > 0) {\n        const localBlock = localBlocks.find((localBlock) => localBlock.node.type === referencedBlock.type);\n        if (!localBlock)\n            return;\n        const localBlockNode = localBlock.node;\n        validateSettingsKey(context, offset, settingsNode, localBlockNode.settings);\n    }\n    else {\n        const blockSchema = await ((_a = context.getBlockSchema) === null || _a === void 0 ? void 0 : _a.call(context, referencedBlock.type));\n        const { validSchema: validBlockSchema } = blockSchema !== null && blockSchema !== void 0 ? blockSchema : {};\n        if (!validBlockSchema || validBlockSchema instanceof Error)\n            return;\n        validateSettingsKey(context, offset, settingsNode, validBlockSchema.settings, referencedBlock);\n    }\n}\nfunction validateSettingsKey(context, offset, settingsNode, validSettings, blockNode) {\n    if (!settingsNode || settingsNode.type !== 'Object')\n        return;\n    for (const setting of settingsNode.children) {\n        const settingExists = validSettings === null || validSettings === void 0 ? void 0 : validSettings.find((validSetting) => (validSetting === null || validSetting === void 0 ? void 0 : validSetting.id) === setting.key.value);\n        if (!settingExists) {\n            const errorMessage = blockNode\n                ? `Setting '${setting.key.value}' does not exist in 'blocks/${blockNode.type}.liquid'.`\n                : `Setting '${setting.key.value}' does not exist in schema.`;\n            (0, utils_1.reportWarning)(errorMessage, offset, setting.key, context);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidStaticBlockType = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst file_utils_1 = require(\"../../utils/file-utils\");\nconst markup_1 = require(\"../../utils/markup\");\nexports.ValidStaticBlockType = {\n    meta: {\n        code: 'ValidStaticBlockType',\n        name: 'Prevent use of type that is not valid for static blocks',\n        docs: {\n            description: 'This check is aimed at preventing the use of an invalid type for blocks rendered statically.',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-static-block-type',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.ERROR,\n        schema: {},\n        targets: [],\n    },\n    create(context) {\n        return {\n            async LiquidTag(node) {\n                if (node.name !== 'content_for') {\n                    return;\n                }\n                if (!(0, markup_1.isContentForBlock)(node.markup)) {\n                    return;\n                }\n                const typeArg = node.markup.args.find((arg) => arg.name === 'type');\n                if (!typeArg) {\n                    return; // covered by VariableContentForArguments\n                }\n                const typeArgValueNode = typeArg.value;\n                if (typeArgValueNode.type !== liquid_html_parser_1.NodeTypes.String) {\n                    return; // covered by VariableContentForArguments\n                }\n                const blockName = typeArgValueNode.value;\n                const relativePath = `blocks/${blockName}.liquid`;\n                const fileExists = await (0, file_utils_1.doesFileExist)(context, relativePath);\n                if (!fileExists) {\n                    context.report({\n                        message: `'blocks/${blockName}.liquid' does not exist`,\n                        startIndex: typeArgValueNode.position.start,\n                        endIndex: typeArgValueNode.position.end,\n                        suggest: [],\n                    });\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidVisibleIfSettingsSchema = exports.ValidVisibleIf = void 0;\nconst types_1 = require(\"../../types\");\nconst json_1 = require(\"../../json\");\nconst to_schema_1 = require(\"../../to-schema\");\nconst utils_1 = require(\"../../utils\");\nconst visible_if_utils_1 = require(\"./visible-if-utils\");\n// Note that unlike most other files in the `checks` directory, this exports two\n// checks: one for Liquid files and one for 'config/settings_schema.json'. They\n// perform the same check using the same logic (modulo differences extracting\n// the schema and determining warning start and end indices).\nconst meta = {\n    code: 'ValidVisibleIf',\n    name: 'Validate visible_if expressions',\n    docs: {\n        description: 'Ensures visible_if expressions are well-formed and only reference settings keys that are defined',\n        recommended: true,\n        url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-visible-if',\n    },\n    severity: types_1.Severity.ERROR,\n    schema: {},\n    targets: [],\n};\nexports.ValidVisibleIf = {\n    meta: { ...meta, type: types_1.SourceCodeType.LiquidHtml },\n    create(context) {\n        return {\n            async LiquidRawTag(node) {\n                var _a;\n                if (node.name !== 'schema' || node.body.kind !== 'json')\n                    return;\n                const schema = await (0, to_schema_1.getSchema)(context);\n                const { validSchema, ast } = schema !== null && schema !== void 0 ? schema : {};\n                if (!validSchema ||\n                    validSchema instanceof Error ||\n                    !((_a = validSchema.settings) === null || _a === void 0 ? void 0 : _a.some((setting) => 'visible_if' in setting)) ||\n                    !ast ||\n                    ast instanceof Error) {\n                    return;\n                }\n                const offset = node.blockStartPosition.end;\n                const settings = Object.fromEntries((await (0, visible_if_utils_1.getGlobalSettings)(context)).map((s) => [s, true]));\n                const currentFileSettings = Object.fromEntries(validSchema.settings.map((setting) => [setting.id, true]));\n                const vars = { settings };\n                if ((0, to_schema_1.isSectionSchema)(schema)) {\n                    vars.section = { settings: currentFileSettings };\n                }\n                else if ((0, to_schema_1.isBlockSchema)(schema)) {\n                    vars.block = { settings: currentFileSettings };\n                }\n                for (const [i, setting] of validSchema.settings.entries()) {\n                    if (!('visible_if' in setting) || typeof setting.visible_if !== 'string')\n                        continue;\n                    const visibleIfNode = (0, json_1.nodeAtPath)(ast, ['settings', i, 'visible_if']);\n                    const varLookupsOrWarning = (0, visible_if_utils_1.getVariableLookupsInExpression)(setting.visible_if);\n                    if ('warning' in varLookupsOrWarning) {\n                        (0, utils_1.reportWarning)(varLookupsOrWarning.warning, offset, visibleIfNode, context);\n                        continue;\n                    }\n                    const report = (message, lookup) => {\n                        if (typeof message === 'string') {\n                            context.report({\n                                message,\n                                // the JSONNode start location returned by `getLocStart`\n                                // includes the opening quotation mark  whereas when we parse\n                                // the inner expression, 0 is the location _inside_ the quotes.\n                                // we add 1 to the offsets to compensate.\n                                startIndex: offset + (0, json_1.getLocStart)(visibleIfNode) + lookup.position.start + visible_if_utils_1.offsetAdjust + 1,\n                                endIndex: offset + (0, json_1.getLocStart)(visibleIfNode) + lookup.position.end + visible_if_utils_1.offsetAdjust + 1,\n                            });\n                        }\n                    };\n                    for (const lookup of varLookupsOrWarning) {\n                        if (lookup.name === 'section' && !(0, to_schema_1.isSectionSchema)(schema)) {\n                            report(`Invalid visible_if: can't refer to \"section\" when not in a section file.`, lookup);\n                        }\n                        else if (lookup.name === 'block' && !(0, to_schema_1.isBlockSchema)(schema)) {\n                            report(`Invalid visible_if: can't refer to \"block\" when not in a block file.`, lookup);\n                        }\n                        else {\n                            report((0, visible_if_utils_1.validateLookup)(lookup, vars), lookup);\n                        }\n                    }\n                }\n            },\n        };\n    },\n};\nexports.ValidVisibleIfSettingsSchema = {\n    meta: { ...meta, type: types_1.SourceCodeType.JSON },\n    create(context) {\n        const relativePath = context.toRelativePath(context.file.uri);\n        if (relativePath !== 'config/settings_schema.json')\n            return {};\n        return {\n            async Property(node) {\n                if (node.key.value !== 'visible_if' || node.value.type !== 'Literal')\n                    return;\n                const visibleIfExpression = node.value.value;\n                if (typeof visibleIfExpression !== 'string')\n                    return;\n                const offset = node.value.loc.start.offset;\n                const varLookupsOrWarning = (0, visible_if_utils_1.getVariableLookupsInExpression)(visibleIfExpression);\n                if ('warning' in varLookupsOrWarning) {\n                    context.report({\n                        message: varLookupsOrWarning.warning,\n                        startIndex: node.value.loc.start.offset,\n                        endIndex: node.value.loc.end.offset,\n                    });\n                    return;\n                }\n                const settings = Object.fromEntries((await (0, visible_if_utils_1.getGlobalSettings)(context)).map((s) => [s, true]));\n                const vars = { settings };\n                const report = (message, lookup) => {\n                    if (typeof message === 'string') {\n                        context.report({\n                            message,\n                            startIndex: offset + lookup.position.start + visible_if_utils_1.offsetAdjust + 1,\n                            endIndex: offset + lookup.position.end + visible_if_utils_1.offsetAdjust + 1,\n                        });\n                    }\n                };\n                for (const lookup of varLookupsOrWarning) {\n                    // settings_schema.json can't reference `section` or `block`.\n                    if (lookup.name === 'section') {\n                        report(`Invalid visible_if: can't refer to \"section\" when not in a section file.`, lookup);\n                    }\n                    else if (lookup.name === 'block') {\n                        report(`Invalid visible_if: can't refer to \"block\" when not in a block file.`, lookup);\n                    }\n                    else {\n                        report((0, visible_if_utils_1.validateLookup)(lookup, vars), lookup);\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getGlobalSettings = exports.validateLookup = exports.getVariableLookupsInExpression = exports.offsetAdjust = exports.adjustedSuffix = exports.adjustedPrefix = exports.variableExpressionMatcher = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst find_root_1 = require(\"../../find-root\");\nconst json_1 = require(\"../../json\");\nconst path_1 = require(\"../../path\");\nconst visitor_1 = require(\"../../visitor\");\nexports.variableExpressionMatcher = /{{(.+?)}}/;\nexports.adjustedPrefix = '{% if ';\nexports.adjustedSuffix = ' %}{% endif %}';\nexports.offsetAdjust = '{{'.length - exports.adjustedPrefix.length;\nfunction getVariableLookupsInExpression(expression) {\n    // As of February 2025, parsers other than LiquidJS don't yet support\n    // expressions in {{ variable }} tags. So we have to do something a little\n    // gnarly  before parsing it we extract the expression from within the tag\n    // and plunk it into an `{% if <expression> %}{% endif %}` statement instead.\n    // This requires us to adjust the reported character ranges and offer slightly\n    // less useful messages on syntax errors, but otherwise should behave\n    // similarly to a proper `{{ <expression> }}` syntax whenever it lands.\n    const match = exports.variableExpressionMatcher.exec(expression);\n    if (match == null) {\n        return {\n            warning: `Invalid visible_if expression. It should take the form \"{{ <expression> }}\".`,\n        };\n    }\n    const unwrappedExpression = match[1];\n    const adjustedExpression = `${exports.adjustedPrefix}${unwrappedExpression}${exports.adjustedSuffix}`;\n    try {\n        const innerAst = (0, liquid_html_parser_1.toLiquidHtmlAST)(adjustedExpression, {\n            mode: 'strict',\n            allowUnclosedDocumentNode: false,\n        });\n        if (innerAst.children.length !== 1) {\n            throw new Error('Unexpected child count for DocumentNode');\n        }\n        const ifTag = innerAst.children[0];\n        if (ifTag.type !== 'LiquidTag' || ifTag.name !== 'if') {\n            throw new Error(\"Expected DocumentNode to contain 'if' tag\");\n        }\n        const vars = (0, visitor_1.visit)(ifTag, {\n            VariableLookup: (node) => node,\n        });\n        if (vars.length === 0) {\n            return {\n                warning: `visible_if expression contains no references to any settings. This is likely an error.`,\n            };\n        }\n        return vars;\n    }\n    catch (error) {\n        if (error instanceof SyntaxError) {\n            // Because of our hackish approach, the underlying error is likely to\n            // include an incorrect character range and/or mention {% if %} tags.\n            // Squelch the details and just report it as a simple syntax error.\n            return { warning: 'Syntax error: cannot parse visible_if expression.' };\n        }\n        return { warning: String(error) };\n    }\n}\nexports.getVariableLookupsInExpression = getVariableLookupsInExpression;\nfunction validateLookup(lookup, vars) {\n    const normalized = getNormalizedLookups(lookup);\n    const poppedSegments = [];\n    let scope = vars;\n    while (normalized.length > 0) {\n        const segment = normalized.shift();\n        poppedSegments.push(segment);\n        // \"noUncheckedIndexedAccess\" is false in our tsconfig.json\n        const next = scope[segment];\n        if (!next) {\n            return `Invalid variable: \"${poppedSegments.join('.')}\" was not found.`;\n        }\n        if (typeof next === 'boolean') {\n            if (normalized.length > 0) {\n                return `Invalid variable: \"${poppedSegments.join('.')}\" refers to a variable, but is being used here as a namespace.`;\n            }\n            return null;\n        }\n        scope = next;\n    }\n    // note this is the reverse of the above similar-looking case\n    return `Invalid variable: \"${poppedSegments.join('.')}\" refers to a namespace, but is being used here as a variable.`;\n}\nexports.validateLookup = validateLookup;\nfunction getNormalizedLookups(lookup) {\n    const nestedLookups = lookup.lookups.map((lookup) => {\n        if (lookup.type !== liquid_html_parser_1.NodeTypes.String) {\n            throw new Error(`Expected lookups to be String nodes: ${JSON.stringify(lookup)}`);\n        }\n        return lookup.value;\n    });\n    return [lookup.name, ...nestedLookups];\n}\nasync function getGlobalSettings(context) {\n    const globalSettings = [];\n    try {\n        const path = (0, path_1.join)(await (0, find_root_1.findRoot)(context.file.uri, context.fileExists), 'config/settings_schema.json');\n        const settingsFile = await context.fs.readFile(path);\n        const settings = (0, json_1.parseJSON)(settingsFile);\n        if (Array.isArray(settings)) {\n            for (const group of settings) {\n                if ('settings' in group && Array.isArray(group.settings)) {\n                    globalSettings.push(...group.settings.map((setting) => setting.id).filter((id) => id));\n                }\n            }\n        }\n    }\n    catch (e) {\n        console.error('Error fetching global settings:', e);\n        // ignore absent or malformed settings schema\n    }\n    return globalSettings;\n}\nexports.getGlobalSettings = getGlobalSettings;\n//# sourceMappingURL=visible-if-utils.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VariableName = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst types_1 = require(\"../../types\");\nconst camelCase_1 = __importDefault(require(\"lodash/camelCase\"));\nconst kebabCase_1 = __importDefault(require(\"lodash/kebabCase\"));\nconst snakeCase_1 = __importDefault(require(\"lodash/snakeCase\"));\nconst pascalCase = (string) => {\n    const camelCased = (0, camelCase_1.default)(string);\n    return camelCased.charAt(0).toUpperCase() + camelCased.slice(1);\n};\nconst isLiquidTagAssign = (node) => {\n    return node.name === 'assign' && typeof node.markup !== 'string';\n};\nconst isLiquidTagCapture = (node) => {\n    return (node.type == liquid_html_parser_1.NodeTypes.LiquidTag && node.name === 'capture' && typeof node.markup !== 'string');\n};\nconst formatTypes = {\n    camelCase: camelCase_1.default,\n    PascalCase: pascalCase,\n    snake_case: snakeCase_1.default,\n    'kebab-case': kebabCase_1.default,\n};\nconst schema = {\n    format: types_1.SchemaProp.string('snake_case'),\n};\nexports.VariableName = {\n    meta: {\n        code: 'VariableName',\n        name: 'Invalid variable naming format',\n        docs: {\n            description: 'This check is aimed at using certain variable naming conventions',\n            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/variable-name',\n            recommended: true,\n        },\n        type: types_1.SourceCodeType.LiquidHtml,\n        severity: types_1.Severity.WARNING,\n        schema,\n        targets: [],\n    },\n    create(context) {\n        const formatter = (node) => {\n            if (!node.markup.name) {\n                return {\n                    valid: false,\n                };\n            }\n            const suggestion = formatTypes[context.settings.format]\n                .call(null, node.markup.name)\n                .replace(/(\\d+)[-_](?=[a-z])/g, '$1');\n            return {\n                valid: node.markup.name === suggestion,\n                suggestion,\n            };\n        };\n        const reportHandler = (node) => {\n            return context.report({\n                message: `The variable '${node.markup.name}' uses wrong naming format`,\n                startIndex: node.markup.position.start,\n                endIndex: node.markup.position.end,\n                suggest: [\n                    {\n                        message: `Change variable '${node.markup.name}' to '${formatter(node).suggestion}'`,\n                        fix: (corrector) => {\n                            const { position, name, source } = node.markup;\n                            return corrector.replace(position.start, position.end, source\n                                .slice(position.start, position.end)\n                                .replace(name, formatter(node).suggestion));\n                        },\n                    },\n                ],\n            });\n        };\n        return {\n            async LiquidTag(node) {\n                if (isLiquidTagAssign(node)) {\n                    if (!formatter(node).valid) {\n                        reportHandler(node);\n                    }\n                }\n                else if (isLiquidTagCapture(node) && node.markup.name) {\n                    if (!formatter(node).valid) {\n                        reportHandler(node);\n                    }\n                }\n            },\n        };\n    },\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeGetMetafieldDefinitions = exports.FETCHED_METAFIELD_CATEGORIES = exports.isDirectory = exports.recursiveReadDirectory = exports.makeGetDefaultSchemaTranslations = exports.makeGetDefaultTranslations = exports.makeGetDefaultSchemaLocale = exports.makeGetDefaultLocale = exports.makeFileSize = exports.makeFileExists = void 0;\nconst vscode_uri_1 = require(\"vscode-uri\");\nconst AbstractFileSystem_1 = require(\"./AbstractFileSystem\");\nconst json_1 = require(\"./json\");\nconst path_1 = require(\"./path\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst makeFileExists = (fs) => async function fileExists(uri) {\n    try {\n        await fs.stat(uri);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.makeFileExists = makeFileExists;\nconst makeFileSize = (fs) => async function fileSize(uri) {\n    try {\n        const stats = await fs.stat(uri);\n        return stats.size;\n    }\n    catch (error) {\n        return 0;\n    }\n};\nexports.makeFileSize = makeFileSize;\nexports.makeGetDefaultLocale = getDefaultLocaleFactoryFactory('.default.json');\nexports.makeGetDefaultSchemaLocale = getDefaultLocaleFactoryFactory('.default.schema.json');\nfunction getDefaultLocaleFactoryFactory(postfix = '.default.json') {\n    return function getDefaultLocaleFactory(fs, rootUri) {\n        return cached(() => getDefaultLocale(fs, rootUri, postfix));\n    };\n}\nexports.makeGetDefaultTranslations = getDefaultTranslationsFactoryFactory('.default.json');\nexports.makeGetDefaultSchemaTranslations = getDefaultTranslationsFactoryFactory('.default.schema.json');\n// prettier-ignore\nfunction getDefaultTranslationsFactoryFactory(postfix = '.default.json') {\n    return function getDefaultTranslationsFactory(fs, theme, rootUri) {\n        return cached(() => getDefaultTranslations(fs, theme, rootUri, postfix));\n    };\n}\nasync function getDefaultLocaleFile(fs, rootUri, postfix = '.default.json') {\n    var _a;\n    const files = await fs.readDirectory((0, path_1.join)(rootUri, 'locales'));\n    return (_a = files.find(([uri]) => uri.endsWith(postfix))) === null || _a === void 0 ? void 0 : _a[0];\n}\nasync function getDefaultLocale(fs, rootUri, postfix) {\n    try {\n        const defaultLocaleFile = await getDefaultLocaleFile(fs, rootUri, postfix);\n        if (!defaultLocaleFile)\n            return 'en';\n        const defaultLocaleFileName = vscode_uri_1.Utils.basename(vscode_uri_1.URI.parse(defaultLocaleFile));\n        return defaultLocaleFileName.split('.')[0];\n    }\n    catch (error) {\n        console.error(error);\n        return 'en';\n    }\n}\nasync function getDefaultTranslations(fs, theme, rootUri, postfix) {\n    try {\n        const bufferTranslations = getDefaultTranslationsFromBuffer(theme, postfix);\n        if (bufferTranslations)\n            return bufferTranslations;\n        const defaultLocaleFile = await getDefaultLocaleFile(fs, rootUri, postfix);\n        if (!defaultLocaleFile)\n            return {};\n        const defaultTranslationsFile = await fs.readFile(defaultLocaleFile);\n        return (0, json_1.parseJSON)(defaultTranslationsFile, {});\n    }\n    catch (error) {\n        console.error(error);\n        return {};\n    }\n}\n/** It might be that you have an open buffer, we prefer translations from there if available */\nfunction getDefaultTranslationsFromBuffer(theme, postfix) {\n    const defaultTranslationsSourceCode = theme.find((sourceCode) => sourceCode.type === types_1.SourceCodeType.JSON &&\n        sourceCode.uri.match(/locales/) &&\n        sourceCode.uri.endsWith(postfix));\n    if (!defaultTranslationsSourceCode)\n        return undefined;\n    const translations = (0, json_1.parseJSON)(defaultTranslationsSourceCode.source);\n    if ((0, utils_1.isError)(translations))\n        return undefined;\n    return translations;\n}\nfunction cached(fn) {\n    let cachedPromise;\n    return async (...args) => {\n        if (!cachedPromise)\n            cachedPromise = fn(...args);\n        return cachedPromise;\n    };\n}\nasync function recursiveReadDirectory(fs, uri, filter) {\n    const allFiles = await fs.readDirectory(uri);\n    const files = allFiles.filter((ft) => !isIgnored(ft) && (isDirectory(ft) || filter(ft)));\n    const results = await Promise.all(files.map((ft) => {\n        if (isDirectory(ft)) {\n            return recursiveReadDirectory(fs, ft[0], filter);\n        }\n        else {\n            return Promise.resolve([ft[0]]);\n        }\n    }));\n    return results.flat();\n}\nexports.recursiveReadDirectory = recursiveReadDirectory;\nfunction isDirectory([_, type]) {\n    return type === AbstractFileSystem_1.FileType.Directory;\n}\nexports.isDirectory = isDirectory;\nconst ignoredFolders = ['.git', 'node_modules', 'dist', 'build', 'tmp', 'vendor'];\nfunction isIgnored([uri, type]) {\n    return type === AbstractFileSystem_1.FileType.Directory && ignoredFolders.some((folder) => uri.endsWith(folder));\n}\nexports.FETCHED_METAFIELD_CATEGORIES = [\n    'article',\n    'blog',\n    'brand',\n    'collection',\n    'company',\n    'company_location',\n    'location',\n    'market',\n    'order',\n    'page',\n    'product',\n    'variant',\n    'shop',\n];\nconst makeGetMetafieldDefinitions = (fs) => async function (rootUri) {\n    const definitions = {\n        article: [],\n        blog: [],\n        brand: [],\n        collection: [],\n        company: [],\n        company_location: [],\n        location: [],\n        market: [],\n        order: [],\n        page: [],\n        product: [],\n        variant: [],\n        shop: [],\n    };\n    try {\n        const content = await fs.readFile((0, path_1.join)(rootUri, '.shopify', 'metafields.json'));\n        const json = (0, json_1.parseJSON)(content);\n        if ((0, utils_1.isError)(json))\n            return definitions;\n        return exports.FETCHED_METAFIELD_CATEGORIES.reduce((definitions, group) => {\n            try {\n                definitions[group] = json[group].map((definition) => ({\n                    key: definition.key,\n                    name: definition.name,\n                    namespace: definition.namespace,\n                    description: definition.description,\n                    type: {\n                        category: definition.type.category,\n                        name: definition.type.name,\n                    },\n                }));\n            }\n            catch (error) {\n                // If there are errors in the file, we ignore it\n            }\n            return definitions;\n        }, definitions);\n    }\n    catch (err) {\n        return definitions;\n    }\n};\nexports.makeGetMetafieldDefinitions = makeGetMetafieldDefinitions;\n//# sourceMappingURL=context-utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDisabledChecksModule = void 0;\nfunction createDisabledChecksModule() {\n    const SPECIFIC_CHECK_NOT_DEFINED = '@all';\n    const INLINE_COMMENT_TAG = '#';\n    const disabledChecks = new Map();\n    function determineRanges(uri, value, position) {\n        const [_, command, checksJoined] = value.trim().match(/^(?:theme\\-check\\-(disable|enable)) ?(.*)/) || [];\n        const checks = checksJoined ? checksJoined.split(/,[ ]*/) : [SPECIFIC_CHECK_NOT_DEFINED];\n        checks.forEach((check) => {\n            const disabledRanges = disabledChecks.get(uri);\n            if (command === 'disable') {\n                if (!disabledRanges.has(check)) {\n                    disabledRanges.set(check, []);\n                }\n                disabledRanges.get(check).push({ from: position.end });\n            }\n            if (command === 'enable') {\n                let disabledRangesForCheck = disabledRanges.get(check);\n                if (disabledRangesForCheck) {\n                    disabledRangesForCheck[disabledRangesForCheck.length - 1].to = position.start;\n                }\n                else {\n                    if (check === SPECIFIC_CHECK_NOT_DEFINED) {\n                        for (let ranges of disabledRanges.values()) {\n                            for (let range of ranges) {\n                                if (!range.to) {\n                                    range.to = position.start;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    const DisabledChecksVisitor = {\n        meta: { schema: {} },\n        create: ({ file }) => ({\n            async onCodePathStart() {\n                disabledChecks.set(file.uri, new Map());\n            },\n            async LiquidRawTag(node) {\n                if (node.name !== 'comment') {\n                    return;\n                }\n                determineRanges(file.uri, node.body.value, node.position);\n            },\n            async LiquidTag(node) {\n                if (typeof node.markup !== 'string' || node.name !== INLINE_COMMENT_TAG) {\n                    return;\n                }\n                determineRanges(file.uri, node.markup, node.position);\n            },\n        }),\n    };\n    function isDisabled(offense) {\n        const ranges = [SPECIFIC_CHECK_NOT_DEFINED, offense.check].flatMap((check) => {\n            if (!disabledChecks.has(offense.uri)) {\n                return [];\n            }\n            if (!disabledChecks.get(offense.uri).has(check)) {\n                return [];\n            }\n            return disabledChecks.get(offense.uri).get(check);\n        });\n        return ranges.some((range) => offense.start.index >= range.from && (!range.to || offense.end.index <= range.to));\n    }\n    return {\n        DisabledChecksVisitor,\n        isDisabled,\n    };\n}\nexports.createDisabledChecksModule = createDisabledChecksModule;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findRoot = void 0;\nconst path = __importStar(require(\"./path\"));\nasync function isRoot(dir, fileExists) {\n    return or(fileExists(path.join(dir, 'shopify.extension.toml')), // for theme-app-extensions\n    fileExists(path.join(dir, '.theme-check.yml')), fileExists(path.join(dir, '.git')), \n    // zip files and TAEs might not have config files, but they should have a\n    // snippets directory but in case they do specify a .theme-check.yml a\n    // couple of directories up, we should respect that\n    and(fileExists(path.join(dir, 'snippets')), not(fileExists(path.join(path.dirname(dir), '.theme-check.yml'))), not(fileExists(path.join(path.dirname(path.dirname(dir)), '.theme-check.yml')))));\n}\nasync function and(...promises) {\n    const bools = await Promise.all(promises);\n    return bools.reduce((a, b) => a && b, true);\n}\nasync function or(...promises) {\n    const bools = await Promise.all(promises);\n    return bools.reduce((a, b) => a || b, false);\n}\nasync function not(ap) {\n    const a = await ap;\n    return !a;\n}\n/**\n * Returns the \"root\" of a theme or theme app extension. The root is the\n * directory that contains a `.theme-check.yml` file, a `.git` directory, or a\n * `shopify.extension.toml` file.\n *\n * There are cases where .theme-check.yml is not defined and we have to infer the root.\n * We'll assume that the root is the directory that contains a `snippets` directory.\n *\n * So you can think of this function as the function that infers where a .theme-check.yml\n * should be.\n *\n * Note: that this is not the theme root. The config file might have a `root` entry in it\n * that points to somewhere else.\n */\nasync function findRoot(curr, fileExists) {\n    const currIsRoot = await isRoot(curr, fileExists);\n    if (currIsRoot) {\n        return curr;\n    }\n    const dir = path.dirname(curr);\n    const currIsAbsoluteRoot = dir === curr;\n    if (currIsAbsoluteRoot) {\n        return curr;\n    }\n    return findRoot(dir, fileExists);\n}\nexports.findRoot = findRoot;\n//# sourceMappingURL=find-root.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyFixToString = void 0;\nconst utils_1 = require(\"./utils\");\n// First iteration imported @codemirror/state to do this but it's kind of\n// a gross dependency. I asked chatGPT to make me something similar and,\n// after a couple of prompts, was surprised to like the result.\n//\n// So here goes:\n// A neat and mean (Source, Fix) => Source function :)\nfunction applyFixToString(source, fix) {\n    // Create a copy of the original string to store the modified result\n    let newStr = source;\n    // Initialize an offset variable to keep track of the changes in index\n    // due to previous fixes. This is necessary because each modification\n    // is assumed to be to the original document, and we need to account for\n    // the index drift caused by previous fixes.\n    let offset = 0;\n    // Sort modifications by startIndex in ascending order to ensure that\n    // modifications with lower indices are applied first. This helps to\n    // maintain the correct index positions for subsequent modifications.\n    const sortedFixes = (0, utils_1.flattenFixes)(fix).sort((a, b) => a.startIndex - b.startIndex);\n    // Verify that the fixes are valid and do not overlap\n    for (let i = 0; i < sortedFixes.length - 1; i++) {\n        const currentFix = sortedFixes[i];\n        const nextFix = sortedFixes[i + 1];\n        // Check if the current fix overlaps with the next fix\n        if (currentFix.endIndex > nextFix.startIndex) {\n            throw new Error('Overlapping ranges are not allowed');\n        }\n    }\n    for (const fix of sortedFixes) {\n        // Drift-adjust the fix location\n        const startIndex = fix.startIndex + offset;\n        const endIndex = fix.endIndex + offset;\n        // Throw an error if either startIndex or endIndex are out of bounds.\n        if (startIndex < 0 ||\n            startIndex > newStr.length ||\n            endIndex < startIndex ||\n            endIndex > newStr.length) {\n            throw new Error('Fix description is going overboard');\n        }\n        // Perform the modification at the drift-adjusted location\n        newStr = newStr.slice(0, startIndex) + fix.insert + newStr.slice(endIndex);\n        // Account for \"index drift\" as the modifications are applied.\n        offset += fix.insert.length - (endIndex - startIndex);\n    }\n    return newStr;\n}\nexports.applyFixToString = applyFixToString;\n//# sourceMappingURL=apply-fix-to-string.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.autofix = void 0;\nconst correctors_1 = require(\"./correctors\");\nconst utils_1 = require(\"./utils\");\n/**\n * Takes a theme, list of offenses and a fixApplicator and runs all the\n * safe ones on the theme.\n *\n * Note that offense.fix is assumed to be safe, unlike offense.suggest\n * options.\n */\nasync function autofix(sourceCodes, offenses, applyFixes) {\n    const fixableOffenses = offenses.filter((offense) => 'fix' in offense && !!offense.fix);\n    const promises = [];\n    for (const sourceCode of sourceCodes) {\n        const sourceCodeOffenses = fixableOffenses.filter((offense) => offense.uri === sourceCode.uri);\n        if (sourceCodeOffenses.length === 0) {\n            continue;\n        }\n        const corrector = (0, correctors_1.createCorrector)(sourceCode.type, sourceCode.source);\n        for (const offense of sourceCodeOffenses) {\n            // I'm being slightly too clever for TypeScript here...\n            offense.fix(corrector);\n        }\n        promises.push(applyFixes(sourceCode, (0, utils_1.flattenFixes)(corrector.fix)));\n    }\n    await Promise.all(promises);\n}\nexports.autofix = autofix;\n//# sourceMappingURL=autofix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createCorrector = exports.StringCorrector = exports.JSONCorrector = void 0;\nconst types_1 = require(\"../../types\");\nconst json_corrector_1 = require(\"./json-corrector\");\nObject.defineProperty(exports, \"JSONCorrector\", { enumerable: true, get: function () { return json_corrector_1.JSONCorrector; } });\nconst string_corrector_1 = require(\"./string-corrector\");\nObject.defineProperty(exports, \"StringCorrector\", { enumerable: true, get: function () { return string_corrector_1.StringCorrector; } });\nfunction createCorrector(sourceCodeType, source) {\n    switch (sourceCodeType) {\n        case types_1.SourceCodeType.JSON: {\n            return new json_corrector_1.JSONCorrector(source);\n        }\n        case types_1.SourceCodeType.LiquidHtml: {\n            return new string_corrector_1.StringCorrector(source);\n        }\n        default: {\n            return assertNever(sourceCodeType);\n        }\n    }\n}\nexports.createCorrector = createCorrector;\nfunction assertNever(x) {\n    throw new Error(`Case statement not exhausted: ${x}`);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONCorrector = void 0;\nconst set_1 = __importDefault(require(\"lodash/set\"));\nconst unset_1 = __importDefault(require(\"lodash/unset\"));\n// This function mutates json. So use it in a reducer and consider it a\n// fire and forget.\nfunction applyPatch(json, operation) {\n    switch (operation.type) {\n        case 'add': {\n            return (0, set_1.default)(json, operation.path, operation.value);\n        }\n        case 'remove': {\n            (0, unset_1.default)(json, operation.path);\n            return json;\n        }\n    }\n}\n/**\n * The JSONCorrector collects patches and then creates a Fix object\n * that represents the application of all the collected patches on the\n * source document.\n *\n * Fixes are assumed to not be overlapping.\n */\nclass JSONCorrector {\n    constructor(source) {\n        this.source = source;\n        this.patches = [];\n    }\n    /**\n     * corrector.fix is the data representation of all the changes to source.\n     */\n    get fix() {\n        if (this.patches.length === 0)\n            return [];\n        const json = this.patches.reduce(applyPatch, JSON.parse(this.source));\n        return {\n            startIndex: 0,\n            endIndex: this.source.length,\n            insert: JSON.stringify(json, null, 2),\n        };\n    }\n    /**\n     * Add value at dot delited JSON path\n     *\n     * @example\n     * corrector.add('missing.key', 'TO DO')\n     */\n    add(path, value) {\n        this.patches.push({\n            type: 'add',\n            path,\n            value,\n        });\n    }\n    /**\n     * Replace a value at dot delited JSON path.\n     *\n     * @example\n     * corrector.replace('missing.key', 'TO DO')\n     */\n    replace(path, value) {\n        this.patches.push({\n            type: 'remove',\n            path,\n        }, {\n            type: 'add',\n            path,\n            value,\n        });\n    }\n    /**\n     * Remove key from JSON object\n     *\n     * @example\n     * corrector.remove('unneeded.key')\n     */\n    remove(path) {\n        this.patches.push({\n            type: 'remove',\n            path,\n        });\n    }\n}\nexports.JSONCorrector = JSONCorrector;\n//# sourceMappingURL=json-corrector.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringCorrector = void 0;\n/**\n * The corrector is a helper that collects Fix objects. At the end we\n * collect those fix objects and apply them on the source code to obtain a\n * \"fixed\" file.\n *\n * We cannot fix on overlapping ranges.\n *\n * All fix are assumed to be on the file without modifications. The\n * FixApplicator should take care of knowing where to apply fixes as the\n * changes are applied.\n */\nclass StringCorrector {\n    constructor(source) {\n        this.source = source;\n        this.fix = [];\n    }\n    /**\n     * insert text before the given index\n     *\n     * @example\n     * corrector.insert(\n     *   node.position.start,\n     *   node.position.start,\n     *   'prefix node with this content'\n     * )\n     *\n     * corrector.insert(\n     *   node.position.end,\n     *   node.position.end,\n     *   'suffix node with this content (since position.end is excluded)'\n     * )\n     */\n    insert(index, text) {\n        this.fix.push({\n            startIndex: index,\n            endIndex: index,\n            insert: text,\n        });\n    }\n    /**\n     * replace text between start (included) and end (excluded) with text.\n     *\n     * @example\n     * corrector.replace(\n     *   node.position.start,\n     *   node.position.end,\n     *   'ho ho ho',\n     * );\n     */\n    replace(start, end, text) {\n        this.fix.push({\n            startIndex: start,\n            endIndex: end,\n            insert: text,\n        });\n    }\n    /**\n     * remove text between start (included) and end (excluded)\n     *\n     * @example\n     * corrector.remove(\n     *   node.position.start,\n     *   node.position.end,\n     * )\n     */\n    remove(start, end) {\n        this.fix.push({\n            startIndex: start,\n            endIndex: end,\n            insert: '',\n        });\n    }\n}\nexports.StringCorrector = StringCorrector;\n//# sourceMappingURL=string-corrector.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyFixToString = exports.autofix = exports.createCorrector = exports.JSONCorrector = exports.StringCorrector = exports.flattenFixes = void 0;\nvar utils_1 = require(\"./utils\");\nObject.defineProperty(exports, \"flattenFixes\", { enumerable: true, get: function () { return utils_1.flattenFixes; } });\nvar correctors_1 = require(\"./correctors\");\nObject.defineProperty(exports, \"StringCorrector\", { enumerable: true, get: function () { return correctors_1.StringCorrector; } });\nObject.defineProperty(exports, \"JSONCorrector\", { enumerable: true, get: function () { return correctors_1.JSONCorrector; } });\nObject.defineProperty(exports, \"createCorrector\", { enumerable: true, get: function () { return correctors_1.createCorrector; } });\nvar autofix_1 = require(\"./autofix\");\nObject.defineProperty(exports, \"autofix\", { enumerable: true, get: function () { return autofix_1.autofix; } });\nvar apply_fix_to_string_1 = require(\"./apply-fix-to-string\");\nObject.defineProperty(exports, \"applyFixToString\", { enumerable: true, get: function () { return apply_fix_to_string_1.applyFixToString; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.flattenFixes = void 0;\nfunction flattenFixes(fix) {\n    if (!Array.isArray(fix))\n        return [fix];\n    return fix.flatMap(flattenFixes);\n}\nexports.flattenFixes = flattenFixes;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isIgnored = void 0;\nconst minimatch_1 = require(\"minimatch\");\nfunction isIgnored(uri, config, checkDef) {\n    const ignorePatterns = [...checkIgnorePatterns(checkDef, config), ...asArray(config.ignore)].map((pattern) => pattern\n        .replace(/^\\//, config.rootUri + '/') // \"absolute patterns\" are config.rootUri matches\n        .replace(/^([^\\/])/, '**/$1') // \"relative patterns\" are \"**/${pattern}\"\n        .replace(/\\/\\*$/, '/**'));\n    return ignorePatterns.some((pattern) => (0, minimatch_1.minimatch)(uri, pattern));\n}\nexports.isIgnored = isIgnored;\nfunction checkIgnorePatterns(checkDef, config) {\n    var _a;\n    if (!checkDef)\n        return [];\n    return asArray((_a = config.settings[checkDef.meta.code]) === null || _a === void 0 ? void 0 : _a.ignore);\n}\nfunction asArray(x) {\n    return x !== null && x !== void 0 ? x : [];\n}\n//# sourceMappingURL=ignore.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.check = exports.path = void 0;\nconst AugmentedThemeDocset_1 = require(\"./AugmentedThemeDocset\");\nconst JSONValidator_1 = require(\"./JSONValidator\");\nconst context_utils_1 = require(\"./context-utils\");\nconst disabled_checks_1 = require(\"./disabled-checks\");\nconst ignore_1 = require(\"./ignore\");\nconst path = __importStar(require(\"./path\"));\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst visitors_1 = require(\"./visitors\");\n__exportStar(require(\"./AbstractFileSystem\"), exports);\n__exportStar(require(\"./AugmentedThemeDocset\"), exports);\n__exportStar(require(\"./checks\"), exports);\n__exportStar(require(\"./context-utils\"), exports);\n__exportStar(require(\"./find-root\"), exports);\n__exportStar(require(\"./fixes\"), exports);\n__exportStar(require(\"./ignore\"), exports);\n__exportStar(require(\"./json\"), exports);\n__exportStar(require(\"./JSONValidator\"), exports);\nexports.path = __importStar(require(\"./path\"));\n__exportStar(require(\"./to-schema\"), exports);\n__exportStar(require(\"./to-source-code\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./utils/error\"), exports);\n__exportStar(require(\"./utils/indexBy\"), exports);\n__exportStar(require(\"./utils/memo\"), exports);\n__exportStar(require(\"./utils/types\"), exports);\n__exportStar(require(\"./utils/object\"), exports);\n__exportStar(require(\"./visitor\"), exports);\n__exportStar(require(\"./liquid-doc/liquidDoc\"), exports);\n__exportStar(require(\"./liquid-doc/utils\"), exports);\nconst defaultErrorHandler = (_error) => {\n    // Silently ignores errors by default.\n};\nasync function check(theme, config, injectedDependencies) {\n    var _a;\n    const pipelines = [];\n    const offenses = [];\n    const { fs } = injectedDependencies;\n    const { rootUri } = config;\n    const dependencies = {\n        ...injectedDependencies,\n        mode: config.context,\n        fileExists: (0, context_utils_1.makeFileExists)(fs),\n        fileSize: (0, context_utils_1.makeFileSize)(fs),\n        getDefaultLocale: (0, context_utils_1.makeGetDefaultLocale)(fs, rootUri),\n        getDefaultTranslations: (0, context_utils_1.makeGetDefaultTranslations)(fs, theme, rootUri),\n        getDefaultSchemaLocale: (0, context_utils_1.makeGetDefaultSchemaLocale)(fs, rootUri),\n        getDefaultSchemaTranslations: (0, context_utils_1.makeGetDefaultSchemaTranslations)(fs, theme, rootUri),\n        getMetafieldDefinitions: (_a = injectedDependencies.getMetafieldDefinitions) !== null && _a !== void 0 ? _a : (0, context_utils_1.makeGetMetafieldDefinitions)(fs),\n    };\n    const { DisabledChecksVisitor, isDisabled } = (0, disabled_checks_1.createDisabledChecksModule)();\n    const jsonValidator = await JSONValidator_1.JSONValidator.create(dependencies.jsonValidationSet, config);\n    const validateJSON = jsonValidator === null || jsonValidator === void 0 ? void 0 : jsonValidator.validate;\n    // We're memozing those deps here because they shouldn't change within a run.\n    if (dependencies.themeDocset && !dependencies.themeDocset.isAugmented) {\n        dependencies.themeDocset = new AugmentedThemeDocset_1.AugmentedThemeDocset(dependencies.themeDocset);\n    }\n    for (const type of Object.values(types_1.SourceCodeType)) {\n        switch (type) {\n            case types_1.SourceCodeType.JSON: {\n                const files = filesOfType(type, theme);\n                const checkDefs = checksOfType(type, config.checks);\n                for (const file of files) {\n                    for (const checkDef of checkDefs) {\n                        if ((0, ignore_1.isIgnored)(file.uri, config, checkDef))\n                            continue;\n                        const check = createCheck(checkDef, file, config, offenses, dependencies, validateJSON);\n                        pipelines.push(checkJSONFile(check, file));\n                    }\n                }\n                break;\n            }\n            case types_1.SourceCodeType.LiquidHtml: {\n                const files = filesOfType(type, theme);\n                const checkDefs = [DisabledChecksVisitor, ...checksOfType(type, config.checks)];\n                for (const file of files) {\n                    for (const checkDef of checkDefs) {\n                        if ((0, ignore_1.isIgnored)(file.uri, config, checkDef))\n                            continue;\n                        const check = createCheck(checkDef, file, config, offenses, dependencies, validateJSON);\n                        pipelines.push(checkLiquidFile(check, file));\n                    }\n                }\n                break;\n            }\n        }\n    }\n    const onRejected = config.onError || defaultErrorHandler;\n    await Promise.all(pipelines.map((pipeline) => pipeline.catch(onRejected)));\n    return offenses.filter((offense) => !isDisabled(offense));\n}\nexports.check = check;\nfunction createContext(check, file, offenses, config, dependencies, validateJSON) {\n    const checkSettings = config.settings[check.meta.code];\n    return {\n        ...dependencies,\n        validateJSON,\n        settings: createSettings(checkSettings, check.meta.schema),\n        toUri: (relativePath) => path.join(config.rootUri, relativePath),\n        toRelativePath: (uri) => path.relative(uri, config.rootUri),\n        report(problem) {\n            var _a;\n            offenses.push({\n                type: check.meta.type,\n                check: check.meta.code,\n                message: problem.message,\n                uri: file.uri,\n                severity: (_a = checkSettings === null || checkSettings === void 0 ? void 0 : checkSettings.severity) !== null && _a !== void 0 ? _a : check.meta.severity,\n                start: (0, utils_1.getPosition)(file.source, problem.startIndex),\n                end: (0, utils_1.getPosition)(file.source, problem.endIndex),\n                fix: problem.fix,\n                suggest: problem.suggest,\n            });\n        },\n        file,\n    };\n}\nfunction createSettings(checkSettings, schema) {\n    var _a;\n    const settings = {};\n    for (const [key, schemaProp] of Object.entries(schema)) {\n        settings[key] = (_a = checkSettings === null || checkSettings === void 0 ? void 0 : checkSettings[key]) !== null && _a !== void 0 ? _a : schemaProp.defaultValue();\n    }\n    return settings;\n}\nfunction checksOfType(type, checks) {\n    return checks.filter((def) => def.meta.type === type);\n}\nfunction createCheck(check, file, config, offenses, dependencies, validateJSON) {\n    const context = createContext(check, file, offenses, config, dependencies, validateJSON);\n    return check.create(context);\n}\nfunction filesOfType(type, sourceCodes) {\n    return sourceCodes.filter((file) => file.type === type);\n}\nasync function checkJSONFile(check, file) {\n    if (check.onCodePathStart)\n        await check.onCodePathStart(file);\n    if (file.ast instanceof Error)\n        return;\n    if (Object.keys(check).length > 0)\n        await (0, visitors_1.visitJSON)(file.ast, check);\n    if (check.onCodePathEnd)\n        await check.onCodePathEnd(file);\n}\nasync function checkLiquidFile(check, file) {\n    if (check.onCodePathStart)\n        await check.onCodePathStart(file);\n    if (file.ast instanceof Error)\n        return;\n    if (Object.keys(check).length > 0)\n        await (0, visitors_1.visitLiquid)(file.ast, check);\n    if (check.onCodePathEnd)\n        await check.onCodePathEnd(file);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLocEnd = exports.getLocStart = exports.nodeAtPath = exports.parseJSON = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"./utils\");\nconst PARSE_OPTS = {\n    disallowComments: false,\n    allowTrailingComma: true,\n    allowEmptyContent: false,\n};\nfunction parseJSON(source, defaultValue, isStrict) {\n    try {\n        /**\n         * The jsonc-parser is fault-tolerant and typically returns a valid\n         * result. However, it also mutates the 'errors' array with any\n         * errors it encounters during parsing.\n         */\n        const errors = [];\n        const result = (0, jsonc_parser_1.parse)(source, errors, PARSE_OPTS);\n        if (errors.length && isStrict) {\n            throw errors[0];\n        }\n        return result;\n    }\n    catch (error) {\n        if (defaultValue !== undefined)\n            return defaultValue;\n        return (0, utils_1.asError)(error);\n    }\n}\nexports.parseJSON = parseJSON;\n/**\n * Given a known path to a property and an ast, returns the AST node at that path.\n *\n * @example\n * const nameNode = nodeAtPath(ast, ['name'])! as LiteralNode;\n * const blocksNode = nodeAtPath(ast, ['blocks'])! as ArrayNode;\n * const someDeepNode = nodeAtPath(ast, ['blocks', 0, 'settings', 'someDeepKey'])! as LiteralNode;\n */\nfunction nodeAtPath(node, path) {\n    return path.reduce((acc, key) => {\n        if (!acc)\n            return;\n        switch (acc.type) {\n            case 'Object': {\n                const property = acc.children.find((child) => child.key.value === key);\n                if (!property)\n                    return;\n                return property.value;\n            }\n            case 'Array': {\n                return acc.children[key];\n            }\n            case 'Literal': {\n                // You're probably going too deep\n                return;\n            }\n            case 'Identifier': {\n                // This is for keys, shouldn't get there\n                return;\n            }\n            case 'Property': {\n                // This is for keys, shouldn't get there\n                return;\n            }\n        }\n    }, node);\n}\nexports.nodeAtPath = nodeAtPath;\n/** Given a JSONNode, returns the start offset of the node in the source string. */\nfunction getLocStart(node) {\n    var _a, _b;\n    return (_b = (_a = node.loc) === null || _a === void 0 ? void 0 : _a.start.offset) !== null && _b !== void 0 ? _b : 0;\n}\nexports.getLocStart = getLocStart;\n/** Given a JSONNode, returns the end offset of the node in the source string. */\nfunction getLocEnd(node) {\n    var _a, _b;\n    return (_b = (_a = node.loc) === null || _a === void 0 ? void 0 : _a.end.offset) !== null && _b !== void 0 ? _b : 0;\n}\nexports.getLocEnd = getLocEnd;\n//# sourceMappingURL=json.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.location = exports.toJSONNode = exports.JSONCParseErrors = void 0;\nconst utils_1 = require(\"../utils\");\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nclass JSONCParseErrors extends Error {\n    constructor(message, errors) {\n        super(message);\n        this.errors = errors;\n    }\n}\nexports.JSONCParseErrors = JSONCParseErrors;\n/**\n * At some point, we started supporting JSONC. Theme Check 2 was built on top of\n * `json-to-ast` which does not support comments.\n *\n * This little adapter here will take a tree we get from `jsonc-parser` and\n * convert it to the shape of `json-to-ast`.\n *\n * The `json-to-ast` types feel much better to use than the ones from `jsonc-parser`\n * and we don't need to rewrite all our downstream code.\n */\nfunction toJSONNode(source) {\n    const errors = [];\n    const tree = (0, jsonc_parser_1.parseTree)(source, errors, {\n        allowTrailingComma: true,\n        disallowComments: false,\n    });\n    if (errors.length || tree === undefined) {\n        throw new JSONCParseErrors('Failed to parse JSONC', errors);\n    }\n    return jsoncToJsonAst(tree);\n}\nexports.toJSONNode = toJSONNode;\nfunction jsoncToJsonAst(node) {\n    switch (node.type) {\n        case 'object': {\n            return objectToObjectNode(node);\n        }\n        case 'property': {\n            return propertyToPropertyNode(node);\n        }\n        case 'array': {\n            return arrayToArrayNode(node);\n        }\n        case 'boolean':\n        case 'null':\n        case 'number':\n        case 'string': {\n            return valueToLiteralNode(node);\n        }\n        default: {\n            (0, utils_1.assertNever)(node.type);\n        }\n    }\n}\nfunction objectToObjectNode(node) {\n    var _a;\n    return {\n        type: 'Object',\n        children: ((_a = node.children) !== null && _a !== void 0 ? _a : []).map(jsoncToJsonAst),\n        loc: (0, exports.location)(node.offset, node.offset + node.length),\n    };\n}\nfunction arrayToArrayNode(node) {\n    return {\n        type: 'Array',\n        children: node.children.map(jsoncToJsonAst),\n        loc: (0, exports.location)(node.offset, node.offset + node.length),\n    };\n}\nfunction propertyToPropertyNode(node) {\n    return {\n        type: 'Property',\n        key: identifierToIdentifierNode(node.children[0]),\n        value: jsoncToJsonAst(node.children[1]),\n        loc: (0, exports.location)(node.offset, node.offset + node.length),\n    };\n}\nfunction identifierToIdentifierNode(node) {\n    return {\n        type: 'Identifier',\n        value: node.value,\n        raw: JSON.stringify(node.value),\n        loc: (0, exports.location)(node.offset, node.offset + node.length),\n    };\n}\nfunction valueToLiteralNode(node) {\n    return {\n        type: 'Literal',\n        value: node.value,\n        raw: JSON.stringify(node.value),\n        loc: (0, exports.location)(node.offset, node.offset + node.length),\n    };\n}\nconst location = (start, end) => ({\n    start: position(start),\n    end: position(end),\n});\nexports.location = location;\nconst position = (offset) => ({ offset });\n//# sourceMappingURL=parse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSnippetDefinition = void 0;\nconst visitor_1 = require(\"../visitor\");\nfunction getSnippetDefinition(snippet, snippetName) {\n    let hasDocTag = false;\n    const nodes = (0, visitor_1.visit)(snippet, {\n        LiquidRawTag(node) {\n            if (node.name === 'doc')\n                hasDocTag = true;\n            return undefined;\n        },\n        LiquidDocParamNode(node) {\n            var _a, _b, _c, _d;\n            return {\n                name: node.paramName.value,\n                description: (_b = (_a = node.paramDescription) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : null,\n                type: (_d = (_c = node.paramType) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : null,\n                required: node.required,\n                nodeType: 'param',\n            };\n        },\n        LiquidDocExampleNode(node) {\n            return {\n                content: node.content.value,\n                nodeType: 'example',\n            };\n        },\n    });\n    const { parameters, examples } = nodes.reduce((acc, node) => {\n        if (node.nodeType === 'param') {\n            acc.parameters.push(node);\n        }\n        else if (node.nodeType === 'example') {\n            acc.examples.push(node);\n        }\n        return acc;\n    }, { parameters: [], examples: [] });\n    if (!hasDocTag)\n        return { name: snippetName };\n    return {\n        name: snippetName,\n        liquidDoc: {\n            ...(parameters.length && { parameters }),\n            ...(examples.length && { examples }),\n        },\n    };\n}\nexports.getSnippetDefinition = getSnippetDefinition;\n//# sourceMappingURL=liquidDoc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultValueForType = exports.SupportedDocTagTypes = exports.SupportedParamTypes = void 0;\nvar SupportedParamTypes;\n(function (SupportedParamTypes) {\n    SupportedParamTypes[\"String\"] = \"string\";\n    SupportedParamTypes[\"Number\"] = \"number\";\n    SupportedParamTypes[\"Boolean\"] = \"boolean\";\n    SupportedParamTypes[\"Object\"] = \"object\";\n})(SupportedParamTypes = exports.SupportedParamTypes || (exports.SupportedParamTypes = {}));\nvar SupportedDocTagTypes;\n(function (SupportedDocTagTypes) {\n    SupportedDocTagTypes[\"Param\"] = \"param\";\n    SupportedDocTagTypes[\"Example\"] = \"example\";\n    SupportedDocTagTypes[\"Description\"] = \"description\";\n})(SupportedDocTagTypes = exports.SupportedDocTagTypes || (exports.SupportedDocTagTypes = {}));\n/**\n * Provides a default completion value for an argument / parameter of a given type.\n */\nfunction getDefaultValueForType(type) {\n    switch (type === null || type === void 0 ? void 0 : type.toLowerCase()) {\n        case SupportedParamTypes.String:\n            return \"''\";\n        case SupportedParamTypes.Number:\n            return '0';\n        case SupportedParamTypes.Boolean:\n            return 'false';\n        case SupportedParamTypes.Object:\n            return 'empty';\n        default:\n            return \"''\";\n    }\n}\nexports.getDefaultValueForType = getDefaultValueForType;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fsPath = exports.basename = exports.dirname = exports.normalize = exports.resolve = exports.join = exports.relative = exports.Utils = exports.URI = void 0;\nconst vscode_uri_1 = require(\"vscode-uri\");\nObject.defineProperty(exports, \"URI\", { enumerable: true, get: function () { return vscode_uri_1.URI; } });\nObject.defineProperty(exports, \"Utils\", { enumerable: true, get: function () { return vscode_uri_1.Utils; } });\nfunction relative(uri, rootUri) {\n    return normalize(uri)\n        .replace(rootUri, '')\n        .replace(/\\\\\\\\/g, '/') // We expect forward slash paths (windows path get normalized)\n        .replace(/^\\/+/, '');\n}\nexports.relative = relative;\nfunction join(rootUri, ...paths) {\n    return normalize(vscode_uri_1.Utils.joinPath(asUri(rootUri), ...paths));\n}\nexports.join = join;\nfunction resolve(uri, path) {\n    return normalize(vscode_uri_1.Utils.resolvePath(asUri(uri), path));\n}\nexports.resolve = resolve;\nfunction normalize(uri) {\n    return asUri(uri).toString(true);\n}\nexports.normalize = normalize;\nfunction dirname(uri) {\n    return normalize(vscode_uri_1.Utils.dirname(asUri(uri)));\n}\nexports.dirname = dirname;\nfunction basename(uri, ext) {\n    const base = vscode_uri_1.Utils.basename(asUri(uri));\n    return ext ? base.replace(new RegExp(`${ext}$`), '') : base;\n}\nexports.basename = basename;\nfunction fsPath(uri) {\n    return asUri(uri).fsPath;\n}\nexports.fsPath = fsPath;\nfunction asUri(uri) {\n    return vscode_uri_1.URI.isUri(uri) ? uri : vscode_uri_1.URI.parse(uri);\n}\n//# sourceMappingURL=path.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaFromJSON = exports.getSchema = exports.toAppBlockSchema = exports.toSectionSchema = exports.toBlockSchema = exports.isSectionSchema = exports.isBlockSchema = exports.isSection = exports.isBlock = exports.toSchema = void 0;\nconst json_1 = require(\"./json\");\nconst path = __importStar(require(\"./path\"));\nconst to_source_code_1 = require(\"./to-source-code\");\nconst types_1 = require(\"./types\");\nconst visitor_1 = require(\"./visitor\");\nasync function toSchema(mode, uri, sourceCode, isValidSchema, isStrict = true) {\n    if (sourceCode.type !== types_1.SourceCodeType.LiquidHtml)\n        return undefined;\n    switch (true) {\n        case mode === 'app' && isBlock(uri):\n            return toAppBlockSchema(uri, sourceCode.ast, isStrict);\n        case mode === 'theme' && isBlock(uri):\n            return toBlockSchema(uri, sourceCode.ast, isValidSchema, isStrict);\n        case mode === 'theme' && isSection(uri):\n            return toSectionSchema(uri, sourceCode.ast, isValidSchema, isStrict);\n        default:\n            return undefined;\n    }\n}\nexports.toSchema = toSchema;\nfunction isBlock(uri) {\n    return path.dirname(uri).endsWith('blocks');\n}\nexports.isBlock = isBlock;\nfunction isSection(uri) {\n    return path.dirname(uri).endsWith('sections');\n}\nexports.isSection = isSection;\nfunction isBlockSchema(schema) {\n    return (schema === null || schema === void 0 ? void 0 : schema.type) === types_1.ThemeSchemaType.Block;\n}\nexports.isBlockSchema = isBlockSchema;\nfunction isSectionSchema(schema) {\n    return (schema === null || schema === void 0 ? void 0 : schema.type) === types_1.ThemeSchemaType.Section;\n}\nexports.isSectionSchema = isSectionSchema;\nasync function toValidSchema(uri, schemaNode, parsed, isValidSchema) {\n    if (!isValidSchema)\n        return new Error('No JSON validator provided');\n    if (schemaNode instanceof Error)\n        return parsed;\n    if (await isValidSchema(uri, schemaNode.body.value)) {\n        return parsed;\n    }\n    else {\n        return new Error('Invalid schema');\n    }\n}\nasync function toBlockSchema(uri, liquidAst, isValidSchema, isStrict) {\n    const name = path.basename(uri, '.liquid');\n    const schemaNode = toSchemaNode(liquidAst);\n    const parsed = toParsed(schemaNode, isStrict);\n    const ast = toAst(schemaNode);\n    return {\n        type: types_1.ThemeSchemaType.Block,\n        validSchema: await toValidSchema(uri, schemaNode, parsed, isValidSchema),\n        offset: schemaNode instanceof Error ? 0 : schemaNode.blockStartPosition.end,\n        name,\n        parsed,\n        ast,\n        value: schemaNode instanceof Error ? '' : schemaNode.body.value,\n    };\n}\nexports.toBlockSchema = toBlockSchema;\n// Coincidentally very similar right now... but could be different in the future\n// given there might be a plan to support folders in the blocks folder.\n// e.g. if we start having a stricter \"parsed\" object / ways to get settings.\nasync function toSectionSchema(uri, liquidAst, isValidSchema, isStrict) {\n    const name = path.basename(uri, '.liquid');\n    const schemaNode = toSchemaNode(liquidAst);\n    const parsed = toParsed(schemaNode, isStrict);\n    const ast = toAst(schemaNode);\n    return {\n        type: types_1.ThemeSchemaType.Section,\n        validSchema: await toValidSchema(uri, schemaNode, parsed, isValidSchema),\n        offset: schemaNode instanceof Error ? 0 : schemaNode.blockStartPosition.end,\n        name,\n        parsed,\n        ast,\n        value: schemaNode instanceof Error ? '' : schemaNode.body.value,\n    };\n}\nexports.toSectionSchema = toSectionSchema;\n// validSchema not implemented yet. You can still `visit` the ast.\nasync function toAppBlockSchema(uri, liquidAst, isStrict) {\n    const name = path.basename(uri, '.liquid');\n    const schemaNode = toSchemaNode(liquidAst);\n    const parsed = toParsed(schemaNode, isStrict);\n    const ast = toAst(schemaNode);\n    return {\n        type: types_1.ThemeSchemaType.AppBlock,\n        offset: schemaNode instanceof Error ? 0 : schemaNode.blockStartPosition.end,\n        name,\n        parsed,\n        ast,\n        value: schemaNode instanceof Error ? '' : schemaNode.body.value,\n    };\n}\nexports.toAppBlockSchema = toAppBlockSchema;\nfunction toSchemaNode(ast) {\n    var _a;\n    if (ast instanceof Error)\n        return ast;\n    return ((_a = (0, visitor_1.visit)(ast, {\n        LiquidRawTag(node) {\n            if (node.name === 'schema') {\n                return node;\n            }\n        },\n    })[0]) !== null && _a !== void 0 ? _a : new Error('No schema tag found'));\n}\nfunction getSchema(context) {\n    var _a, _b;\n    const name = path.basename(context.file.uri, '.liquid');\n    switch (true) {\n        case isBlock(context.file.uri):\n            return (_a = context.getBlockSchema) === null || _a === void 0 ? void 0 : _a.call(context, name);\n        case isSection(context.file.uri):\n            return (_b = context.getSectionSchema) === null || _b === void 0 ? void 0 : _b.call(context, name);\n        default:\n            return undefined;\n    }\n}\nexports.getSchema = getSchema;\nasync function getSchemaFromJSON(context) {\n    const originalSource = context.file.source;\n    const strippedSource = originalSource.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, '').trim();\n    const offset = originalSource.indexOf(strippedSource);\n    const parsed = (0, json_1.parseJSON)(strippedSource);\n    const ast = (0, to_source_code_1.toJSONAST)(strippedSource);\n    return {\n        parsed,\n        ast,\n        offset,\n    };\n}\nexports.getSchemaFromJSON = getSchemaFromJSON;\nfunction toParsed(schemaNode, isStrict) {\n    if (schemaNode instanceof Error)\n        return schemaNode;\n    return (0, json_1.parseJSON)(schemaNode.body.value, undefined, isStrict);\n}\nfunction toAst(schemaNode) {\n    if (schemaNode instanceof Error)\n        return schemaNode;\n    return (0, to_source_code_1.toJSONAST)(schemaNode.body.value);\n}\n//# sourceMappingURL=to-schema.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toSourceCode = exports.toJSONAST = exports.toLiquidHTMLAST = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst parse_1 = require(\"./jsonc/parse\");\nconst path = __importStar(require(\"./path\"));\nconst types_1 = require(\"./types\");\nconst error_1 = require(\"./utils/error\");\nfunction toLiquidHTMLAST(source) {\n    try {\n        return (0, liquid_html_parser_1.toLiquidHtmlAST)(source);\n    }\n    catch (error) {\n        return (0, error_1.asError)(error);\n    }\n}\nexports.toLiquidHTMLAST = toLiquidHTMLAST;\nfunction toJSONAST(source) {\n    try {\n        return (0, parse_1.toJSONNode)(source);\n    }\n    catch (error) {\n        return (0, error_1.asError)(error);\n    }\n}\nexports.toJSONAST = toJSONAST;\nfunction toSourceCode(uri, source, version) {\n    const isLiquid = uri.endsWith('.liquid');\n    if (isLiquid) {\n        return {\n            uri: path.normalize(uri),\n            source,\n            type: types_1.SourceCodeType.LiquidHtml,\n            ast: toLiquidHTMLAST(source),\n            version,\n        };\n    }\n    else {\n        return {\n            uri: path.normalize(uri),\n            source,\n            type: types_1.SourceCodeType.JSON,\n            ast: toJSONAST(source),\n            version,\n        };\n    }\n}\nexports.toSourceCode = toSourceCode;\n//# sourceMappingURL=to-source-code.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigTarget = exports.Severity = exports.LiquidHtmlNodeTypes = exports.SourceCodeType = exports.Modes = exports.isLiteralNode = exports.isValueNode = exports.isPropertyNode = exports.isArrayNode = exports.isObjectNode = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nObject.defineProperty(exports, \"LiquidHtmlNodeTypes\", { enumerable: true, get: function () { return liquid_html_parser_1.NodeTypes; } });\n__exportStar(require(\"./jsonc/types\"), exports);\n__exportStar(require(\"./types/schema-prop-factory\"), exports);\n__exportStar(require(\"./types/theme-liquid-docs\"), exports);\n__exportStar(require(\"./types/theme-schemas\"), exports);\nconst isObjectNode = (node) => (node === null || node === void 0 ? void 0 : node.type) === 'Object';\nexports.isObjectNode = isObjectNode;\nconst isArrayNode = (node) => (node === null || node === void 0 ? void 0 : node.type) === 'Array';\nexports.isArrayNode = isArrayNode;\nconst isPropertyNode = (node) => (node === null || node === void 0 ? void 0 : node.type) === 'Property';\nexports.isPropertyNode = isPropertyNode;\nconst isValueNode = (node) => (node === null || node === void 0 ? void 0 : node.type) === 'Value';\nexports.isValueNode = isValueNode;\nconst isLiteralNode = (node) => (node === null || node === void 0 ? void 0 : node.type) === 'Literal';\nexports.isLiteralNode = isLiteralNode;\nexports.Modes = ['theme', 'app'];\nvar SourceCodeType;\n(function (SourceCodeType) {\n    SourceCodeType[\"JSON\"] = \"JSON\";\n    SourceCodeType[\"LiquidHtml\"] = \"LiquidHtml\";\n})(SourceCodeType = exports.SourceCodeType || (exports.SourceCodeType = {}));\n/** The severity determines the icon and color of diagnostics */\nvar Severity;\n(function (Severity) {\n    Severity[Severity[\"ERROR\"] = 0] = \"ERROR\";\n    Severity[Severity[\"WARNING\"] = 1] = \"WARNING\";\n    Severity[Severity[\"INFO\"] = 2] = \"INFO\";\n})(Severity = exports.Severity || (exports.Severity = {}));\n/** The yaml configurations to target checks */\nvar ConfigTarget;\n(function (ConfigTarget) {\n    ConfigTarget[\"All\"] = \"all\";\n    ConfigTarget[\"Recommended\"] = \"recommended\";\n    ConfigTarget[\"ThemeAppExtension\"] = \"theme-app-extension\";\n})(ConfigTarget = exports.ConfigTarget || (exports.ConfigTarget = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaProp = void 0;\nclass SchemaProp {\n    constructor(options) {\n        this.options = options;\n    }\n    /** Creates a string setting definition */\n    static string(defaultValue) {\n        return new SchemaProp({ type: 'string', defaultValue });\n    }\n    /** Creates a number setting definition */\n    static number(defaultValue) {\n        return new SchemaProp({ type: 'number', defaultValue });\n    }\n    /** Creates a boolean setting definition */\n    static boolean(defaultValue) {\n        return new SchemaProp({ type: 'boolean', defaultValue });\n    }\n    /**\n     * Creates an object setting definition\n     *\n     * Usage:\n     * ```\n     * const schema = {\n     *   user: SchemaProp.object({\n     *     age: SchemaProp.number(),\n     *     name: SchemaProp.string(),\n     *   })\n     * };\n     * ```\n     *\n     * @returns a schema property definition for an object type\n     */\n    static object(\n    /** The schema of the object's properties */\n    properties, defaultValue) {\n        const schema = new SchemaProp({ type: 'object', defaultValue, properties });\n        return schema;\n    }\n    /**\n     * Creates an array setting definition\n     *\n     * Usage:\n     * ```\n     * const schema = {\n     *   numbers: SchemaProp.array(SchemaProp.number(), [0, 1]),\n     *   strings: SchemaProp.array(SchemaProp.string(), [\"foo\", \"bar\"]),\n     *   users: SchemaProp.array(SchemaProp.object({\n     *    name: SchemaProp.string(),\n     *    age: SchemaProp.number(),\n     *   })),\n     * };\n     * ```\n     *\n     * @param itemType the type of the items in the array\n     * @returns a schema property definition for an object type\n     */\n    static array(\n    /** The schema prop type of the items in the array */\n    itemType, defaultValue) {\n        const schema = new SchemaProp({ type: 'array', defaultValue, itemType });\n        return schema;\n    }\n    /**\n     * A schema prop can be optional, making the setting T | undefined.\n     *\n     * Usage:\n     * ```\n     * const Schema = {\n     *   age: SchemaProp.number().optional(),\n     * }\n     * ```\n     */\n    optional() {\n        this.options.optional = true;\n        return this;\n    }\n    defaultValue() {\n        return this.options.defaultValue;\n    }\n}\nexports.SchemaProp = SchemaProp;\n//# sourceMappingURL=schema-prop-factory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Setting = void 0;\nvar setting_1 = require(\"./setting\");\nObject.defineProperty(exports, \"Setting\", { enumerable: true, get: function () { return setting_1.Setting; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=setting.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=theme-liquid-docs.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThemeSchemaType = void 0;\n__exportStar(require(\"./schemas\"), exports);\nvar ThemeSchemaType;\n(function (ThemeSchemaType) {\n    ThemeSchemaType[\"AppBlock\"] = \"app-block\";\n    ThemeSchemaType[\"Block\"] = \"block\";\n    ThemeSchemaType[\"Section\"] = \"section\";\n})(ThemeSchemaType = exports.ThemeSchemaType || (exports.ThemeSchemaType = {}));\n//# sourceMappingURL=theme-schemas.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findLastAndIndex = exports.findLastIndex = exports.findLast = exports.last = exports.first = void 0;\nfunction first(arr) {\n    return arr[0];\n}\nexports.first = first;\nfunction last(arr, offset = 0) {\n    return arr[arr.length - 1 + offset];\n}\nexports.last = last;\nfunction findLast(array, pred) {\n    return array[findLastIndex(array, pred)];\n}\nexports.findLast = findLast;\nfunction findLastIndex(array, pred) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        if (pred(array[i]))\n            return i;\n    }\n    return -1;\n}\nexports.findLastIndex = findLastIndex;\nfunction findLastAndIndex(array, pred) {\n    const index = findLastIndex(array, pred);\n    return [array[index], index];\n}\nexports.findLastAndIndex = findLastAndIndex;\n//# sourceMappingURL=array.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateBlockFileExistence = exports.reportWarning = exports.validateNestedBlocks = exports.isInvalidPresetBlock = exports.getBlocks = void 0;\nconst json_1 = require(\"../json\");\nconst file_utils_1 = require(\"./file-utils\");\nfunction getBlocks(validSchema) {\n    const rootLevelThemeBlocks = [];\n    const rootLevelLocalBlocks = [];\n    const presetLevelBlocks = {};\n    const rootLevelBlocks = validSchema.blocks;\n    const presets = validSchema.presets;\n    // Helper function to categorize blocks\n    function categorizeRootLevelBlocks(block, index) {\n        if (!block)\n            return;\n        const hasName = 'name' in block;\n        if (hasName) {\n            rootLevelLocalBlocks.push({\n                node: block,\n                path: ['blocks', String(index), 'type'],\n            });\n        }\n        else if (block.type !== '@app') {\n            rootLevelThemeBlocks.push({\n                node: block,\n                path: ['blocks', String(index), 'type'],\n            });\n        }\n    }\n    function categorizePresetLevelBlocks(block, currentPath, depth = 0) {\n        if (!block)\n            return;\n        if (!presetLevelBlocks[depth]) {\n            presetLevelBlocks[depth] = [];\n        }\n        presetLevelBlocks[depth].push({\n            node: block,\n            path: currentPath.concat('type'),\n        });\n        if ('blocks' in block) {\n            if (Array.isArray(block.blocks)) {\n                block.blocks.forEach((nestedBlock, index) => {\n                    categorizePresetLevelBlocks(nestedBlock, currentPath.concat('blocks', String(index)), depth + 1);\n                });\n            }\n            else if (typeof block.blocks === 'object' && block.blocks !== null) {\n                Object.entries(block.blocks).forEach(([key, nestedBlock]) => {\n                    categorizePresetLevelBlocks(nestedBlock, currentPath.concat('blocks', key), depth + 1);\n                });\n            }\n        }\n    }\n    if (Array.isArray(rootLevelBlocks)) {\n        rootLevelBlocks.forEach((block, index) => {\n            categorizeRootLevelBlocks(block, index);\n        });\n    }\n    if (presets) {\n        presets.forEach((preset, presetIndex) => {\n            if ('blocks' in preset && preset.blocks) {\n                if (Array.isArray(preset.blocks)) {\n                    preset.blocks.forEach((block, blockIndex) => {\n                        categorizePresetLevelBlocks(block, ['presets', String(presetIndex), 'blocks', String(blockIndex)], 0);\n                    });\n                }\n                else if (typeof preset.blocks === 'object') {\n                    Object.entries(preset.blocks).forEach(([key, block]) => {\n                        categorizePresetLevelBlocks(block, ['presets', String(presetIndex), 'blocks', key], 0);\n                    });\n                }\n            }\n        });\n    }\n    return {\n        rootLevelThemeBlocks,\n        rootLevelLocalBlocks,\n        presetLevelBlocks,\n    };\n}\nexports.getBlocks = getBlocks;\nfunction isInvalidPresetBlock(blockNode, rootLevelThemeBlocks) {\n    const isPrivateBlockType = blockNode.type.startsWith('_');\n    const isThemeInRootLevel = rootLevelThemeBlocks.some((block) => block.node.type === '@theme');\n    const needsExplicitRootBlock = isPrivateBlockType || !isThemeInRootLevel;\n    const isPresetInRootLevel = rootLevelThemeBlocks.some((block) => block.node.type === blockNode.type);\n    return !isPresetInRootLevel && needsExplicitRootBlock;\n}\nexports.isInvalidPresetBlock = isInvalidPresetBlock;\nfunction validateBlockTargeting(nestedBlock, nestedPath, context, parentNode, rootLevelThemeBlocks, allowedBlockTypes, offset, ast) {\n    const typeNode = (0, json_1.nodeAtPath)(ast, nestedPath);\n    if (typeNode && isInvalidPresetBlock(nestedBlock, rootLevelThemeBlocks)) {\n        const isPrivateBlock = nestedBlock.type.startsWith('_');\n        const errorMessage = isPrivateBlock\n            ? `Private block type \"${nestedBlock.type}\" is not allowed in \"${parentNode.type}\" blocks.`\n            : `Block type \"${nestedBlock.type}\" is not allowed in \"${parentNode.type}\" blocks. Allowed types are: ${allowedBlockTypes.join(', ')}.`;\n        reportWarning(errorMessage, offset, typeNode, context);\n    }\n    if ('blocks' in nestedBlock && nestedBlock.blocks) {\n        validateNestedBlocks(context, nestedBlock, nestedBlock.blocks, nestedPath.slice(0, -1), offset, ast);\n    }\n}\nasync function validateNestedBlocks(context, parentNode, nestedBlocks, currentPath, offset, ast) {\n    var _a;\n    if (!nestedBlocks)\n        return;\n    const parentSchema = await ((_a = context.getBlockSchema) === null || _a === void 0 ? void 0 : _a.call(context, parentNode.type));\n    if (!parentSchema || parentSchema instanceof Error)\n        return;\n    const { validSchema } = parentSchema;\n    if (!validSchema || validSchema instanceof Error)\n        return;\n    const { rootLevelThemeBlocks } = getBlocks(validSchema);\n    const allowedBlockTypes = rootLevelThemeBlocks.map((block) => block.node.type);\n    if (Array.isArray(nestedBlocks)) {\n        nestedBlocks.forEach((nestedBlock, index) => {\n            const nestedPath = currentPath.concat(['blocks', String(index), 'type']);\n            validateBlockTargeting(nestedBlock, nestedPath, context, parentNode, rootLevelThemeBlocks, allowedBlockTypes, offset, ast);\n        });\n    }\n    else if (typeof nestedBlocks === 'object') {\n        Object.entries(nestedBlocks).forEach(([key, nestedBlock]) => {\n            const nestedPath = currentPath.concat(['blocks', key, 'type']);\n            validateBlockTargeting(nestedBlock, nestedPath, context, parentNode, rootLevelThemeBlocks, allowedBlockTypes, offset, ast);\n        });\n    }\n}\nexports.validateNestedBlocks = validateNestedBlocks;\nfunction reportWarning(message, offset, astNode, context) {\n    context.report({\n        message,\n        startIndex: offset + (0, json_1.getLocStart)(astNode),\n        endIndex: offset + (0, json_1.getLocEnd)(astNode),\n    });\n}\nexports.reportWarning = reportWarning;\nasync function validateBlockFileExistence(blockType, context) {\n    if (blockType === '@theme' || blockType === '@app') {\n        return true;\n    }\n    const blockPath = `blocks/${blockType}.liquid`;\n    return await (0, file_utils_1.doesFileExist)(context, blockPath);\n}\nexports.validateBlockFileExistence = validateBlockFileExistence;\n//# sourceMappingURL=block.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asError = exports.isError = void 0;\nconst PARSE_ERROR_MESSAGES = {\n    [1 /* ParseErrorCode.InvalidSymbol */]: 'Invalid symbol found in the input.',\n    [2 /* ParseErrorCode.InvalidNumberFormat */]: 'Invalid number format detected.',\n    [3 /* ParseErrorCode.PropertyNameExpected */]: 'Property name expected but not found.',\n    [4 /* ParseErrorCode.ValueExpected */]: 'A value was expected but not found.',\n    [5 /* ParseErrorCode.ColonExpected */]: 'Colon `:` expected after the property name.',\n    [6 /* ParseErrorCode.CommaExpected */]: 'Comma `,` expected between elements and properties.',\n    [7 /* ParseErrorCode.CloseBraceExpected */]: 'Closing brace `}` expected.',\n    [8 /* ParseErrorCode.CloseBracketExpected */]: 'Closing bracket `]` expected.',\n    [9 /* ParseErrorCode.EndOfFileExpected */]: 'End of file expected.',\n    [10 /* ParseErrorCode.InvalidCommentToken */]: 'Invalid comment token found.',\n    [11 /* ParseErrorCode.UnexpectedEndOfComment */]: 'Unexpected end of comment.',\n    [12 /* ParseErrorCode.UnexpectedEndOfString */]: 'Unexpected end of string.',\n    [13 /* ParseErrorCode.UnexpectedEndOfNumber */]: 'Unexpected end of number.',\n    [14 /* ParseErrorCode.InvalidUnicode */]: 'Invalid Unicode escape sequence.',\n    [15 /* ParseErrorCode.InvalidEscapeCharacter */]: 'Invalid escape character found.',\n    [16 /* ParseErrorCode.InvalidCharacter */]: 'Invalid character found in the input.',\n};\nfunction isError(error) {\n    return error instanceof Error;\n}\nexports.isError = isError;\nfunction asError(error) {\n    if (error instanceof Error) {\n        return error;\n    }\n    if (typeof error === 'string') {\n        return new Error(error);\n    }\n    if (error && typeof error === 'object' && 'error' in error) {\n        return new Error(getParseErrorMessage(error));\n    }\n    if (error && typeof error.toString === 'function') {\n        return new Error(error.toString());\n    }\n    return new Error('An unknown error occurred');\n}\nexports.asError = asError;\nfunction getParseErrorMessage(parseError) {\n    return PARSE_ERROR_MESSAGES[parseError.error] || 'Unknown parse error.';\n}\n//# sourceMappingURL=error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasLocalAssetSizeExceededThreshold = exports.hasRemoteAssetSizeExceededThreshold = exports.getFileSize = exports.doesFileExceedThreshold = exports.doesFileExist = void 0;\nconst cross_fetch_1 = require(\"cross-fetch\");\nasync function doesFileExist(context, relativePath) {\n    const uri = context.toUri(relativePath);\n    return await context.fileExists(uri);\n}\nexports.doesFileExist = doesFileExist;\nasync function doesFileExceedThreshold(context, relativePath, thresholdInBytes) {\n    const uri = context.toUri(relativePath);\n    if (!context.fileSize)\n        return [false, 0];\n    const fileSize = await context.fileSize(uri);\n    return [fileSize > thresholdInBytes, fileSize];\n}\nexports.doesFileExceedThreshold = doesFileExceedThreshold;\nasync function getFileSize(url) {\n    try {\n        const response = await (0, cross_fetch_1.fetch)(url, { method: 'HEAD' });\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const fileSize = response.headers.get('Content-Length');\n        if (fileSize === null)\n            return 0;\n        return parseFloat(fileSize);\n    }\n    catch (error) {\n        return 0;\n    }\n}\nexports.getFileSize = getFileSize;\nasync function hasRemoteAssetSizeExceededThreshold(url, thresholdInBytes) {\n    const fileSize = await getFileSize(url);\n    return fileSize > thresholdInBytes;\n}\nexports.hasRemoteAssetSizeExceededThreshold = hasRemoteAssetSizeExceededThreshold;\nasync function hasLocalAssetSizeExceededThreshold(context, relativePath, thresholdInBytes) {\n    const fileExists = await doesFileExist(context, relativePath);\n    if (!fileExists)\n        return false;\n    const [fileExceedsThreshold, _fileSize] = await doesFileExceedThreshold(context, relativePath, thresholdInBytes);\n    return fileExceedsThreshold;\n}\nexports.hasLocalAssetSizeExceededThreshold = hasLocalAssetSizeExceededThreshold;\n//# sourceMappingURL=file-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./object\"), exports);\n__exportStar(require(\"./array\"), exports);\n__exportStar(require(\"./position\"), exports);\n__exportStar(require(\"./error\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./memo\"), exports);\n__exportStar(require(\"./indexBy\"), exports);\n__exportStar(require(\"./block\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indexBy = void 0;\n/**\n * Returns an Record representation of the collection indexed by keyFn. Assumes\n * the key function returns unique results.\n */\nfunction indexBy(keyFn, collection) {\n    const record = {};\n    for (const item of collection) {\n        record[keyFn(item)] = item;\n    }\n    return record;\n}\nexports.indexBy = indexBy;\n//# sourceMappingURL=indexBy.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isContentForBlock = void 0;\nfunction isContentForBlock(nodeMarkup) {\n    if (typeof nodeMarkup === 'string') {\n        return false;\n    }\n    return nodeMarkup.contentForType.value === 'block';\n}\nexports.isContentForBlock = isContentForBlock;\n//# sourceMappingURL=markup.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoize = exports.memo = void 0;\nconst Unset = Symbol('Unset');\n/** Returns a cached version of a function. Only caches one result. */\nfunction memo(fn) {\n    let cachedValue = Unset;\n    const memoedFunction = (...args) => {\n        if (cachedValue === Unset) {\n            cachedValue = fn(...args);\n        }\n        return cachedValue;\n    };\n    memoedFunction.clearCache = () => {\n        cachedValue = Unset;\n    };\n    return memoedFunction;\n}\nexports.memo = memo;\n/**\n * Returns a function that is cached-by-keyFn(argument)\n *\n * e.g.\n *\n * const expensiveFunction = (thing: Thing) => ...\n * const thingToString = (thing: Thing): string => ...\n * const fastOnSubsequentCalls = memoize(\n *   expensiveFunction,\n *   thingToString,\n * );\n *\n * // slow first run\n * fastOnSubsequentCalls(thing1);\n *\n * // fast subsequent ones\n * fastOnSubsequentCalls(thing1);\n * fastOnSubsequentCalls(thing1);\n */\nfunction memoize(fn, keyFn) {\n    const cache = {};\n    const memoedFunction = (arg) => {\n        const key = keyFn(arg);\n        if (!cache[key]) {\n            cache[key] = fn(arg);\n        }\n        return cache[key];\n    };\n    memoedFunction.force = (arg) => {\n        memoedFunction.invalidate(arg);\n        return memoedFunction(arg);\n    };\n    memoedFunction.invalidate = (arg) => {\n        const key = keyFn(arg);\n        delete cache[key];\n    };\n    return memoedFunction;\n}\nexports.memoize = memoize;\n//# sourceMappingURL=memo.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepGet = void 0;\nfunction deepGet(obj, path) {\n    return path.reduce((acc, key) => acc === null || acc === void 0 ? void 0 : acc[key], obj);\n}\nexports.deepGet = deepGet;\n//# sourceMappingURL=object.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOffset = exports.getPosition = void 0;\nconst line_column_1 = __importDefault(require(\"line-column\"));\nfunction getPosition(source, index) {\n    const lineCol = (0, line_column_1.default)(source, { origin: 0 }).fromIndex(Math.min(index, source.length - 1));\n    return {\n        index,\n        line: lineCol ? lineCol.line : -1,\n        character: lineCol ? lineCol.col : -1,\n    };\n}\nexports.getPosition = getPosition;\nfunction getOffset(source, line, column) {\n    return (0, line_column_1.default)(source, { origin: 1 }).toIndex(line, column);\n}\nexports.getOffset = getOffset;\n//# sourceMappingURL=position.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertNever = void 0;\n/**\n * assertNever(x: never);\n *\n * You use this in the default case of switch statements to make sure you\n * exhaust your discriminated union.\n *\n * If you don't, typescript is going to complain that assertNever is being\n * called with a non-never value.\n *\n * @example\n * switch (fruit.type) {\n *   case BANANA: // ...\n *   case APPLE: // ...\n *   default: return assertNever(fruit.type);\n * }\n */\nfunction assertNever(x) {\n    throw new Error(`We should never reach this code, you are missing a case for ${x}`);\n}\nexports.assertNever = assertNever;\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findCurrentNode = exports.forEachChildNodes = exports.visit = void 0;\nfunction isNode(x) {\n    return x !== null && typeof x === 'object' && typeof x.type === 'string';\n}\n/**\n * @example\n *\n * const links = visit<'LiquidHTML', DocumentLink>(liquidAST, {\n *   'LiquidTag': (node, ancestors) => {\n *     if (node.name === 'render' || node.name === 'include') {\n *       return DocumentLink.create(...);\n *     }\n *   },\n * })\n *\n * Note: this is the ChatGPT-rewritten version of the recursive method.\n * If you want to refactor it, just ask it to do it for you :P\n */\nfunction visit(node, visitor) {\n    const results = [];\n    const stack = [{ node, lineage: [] }];\n    const pushStack = (node, lineage) => stack.push({ node, lineage });\n    while (stack.length > 0) {\n        // Visit current node\n        const { node, lineage } = stack.pop();\n        const visitNode = visitor[node.type];\n        const result = visitNode ? visitNode(node, lineage) : undefined;\n        if (Array.isArray(result)) {\n            results.push(...result);\n        }\n        else if (result !== undefined) {\n            results.push(result);\n        }\n        // Enqueue child nodes\n        forEachChildNodes(node, lineage.concat(node), pushStack);\n    }\n    return results;\n}\nexports.visit = visit;\nfunction forEachChildNodes(node, lineage, execute) {\n    for (const value of Object.values(node)) {\n        if (Array.isArray(value)) {\n            for (let i = value.length - 1; i >= 0; i--) {\n                execute(value[i], lineage);\n            }\n        }\n        else if (isNode(value)) {\n            execute(value, lineage);\n        }\n    }\n}\nexports.forEachChildNodes = forEachChildNodes;\nfunction findCurrentNode(ast, cursorPosition) {\n    let prev;\n    let current = ast;\n    let ancestors = [];\n    while (current !== prev) {\n        prev = current;\n        forEachChildNodes(current, ancestors.concat(current), (child, lineage) => {\n            if (isUnclosed(child) ||\n                (isCovered(child, cursorPosition) && size(child) <= size(current))) {\n                current = child;\n                ancestors = lineage;\n            }\n        });\n    }\n    return [current, ancestors];\n}\nexports.findCurrentNode = findCurrentNode;\nfunction isCovered(node, offset) {\n    return node.position.start < offset && offset <= node.position.end;\n}\nfunction size(node) {\n    return node.position.end - node.position.start;\n}\nfunction isUnclosed(node) {\n    var _a;\n    if ('blockEndPosition' in node) {\n        return ((_a = node.blockEndPosition) === null || _a === void 0 ? void 0 : _a.end) === -1;\n    }\n    else if ('children' in node) {\n        return node.children.length > 0;\n    }\n    return false;\n}\n//# sourceMappingURL=visitor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJSON = exports.visitLiquid = void 0;\nvar liquid_1 = require(\"./liquid\");\nObject.defineProperty(exports, \"visitLiquid\", { enumerable: true, get: function () { return liquid_1.visitLiquid; } });\nvar json_1 = require(\"./json\");\nObject.defineProperty(exports, \"visitJSON\", { enumerable: true, get: function () { return json_1.visitJSON; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJSON = void 0;\nfunction isJSONNode(thing) {\n    return !!thing && typeof thing === 'object' && 'type' in thing;\n}\nconst nonTraversableProperties = new Set(['loc']);\nasync function visitJSON(node, check) {\n    const stack = [{ node, ancestors: [] }];\n    let method;\n    while (stack.length > 0) {\n        const { node, ancestors } = stack.pop();\n        const lineage = ancestors.concat(node);\n        method = check[node.type];\n        if (method)\n            await method(node, ancestors);\n        for (const key in node) {\n            if (!node.hasOwnProperty(key) || nonTraversableProperties.has(key)) {\n                continue;\n            }\n            const value = node[key];\n            if (Array.isArray(value)) {\n                for (let i = value.length - 1; i >= 0; i--) {\n                    const item = value[i];\n                    if (isJSONNode(item)) {\n                        stack.push({ node: item, ancestors: lineage });\n                    }\n                }\n            }\n            else if (isJSONNode(value)) {\n                stack.push({ node: value, ancestors: lineage });\n            }\n        }\n        method = check[`${node.type}:exit`];\n        if (method)\n            await method(node, ancestors);\n    }\n}\nexports.visitJSON = visitJSON;\n//# sourceMappingURL=json.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitLiquid = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nfunction isLiquidHtmlNode(thing) {\n    return !!thing && typeof thing === 'object' && 'type' in thing;\n}\nasync function visitLiquid(node, check) {\n    const stack = [{ node, ancestors: [] }];\n    let method;\n    while (stack.length > 0) {\n        const { node, ancestors } = stack.pop();\n        const lineage = ancestors.concat(node);\n        method = check[node.type];\n        if (method)\n            await method(node, ancestors);\n        for (const key in node) {\n            if (!node.hasOwnProperty(key) || liquid_html_parser_1.nonTraversableProperties.has(key)) {\n                continue;\n            }\n            const value = node[key];\n            if (Array.isArray(value)) {\n                for (let i = value.length - 1; i >= 0; i--) {\n                    const item = value[i];\n                    if (isLiquidHtmlNode(item)) {\n                        stack.push({ node: item, ancestors: lineage });\n                    }\n                }\n            }\n            else if (isLiquidHtmlNode(value)) {\n                stack.push({ node: value, ancestors: lineage });\n            }\n        }\n        method = check[`${node.type}:exit`];\n        if (method)\n            await method(node, ancestors);\n    }\n}\nexports.visitLiquid = visitLiquid;\n//# sourceMappingURL=liquid.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.startServer = exports.getConnection = void 0;\nconst theme_language_server_common_1 = require(\"@shopify/theme-language-server-common\");\nconst browser_1 = require(\"vscode-languageserver/browser\");\n__exportStar(require(\"@shopify/theme-language-server-common\"), exports);\nfunction getConnection(worker) {\n    const reader = new browser_1.BrowserMessageReader(worker);\n    const writer = new browser_1.BrowserMessageWriter(worker);\n    return (0, browser_1.createConnection)(reader, writer);\n}\nexports.getConnection = getConnection;\n// This is where you do the worker.postMessage stuff?\n// Or is this where we accept the worker.postMessage stuff?\n// Yeah I think this is where you _accept_ the worker.postMessage stuff\nfunction startServer(worker, dependencies, connection = getConnection(worker)) {\n    console.info('staging server', worker, dependencies, connection);\n    (0, theme_language_server_common_1.startServer)(connection, dependencies);\n}\nexports.startServer = startServer;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientCapabilities = void 0;\nclass ClientCapabilities {\n    constructor() {\n        this.capabilities = {};\n        this.initializationOptions = {};\n    }\n    setup(capabilities, initializationOptions = {}) {\n        this.capabilities = capabilities;\n        this.initializationOptions = initializationOptions;\n    }\n    get hasWorkspaceConfigurationSupport() {\n        var _a, _b;\n        return !!((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.configuration);\n    }\n    get hasApplyEditSupport() {\n        var _a, _b;\n        return !!((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.applyEdit);\n    }\n    get hasWorkspaceFoldersSupport() {\n        var _a, _b;\n        return !!((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.workspaceFolders);\n    }\n    get hasDidChangeConfigurationDynamicRegistrationSupport() {\n        var _a, _b, _c;\n        return !!((_c = (_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.didChangeConfiguration) === null || _c === void 0 ? void 0 : _c.dynamicRegistration);\n    }\n    get hasDidChangeWatchedFilesDynamicRegistrationSupport() {\n        var _a, _b, _c;\n        return !!((_c = (_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFiles) === null || _c === void 0 ? void 0 : _c.dynamicRegistration);\n    }\n    get hasShowDocumentSupport() {\n        var _a, _b;\n        return !!((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.showDocument);\n    }\n    get hasProgressSupport() {\n        var _a, _b;\n        return !!((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.workDoneProgress);\n    }\n    initializationOption(key, defaultValue) {\n        var _a;\n        // { 'themeCheck.checkOnSave': true }\n        const direct = (_a = this.initializationOptions) === null || _a === void 0 ? void 0 : _a[key];\n        if (direct !== undefined)\n            return direct;\n        // { themeCheck: { checkOnSave: true } }\n        const nested = pathGet(this.initializationOptions, key);\n        if (nested !== undefined)\n            return nested;\n        // fallback\n        return defaultValue;\n    }\n}\nexports.ClientCapabilities = ClientCapabilities;\nfunction pathGet(obj, key) {\n    const path = key.split('.');\n    return path.reduce((acc, subpath) => acc === null || acc === void 0 ? void 0 : acc[subpath], obj);\n}\n//# sourceMappingURL=ClientCapabilities.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isArrayType = exports.docsetEntryReturnType = exports.TypeSystem = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst settings_1 = require(\"./settings\");\nconst utils_1 = require(\"./utils\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nclass TypeSystem {\n    constructor(themeDocset, getThemeSettingsSchemaForURI, getMetafieldDefinitions) {\n        this.themeDocset = themeDocset;\n        this.getThemeSettingsSchemaForURI = getThemeSettingsSchemaForURI;\n        this.getMetafieldDefinitions = getMetafieldDefinitions;\n        /**\n         * An indexed representation of objects.json by name\n         *\n         * e.g. objectMap['product'] returns the product ObjectEntry.\n         */\n        this.objectMap = async (uri, ast) => {\n            var _a, _b, _c, _d;\n            const [objectMap, themeSettingProperties, metafieldDefinitionsObjectMap] = await Promise.all([\n                this._objectMap(),\n                this.themeSettingProperties(uri),\n                this.metafieldDefinitionsObjectMap(uri),\n            ]);\n            // Here we shallow mutate `settings.properties` to have the properties made\n            // available by settings_schema.json\n            const result = {\n                ...objectMap,\n                settings: {\n                    ...((_a = objectMap.settings) !== null && _a !== void 0 ? _a : {}),\n                    properties: themeSettingProperties,\n                },\n                ...customMetafieldTypeEntries(objectMap['metafield']),\n                ...metafieldDefinitionsObjectMap,\n            };\n            // For each metafield definition fetched, we need to override existing types with `metafields` property\n            // to `${category}_metafield`.\n            //\n            // WARNING: Since we aren't cloning the object, we are mutating the original type for all themes in\n            // the workspace. However, this is fine since these changes are not unique to a theme.\n            for (let category of theme_check_common_1.FETCHED_METAFIELD_CATEGORIES) {\n                if (!result[category])\n                    continue;\n                let metafieldsProperty = (_b = result[category].properties) === null || _b === void 0 ? void 0 : _b.find((prop) => prop.name === 'metafields');\n                if (!metafieldsProperty)\n                    continue;\n                metafieldsProperty.return_type = [{ type: `${category}_metafields`, name: '' }];\n            }\n            // Deal with sections/file.liquid section.settings by infering the type from the {% schema %}\n            if (/[\\/\\\\]sections[\\/\\\\]/.test(uri) && result.section) {\n                result.section = JSON.parse(JSON.stringify(result.section)); // easy deep clone\n                const settings = (_c = result.section.properties) === null || _c === void 0 ? void 0 : _c.find((x) => x.name === 'settings');\n                if (!settings || !settings.return_type)\n                    return result;\n                settings.return_type = [{ type: 'section_settings', name: '' }];\n                result.section_settings = {\n                    name: 'section_settings',\n                    access: {\n                        global: false,\n                        parents: [],\n                        template: [],\n                    },\n                    properties: schemaSettingsAsProperties(ast),\n                    return_type: [],\n                };\n            }\n            // Deal with blocks/files.liquid block.settings in a similar fashion\n            if (/[\\/\\\\]blocks[\\/\\\\]/.test(uri) && result.block) {\n                result.block = JSON.parse(JSON.stringify(result.block)); // easy deep clone\n                const settings = (_d = result.block.properties) === null || _d === void 0 ? void 0 : _d.find((x) => x.name === 'settings');\n                if (!settings || !settings.return_type)\n                    return result;\n                settings.return_type = [{ type: 'block_settings', name: '' }];\n                result.block_settings = {\n                    name: 'block_settings',\n                    access: {\n                        global: false,\n                        parents: [],\n                        template: [],\n                    },\n                    properties: schemaSettingsAsProperties(ast),\n                    return_type: [],\n                };\n            }\n            return result;\n        };\n        // This is the big one we reuse (memoized)\n        this._objectMap = (0, utils_1.memo)(async () => {\n            const entries = await this.objectEntries();\n            return entries.reduce((map, entry) => {\n                map[entry.name] = entry;\n                return map;\n            }, {});\n        });\n        /** An indexed representation of filters.json by name */\n        this.filtersMap = (0, utils_1.memo)(async () => {\n            const entries = await this.filterEntries();\n            return entries.reduce((map, entry) => {\n                map[entry.name] = entry;\n                return map;\n            }, {});\n        });\n        this.filterEntries = (0, utils_1.memo)(async () => {\n            return this.themeDocset.filters();\n        });\n        this.objectEntries = (0, utils_1.memo)(async () => {\n            return this.themeDocset.objects();\n        });\n        /**\n         * The seedSymbolsTable contains all the global variables.\n         *\n         * This lets us have the ambient type of things first, but if someone\n         * reassigns product, then we'll be able to change the type of product on\n         * the appropriate range.\n         *\n         * This is not memo'ed because we would otherwise need to clone the thing.\n         */\n        this.seedSymbolsTable = async (uri) => {\n            const [globalVariables, contextualVariables] = await Promise.all([\n                this.globalVariables(),\n                this.contextualVariables(uri),\n            ]);\n            return globalVariables.concat(contextualVariables).reduce((table, objectEntry) => {\n                var _a;\n                var _b;\n                (_a = table[_b = objectEntry.name]) !== null && _a !== void 0 ? _a : (table[_b] = []);\n                table[objectEntry.name].push({\n                    identifier: objectEntry.name,\n                    type: objectEntryType(objectEntry),\n                    range: [0],\n                });\n                return table;\n            }, {});\n        };\n        this.globalVariables = (0, utils_1.memo)(async () => {\n            const entries = await this.objectEntries();\n            return entries.filter((entry) => !entry.access || entry.access.global === true || entry.access.template.length > 0);\n        });\n        this.contextualVariables = async (uri) => {\n            const entries = await this.objectEntries();\n            const contextualEntries = getContextualEntries(uri);\n            return entries.filter((entry) => contextualEntries.includes(entry.name));\n        };\n    }\n    async inferType(thing, partialAst, uri) {\n        const [objectMap, filtersMap, symbolsTable] = await Promise.all([\n            this.objectMap(uri, partialAst),\n            this.filtersMap(),\n            this.symbolsTable(partialAst, uri),\n        ]);\n        return inferType(thing, symbolsTable, objectMap, filtersMap);\n    }\n    async availableVariables(partialAst, partial, node, uri) {\n        const [objectMap, filtersMap, symbolsTable] = await Promise.all([\n            this.objectMap(uri, partialAst),\n            this.filtersMap(),\n            this.symbolsTable(partialAst, uri),\n        ]);\n        return Object.entries(symbolsTable)\n            .filter(([key, typeRanges]) => key.startsWith(partial) &&\n            typeRanges.some((typeRange) => isCorrectTypeRange(typeRange, node)))\n            .map(([identifier, typeRanges]) => {\n            var _a;\n            const typeRange = (0, utils_1.findLast)(typeRanges, (typeRange) => isCorrectTypeRange(typeRange, node));\n            const type = resolveTypeRangeType(typeRange.type, symbolsTable, objectMap, filtersMap);\n            const entry = (_a = objectMap[isArrayType(type) ? type.valueType : type]) !== null && _a !== void 0 ? _a : {};\n            return {\n                entry: { ...entry, name: identifier },\n                type,\n            };\n        });\n    }\n    async themeSettingProperties(uri) {\n        const themeSettingsSchema = await this.getThemeSettingsSchemaForURI(uri);\n        const categories = themeSettingsSchema.filter(settings_1.isSettingsCategory);\n        const result = [];\n        for (const category of categories) {\n            const inputSettings = category.settings.filter(settings_1.isInputSetting);\n            for (const setting of inputSettings) {\n                result.push({\n                    name: setting.id,\n                    summary: '',\n                    description: '',\n                    return_type: settingReturnType(setting),\n                    access: {\n                        global: false,\n                        parents: [],\n                        template: [],\n                    },\n                });\n            }\n        }\n        return result;\n    }\n    async metafieldDefinitionsObjectMap(uri) {\n        let result = {};\n        const metafieldDefinitionMap = await this.getMetafieldDefinitions(uri);\n        for (let [category, definitions] of Object.entries(metafieldDefinitionMap)) {\n            // Metafield definitions need to be grouped by their namespace\n            let metafieldNamespaces = new Map();\n            for (let definition of definitions) {\n                if (!metafieldNamespaces.has(definition.namespace)) {\n                    metafieldNamespaces.set(definition.namespace, []);\n                }\n                metafieldNamespaces.get(definition.namespace).push({\n                    name: definition.key,\n                    description: definition.description,\n                    return_type: metafieldReturnType(definition.type.name),\n                });\n            }\n            let metafieldGroupProperties = [];\n            for (let [namespace, namespaceProperties] of metafieldNamespaces) {\n                const metafieldCategoryNamespaceHandle = `${category}_metafield_${namespace}`;\n                // Since the namespace can be shared by multiple categories, we need to make sure the return_type\n                // handle is unique across all categories\n                metafieldGroupProperties.push({\n                    name: namespace,\n                    return_type: [{ type: metafieldCategoryNamespaceHandle, name: '' }],\n                    access: {\n                        global: false,\n                        parents: [],\n                        template: [],\n                    },\n                });\n                result[metafieldCategoryNamespaceHandle] = {\n                    name: metafieldCategoryNamespaceHandle,\n                    properties: namespaceProperties,\n                    access: {\n                        global: false,\n                        parents: [],\n                        template: [],\n                    },\n                };\n            }\n            const metafieldCategoryHandle = `${category}_metafields`;\n            result[metafieldCategoryHandle] = {\n                name: metafieldCategoryHandle,\n                properties: metafieldGroupProperties,\n                access: {\n                    global: false,\n                    parents: [],\n                    template: [],\n                },\n            };\n        }\n        return result;\n    }\n    async symbolsTable(partialAst, uri) {\n        const seedSymbolsTable = await this.seedSymbolsTable(uri);\n        return buildSymbolsTable(partialAst, seedSymbolsTable);\n    }\n}\nexports.TypeSystem = TypeSystem;\nconst SECTION_FILE_REGEX = /sections[\\/\\\\][^.\\\\\\/]*\\.liquid$/;\nconst BLOCK_FILE_REGEX = /blocks[\\/\\\\][^.\\\\\\/]*\\.liquid$/;\nconst SNIPPET_FILE_REGEX = /snippets[\\/\\\\][^.\\\\\\/]*\\.liquid$/;\nconst LAYOUT_FILE_REGEX = /layout[\\/\\\\]checkout\\.liquid$/;\nfunction getContextualEntries(uri) {\n    const normalizedUri = theme_check_common_1.path.normalize(uri);\n    if (LAYOUT_FILE_REGEX.test(normalizedUri)) {\n        return [\n            'locale',\n            'direction',\n            'skip_to_content_link',\n            'checkout_html_classes',\n            'checkout_stylesheets',\n            'checkout_scripts',\n            'content_for_logo',\n            'breadcrumb',\n            'order_summary_toggle',\n            'content_for_order_summary',\n            'alternative_payment_methods',\n            'content_for_footer',\n            'tracking_code',\n        ];\n    }\n    if (SECTION_FILE_REGEX.test(normalizedUri)) {\n        return ['section', 'predictive_search', 'recommendations', 'comment'];\n    }\n    if (BLOCK_FILE_REGEX.test(normalizedUri)) {\n        return ['app', 'section', 'block'];\n    }\n    if (SNIPPET_FILE_REGEX.test(normalizedUri)) {\n        return ['app'];\n    }\n    return [];\n}\nconst Untyped = 'untyped';\nconst String = 'string';\nconst arrayType = (valueType) => ({\n    kind: 'array',\n    valueType,\n});\nconst lazyVariable = (node, offset) => ({\n    kind: liquid_html_parser_1.NodeTypes.LiquidVariable,\n    node,\n    offset,\n});\nconst LazyDeconstructedExpression = (node, offset) => ({\n    kind: 'deconstructed',\n    node,\n    offset,\n});\nfunction buildSymbolsTable(partialAst, seedSymbolsTable) {\n    const typeRanges = (0, theme_check_common_2.visit)(partialAst, {\n        // {% assign x = foo.x | filter %}\n        AssignMarkup(node) {\n            return {\n                identifier: node.name,\n                type: lazyVariable(node.value, node.position.start),\n                range: [node.position.end],\n            };\n        },\n        // This also covers tablerow\n        ForMarkup(node, ancestors) {\n            var _a;\n            const parentNode = ancestors.at(-1);\n            return {\n                identifier: node.variableName,\n                type: LazyDeconstructedExpression(node.collection, node.position.start),\n                range: [parentNode.blockStartPosition.end, end((_a = parentNode.blockEndPosition) === null || _a === void 0 ? void 0 : _a.end)],\n            };\n        },\n        // {% capture foo %}\n        //   ...\n        // {% endcapture}\n        LiquidTag(node) {\n            var _a, _b;\n            if (node.name === 'capture' && typeof node.markup !== 'string') {\n                return {\n                    identifier: node.markup.name,\n                    type: String,\n                    range: [node.position.end],\n                };\n            }\n            else if (['form', 'paginate'].includes(node.name)) {\n                return {\n                    identifier: node.name,\n                    type: node.name,\n                    range: [node.blockStartPosition.end, end((_a = node.blockEndPosition) === null || _a === void 0 ? void 0 : _a.end)],\n                };\n            }\n            else if (['for', 'tablerow'].includes(node.name)) {\n                return {\n                    identifier: node.name + 'loop',\n                    type: node.name + 'loop',\n                    range: [node.blockStartPosition.end, end((_b = node.blockEndPosition) === null || _b === void 0 ? void 0 : _b.end)],\n                };\n            }\n            else if (isLiquidTagIncrement(node) || isLiquidTagDecrement(node)) {\n                if (node.markup.name === null)\n                    return;\n                return {\n                    identifier: node.markup.name,\n                    type: 'number',\n                    range: [node.position.start],\n                };\n            }\n            else if (node.name === 'layout') {\n                return {\n                    identifier: 'none',\n                    type: 'keyword',\n                    range: [node.position.start, node.position.end],\n                };\n            }\n        },\n    });\n    return typeRanges\n        .sort(({ range: [startA] }, { range: [startB] }) => startA - startB)\n        .reduce((table, typeRange) => {\n        var _a;\n        var _b;\n        (_a = table[_b = typeRange.identifier]) !== null && _a !== void 0 ? _a : (table[_b] = []);\n        table[typeRange.identifier].push(typeRange);\n        return table;\n    }, seedSymbolsTable);\n}\n/**\n * Given a TypeRange['type'] (which may be lazy), resolve its type recursively.\n *\n * The output is a fully resolved PseudoType | ArrayType. Which means we\n * could use it to power completions.\n */\nfunction resolveTypeRangeType(typeRangeType, symbolsTable, objectMap, filtersMap) {\n    if (typeof typeRangeType === 'string') {\n        return typeRangeType;\n    }\n    switch (typeRangeType.kind) {\n        case 'array': {\n            return typeRangeType;\n        }\n        case 'deconstructed': {\n            const arrayType = inferType(typeRangeType.node, symbolsTable, objectMap, filtersMap);\n            if (typeof arrayType === 'string') {\n                return Untyped;\n            }\n            else {\n                return arrayType.valueType;\n            }\n        }\n        default: {\n            return inferType(typeRangeType.node, symbolsTable, objectMap, filtersMap);\n        }\n    }\n}\nfunction inferType(thing, symbolsTable, objectMap, filtersMap) {\n    var _a, _b;\n    if (typeof thing === 'string') {\n        return (_b = (_a = objectMap[thing]) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : Untyped;\n    }\n    switch (thing.type) {\n        case liquid_html_parser_1.NodeTypes.Number: {\n            return 'number';\n        }\n        case liquid_html_parser_1.NodeTypes.String: {\n            return 'string';\n        }\n        case liquid_html_parser_1.NodeTypes.LiquidLiteral: {\n            return 'boolean';\n        }\n        case liquid_html_parser_1.NodeTypes.Range: {\n            return arrayType('number');\n        }\n        // The type of the assign markup is the type of the right hand side.\n        // {% assign x = y.property | filter1 | filter2 %}\n        case liquid_html_parser_1.NodeTypes.AssignMarkup: {\n            return inferType(thing.value, symbolsTable, objectMap, filtersMap);\n        }\n        // A variable lookup is expression[.lookup]*\n        // {{ y.property }}\n        case liquid_html_parser_1.NodeTypes.VariableLookup: {\n            return inferLookupType(thing, symbolsTable, objectMap, filtersMap);\n        }\n        // A variable is the VariableLookup + Filters\n        // The type is the return value of the last filter\n        // {{ y.property | filter1 | filter2 }}\n        case liquid_html_parser_1.NodeTypes.LiquidVariable: {\n            if (thing.filters.length > 0) {\n                const lastFilter = thing.filters.at(-1);\n                const filterEntry = filtersMap[lastFilter.name];\n                return filterEntry ? filterEntryReturnType(filterEntry) : Untyped;\n            }\n            else {\n                return inferType(thing.expression, symbolsTable, objectMap, filtersMap);\n            }\n        }\n        default: {\n            return Untyped;\n        }\n    }\n}\nfunction inferLookupType(thing, symbolsTable, objectMap, filtersMap) {\n    // we return the type of the drop, so a.b.c\n    const node = thing;\n    // We don't complete global lookups. It's too much of an edge case.\n    if (node.name === null)\n        return Untyped;\n    /**\n     * curr stores the type of the variable lookup starting at the beginning.\n     *\n     * It starts as the type of the top-level identifier, and the we\n     * recursively change it to the return type of the lookups.\n     *\n     * So, for x.images.first.src we do:\n     * - curr = infer type of x                   | x\n     * - curr = x.images -> ArrayType<image>      | x.images\n     * - curr = images.first -> image             | x.images.first\n     * - curr = first.src -> string               | x.images.first.src\n     *\n     * Once were done iterating, the type of the lookup is curr.\n     */\n    let curr = inferIdentifierType(node, symbolsTable, objectMap, filtersMap);\n    for (let lookup of node.lookups) {\n        // Here we redefine curr to be the returnType of the lookup.\n        // e.g. images[0] -> image\n        // e.g. images.first -> image\n        // e.g. images.size -> number\n        if (isArrayType(curr)) {\n            curr = inferArrayTypeLookupType(curr, lookup);\n        }\n        // e.g. product.featured_image -> image\n        // e.g. product.images -> ArrayType<images>\n        // e.g. product.name -> string\n        else {\n            curr = inferPseudoTypePropertyType(curr, lookup, objectMap);\n        }\n        // Early return\n        if (curr === Untyped) {\n            return Untyped;\n        }\n    }\n    return curr;\n}\n/**\n * Given a VariableLookup node, infer the type of its root (position-relative).\n *\n * e.g. for the following\n *   {% assign x = product %}\n *   {{ x.images.first }}\n *\n * This function infers the type of `x`.\n */\nfunction inferIdentifierType(node, symbolsTable, objectMap, filtersMap) {\n    // The name of a variable\n    const identifier = node.name;\n    // We don't complete the global access edge case\n    // e.g. {{ ['all_products'] }}\n    if (!identifier) {\n        return Untyped;\n    }\n    const typeRanges = symbolsTable[identifier];\n    if (!typeRanges) {\n        return Untyped;\n    }\n    const typeRange = (0, utils_1.findLast)(typeRanges, (tr) => isCorrectTypeRange(tr, node));\n    return typeRange\n        ? resolveTypeRangeType(typeRange.type, symbolsTable, objectMap, filtersMap)\n        : Untyped;\n}\n/**\n * infers the type of a lookup on an ArrayType\n * - images[0] becomes 'image'\n * - images[index] becomes 'image'\n * - images.first becomes 'image'\n * - images.last becomes 'image'\n * - images.size becomes 'number'\n * - anything else becomes 'untyped'\n */\nfunction inferArrayTypeLookupType(curr, lookup) {\n    // images[0]\n    // images[index]\n    if (lookup.type === liquid_html_parser_1.NodeTypes.Number || lookup.type === liquid_html_parser_1.NodeTypes.VariableLookup) {\n        return curr.valueType;\n    }\n    // images.first\n    // images.last\n    // images.size\n    // anything else is undef\n    else if (lookup.type === liquid_html_parser_1.NodeTypes.String) {\n        switch (lookup.value) {\n            case 'first':\n            case 'last': {\n                return curr.valueType;\n            }\n            case 'size': {\n                return 'number';\n            }\n            default: {\n                return Untyped;\n            }\n        }\n    }\n    // images[true]\n    // images[(0..2)]\n    else {\n        return Untyped;\n    }\n}\nfunction inferPseudoTypePropertyType(curr, // settings\nlookup, objectMap) {\n    var _a;\n    const parentEntry = objectMap[curr];\n    // products[0]\n    // products[true]\n    // products[(0..10)]\n    // unknown.images\n    if (!parentEntry || lookup.type !== liquid_html_parser_1.NodeTypes.String) {\n        return Untyped;\n    }\n    const propertyName = lookup.value;\n    const property = (_a = parentEntry.properties) === null || _a === void 0 ? void 0 : _a.find((property) => property.name === propertyName);\n    if (!property) {\n        return Untyped;\n    }\n    return objectEntryType(property);\n}\nfunction filterEntryReturnType(entry) {\n    return docsetEntryReturnType(entry, 'string');\n}\nfunction objectEntryType(entry) {\n    return docsetEntryReturnType(entry, entry.name);\n}\n/**\n * This function converts the return_type property in one of the .json\n * files into a PseudoType or ArrayType.\n */\nfunction docsetEntryReturnType(entry, defaultValue) {\n    const returnTypes = entry.return_type;\n    if (returnTypes && returnTypes.length > 0) {\n        const returnType = returnTypes[0];\n        if (isArrayReturnType(returnType)) {\n            return arrayType(returnType.array_value);\n        }\n        else {\n            return returnType.type;\n        }\n    }\n    return defaultValue;\n}\nexports.docsetEntryReturnType = docsetEntryReturnType;\nfunction isArrayReturnType(rt) {\n    return rt.type === 'array';\n}\nfunction isArrayType(thing) {\n    return typeof thing !== 'string';\n}\nexports.isArrayType = isArrayType;\n/** Assumes findLast */\nfunction isCorrectTypeRange(typeRange, node) {\n    const [start, end] = typeRange.range;\n    if (end && node.position.start > end)\n        return false;\n    return node.position.start > start;\n}\nfunction end(offset) {\n    if (offset === -1)\n        return undefined;\n    return offset;\n}\nfunction isLiquidTagIncrement(node) {\n    return node.name === liquid_html_parser_1.NamedTags.increment && typeof node.markup !== 'string';\n}\nfunction isLiquidTagDecrement(node) {\n    return node.name === liquid_html_parser_1.NamedTags.decrement && typeof node.markup !== 'string';\n}\nfunction settingReturnType(setting) {\n    switch (setting.type) {\n        // basic settings\n        case 'checkbox':\n            return [{ type: 'boolean', name: '' }];\n        case 'range':\n        case 'number':\n            return [{ type: 'number', name: '' }];\n        case 'radio':\n        case 'select':\n        case 'text':\n        case 'textarea':\n            return [{ type: 'string', name: '' }];\n        // specialized settings\n        case 'article':\n            return [{ type: 'article', name: '' }];\n        case 'blog':\n            return [{ type: 'blog', name: '' }];\n        case 'collection':\n            return [{ type: 'collection', name: '' }];\n        case 'collection_list':\n            return [{ type: 'array', array_value: 'collection' }];\n        case 'color':\n            return [{ type: 'color', name: '' }];\n        case 'color_background':\n            return [{ type: 'string', name: '' }];\n        case 'color_scheme':\n            return [{ type: 'color_scheme', name: '' }];\n        // TODO ??\n        case 'color_scheme_group':\n            return [];\n        case 'font_picker':\n            return [{ type: 'font', name: '' }];\n        case 'html':\n            return [{ type: 'string', name: '' }];\n        case 'image_picker':\n            return [{ type: 'image', name: '' }];\n        case 'inline_richtext':\n            return [{ type: 'string', name: '' }];\n        case 'link_list':\n            return [{ type: 'linklist', name: '' }];\n        case 'liquid':\n            return [{ type: 'string', name: '' }];\n        case 'page':\n            return [{ type: 'page', name: '' }];\n        case 'product':\n            return [{ type: 'product', name: '' }];\n        case 'product_list':\n            return [{ type: 'array', array_value: 'product' }];\n        case 'richtext':\n            return [{ type: 'string', name: '' }];\n        case 'text_alignment':\n            return [{ type: 'string', name: '' }];\n        case 'url':\n            return [{ type: 'string', name: '' }];\n        case 'video':\n            return [{ type: 'video', name: '' }];\n        case 'video_url':\n            return [{ type: 'string', name: '' }];\n        default:\n            return [];\n    }\n}\nconst METAFIELD_TYPE_TO_TYPE = Object.freeze({\n    single_line_text_field: String,\n    multi_line_text_field: String,\n    url_reference: String,\n    date: String,\n    date_time: String,\n    number_integer: 'number',\n    number_decimal: 'number',\n    product_reference: 'product',\n    collection_reference: 'collection',\n    variant_reference: 'variant',\n    page_reference: 'page',\n    boolean: 'boolean',\n    color: 'color',\n    weight: 'measurement',\n    volume: 'measurement',\n    dimension: 'measurement',\n    rating: 'rating',\n    money: 'money',\n    json: Untyped,\n    metaobject_reference: 'metaobject',\n    mixed_reference: Untyped,\n    rich_text_field: Untyped,\n    file_reference: Untyped,\n});\nconst REFERENCE_TYPE_METAFIELDS = Object.entries(METAFIELD_TYPE_TO_TYPE)\n    .filter(([metafieldType, _type]) => metafieldType.endsWith('_reference'))\n    .map(([_metafieldType, type]) => type);\nfunction metafieldReturnType(metafieldType) {\n    var _a;\n    let isArray = metafieldType.startsWith('list.');\n    if (isArray) {\n        metafieldType = metafieldType.split('.')[1];\n    }\n    let type = 'metafield_' + ((_a = METAFIELD_TYPE_TO_TYPE[metafieldType]) !== null && _a !== void 0 ? _a : Untyped);\n    if (isArray) {\n        return [{ type: `${type}_array`, name: '' }];\n    }\n    return [{ type: type, name: '' }];\n}\n// The default `metafield` type has an untyped `value` property.\n// We need to create new metafield types with the labels `metafield_x` and `metafield_x_array`\n// where x is the type of metafield inside the `value` property. The metafields ending with `x_array`\n// is where the value is an array of type x.\nconst customMetafieldTypeEntries = (0, utils_1.memo)((baseMetafieldEntry) => {\n    if (!baseMetafieldEntry)\n        return {};\n    return [\n        ...new Set([...Object.values(METAFIELD_TYPE_TO_TYPE), ...theme_check_common_1.FETCHED_METAFIELD_CATEGORIES]),\n    ].reduce((map, type) => {\n        var _a, _b;\n        {\n            const metafieldEntry = JSON.parse(JSON.stringify(baseMetafieldEntry)); // easy deep clone\n            const metafieldValueProp = (_a = metafieldEntry.properties) === null || _a === void 0 ? void 0 : _a.find((prop) => prop.name === 'value');\n            if (metafieldValueProp) {\n                metafieldValueProp.return_type = [{ type: type, name: '' }];\n                metafieldValueProp.description = '';\n                metafieldEntry.name = `metafield_${type}`;\n                map[metafieldEntry.name] = metafieldEntry;\n            }\n        }\n        {\n            const metafieldArrayEntry = JSON.parse(JSON.stringify(baseMetafieldEntry)); // easy deep clone\n            const metafieldArrayValueProp = (_b = metafieldArrayEntry.properties) === null || _b === void 0 ? void 0 : _b.find((prop) => prop.name === 'value');\n            if (metafieldArrayValueProp) {\n                // A metafield definition using a list of references does not use an array, but a separate type of collection.\n                // For auto-completion purposes, we can't use the array type\n                // https://shopify.dev/docs/api/liquid/objects/metafield#metafield-determining-the-length-of-a-list-metafield\n                if (REFERENCE_TYPE_METAFIELDS.includes(type)) {\n                    metafieldArrayValueProp.return_type = [{ type: 'untyped', name: '' }];\n                }\n                else {\n                    metafieldArrayValueProp.return_type = [{ type: 'array', name: '', array_value: type }];\n                }\n                metafieldArrayValueProp.description = '';\n                metafieldArrayEntry.name = `metafield_${type}_array`;\n                map[metafieldArrayEntry.name] = metafieldArrayEntry;\n            }\n        }\n        return map;\n    }, {});\n});\nfunction schemaSettingsAsProperties(ast) {\n    if (ast.type !== liquid_html_parser_1.NodeTypes.Document)\n        return [];\n    try {\n        const source = ast._source; // (the unfixed source)\n        const start = /\\{%\\s*schema\\s*%\\}/m.exec(source);\n        const end = /\\{%\\s*endschema\\s*%\\}/m.exec(source);\n        if (!start || !end)\n            return [];\n        const schema = source.slice(start.index + start[0].length, end.index);\n        const json = (0, theme_check_common_1.parseJSON)(schema);\n        if ((0, theme_check_common_1.isError)(json) || !('settings' in json) || !Array.isArray(json.settings))\n            return [];\n        const result = [];\n        const inputSettings = json.settings.filter(settings_1.isInputSetting);\n        for (const setting of inputSettings) {\n            result.push({\n                name: setting.id,\n                summary: '',\n                description: '',\n                return_type: settingReturnType(setting),\n                access: {\n                    global: false,\n                    parents: [],\n                    template: [],\n                },\n            });\n        }\n        return result;\n    }\n    catch (_) {\n        return [];\n    }\n}\n//# sourceMappingURL=TypeSystem.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseCodeActionsProvider = void 0;\nclass BaseCodeActionsProvider {\n    constructor(documentManager, diagnosticsManager) {\n        this.documentManager = documentManager;\n        this.diagnosticsManager = diagnosticsManager;\n    }\n    get kind() {\n        return this.constructor.kind;\n    }\n}\nexports.BaseCodeActionsProvider = BaseCodeActionsProvider;\n//# sourceMappingURL=BaseCodeActionsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeActionsProvider = exports.CodeActionKinds = void 0;\nconst providers_1 = require(\"./providers\");\nexports.CodeActionKinds = Array.from(new Set([providers_1.FixAllProvider.kind, providers_1.FixProvider.kind, providers_1.SuggestionProvider.kind]));\nclass CodeActionsProvider {\n    constructor(documentManager, diagnosticsManager) {\n        this.providers = [\n            new providers_1.FixAllProvider(documentManager, diagnosticsManager),\n            new providers_1.FixProvider(documentManager, diagnosticsManager),\n            new providers_1.SuggestionProvider(documentManager, diagnosticsManager),\n        ];\n    }\n    codeActions(params) {\n        const only = params.context.only;\n        return this.providers\n            .filter((provider) => !only || only.some((kind) => provider.kind.startsWith(kind)))\n            .flatMap((provider) => provider.codeActions(params));\n    }\n}\nexports.CodeActionsProvider = CodeActionsProvider;\n//# sourceMappingURL=CodeActionsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeActionKinds = exports.CodeActionsProvider = void 0;\nvar CodeActionsProvider_1 = require(\"./CodeActionsProvider\");\nObject.defineProperty(exports, \"CodeActionsProvider\", { enumerable: true, get: function () { return CodeActionsProvider_1.CodeActionsProvider; } });\nObject.defineProperty(exports, \"CodeActionKinds\", { enumerable: true, get: function () { return CodeActionsProvider_1.CodeActionKinds; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FixAllProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst commands_1 = require(\"../../commands\");\nconst BaseCodeActionsProvider_1 = require(\"../BaseCodeActionsProvider\");\nconst utils_1 = require(\"./utils\");\n/**\n * FixAllProvider is a `source.fixAll` code action provider.\n *\n * It is different from FixProvider in the sense where this won't appear on\n * top of diagnostics, but rather can be executed in different contexts.\n * Unlike FixProvider, it is also cursor position independent.\n *\n * Folks can have this run automatically on save with the following config:\n *\n * \"[liquid]\": {\n *   \"editor.codeActionsOnSave\": {\n *     \"source.fixAll\": true,\n *   }\n * },\n *\n * Or as as 'Right click > Source Actions...' request\n */\nclass FixAllProvider extends BaseCodeActionsProvider_1.BaseCodeActionsProvider {\n    codeActions(params) {\n        const { uri } = params.textDocument;\n        const document = this.documentManager.get(uri);\n        const diagnostics = this.diagnosticsManager.get(uri);\n        if (!document || !diagnostics)\n            return [];\n        const { anomalies, version } = diagnostics;\n        const fixableAnomalies = anomalies.filter(utils_1.isFixable);\n        if (fixableAnomalies.length === 0)\n            return [];\n        return quickfixAllAction(uri, version, fixableAnomalies);\n    }\n}\nexports.FixAllProvider = FixAllProvider;\nFixAllProvider.kind = vscode_languageserver_1.CodeActionKind.SourceFixAll;\n/**\n * @returns code action to fix all offenses in a file\n * @example Fix all auto-fixable problems\n */\nfunction quickfixAllAction(uri, version, fixableAnomalies) {\n    const ids = fixableAnomalies.map((a) => a.id);\n    const diagnostics = fixableAnomalies.map((a) => a.diagnostic);\n    return [\n        (0, utils_1.toCodeAction)(`Fix all auto-fixable problems`, (0, commands_1.applyFixCommand)(uri, version, ids), diagnostics, FixAllProvider.kind),\n    ];\n}\n//# sourceMappingURL=FixAllProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FixProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst commands_1 = require(\"../../commands\");\nconst BaseCodeActionsProvider_1 = require(\"../BaseCodeActionsProvider\");\nconst utils_1 = require(\"./utils\");\nclass FixProvider extends BaseCodeActionsProvider_1.BaseCodeActionsProvider {\n    codeActions(params) {\n        const { uri } = params.textDocument;\n        const document = this.documentManager.get(uri);\n        const diagnostics = this.diagnosticsManager.get(uri);\n        if (!document || !diagnostics)\n            return [];\n        const { textDocument } = document;\n        const { anomalies, version } = diagnostics;\n        const start = textDocument.offsetAt(params.range.start);\n        const end = textDocument.offsetAt(params.range.end);\n        const fixableAnomalies = anomalies.filter(utils_1.isFixable);\n        const anomaliesUnderCursor = fixableAnomalies.filter((anomaly) => (0, utils_1.isInRange)(anomaly, start, end));\n        if (anomaliesUnderCursor.length === 0)\n            return [];\n        return [\n            ...quickfixCursorActions(uri, version, anomaliesUnderCursor),\n            ...quickfixSameTypeActions(uri, version, anomaliesUnderCursor, fixableAnomalies),\n            ...quickfixAllAction(uri, version, fixableAnomalies),\n        ];\n    }\n}\nexports.FixProvider = FixProvider;\nFixProvider.kind = vscode_languageserver_1.CodeActionKind.QuickFix;\n/**\n * @returns code actions to fix only one of the offenses under the cursor\n * @example Fix this ParserBlockingScript problem: '...'\n */\nfunction quickfixCursorActions(uri, version, anomaliesUnderCursor) {\n    return anomaliesUnderCursor.map(({ offense, diagnostic, id }) => {\n        return (0, utils_1.toCodeAction)(`Fix this ${offense.check} problem: ${offense.message}`, (0, commands_1.applyFixCommand)(uri, version, [id]), [diagnostic], FixProvider.kind, true);\n    });\n}\n/**\n * @returns code actions to fix all offenses of a particular type\n * @example Fix all ParserBlockingScript problems\n */\nfunction quickfixSameTypeActions(uri, version, anomaliesUnderCursor, fixableAnomalies) {\n    const checks = new Set(anomaliesUnderCursor.map((anomaly) => anomaly.offense.check));\n    return Array.from(checks).flatMap((check) => {\n        const checkAnomalies = fixableAnomalies.filter(({ offense }) => offense.check === check);\n        // We don't want to show this one if there's only one of this type.\n        if (checkAnomalies.length < 2)\n            return [];\n        const ids = checkAnomalies.map((a) => a.id);\n        const diagnostics = checkAnomalies.map((a) => a.diagnostic);\n        return (0, utils_1.toCodeAction)(`Fix all ${check} problems`, (0, commands_1.applyFixCommand)(uri, version, ids), diagnostics, FixProvider.kind);\n    });\n}\n/**\n * @returns code action to fix all offenses of a particular type\n * @example Fix all auto-fixable problems\n */\nfunction quickfixAllAction(uri, version, fixableAnomalies) {\n    const ids = fixableAnomalies.map((a) => a.id);\n    const diagnostics = fixableAnomalies.map((a) => a.diagnostic);\n    const checks = new Set(diagnostics.map((a) => a.code));\n    // We don't want to this one if there's only one type of problems\n    if (checks.size < 2)\n        return [];\n    return [\n        (0, utils_1.toCodeAction)(`Fix all auto-fixable problems`, (0, commands_1.applyFixCommand)(uri, version, ids), diagnostics, FixProvider.kind),\n    ];\n}\n//# sourceMappingURL=FixProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SuggestionProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst providers_1 = require(\"../../commands/providers\");\nconst BaseCodeActionsProvider_1 = require(\"../BaseCodeActionsProvider\");\nconst utils_1 = require(\"./utils\");\nclass SuggestionProvider extends BaseCodeActionsProvider_1.BaseCodeActionsProvider {\n    codeActions(params) {\n        const { uri } = params.textDocument;\n        const document = this.documentManager.get(uri);\n        const diagnostics = this.diagnosticsManager.get(uri);\n        if (!document || !diagnostics)\n            return [];\n        const { textDocument } = document;\n        const { anomalies, version } = diagnostics;\n        const start = textDocument.offsetAt(params.range.start);\n        const end = textDocument.offsetAt(params.range.end);\n        const suggestibleAnomalies = anomalies.filter(isSuggestible);\n        const anomaliesUnderCursor = suggestibleAnomalies.filter((anomaly) => (0, utils_1.isInRange)(anomaly, start, end));\n        if (anomaliesUnderCursor.length === 0)\n            return [];\n        return quickfixCursorActions(uri, version, anomaliesUnderCursor);\n    }\n}\nexports.SuggestionProvider = SuggestionProvider;\nSuggestionProvider.kind = vscode_languageserver_1.CodeActionKind.QuickFix;\n/**\n * @returns all Offense.suggest code actions for the offenses under the cursor\n * @example Suggestion: Add the `defer` HTML attribute\n */\nfunction quickfixCursorActions(uri, version, anomaliesUnderCursor) {\n    return anomaliesUnderCursor.flatMap(({ offense, diagnostic, id }) => {\n        return offense.suggest.map((suggestion, suggestionId) => (0, utils_1.toCodeAction)(`Suggestion: ${suggestion.message}`, (0, providers_1.applySuggestionCommand)(uri, version, id, suggestionId), [diagnostic], SuggestionProvider.kind));\n    });\n}\nfunction isSuggestible(anomaly) {\n    const { offense } = anomaly;\n    return 'suggest' in offense && offense.suggest !== undefined;\n}\n//# sourceMappingURL=SuggestionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SuggestionProvider = exports.FixAllProvider = exports.FixProvider = void 0;\nvar FixProvider_1 = require(\"./FixProvider\");\nObject.defineProperty(exports, \"FixProvider\", { enumerable: true, get: function () { return FixProvider_1.FixProvider; } });\nvar FixAllProvider_1 = require(\"./FixAllProvider\");\nObject.defineProperty(exports, \"FixAllProvider\", { enumerable: true, get: function () { return FixAllProvider_1.FixAllProvider; } });\nvar SuggestionProvider_1 = require(\"./SuggestionProvider\");\nObject.defineProperty(exports, \"SuggestionProvider\", { enumerable: true, get: function () { return SuggestionProvider_1.SuggestionProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFixable = exports.isInRange = exports.toCodeAction = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\n// They have an awkard API for creating them, so we have this helper here\n// to make it a bit more straightforward.\nfunction toCodeAction(title, command, diagnostics, kind, isPreferred = false) {\n    const codeAction = vscode_languageserver_1.CodeAction.create(title, command, kind);\n    codeAction.diagnostics = diagnostics;\n    codeAction.isPreferred = isPreferred;\n    return codeAction;\n}\nexports.toCodeAction = toCodeAction;\n/**\n * The range is either the selection or cursor position, an offense is in\n * range if the selection and offense overlap in any way.\n */\nfunction isInRange({ offense }, start, end) {\n    const offenseStart = offense.start.index;\n    const offenseEnd = offense.end.index;\n    const isOutOfRange = offenseEnd < start || offenseStart > end;\n    return !isOutOfRange;\n}\nexports.isInRange = isInRange;\nfunction isFixable(anomaly) {\n    const { offense } = anomaly;\n    return 'fix' in offense && offense.fix !== undefined;\n}\nexports.isFixable = isFixable;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseExecuteCommandProvider = void 0;\nclass BaseExecuteCommandProvider {\n    constructor(documentManager, diagnosticsManager, clientCapabilities, connection) {\n        this.documentManager = documentManager;\n        this.diagnosticsManager = diagnosticsManager;\n        this.clientCapabilities = clientCapabilities;\n        this.connection = connection;\n    }\n}\nexports.BaseExecuteCommandProvider = BaseExecuteCommandProvider;\n//# sourceMappingURL=BaseExecuteCommandProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExecuteCommandProvider = exports.Commands = void 0;\nconst providers_1 = require(\"./providers\");\nexports.Commands = [\n    providers_1.ApplyFixesProvider.command,\n    providers_1.ApplySuggestionProvider.command,\n    providers_1.RunChecksProvider.command,\n];\nfunction isKnownCommand(command) {\n    return exports.Commands.includes(command);\n}\nclass ExecuteCommandProvider {\n    constructor(documentManager, diagnosticsManager, clientCapabilities, runChecks, connection) {\n        this.commands = {\n            [providers_1.ApplyFixesProvider.command]: new providers_1.ApplyFixesProvider(documentManager, diagnosticsManager, clientCapabilities, connection),\n            [providers_1.ApplySuggestionProvider.command]: new providers_1.ApplySuggestionProvider(documentManager, diagnosticsManager, clientCapabilities, connection),\n            [providers_1.RunChecksProvider.command]: new providers_1.RunChecksProvider(documentManager, diagnosticsManager, clientCapabilities, connection, runChecks),\n        };\n    }\n    async execute(params) {\n        var _a;\n        if (!isKnownCommand(params.command))\n            return;\n        const provider = this.commands[params.command];\n        const args = (_a = params.arguments) !== null && _a !== void 0 ? _a : [];\n        await provider.execute(...args);\n    }\n}\nexports.ExecuteCommandProvider = ExecuteCommandProvider;\n//# sourceMappingURL=ExecuteCommandProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyFixCommand = exports.Commands = exports.ExecuteCommandProvider = void 0;\nvar ExecuteCommandProvider_1 = require(\"./ExecuteCommandProvider\");\nObject.defineProperty(exports, \"ExecuteCommandProvider\", { enumerable: true, get: function () { return ExecuteCommandProvider_1.ExecuteCommandProvider; } });\nObject.defineProperty(exports, \"Commands\", { enumerable: true, get: function () { return ExecuteCommandProvider_1.Commands; } });\nvar providers_1 = require(\"./providers\");\nObject.defineProperty(exports, \"applyFixCommand\", { enumerable: true, get: function () { return providers_1.applyFixCommand; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyFixCommand = exports.ApplyFixesProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst BaseExecuteCommandProvider_1 = require(\"../BaseExecuteCommandProvider\");\n/**\n * The ApplyFixesProvider is responsible for handling the `themeCheck/applyFixes` command.\n *\n * To create a command, use the `applyFixCommand` function.\n * The provider will execute the command with the given arguments.\n *\n * ApplyFixesProvider collects the text edits represented by the targeted offenses' `.fix` property,\n * applies them, and forwards the result to the client using the 'workspace/applyEdit' request.\n */\nclass ApplyFixesProvider extends BaseExecuteCommandProvider_1.BaseExecuteCommandProvider {\n    async execute(uri, version, ids) {\n        if (!this.clientCapabilities.hasApplyEditSupport)\n            return;\n        const diagnostics = this.diagnosticsManager.get(uri);\n        const document = this.documentManager.get(uri);\n        if (!document || !diagnostics)\n            return;\n        if (document.version !== version || diagnostics.version !== version)\n            return;\n        const anomalies = ids\n            .map((id) => diagnostics.anomalies[id])\n            .filter((anomaly) => !!anomaly.offense.fix);\n        const fixes = anomalies.map((anomaly) => anomaly.offense.fix);\n        const corrector = (0, theme_check_common_1.createCorrector)(document.type, document.source);\n        for (const collectFixes of fixes) {\n            collectFixes(corrector);\n        }\n        const { textDocument } = document;\n        const textDocumentEdit = vscode_languageserver_1.TextDocumentEdit.create({ uri: textDocument.uri, version: textDocument.version }, toTextEdits(document.textDocument, corrector.fix));\n        await this.connection.sendRequest(vscode_languageserver_1.ApplyWorkspaceEditRequest.type, {\n            edit: {\n                documentChanges: [textDocumentEdit],\n            },\n        });\n        // Clean up state diagnostics when we're done\n        const offenses = diagnostics.anomalies.map((a) => a.offense);\n        const fixedOffenses = anomalies.map((a) => a.offense);\n        const remainingOffenses = offenses.filter((offense) => !fixedOffenses.includes(offense));\n        this.diagnosticsManager.set(uri, diagnostics.version, remainingOffenses);\n    }\n}\nexports.ApplyFixesProvider = ApplyFixesProvider;\nApplyFixesProvider.command = 'themeCheck/applyFixes';\n/**\n * applyFixCommand creates an LSP Command that the client can call\n */\nfunction applyFixCommand(uri, version, ids) {\n    return vscode_languageserver_1.Command.create('applyFixes', ApplyFixesProvider.command, uri, version, ids);\n}\nexports.applyFixCommand = applyFixCommand;\nfunction toTextEdit(document, fixDesc) {\n    return {\n        newText: fixDesc.insert,\n        range: {\n            start: document.positionAt(fixDesc.startIndex),\n            end: document.positionAt(fixDesc.endIndex),\n        },\n    };\n}\nfunction toTextEdits(document, fix) {\n    return (0, theme_check_common_1.flattenFixes)(fix).map((fixDesc) => toTextEdit(document, fixDesc));\n}\n//# sourceMappingURL=ApplyFixesProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applySuggestionCommand = exports.ApplySuggestionProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst BaseExecuteCommandProvider_1 = require(\"../BaseExecuteCommandProvider\");\n/**\n * The ApplySuggestionProvider is responsible for handling the `themeCheck/applySuggestion` command.\n *\n * To create a command, use the `applySuggestionCommand` function.\n * The provider will execute the command with the given arguments.\n *\n * ApplySuggestionProvider collects the text edits represented by the targeted offense' `.suggest` property,\n * applies them, and forwards the result to the client using the 'workspace/applyEdit' request.\n */\nclass ApplySuggestionProvider extends BaseExecuteCommandProvider_1.BaseExecuteCommandProvider {\n    async execute(uri, version, anomalyId, suggestionIndex) {\n        var _a;\n        if (!this.clientCapabilities.hasApplyEditSupport)\n            return;\n        const diagnostics = this.diagnosticsManager.get(uri);\n        const document = this.documentManager.get(uri);\n        if (!document || !diagnostics)\n            return;\n        if (document.version !== version || diagnostics.version !== version)\n            return;\n        const anomaly = diagnostics.anomalies[anomalyId];\n        if (!anomaly)\n            return;\n        const offense = anomaly.offense;\n        const suggestion = (_a = offense.suggest) === null || _a === void 0 ? void 0 : _a[suggestionIndex];\n        if (!suggestion)\n            return;\n        // Collect text edits\n        const corrector = (0, theme_check_common_1.createCorrector)(document.type, document.source);\n        suggestion.fix(corrector);\n        // Suggest -> TextDocumentEdit\n        const { textDocument } = document;\n        const textDocumentEdit = vscode_languageserver_1.TextDocumentEdit.create({ uri: textDocument.uri, version: textDocument.version }, toTextEdits(document.textDocument, corrector.fix));\n        await this.connection.sendRequest(vscode_languageserver_1.ApplyWorkspaceEditRequest.type, {\n            label: `Apply suggestion: ${suggestion.message}`,\n            edit: {\n                documentChanges: [textDocumentEdit],\n            },\n        });\n        // Clean up state diagnostics when we're done\n        const offenses = diagnostics.anomalies.map((a) => a.offense);\n        const fixedOffense = offense;\n        const remainingOffenses = offenses.filter((offense) => offense !== fixedOffense);\n        this.diagnosticsManager.set(uri, diagnostics.version, remainingOffenses);\n    }\n}\nexports.ApplySuggestionProvider = ApplySuggestionProvider;\nApplySuggestionProvider.command = 'themeCheck/applySuggestion';\n/**\n * applySuggestionCommand creates an LSP Command that the client can call\n */\nfunction applySuggestionCommand(uri, version, anomalyId, suggestionIndex) {\n    return vscode_languageserver_1.Command.create('applySuggestion', ApplySuggestionProvider.command, uri, version, anomalyId, suggestionIndex);\n}\nexports.applySuggestionCommand = applySuggestionCommand;\nfunction toTextEdits(document, fix) {\n    return (0, theme_check_common_1.flattenFixes)(fix).map((fixDesc) => toTextEdit(document, fixDesc));\n}\nfunction toTextEdit(document, fixDesc) {\n    return {\n        newText: fixDesc.insert,\n        range: {\n            start: document.positionAt(fixDesc.startIndex),\n            end: document.positionAt(fixDesc.endIndex),\n        },\n    };\n}\n//# sourceMappingURL=ApplySuggestionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunChecksProvider = void 0;\nconst BaseExecuteCommandProvider_1 = require(\"../BaseExecuteCommandProvider\");\n/**\n * The RunChecksProvider runs theme check on all open files.\n *\n * It is triggered by the cmd+p command in the VS Code extension and is\n * otherwise not used internally, which is why there is no\n * `runChecksCommand` method.\n *\n * This will be useful in a world where `checkOnSave`, `checkOnChange`,\n * `checkOnOpen` are all false.\n */\nclass RunChecksProvider extends BaseExecuteCommandProvider_1.BaseExecuteCommandProvider {\n    constructor(documentManager, diagnosticsManager, clientCapabilities, connection, runChecks) {\n        super(documentManager, diagnosticsManager, clientCapabilities, connection);\n        this.documentManager = documentManager;\n        this.diagnosticsManager = diagnosticsManager;\n        this.clientCapabilities = clientCapabilities;\n        this.connection = connection;\n        this.runChecks = runChecks;\n    }\n    async execute() {\n        const openDocuments = this.documentManager.openDocuments;\n        const triggerURIs = openDocuments.map((sourceCode) => sourceCode.uri);\n        this.runChecks(triggerURIs);\n    }\n}\nexports.RunChecksProvider = RunChecksProvider;\nRunChecksProvider.command = 'themeCheck/runChecks';\n//# sourceMappingURL=RunChecksProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunChecksProvider = exports.ApplySuggestionProvider = exports.applySuggestionCommand = exports.ApplyFixesProvider = exports.applyFixCommand = void 0;\nvar ApplyFixesProvider_1 = require(\"./ApplyFixesProvider\");\nObject.defineProperty(exports, \"applyFixCommand\", { enumerable: true, get: function () { return ApplyFixesProvider_1.applyFixCommand; } });\nObject.defineProperty(exports, \"ApplyFixesProvider\", { enumerable: true, get: function () { return ApplyFixesProvider_1.ApplyFixesProvider; } });\nvar ApplySuggestionProvider_1 = require(\"./ApplySuggestionProvider\");\nObject.defineProperty(exports, \"applySuggestionCommand\", { enumerable: true, get: function () { return ApplySuggestionProvider_1.applySuggestionCommand; } });\nObject.defineProperty(exports, \"ApplySuggestionProvider\", { enumerable: true, get: function () { return ApplySuggestionProvider_1.ApplySuggestionProvider; } });\nvar RunChecksProvider_1 = require(\"./RunChecksProvider\");\nObject.defineProperty(exports, \"RunChecksProvider\", { enumerable: true, get: function () { return RunChecksProvider_1.RunChecksProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompletionsProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst TypeSystem_1 = require(\"../TypeSystem\");\nconst params_1 = require(\"./params\");\nconst providers_1 = require(\"./providers\");\nconst RenderSnippetParameterCompletionProvider_1 = require(\"./providers/RenderSnippetParameterCompletionProvider\");\nconst LiquidDocTagCompletionProvider_1 = require(\"./providers/LiquidDocTagCompletionProvider\");\nconst LiquidDocParamTypeCompletionProvider_1 = require(\"./providers/LiquidDocParamTypeCompletionProvider\");\nclass CompletionsProvider {\n    constructor({ documentManager, themeDocset, getMetafieldDefinitions, getTranslationsForURI = async () => ({}), getSnippetNamesForURI = async () => [], getThemeSettingsSchemaForURI = async () => [], getSnippetDefinitionForURI = async (_uri, snippetName) => ({\n        name: snippetName,\n    }), getThemeBlockNames = async (_rootUri, _includePrivate) => [], log = () => { }, }) {\n        this.providers = [];\n        this.documentManager = documentManager;\n        this.themeDocset = themeDocset;\n        this.log = log;\n        const typeSystem = new TypeSystem_1.TypeSystem(themeDocset, getThemeSettingsSchemaForURI, getMetafieldDefinitions);\n        this.providers = [\n            new providers_1.ContentForCompletionProvider(),\n            new providers_1.ContentForBlockTypeCompletionProvider(getThemeBlockNames),\n            new providers_1.ContentForParameterCompletionProvider(),\n            new providers_1.HtmlTagCompletionProvider(),\n            new providers_1.HtmlAttributeCompletionProvider(documentManager),\n            new providers_1.HtmlAttributeValueCompletionProvider(),\n            new providers_1.LiquidTagsCompletionProvider(themeDocset),\n            new providers_1.ObjectCompletionProvider(typeSystem),\n            new providers_1.ObjectAttributeCompletionProvider(typeSystem, getThemeSettingsSchemaForURI),\n            new providers_1.FilterCompletionProvider(typeSystem),\n            new providers_1.TranslationCompletionProvider(documentManager, getTranslationsForURI),\n            new providers_1.RenderSnippetCompletionProvider(getSnippetNamesForURI),\n            new RenderSnippetParameterCompletionProvider_1.RenderSnippetParameterCompletionProvider(getSnippetDefinitionForURI),\n            new providers_1.FilterNamedParameterCompletionProvider(themeDocset),\n            new LiquidDocTagCompletionProvider_1.LiquidDocTagCompletionProvider(),\n            new LiquidDocParamTypeCompletionProvider_1.LiquidDocParamTypeCompletionProvider(),\n        ];\n    }\n    async completions(params) {\n        const uri = params.textDocument.uri;\n        const document = this.documentManager.get(uri);\n        // Supports only Liquid resources\n        if ((document === null || document === void 0 ? void 0 : document.type) !== theme_check_common_1.SourceCodeType.LiquidHtml) {\n            return [];\n        }\n        try {\n            const liquidParams = (0, params_1.createLiquidCompletionParams)(document, params);\n            const promises = this.providers.map((p) => p.completions(liquidParams));\n            const results = await Promise.all(promises);\n            return results.flat();\n        }\n        catch (err) {\n            this.log(`[SERVER] CompletionsProvider error: ${err}`);\n            return [];\n        }\n    }\n}\nexports.CompletionsProvider = CompletionsProvider;\n//# sourceMappingURL=CompletionsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompletionsProvider = void 0;\nvar CompletionsProvider_1 = require(\"./CompletionsProvider\");\nObject.defineProperty(exports, \"CompletionsProvider\", { enumerable: true, get: function () { return CompletionsProvider_1.CompletionsProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLiquidCompletionParams = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst fix_1 = require(\"./fix\");\nfunction createLiquidCompletionParams(sourceCode, params) {\n    const { textDocument } = sourceCode;\n    const cursor = textDocument.offsetAt(params.position);\n    const completionContext = getCompletionContext(sourceCode, cursor);\n    return {\n        ...params,\n        completionContext,\n        document: sourceCode,\n    };\n}\nexports.createLiquidCompletionParams = createLiquidCompletionParams;\nfunction getCompletionContext(sourceCode, cursor) {\n    const partialAst = parsePartial(sourceCode, cursor);\n    if (!partialAst) {\n        return undefined;\n    }\n    const [node, ancestors] = findCurrentNode(partialAst, cursor);\n    return {\n        partialAst,\n        ancestors,\n        node,\n    };\n}\n/**\n * This function will return an AST of the entire file up until the cursor\n * position.\n *\n * So if you accept that we use  to represent the cursor, and a have a file that\n * looks like this:\n *\n * <div>\n *   {% assign x = product %}\n *   {% assign y = x | plus: 20 %}\n *   {% assign z =  %}\n *   <span>\n *     this content is not part of the partial tree\n *   </span>\n * </div>\n *\n * Then the contents of the file up until the cursor position is this:\n *\n * <div>\n *   {% assign x = product %}\n *   {% assign y = x | plus: 20 %}\n *   {% assign z = \n *\n * Then we'll use `fix(sourceCode, cursorPosition)` to make it parseable.\n * Fixed output:\n *\n * <div>\n *   {% assign x = product %}\n *   {% assign y = x | plus: 20 %}\n *   {% assign z = %}\n *\n * Then we'll parse this with `allowUnclosedDocumentNode` and\n * `mode: completion` to allow parsing of placeholder characters ()\n *\n * The result is a partial AST whose last-most node is probably the one\n * under the cursor.\n */\nfunction parsePartial(sourceCode, cursorPosition) {\n    let fixedSource;\n    try {\n        fixedSource = (0, fix_1.fix)(sourceCode.source, cursorPosition);\n        const ast = (0, liquid_html_parser_1.toLiquidHtmlAST)(fixedSource, {\n            allowUnclosedDocumentNode: true,\n            mode: 'completion',\n        });\n        ast._source = sourceCode.source;\n        return ast;\n    }\n    catch (err) {\n        // We swallow errors here, because we gracefully accept that and\n        // simply don't offer completions when that happens.\n        return undefined;\n    }\n}\nclass Finder {\n    constructor(ast) {\n        this.stack = [ast];\n    }\n    get current() {\n        return last(this.stack);\n    }\n    get parent() {\n        return this.stack.at(-2);\n    }\n    set current(node) {\n        this.stack.push(node);\n    }\n}\n/**\n * @returns the node at the cursor position and its ancestry.\n *\n * Undefined when you're not really on a node (there's nothing to complete)\n */\nfunction findCurrentNode(partialAst, cursor) {\n    // The current node is the \"last\" node in the AST.\n    const finder = new Finder(partialAst);\n    let current = { ...partialAst };\n    // Our objective:\n    //   Finding the \"last-most node\" in the partial AST.\n    //\n    // Context:\n    //   A generic visitor doesn't quite work in this context because we\n    //   cannot trust the position, blockStartPosition, blockEndPosition of\n    //   nodes when we use `allowUnclosedDocumentNode`. You see, these\n    //   properties are updated when the nodes are closed. An {% if cond %}\n    //   node without its closing {% endif %} would have its position.end be\n    //   the one of the starting block. Which means that any children it may\n    //   have wouldn't be covered.\n    //\n    // How we do it:\n    //   We define logic per node type. For example, HTML tags will do this:\n    //     - If the node is closed (<a>child</a>),\n    //         then there's nothing to complete.\n    //         We return undefined\n    //     - If the node has children,\n    //         then we visit the last children\n    //     - If the node has attributes,\n    //         then we visit the last attribute\n    //     - If the node has a name,\n    //         then we visit the last name node (<a--{{ product.id }}>)\n    //\n    //   It's different per node type, because each node type has a different\n    //   concept of child node and because they have to be traversed in a\n    //   specific order.\n    while (finder.current !== undefined && current !== finder.current) {\n        current = finder.current;\n        switch (current.type) {\n            case liquid_html_parser_1.NodeTypes.Document: {\n                if (hasNonEmptyArrayProperty(current, 'children')) {\n                    finder.current = last(current.children);\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.HtmlRawNode:\n            case liquid_html_parser_1.NodeTypes.HtmlVoidElement:\n            case liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose:\n            case liquid_html_parser_1.NodeTypes.HtmlSelfClosingElement:\n            case liquid_html_parser_1.NodeTypes.HtmlElement: {\n                if (isCompletedTag(current)) {\n                    finder.current = undefined;\n                }\n                else if (hasNonEmptyArrayProperty(current, 'children')) {\n                    finder.current = last(current.children);\n                }\n                else if (hasNonEmptyArrayProperty(current, 'attributes')) {\n                    finder.current = last(current.attributes);\n                }\n                else if (hasNonEmptyArrayProperty(current, 'name') &&\n                    isCoveredExcluded(cursor, current.blockStartPosition)) {\n                    finder.current = last(current.name);\n                }\n                else if (typeof current.name === 'string' &&\n                    isCoveredExcluded(cursor, current.blockStartPosition)) {\n                    /* break */\n                }\n                else {\n                    finder.current = undefined; // there's nothing to complete\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LiquidTag: {\n                if (isLiquidLiquidTag(finder.current) ||\n                    isCoveredExcluded(cursor, current.blockStartPosition) || // wouldn't want to complete {% if cond %} after the }.\n                    (isInLiquidLiquidTagContext(finder) && isCovered(cursor, current.blockStartPosition))) {\n                    if (hasNonNullProperty(current, 'markup') && typeof current.markup !== 'string') {\n                        finder.current = Array.isArray(current.markup) ? current.markup.at(-1) : current.markup;\n                    }\n                    else {\n                        // Exits the loop and the node is the thing to complete\n                        // (presumably name or something else)\n                        // finder.current = finder.current;\n                    }\n                }\n                else if (isIncompleteBlockTag(current)) {\n                    finder.current = last(current.children);\n                }\n                else {\n                    finder.current = undefined; // we're done and there's nothing to complete\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LiquidBranch:\n                if (isCovered(cursor, current.blockStartPosition) && typeof current.markup !== 'string') {\n                    finder.current = Array.isArray(current.markup) ? current.markup.at(-1) : current.markup;\n                }\n                else if (hasNonEmptyArrayProperty(current, 'children')) {\n                    finder.current = last(current.children);\n                }\n                else {\n                    finder.current = undefined; // there's nothing to complete\n                }\n                break;\n            case liquid_html_parser_1.NodeTypes.LiquidRawTag:\n                if (current.name === 'doc' && current.body.nodes.length > 0) {\n                    finder.current = current.body.nodes.at(-1);\n                }\n                break;\n            case liquid_html_parser_1.NodeTypes.AttrDoubleQuoted:\n            case liquid_html_parser_1.NodeTypes.AttrSingleQuoted:\n            case liquid_html_parser_1.NodeTypes.AttrEmpty:\n            case liquid_html_parser_1.NodeTypes.AttrUnquoted: {\n                const lastNameNode = last(current.name); // there's at least one... guaranteed.\n                if (isCovered(cursor, lastNameNode.position)) {\n                    finder.current = lastNameNode;\n                }\n                else if (current.type !== liquid_html_parser_1.NodeTypes.AttrEmpty &&\n                    isCovered(cursor, current.attributePosition) &&\n                    isNotEmpty(current.value)) {\n                    finder.current = last(current.value);\n                }\n                else {\n                    finder.current = undefined;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.YAMLFrontmatter:\n            case liquid_html_parser_1.NodeTypes.HtmlDoctype:\n            case liquid_html_parser_1.NodeTypes.HtmlComment:\n            case liquid_html_parser_1.NodeTypes.RawMarkup: {\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LiquidVariableOutput: {\n                if (typeof current.markup !== 'string') {\n                    finder.current = current.markup;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LiquidVariable: {\n                if (isNotEmpty(current.filters)) {\n                    finder.current = last(current.filters);\n                }\n                else {\n                    finder.current = current.expression;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LiquidFilter: {\n                if (isNotEmpty(current.args)) {\n                    finder.current = last(current.args);\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.VariableLookup: {\n                if (hasNonEmptyArrayProperty(current, 'lookups') &&\n                    last(current.lookups).type === liquid_html_parser_1.NodeTypes.VariableLookup) {\n                    finder.current = last(current.lookups);\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.AssignMarkup: {\n                finder.current = current.value;\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.ForMarkup: {\n                if (isCovered(cursor, current.collection.position)) {\n                    finder.current = current.collection;\n                }\n                else if (isNotEmpty(current.args) && isCovered(cursor, last(current.args).position)) {\n                    finder.current = last(current.args);\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.NamedArgument: {\n                if (isCovered(cursor, current.value.position)) {\n                    finder.current = current.value;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.Comparison: {\n                finder.current = current.right;\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.LogicalExpression: {\n                finder.current = current.right;\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.CycleMarkup: {\n                if (isNotEmpty(current.args)) {\n                    finder.current = last(current.args);\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.PaginateMarkup: {\n                if (isNotEmpty(current.args)) {\n                    finder.current = last(current.args);\n                }\n                else if (isCovered(cursor, current.collection.position)) {\n                    finder.current = current.collection;\n                }\n                else if (isCovered(cursor, current.pageSize.position)) {\n                    finder.current = current.pageSize;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.ContentForMarkup: {\n                if (isNotEmpty(current.args)) {\n                    finder.current = last(current.args);\n                }\n                else if (isCovered(cursor, current.contentForType.position)) {\n                    finder.current = current.contentForType;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.RenderMarkup: {\n                if (isNotEmpty(current.args)) {\n                    finder.current = last(current.args);\n                }\n                else if (current.variable && isCovered(cursor, current.variable.position)) {\n                    finder.current = current.variable;\n                }\n                else if (current.snippet && isCovered(cursor, current.snippet.position)) {\n                    finder.current = current.snippet;\n                }\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.RenderVariableExpression: {\n                finder.current = current.name;\n                break;\n            }\n            case liquid_html_parser_1.NodeTypes.Range: {\n                // This means you can't complete the start range as a variable...\n                // is this bad?\n                finder.current = current.end;\n                break;\n            }\n            // If you end up on any of these. You're done.\n            // That's the current node.\n            case liquid_html_parser_1.NodeTypes.TextNode:\n            case liquid_html_parser_1.NodeTypes.LiquidLiteral:\n            case liquid_html_parser_1.NodeTypes.String:\n            case liquid_html_parser_1.NodeTypes.Number:\n            case liquid_html_parser_1.NodeTypes.LiquidDocParamNode:\n            case liquid_html_parser_1.NodeTypes.LiquidDocExampleNode:\n            case liquid_html_parser_1.NodeTypes.LiquidDocDescriptionNode: {\n                break;\n            }\n            default: {\n                return assertNever(current);\n            }\n        }\n    }\n    return [finder.stack.pop(), finder.stack];\n}\nfunction hasNonNullProperty(thing, property) {\n    return thing !== null && property in thing && !!thing[property];\n}\nfunction isIncompleteBlockTag(thing) {\n    return (hasNonEmptyArrayProperty(thing, 'children') &&\n        (!hasNonNullProperty(thing, 'blockEndPosition') ||\n            (thing.blockEndPosition.start === -1 && thing.blockEndPosition.end === -1)));\n}\nfunction isCompletedTag(thing) {\n    return (hasNonNullProperty(thing, 'blockEndPosition') &&\n        thing.blockEndPosition.start !== -1 &&\n        thing.blockEndPosition.end !== -1);\n}\nfunction hasNonEmptyArrayProperty(thing, property) {\n    return (thing !== null &&\n        property in thing &&\n        Array.isArray(thing[property]) &&\n        !isEmpty(thing[property]));\n}\nfunction isInLiquidLiquidTagContext(finder) {\n    return finder.stack.some(isLiquidLiquidTag);\n}\nfunction isLiquidLiquidTag(node) {\n    if (!node)\n        return false;\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidTag && node.name === 'liquid';\n}\nfunction isCoveredExcluded(cursor, position) {\n    return position.start <= cursor && cursor < position.end;\n}\nfunction isCovered(cursor, position) {\n    return position.start <= cursor && cursor <= position.end;\n}\nfunction isNotEmpty(x) {\n    return x.length > 0;\n}\nfunction isEmpty(x) {\n    return x.length === 0;\n}\nfunction last(x) {\n    return x[x.length - 1];\n}\nfunction assertNever(x) {\n    throw new Error(`This function should never be called, but was called with ${x}`);\n}\n//# sourceMappingURL=LiquidCompletionParams.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fix = exports.CURSOR = void 0;\nexports.CURSOR = '';\nconst SINGLE_QUOTE = `'`;\nconst DOUBLE_QUOTE = `\"`;\nconst HTML_TOKENS = ['<', '>'];\nconst SHOULD_IGNORE_HTML_TOKENS = [SINGLE_QUOTE, DOUBLE_QUOTE, '{{', '{%'];\nconst QUOTES = [SINGLE_QUOTE, DOUBLE_QUOTE];\nconst CONTROL_TOKENS = ['{{', '{%', '<'];\nconst TokenPairs = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '{{': '}}',\n    '{%': '%}',\n    '<': '>',\n    '[': ']',\n    '(': ')',\n};\n/**\n * Fix the source code and return the new fixed source with the new absolute\n * position\n *\n * @param source - source code\n * @param position - absolute position\n *\n * @returns new fixed source\n */\nfunction fix(source, position = source.length) {\n    const fixer = new Fixer(source, position);\n    return fixer.fix();\n}\nexports.fix = fix;\nclass Fixer {\n    constructor(source, position) {\n        /**\n         * A list of quotes, <, [, etc. We'll pass through that list to determine\n         * what needs to be closed at the end.\n         */\n        this.tokens = [];\n        /**\n         * A stack of closing tokens such that when we're done we simply pop\n         * everything out into the string to get a fixed string.\n         */\n        this.stack = [];\n        this.cursor = 0;\n        this.markup = source.slice(0, position);\n    }\n    /**\n     * This is cool, so bear with me.\n     *\n     * We'll scan the entire string up to the cursor position and turn that\n     * into a list of tokens\n     *\n     * input:\n     *   `<a href=\"hi'\" other=\"{{ 'there'`\n     *\n     * output:\n     *   - <\n     *   - \"\n     *   - '\n     *   - \"\n     *   - \"\n     *   - {{\n     *   - '\n     *   - '\n     *   - }}\n     *   - \"\n     *\n     * Then we take that output, and we turn it into a stack\n     * (open tokens push, close tokens pop)\n     *\n     * stack evolution:\n     *   - <         # open tag\n     *   - < \"       # add quote\n     *   - < \"       # (single quote is ignored)\n     *   - <         # close quote\n     *   - < \"       # open new quote\n     *   - < \" {{    # open liquid variable output\n     *   - < \" {{ '  # open liquid string in variable output\n     *   - < \" {{    # close liquid string in variable output\n     *\n     * then we pop the close characters of that stack onto the string and\n     * have a fixed string\n     *\n     *   - <a href=\"hi'\" other=\"{{ 'there'      # start\n     *   - <a href=\"hi'\" other=\"{{ 'there'}}    # pop close {{\n     *   - <a href=\"hi'\" other=\"{{ 'there'}}\"   # pop close \"\n     *   - <a href=\"hi'\" other=\"{{ 'there'}}\">  # pop close <\n     *\n     * And there we go, we have a fixed string.\n     */\n    fix() {\n        this.scanTokens();\n        this.buildStack();\n        let markup = this.markup;\n        if (this.shouldIncludeCursorPlaceholder()) {\n            markup += exports.CURSOR;\n        }\n        while (this.stack.length !== 0) {\n            markup += this.stack.pop();\n        }\n        return markup;\n    }\n    buildStack() {\n        for (let token of this.tokens) {\n            if (this.shouldPanic(token)) {\n                while (token !== this.stack.pop()) { }\n            }\n            else if (this.shouldSkipToken(token)) {\n                /* do nothing */\n            }\n            else if (this.isClosingToken(token)) {\n                this.stack.pop();\n            }\n            else {\n                const closingToken = TokenPairs[token];\n                if (closingToken) {\n                    this.stack.push(closingToken);\n                }\n            }\n        }\n    }\n    isClosingToken(token) {\n        return this.current === token;\n    }\n    shouldPanic(token) {\n        const isInStringContext = QUOTES.includes(this.current);\n        return isInStringContext && this.stack.at(-2) === token;\n    }\n    shouldSkipToken(token) {\n        const current = this.current;\n        const isInTextContext = !current;\n        const isInStringContext = QUOTES.includes(current);\n        const isInLiquidContext = this.stack.includes('}}') || this.stack.includes('%}');\n        return ((isInTextContext && !CONTROL_TOKENS.includes(token)) ||\n            (isInStringContext && !CONTROL_TOKENS.includes(token) && !QUOTES.includes(token)) ||\n            (isInLiquidContext && token === '<') ||\n            (current === SINGLE_QUOTE && token === DOUBLE_QUOTE) ||\n            (current === DOUBLE_QUOTE && token === SINGLE_QUOTE) ||\n            (SHOULD_IGNORE_HTML_TOKENS.includes(current) && HTML_TOKENS.includes(token)));\n    }\n    scanTokens() {\n        while (!this.isAtEnd()) {\n            const character = this.peek();\n            switch (character) {\n                case DOUBLE_QUOTE:\n                case SINGLE_QUOTE:\n                case '(':\n                case ')':\n                case '[':\n                case ']': {\n                    this.pushToken(character);\n                    break;\n                }\n                case '{': {\n                    if (this.matchNext('%')) {\n                        this.pushToken('{%');\n                    }\n                    else if (this.matchNext('{')) {\n                        this.pushToken('{{');\n                    }\n                    break;\n                }\n                case '%': {\n                    if (this.matchNext('}')) {\n                        this.pushToken('%}');\n                    }\n                    break;\n                }\n                case '}': {\n                    if (this.matchNext('}')) {\n                        this.pushToken('}}');\n                    }\n                    break;\n                }\n                case '<': {\n                    if (this.testNext(/[a-z{\\/]/i)) {\n                        this.pushToken('<');\n                    }\n                    break;\n                }\n                case '>': {\n                    this.pushToken('>');\n                    break;\n                }\n                default: {\n                    /* do nothing */\n                }\n            }\n            this.advance();\n        }\n    }\n    shouldIncludeCursorPlaceholder() {\n        var _a, _b;\n        const prevCharacter = (_a = this.markup.at(-1)) !== null && _a !== void 0 ? _a : '';\n        const prevPrevCharacter = (_b = this.markup.at(-2)) !== null && _b !== void 0 ? _b : '';\n        const isInLiquidContext = this.stack.includes('%}') || this.stack.includes('}}');\n        const isInHtmlContext = this.current === '>';\n        const isInStringContext = QUOTES.includes(this.current);\n        return ((isInStringContext && this.stack.at(-2) === '>' && QUOTES.includes(prevCharacter)) ||\n            (isInHtmlContext &&\n                (/\\s/.test(prevCharacter) ||\n                    prevCharacter === '<' ||\n                    (prevPrevCharacter === '<' && prevCharacter === '/') ||\n                    (prevPrevCharacter === '%' && prevCharacter === '}'))) ||\n            (isInLiquidContext &&\n                ((!isInStringContext && [' ', '\\t', '\\n', '.', '{', '[', ','].includes(prevCharacter)) ||\n                    (isInStringContext && prevPrevCharacter === '['))));\n    }\n    get current() {\n        return this.stack.at(-1);\n    }\n    advance() {\n        this.cursor += 1;\n    }\n    matchNext(character) {\n        if (this.peekNext() !== character)\n            return false;\n        this.cursor++;\n        return true;\n    }\n    testNext(regex) {\n        return regex.test(this.peekNext());\n    }\n    peek(cursor = this.cursor) {\n        return this.markup[cursor];\n    }\n    peekNext(cursor = this.cursor) {\n        return this.markup[cursor + 1];\n    }\n    pushToken(token) {\n        this.tokens.push(token);\n    }\n    isAtEnd() {\n        return this.cursor >= this.markup.length;\n    }\n}\n//# sourceMappingURL=fix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CURSOR = exports.createLiquidCompletionParams = void 0;\nvar LiquidCompletionParams_1 = require(\"./LiquidCompletionParams\");\nObject.defineProperty(exports, \"createLiquidCompletionParams\", { enumerable: true, get: function () { return LiquidCompletionParams_1.createLiquidCompletionParams; } });\nvar fix_1 = require(\"./fix\");\nObject.defineProperty(exports, \"CURSOR\", { enumerable: true, get: function () { return fix_1.CURSOR; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentForBlockTypeCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nclass ContentForBlockTypeCompletionProvider {\n    constructor(getThemeBlockNames) {\n        this.getThemeBlockNames = getThemeBlockNames;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { document } = params;\n        const doc = document.textDocument;\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        const grandParentNode = ancestors.at(-2);\n        if (!node ||\n            !parentNode ||\n            !grandParentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.String ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.NamedArgument ||\n            parentNode.name !== 'type' ||\n            grandParentNode.type !== liquid_html_parser_1.NodeTypes.ContentForMarkup ||\n            grandParentNode.contentForType.value !== 'block') {\n            return [];\n        }\n        return (await this.getThemeBlockNames(doc.uri, false)).map((blockName) => ({\n            label: blockName,\n            kind: vscode_languageserver_1.CompletionItemKind.EnumMember,\n            insertText: blockName,\n        }));\n    }\n}\nexports.ContentForBlockTypeCompletionProvider = ContentForBlockTypeCompletionProvider;\n//# sourceMappingURL=ContentForBlockTypeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentForCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nclass ContentForCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { document } = params;\n        const doc = document.textDocument;\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node ||\n            !parentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.String ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.ContentForMarkup) {\n            return [];\n        }\n        const options = [\n            {\n                keyword: 'block',\n                description: 'Renders a static theme block within `sections` or `theme blocks`.\\n',\n                syntax: \"content_for 'block', type: '$1', id: '$2'\",\n            },\n            {\n                keyword: 'blocks',\n                description: `Renders block elements within sections or other blocks as configured in the JSON template or section groups.\nSee [theme blocks](https://shopify.dev/docs/storefronts/themes/architecture/blocks/theme-blocks)\nto see how to create theme blocks that can be used this way.\\n`,\n                syntax: `content_for 'blocks'`,\n            },\n        ];\n        const partial = node.value;\n        const isInLiquidLiquidTag = ancestors.some((node) => node.type === liquid_html_parser_1.NodeTypes.LiquidTag && node.name === 'liquid');\n        const startPosition = node.position.start + 1; // after the quote\n        const endPosition = indexOf(document.source, \n        // We want to maintain trailing whitespace to whatever it was before the completion\n        isInLiquidLiquidTag ? / *\\n/g : /\\s*-?%}/gm, startPosition + partial.length);\n        const hasMarkup = document.source\n            .slice(startPosition + partial.length, endPosition)\n            .replace(/^['\"]/, '')\n            .trim() !== '';\n        const shouldCompleteSyntax = endPosition !== -1 && !hasMarkup;\n        return options\n            .filter(({ keyword }) => keyword.startsWith(partial))\n            .map(({ keyword, description, syntax }) => {\n            const item = {\n                label: keyword,\n                kind: vscode_languageserver_1.CompletionItemKind.Keyword,\n                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,\n                documentation: {\n                    kind: 'markdown',\n                    value: description,\n                },\n            };\n            if (shouldCompleteSyntax) {\n                const snippetText = getSnippetText(node, syntax);\n                item.insertTextFormat = vscode_languageserver_1.InsertTextFormat.Snippet;\n                item.textEdit = vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(doc.positionAt(startPosition), doc.positionAt(endPosition)), snippetText);\n            }\n            return item;\n        });\n    }\n}\nexports.ContentForCompletionProvider = ContentForCompletionProvider;\nfunction getSnippetText(node, syntax) {\n    // Language clients don't like it when the text edit starts before the word being completed\n    // So we make the snippet text start with the word being completed\n    return (syntax\n        .replace(/^content_for '/, '')\n        // use the same quote type as the original string everywhere in the snippet\n        .replace(node.single ? /\"/g : /'/g, node.single ? \"'\" : '\"'));\n}\n/**\n * String.prototype.indexOf does not accept RegExp args...\n * String.prototype.search does not accept fromIndex args...\n *\n * We want both.\n */\nfunction indexOf(string, searchValue, fromIndex) {\n    searchValue.lastIndex = fromIndex;\n    const match = searchValue.exec(string);\n    return match ? match.index : -1;\n}\n//# sourceMappingURL=ContentForCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentForParameterCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst params_1 = require(\"../params\");\nconst contentForParameterCompletionOptions_1 = require(\"./data/contentForParameterCompletionOptions\");\n/**\n * Offers completions for parameters for the `content_for` tag after a user has\n * specificied the type.\n *\n * @example {% content_for \"block\",  %}\n */\nclass ContentForParameterCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        const parentIsContentFor = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) == liquid_html_parser_1.NodeTypes.ContentForMarkup;\n        const nodeIsVariableLookup = (node === null || node === void 0 ? void 0 : node.type) == liquid_html_parser_1.NodeTypes.VariableLookup;\n        if (!parentIsContentFor || !nodeIsVariableLookup) {\n            return [];\n        }\n        if (!node.name || node.lookups.length > 0) {\n            return [];\n        }\n        let options = contentForParameterCompletionOptions_1.DEFAULT_COMPLETION_OPTIONS;\n        const partial = node.name.replace(params_1.CURSOR, '');\n        if (parentNode.contentForType.value == 'blocks') {\n            options = {\n                closest: contentForParameterCompletionOptions_1.DEFAULT_COMPLETION_OPTIONS.closest,\n            };\n        }\n        return Object.entries(options)\n            .filter(([keyword, _description]) => keyword.startsWith(partial))\n            .map(([keyword, description]) => {\n            const { textEdit, format } = this.textEdit(node, params.document, keyword);\n            return {\n                label: keyword,\n                kind: vscode_languageserver_1.CompletionItemKind.Keyword,\n                documentation: {\n                    kind: 'markdown',\n                    value: description,\n                },\n                insertTextFormat: format,\n                // We want to force these options to appear first in the list given\n                // the context that they are being requested in.\n                sortText: `1${keyword}`,\n                textEdit,\n            };\n        });\n    }\n    textEdit(node, document, name) {\n        var _a, _b;\n        const remainingText = document.source.slice(node.position.end);\n        // Match all the way up to the termination of the parameter which could be\n        // another parameter (`,`), filter (`|`), or the end of a liquid statement.\n        const match = remainingText.match(/^(.*?)\\s*(?=,|\\||-?\\}\\}|-?\\%\\})|^(.*)$/);\n        const offset = match ? match[0].trimEnd().length : remainingText.length;\n        const existingParameterOffset = (_b = (_a = remainingText.match(/[^a-zA-Z]/)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : remainingText.length;\n        let start = document.textDocument.positionAt(node.position.start);\n        let end = document.textDocument.positionAt(node.position.end + offset);\n        let newText = name === 'closest' ? `${name}.` : `${name}: '$1'`;\n        let format = name === 'closest' ? vscode_languageserver_1.InsertTextFormat.PlainText : vscode_languageserver_1.InsertTextFormat.Snippet;\n        // If the cursor is inside the parameter or at the end and it's the same\n        // value as the one we're offering a completion for then we want to restrict\n        // the insert to just the name of the parameter.\n        // e.g. `{% content_for \"block\", type: \"button\" %}` and we're offering `type`\n        if (node.name + remainingText.slice(0, existingParameterOffset) == name) {\n            newText = name;\n            format = vscode_languageserver_1.InsertTextFormat.PlainText;\n            end = document.textDocument.positionAt(node.position.end + existingParameterOffset);\n        }\n        // If the cursor is at the beginning of the string we can consider all\n        // options and should not replace any text.\n        // e.g. `{% content_for \"block\", type: \"button\" %}`\n        // e.g. `{% content_for \"block\",  %}`\n        if (node.name === params_1.CURSOR) {\n            end = start;\n            // If we're inserting text in front of an existing parameter then we need\n            // to add a comma to separate them.\n            if (existingParameterOffset > 0) {\n                newText += ', ';\n            }\n        }\n        return {\n            textEdit: vscode_languageserver_1.TextEdit.replace({\n                start,\n                end,\n            }, newText),\n            format,\n        };\n    }\n}\nexports.ContentForParameterCompletionProvider = ContentForParameterCompletionProvider;\n//# sourceMappingURL=ContentForParameterCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FilterCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst TypeSystem_1 = require(\"../../TypeSystem\");\nconst utils_1 = require(\"../../utils\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass FilterCompletionProvider {\n    constructor(typeSystem) {\n        this.typeSystem = typeSystem;\n        this.options = (0, utils_1.memoize)(async (inputType) => {\n            const filterEntries = await this.typeSystem.filterEntries();\n            const options = filterEntries\n                .filter((entry) => { var _a; return (_a = entry.syntax) === null || _a === void 0 ? void 0 : _a.startsWith(inputType); })\n                .sort(common_1.sortByName);\n            // Case we take \"anything\" as argument\n            if (inputType === 'variable') {\n                const entriesWithoutSyntax = filterEntries.filter((entry) => !entry.syntax);\n                return options.concat(entriesWithoutSyntax).sort(common_1.sortByName);\n            }\n            // Case there doesn't exist filter entries for that type\n            if (options.length === 0) {\n                return filterEntries.sort(common_1.sortByName);\n            }\n            const untypedOptions = await this.options('variable');\n            // We show 'array' options before 'untyped' options because they feel\n            // like better options.\n            return [...options, ...untypedOptions.map(deprioritized)];\n        }, (inputType) => inputType);\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { partialAst, node, ancestors } = params.completionContext;\n        if (!node || node.type !== liquid_html_parser_1.NodeTypes.LiquidFilter) {\n            return [];\n        }\n        if (node.args.length > 0) {\n            // We only do name completion\n            return [];\n        }\n        // We'll fake a LiquidVariable\n        let parentVariable = ancestors.at(-1);\n        if (!parentVariable ||\n            parentVariable.type !== liquid_html_parser_1.NodeTypes.LiquidVariable ||\n            parentVariable.filters.at(-1) !== node) {\n            return []; // something went wrong...\n        }\n        // We'll infer the type of the variable up to the last filter (excluding this one)\n        parentVariable = { ...parentVariable }; // soft clone\n        parentVariable.filters = parentVariable.filters.slice(0, -1); // remove last one\n        const inputType = await this.typeSystem.inferType(parentVariable, partialAst, params.textDocument.uri);\n        const partial = node.name.replace(params_1.CURSOR, '');\n        const options = await this.options((0, TypeSystem_1.isArrayType)(inputType) ? 'array' : inputType);\n        return options\n            .filter(({ name }) => name.startsWith(partial))\n            .map((entry) => {\n            const { textEdit, format } = this.textEdit(node, params.document, entry);\n            return (0, common_1.createCompletionItem)(entry, {\n                kind: vscode_languageserver_1.CompletionItemKind.Function,\n                insertTextFormat: format,\n                textEdit,\n            }, 'filter');\n        });\n    }\n    textEdit(node, document, entry) {\n        var _a, _b;\n        const remainingText = document.source.slice(node.position.end);\n        // Match all the way up to the termination of the filter which could be\n        // another filter (`|`), or the end of a liquid statement.\n        const matchEndOfFilter = remainingText.match(/^(.*?)\\s*(?=\\||-?\\}\\}|-?\\%\\})|^(.*)$/);\n        const endOffset = matchEndOfFilter ? matchEndOfFilter[1].length : remainingText.length;\n        // The start position for a LiquidFilter node includes the `|`. We need to\n        // ignore the pipe and any spaces for our starting position.\n        const pipeRegex = new RegExp(`(\\\\s*\\\\|\\\\s*)(?:${node.name}(?:\\\\}|\\\\%)\\\\})`);\n        const matchFilterPipe = node.source.match(pipeRegex);\n        const startOffet = matchFilterPipe ? matchFilterPipe[1].length : 0;\n        let start = document.textDocument.positionAt(node.position.start + startOffet);\n        let end = document.textDocument.positionAt(node.position.end + endOffset);\n        const { insertText, insertStyle } = appendRequiredParemeters(entry);\n        let newText = insertText;\n        let format = insertStyle;\n        // If the cursor is inside the filter or at the end and it's the same\n        // value as the one we're offering a completion for then we want to restrict\n        // the insert to just the name of the filter.\n        // e.g. `{{ product | image_url: crop: 'center' }}` and we're offering `image_url`\n        const existingFilterOffset = (_b = (_a = remainingText.match(/[^a-zA-Z_]/)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : remainingText.length;\n        if (node.name + remainingText.slice(0, existingFilterOffset) === entry.name) {\n            newText = entry.name;\n            format = vscode_languageserver_1.InsertTextFormat.PlainText;\n            end = document.textDocument.positionAt(node.position.end + existingFilterOffset);\n        }\n        // If the cursor is at the beginning of the string we can consider all\n        // options and should not replace any text.\n        // e.g. `{{ product | image_url: crop: 'center' }}`\n        // e.g. `{{ product |  }}`\n        if (node.name === params_1.CURSOR) {\n            end = start;\n        }\n        return {\n            textEdit: vscode_languageserver_1.TextEdit.replace({\n                start,\n                end,\n            }, newText),\n            format,\n        };\n    }\n}\nexports.FilterCompletionProvider = FilterCompletionProvider;\nfunction deprioritized(entry) {\n    return { ...entry, deprioritized: true };\n}\nfunction appendRequiredParemeters(entry) {\n    var _a;\n    let insertText = entry.name;\n    let insertStyle = vscode_languageserver_1.InsertTextFormat.PlainText;\n    if (!((_a = entry === null || entry === void 0 ? void 0 : entry.parameters) === null || _a === void 0 ? void 0 : _a.length)) {\n        return { insertText, insertStyle };\n    }\n    const requiredPositionalParams = entry.parameters\n        .filter((p) => p.required && p.positional)\n        .map(formatParameter);\n    const requiredNamedParams = entry.parameters\n        .filter((p) => p.required && !p.positional)\n        .map(formatParameter);\n    if (requiredPositionalParams.length) {\n        insertText += `: ${requiredPositionalParams.join(', ')}`;\n        insertStyle = vscode_languageserver_1.InsertTextFormat.Snippet;\n    }\n    if (requiredNamedParams.length) {\n        insertText += `: ${requiredNamedParams.join(', ')}`;\n        insertStyle = vscode_languageserver_1.InsertTextFormat.Snippet;\n    }\n    return {\n        insertText,\n        insertStyle,\n    };\n}\nfunction formatParameter(parameter, index) {\n    let cursorLocation = '';\n    if (parameter.positional) {\n        cursorLocation = `$\\{${index + 1}:${parameter.name}\\}`;\n    }\n    else {\n        cursorLocation = `$${index + 1}`;\n    }\n    if (parameter.types[0] === 'string') {\n        cursorLocation = `'${cursorLocation}'`;\n    }\n    return parameter.positional ? cursorLocation : `${parameter.name}: ${cursorLocation}`;\n}\n//# sourceMappingURL=FilterCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FilterNamedParameterCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass FilterNamedParameterCompletionProvider {\n    constructor(themeDocset) {\n        this.themeDocset = themeDocset;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node } = params.completionContext;\n        if (!node || node.type !== liquid_html_parser_1.NodeTypes.VariableLookup) {\n            return [];\n        }\n        if (!node.name || node.lookups.length > 0) {\n            // We only do top level in this one.\n            return [];\n        }\n        const partial = node.name.replace(params_1.CURSOR, '');\n        const currentContext = params.completionContext.ancestors.at(-1);\n        if (!currentContext || (currentContext === null || currentContext === void 0 ? void 0 : currentContext.type) !== liquid_html_parser_1.NodeTypes.LiquidFilter) {\n            return [];\n        }\n        const filters = await this.themeDocset.filters();\n        const foundFilter = filters.find((f) => f.name === currentContext.name);\n        if (!(foundFilter === null || foundFilter === void 0 ? void 0 : foundFilter.parameters)) {\n            return [];\n        }\n        const filteredOptions = foundFilter.parameters.filter((p) => !p.positional && p.name.startsWith(partial));\n        return filteredOptions.map(({ description, name, types }) => {\n            const { textEdit, format } = this.textEdit(node, params.document, name, types[0]);\n            return (0, common_1.createCompletionItem)({\n                name,\n                description,\n            }, {\n                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,\n                insertTextFormat: format,\n                // We want to force these options to appear first in the list given\n                // the context that they are being requested in.\n                sortText: `1${name}`,\n                textEdit,\n            }, 'filter', Array.isArray(types) ? types[0] : 'unknown');\n        });\n    }\n    textEdit(node, document, name, type) {\n        var _a, _b;\n        const remainingText = document.source.slice(node.position.end);\n        // Match all the way up to the termination of the parameter which could be\n        // another parameter (`,`), filter (`|`), or the end of a liquid statement.\n        const match = remainingText.match(/^(.*?)\\s*(?=,|\\||-?\\}\\}|-?\\%\\})|^(.*)$/);\n        const offset = match ? match[0].length : remainingText.length;\n        const existingParameterOffset = (_b = (_a = remainingText.match(/[^a-zA-Z]/)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : remainingText.length;\n        let start = document.textDocument.positionAt(node.position.start);\n        let end = document.textDocument.positionAt(node.position.end + offset);\n        let newText = type === 'string' ? `${name}: '$1'` : `${name}: `;\n        let format = type === 'string' ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText;\n        // If the cursor is inside the parameter or at the end and it's the same\n        // value as the one we're offering a completion for then we want to restrict\n        // the insert to just the name of the parameter.\n        // e.g. `{{ product | image_url: crop: 'center' }}` and we're offering `crop`\n        if (node.name + remainingText.slice(0, existingParameterOffset) == name) {\n            newText = name;\n            format = vscode_languageserver_1.InsertTextFormat.PlainText;\n            end = document.textDocument.positionAt(node.position.end + existingParameterOffset);\n        }\n        // If the cursor is at the beginning of the string we can consider all\n        // options and should not replace any text.\n        // e.g. `{{ product | image_url: crop: 'center' }}`\n        // e.g. `{{ product | image_url:  }}`\n        if (node.name === '') {\n            end = start;\n        }\n        return {\n            textEdit: vscode_languageserver_1.TextEdit.replace({\n                start,\n                end,\n            }, newText),\n            format,\n        };\n    }\n}\nexports.FilterNamedParameterCompletionProvider = FilterNamedParameterCompletionProvider;\n//# sourceMappingURL=FilterNamedParameterCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlAttributeCompletionProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass HtmlAttributeCompletionProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = (0, utils_1.findLast)(ancestors, utils_1.isAttrEmpty);\n        const grandParentNode = (0, utils_1.findLast)(ancestors, utils_1.isNamedHtmlElementNode);\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!node || !parentNode || !grandParentNode || !document) {\n            return [];\n        }\n        if (!(0, utils_1.isTextNode)(node) || !(0, utils_1.isAttrEmpty)(parentNode) || !(0, utils_1.isNamedHtmlElementNode)(grandParentNode)) {\n            return [];\n        }\n        const grandParentNodeName = (0, utils_1.getCompoundName)(grandParentNode);\n        const name = node.value;\n        const partial = name.replace(params_1.CURSOR, '');\n        const options = getOptions(partial, grandParentNodeName);\n        const attributeTagRange = this.attributeTagRange(node, document);\n        const hasExistingAttributeValue = this.hasExistingAttributeValue(attributeTagRange, document);\n        const hasLiquidTag = this.hasLiquidTag(attributeTagRange, document);\n        return options.sort(common_1.sortByName).map((tag) => {\n            return toCompletionItem(tag, attributeTagRange, hasExistingAttributeValue, hasLiquidTag);\n        });\n    }\n    hasExistingAttributeValue(attributeTagRange, document) {\n        return /^\\s*=/.test(document.source.slice(document.textDocument.offsetAt(attributeTagRange.end)));\n    }\n    hasLiquidTag(attributeTagRange, document) {\n        return /^(?:\\{%|\\{\\{)/.test(document.source.slice(document.textDocument.offsetAt(attributeTagRange.end)));\n    }\n    // Find the range of the attribute partial. If the attribute contains any liquid code, the range\n    // will end before the first character of the liquid block.\n    attributeTagRange(node, document) {\n        var _a, _b;\n        if (node.type === 'TextNode' && node.value === params_1.CURSOR) {\n            // If you try to auto-complete with no provided attribute tag,\n            // we will not try to override the subsequent character.\n            // E.g. <a href=\"\" >\n            return {\n                start: document.textDocument.positionAt(node.position.start),\n                end: document.textDocument.positionAt(node.position.start),\n            };\n        }\n        const sourcePartialPastCursor = document.source.slice(node.position.end);\n        const attributeEndOffset = (_b = (_a = sourcePartialPastCursor.match(/[\\s=]|\\{%|\\{\\{|>/)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : sourcePartialPastCursor.length;\n        return {\n            start: document.textDocument.positionAt(node.position.start),\n            end: document.textDocument.positionAt(node.position.end + attributeEndOffset),\n        };\n    }\n}\nexports.HtmlAttributeCompletionProvider = HtmlAttributeCompletionProvider;\nfunction getOptions(partial, parentNodeName) {\n    var _a;\n    const tag = docset_1.HtmlData.tags.find((tag) => tag.name === parentNodeName);\n    const parentAttributes = (_a = tag === null || tag === void 0 ? void 0 : tag.attributes) !== null && _a !== void 0 ? _a : [];\n    return [...parentAttributes, ...docset_1.HtmlData.globalAttributes].filter((x) => x.name.startsWith(partial));\n}\nfunction toCompletionItem(tag, attributeTagRange, hasExistingAttributeValue, hasLiquidTag) {\n    const attributeWithValue = !tag.valueSet || tag.valueSet !== 'v';\n    const insertSnippet = attributeWithValue && !hasExistingAttributeValue && !hasLiquidTag;\n    return {\n        label: tag.name,\n        kind: vscode_languageserver_1.CompletionItemKind.Value,\n        insertTextFormat: insertSnippet ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText,\n        textEdit: vscode_languageserver_1.TextEdit.replace(attributeTagRange, insertSnippet ? `${tag.name}=\"$1\"$0` : tag.name),\n        documentation: {\n            kind: 'markdown',\n            value: (0, docset_1.renderHtmlEntry)(tag),\n        },\n    };\n}\n//# sourceMappingURL=HtmlAttributeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlAttributeValueCompletionProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass HtmlAttributeValueCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        var _a, _b;\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const attributeNode = (0, utils_1.findLast)(ancestors, utils_1.isHtmlAttribute);\n        const tagNode = (0, utils_1.findLast)(ancestors, utils_1.isNamedHtmlElementNode);\n        if (!node ||\n            !attributeNode ||\n            !tagNode ||\n            !(0, utils_1.isTextNode)(node) ||\n            !(0, utils_1.isHtmlAttribute)(attributeNode) ||\n            !(0, utils_1.isNamedHtmlElementNode)(tagNode) ||\n            (0, utils_1.isAttrEmpty)(attributeNode) ||\n            !attributeNode.value.includes(node)) {\n            return [];\n        }\n        const tagName = (0, utils_1.getCompoundName)(tagNode);\n        const attrName = (0, utils_1.getCompoundName)(attributeNode);\n        const name = node.value;\n        const partial = name.replace(params_1.CURSOR, '');\n        const tagEntry = docset_1.HtmlData.tags.find((tag) => tag.name === tagName);\n        const attribute = (_a = docset_1.HtmlData.globalAttributes.find((attr) => attr.name === attrName)) !== null && _a !== void 0 ? _a : tagEntry === null || tagEntry === void 0 ? void 0 : tagEntry.attributes.find((attr) => attr.name === attrName);\n        const valueSetName = attribute === null || attribute === void 0 ? void 0 : attribute.valueSet;\n        const valueSetEntry = docset_1.HtmlData.valueSets.find((valueSet) => valueSet.name === valueSetName);\n        const options = ((_b = valueSetEntry === null || valueSetEntry === void 0 ? void 0 : valueSetEntry.values) !== null && _b !== void 0 ? _b : []).filter((value) => value.name.startsWith(partial));\n        return options\n            .sort(common_1.sortByName)\n            .map((option) => toCompletionItem(option, attribute && 'references' in attribute ? attribute : tagEntry));\n    }\n}\nexports.HtmlAttributeValueCompletionProvider = HtmlAttributeValueCompletionProvider;\nfunction toCompletionItem(value, parentEntry) {\n    return {\n        label: value.name,\n        kind: vscode_languageserver_1.CompletionItemKind.Value,\n        documentation: {\n            kind: 'markdown',\n            value: (0, docset_1.renderHtmlEntry)(value, parentEntry),\n        },\n    };\n}\n//# sourceMappingURL=HtmlAttributeValueCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass HtmlTagCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        const grandParentNode = ancestors.at(-2);\n        if (node && node.type === liquid_html_parser_1.NodeTypes.HtmlVoidElement) {\n            const options = docset_1.HtmlData.tags.filter((tag) => tag.name === node.name);\n            return options.map(toCompletionItem);\n        }\n        if (!node || !parentNode || !(0, utils_1.isTextNode)(node) || !canComplete(node, parentNode)) {\n            return [];\n        }\n        const name = node.value;\n        const partial = name.replace(params_1.CURSOR, '');\n        const options = getOptions(partial, parentNode, grandParentNode);\n        return options.sort(common_1.sortByName).map(toCompletionItem);\n    }\n}\nexports.HtmlTagCompletionProvider = HtmlTagCompletionProvider;\nfunction canComplete(node, parentNode) {\n    return (isElementOrDanglingClose(parentNode) &&\n        parentNode.name.includes(node) &&\n        parentNode.name.length === 1);\n}\nfunction getOptions(partial, parentNode, grandParentNode) {\n    if (parentNode.type === liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose) {\n        return grandParentCloseOption(grandParentNode);\n    }\n    const grandParentName = getGrandParentName(grandParentNode);\n    return docset_1.HtmlData.tags\n        .filter((tag) => tag.name.startsWith(partial))\n        .concat(grandParentName && partial === ''\n        ? {\n            name: '/' + grandParentName,\n            description: '',\n            attributes: [],\n            references: [],\n        }\n        : []);\n}\nfunction toCompletionItem(tag) {\n    return {\n        label: tag.name,\n        kind: vscode_languageserver_1.CompletionItemKind.Property,\n        documentation: {\n            kind: 'markdown',\n            value: (0, docset_1.renderHtmlEntry)(tag),\n        },\n    };\n}\nfunction grandParentCloseOption(grandParentNode) {\n    var _a;\n    const grandParentName = getGrandParentName(grandParentNode);\n    if (grandParentName) {\n        return [\n            (_a = docset_1.HtmlData.tags.find((tag) => tag.name === grandParentName)) !== null && _a !== void 0 ? _a : {\n                name: grandParentName,\n                description: '',\n                attributes: [],\n                references: [],\n            },\n        ];\n    }\n    else {\n        return [];\n    }\n}\nfunction getGrandParentName(grandParentNode) {\n    if (grandParentNode &&\n        grandParentNode.type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n        grandParentNode.name.length === 1 &&\n        (0, utils_1.isTextNode)(grandParentNode.name[0])) {\n        return grandParentNode.name[0].value.replace(params_1.CURSOR, '');\n    }\n}\nfunction isElementOrDanglingClose(node) {\n    return [liquid_html_parser_1.NodeTypes.HtmlElement, liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose].includes(node.type);\n}\n//# sourceMappingURL=HtmlTagCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidDocParamTypeCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nclass LiquidDocParamTypeCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node ||\n            !parentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.TextNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.LiquidRawTag ||\n            parentNode.name !== 'doc') {\n            return [];\n        }\n        /**\n         * We need to make sure we're trying to code complete after\n         * the param tag's `{` character.\n         *\n         * We will be removing any spaces in case there are any formatting issues.\n         */\n        const fragments = node.value.split(' ').filter(Boolean);\n        if (fragments.length > 2 ||\n            fragments[0] !== `@${theme_check_common_1.SupportedDocTagTypes.Param}` ||\n            !/^\\{[a-zA-Z]*$/.test(fragments[1])) {\n            return [];\n        }\n        return Object.values(theme_check_common_1.SupportedParamTypes).map((label) => ({\n            label,\n            kind: vscode_languageserver_1.CompletionItemKind.EnumMember,\n            insertText: label,\n        }));\n    }\n}\nexports.LiquidDocParamTypeCompletionProvider = LiquidDocParamTypeCompletionProvider;\n//# sourceMappingURL=LiquidDocParamTypeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidDocTagCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst liquidDoc_1 = require(\"../../utils/liquidDoc\");\nclass LiquidDocTagCompletionProvider {\n    constructor() { }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node ||\n            !parentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.TextNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.LiquidRawTag ||\n            parentNode.name !== 'doc' ||\n            !node.value.startsWith('@')) {\n            return [];\n        }\n        // Need to offset the '@' symbol by 1\n        let start = params.document.textDocument.positionAt(node.position.start + 1);\n        let end = params.document.textDocument.positionAt(node.position.end);\n        return Object.entries(liquidDoc_1.SUPPORTED_LIQUID_DOC_TAG_HANDLES)\n            .filter(([label]) => label.startsWith(node.value.slice(1)))\n            .map(([label, { description, example, template }]) => ({\n            label,\n            kind: vscode_languageserver_1.CompletionItemKind.EnumMember,\n            documentation: {\n                kind: vscode_languageserver_1.MarkupKind.Markdown,\n                value: (0, liquidDoc_1.formatLiquidDocTagHandle)(label, description, example),\n            },\n            textEdit: vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(start, end), template),\n            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,\n        }));\n    }\n}\nexports.LiquidDocTagCompletionProvider = LiquidDocTagCompletionProvider;\n//# sourceMappingURL=LiquidDocTagCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidTagsCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst utils_1 = require(\"../../utils\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass LiquidTagsCompletionProvider {\n    constructor(themeDocset) {\n        this.themeDocset = themeDocset;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        if (!node || node.type !== liquid_html_parser_1.NodeTypes.LiquidTag) {\n            return [];\n        }\n        if (typeof node.markup !== 'string' || node.markup !== '') {\n            return [];\n        }\n        const partial = node.name.replace(params_1.CURSOR, '');\n        const blockParent = findParentNode(partial, ancestors);\n        const tags = await this.themeDocset.tags();\n        return tags\n            .filter(({ name }) => name.startsWith(partial))\n            .sort(common_1.sortByName)\n            .map(toCompletionItem(params, node, ancestors, partial))\n            .concat(blockParent && `end${blockParent.name}`.startsWith(partial)\n            ? {\n                label: `end${blockParent.name}`,\n                kind: vscode_languageserver_1.CompletionItemKind.Keyword,\n                sortText: `!end${blockParent.name}`, // we want this first.\n            }\n            : []);\n    }\n}\nexports.LiquidTagsCompletionProvider = LiquidTagsCompletionProvider;\nfunction findParentNode(partial, ancestors) {\n    if (!'end'.startsWith(partial))\n        return;\n    const potentialParentName = partial.replace(/^e(nd?)?/, '');\n    const parentNode = ancestors.at(-1);\n    const grandParentNode = ancestors.at(-2);\n    // This covers the scenario where we have an open liquid tag as a parent\n    //\n    // e.g.\n    // {% liquid\n    //   echo 'hello'\n    // %}\n    //\n    // In that scenario, we have the following tree:\n    //\n    // type: Document\n    // children:\n    //   - LiquidTag#liquid\n    if (parentNode && parentNode.type === 'LiquidTag' && parentNode.name === liquid_html_parser_1.NamedTags.liquid) {\n        return;\n    }\n    // This covers the scenario where we have a dangling conditional tag\n    //\n    // e.g.\n    // {% if cond %}\n    //   hello\n    // {% end %}\n    //\n    // In that scenario, we have the following tree:\n    //\n    // type: Document\n    // children:\n    //   - LiquidTag#if\n    //     children:\n    //       - LiquidBranch\n    //         children:\n    //           - TextNode#hello\n    //           - LiquidTag#end\n    if (parentNode &&\n        parentNode.type === 'LiquidBranch' &&\n        grandParentNode &&\n        grandParentNode.type === 'LiquidTag' &&\n        grandParentNode.name.startsWith(potentialParentName)) {\n        return grandParentNode;\n    }\n    // This covers the scenario where we have a dangling block tag\n    //\n    // e.g.\n    // {% form \"cart\", cart %}\n    //   hello\n    // {% end %}\n    //\n    // In that scenario, we have the following tree:\n    //\n    // type: Document\n    // children:\n    //   - LiquidTag#form\n    //     children:\n    //       - TextNode#hello\n    //       - LiquidTag#end\n    if (parentNode &&\n        parentNode.type === 'LiquidTag' &&\n        parentNode.name.startsWith(potentialParentName)) {\n        return parentNode;\n    }\n    // This covers the case where a raw tag is being parsed as a LiquidTag\n    // because of the missing endtag.\n    //\n    // e.g.\n    // {% comment %}\n    //   hello\n    // {% end %}\n    //\n    // In that scenario, we have the following tree:\n    //\n    // type: Document\n    // children:\n    //   - LiquidTag#comment\n    //   - TextNode#hello\n    //   - LiquidTag#end\n    let previousNode;\n    if (parentNode &&\n        'children' in parentNode &&\n        Array.isArray(parentNode.children) &&\n        (previousNode = (0, utils_1.findLast)(parentNode.children, (node) => node.type === 'LiquidTag' &&\n            node.name.startsWith(potentialParentName) &&\n            (liquid_html_parser_1.BLOCKS.includes(node.name) || liquid_html_parser_1.RAW_TAGS.includes(node.name))))) {\n        return previousNode;\n    }\n}\nfunction toCompletionItem(params, node, ancestors, partial) {\n    const { textDocument, source } = params.document;\n    /** Are we in a {% liquid %} context? Where new lines imply new tags? */\n    const isInLiquidLiquidTag = ancestors.some(isLiquidLiquidTag);\n    /** 0-indexed offset of cursor position */\n    const cursorOffset = textDocument.offsetAt(params.position);\n    /** Position of where the start of the word being completed is */\n    const startOfPartial = textDocument.positionAt(cursorOffset - partial.length);\n    /** Position of the rightmost position in the doc... in {% partial %} it would be after '%}' */\n    const endOfBlockStart = findEndOfBlockStart(params, node, isInLiquidLiquidTag);\n    /** whitespaceStart is '-' or '' depending on if it strips whitespace to the left of the tag */\n    const whitespaceStart = node.whitespaceStart;\n    /** whitespaceEnd is '-' or '' depending on if it strips whitespace to the right of the tag */\n    const whitespaceEnd = inferWhitespaceEnd(textDocument, endOfBlockStart, params, whitespaceStart, source, isInLiquidLiquidTag);\n    return (tag) => {\n        const extraProperties = {\n            kind: vscode_languageserver_1.CompletionItemKind.Keyword,\n            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,\n        };\n        if (shouldSnippetComplete(params, endOfBlockStart)) {\n            extraProperties.insertTextFormat = vscode_languageserver_1.InsertTextFormat.Snippet;\n            extraProperties.insertTextMode = vscode_languageserver_1.InsertTextMode.adjustIndentation;\n            extraProperties.textEdit = vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(startOfPartial, endOfBlockStart), toSnippetCompleteText(tag, node, params, whitespaceStart, whitespaceEnd, textDocument, isInLiquidLiquidTag));\n        }\n        return (0, common_1.createCompletionItem)(tag, extraProperties, 'tag');\n    };\n}\n/**\n * Turns out it's hard to tell if something needs an `end$tag` or not.\n *\n * The safest way to guess that something shouldn't be completed is to check whether markup already exists.\n *\n * Probably shouldn't snippet complete:\n * {% if| cond %}{% endif %}\n * {% render| 'product' %}\n *\n * Probably should snippet complete:\n * {% if| %}\n * {% render| %}\n *\n * It's not perfect, but it covers swapping if for unless and so on.\n */\nfunction shouldSnippetComplete(params, endOfBlockStart) {\n    const { completionContext } = params;\n    const { node, ancestors } = completionContext !== null && completionContext !== void 0 ? completionContext : {};\n    if (!node || !ancestors || node.type !== liquid_html_parser_1.NodeTypes.LiquidTag)\n        return false;\n    /**\n     * If the tag has non-empty markup, we can assume that the name is being\n     * edited. So adding the close tag would be very weird.\n     *\n     * User replaces `if` with `unless`.\n     *\n     * Input\n     *   {% if some_cond %}\n     *   {% endif %}\n     *\n     *  Stuff we DON'T want:\n     *   {% unless some_cond %}\n     *     expression\n     *   {% endunless %}\n     *   {% endif %}\n     *\n     *  Stuff we DO want:\n     *   {% unless some_cond %}\n     *   {% endif %}\n     *\n     * We'll solve the negate condition differently.\n     */\n    const markup = existingMarkup(params, endOfBlockStart);\n    return markup.trim() === '';\n}\nfunction toSnippetCompleteText(tag, node, params, whitespaceStart, whitespaceEnd, textDocument, isInLiquidLiquidTag) {\n    let snippet = toSnippet(tag);\n    if (shouldInline(textDocument, params, node, isInLiquidLiquidTag)) {\n        // Then we need to remove the newlines from the snippet\n        snippet = snippet.replace(/\\n\\s*/g, '');\n    }\n    if (isInLiquidLiquidTag) {\n        // then we need to get rid of all the {% and %} from the snippet\n        snippet = snippet.replace(/\\{%-?[ \\t]*/g, '').replace(/[ \\t]*-?%\\}/g, '');\n    }\n    if (tag.syntax_keywords) {\n        // Then we need to replace the keywords from the snippet with ${n:keyword}\n        let i = 1;\n        for (const { keyword } of tag.syntax_keywords) {\n            if (keyword.includes('expression') ||\n                keyword.includes('code') ||\n                keyword.includes('content')) {\n                // first_expression, second_expression, javascript_code,\n                // forloop_content... we don't want those. Just the cursor position.\n                snippet = snippet.replace(keyword, `\\$${i}`);\n            }\n            else {\n                snippet = snippet.replace(keyword, `\\${${i}:${keyword}}`);\n            }\n            i++;\n        }\n    }\n    // We need to add the whitespace stripping characters to the snippet if there are any to add\n    snippet = withCorrectWhitespaceStrippingCharacters(snippet, whitespaceStart, whitespaceEnd);\n    if (isInLiquidLiquidTag) {\n        return snippet.trimStart();\n    }\n    else {\n        // VS Code doesn't like it when the snippet starts before the word\n        // being completed. So the completion item we offer starts off after\n        // the {%-?\\s part.\n        return snippet.slice(2 + whitespaceStart.length + 1);\n    }\n}\nfunction toSnippet(tag) {\n    // Some of those are exceptional and we don't really want to use the same syntax used on shopify.dev\n    switch (tag.name) {\n        case 'echo':\n            return '{% echo $1 %}';\n        case 'cycle':\n            return \"{% cycle '$1', '$2'$3 %}\";\n        case 'content_for':\n            return \"{% content_for '$1'$2 %}\";\n        case 'render':\n            return \"{% render '$1'$2 %}\";\n        case 'elsif':\n            return '{% elsif ${1:condition} %}';\n        case 'else':\n            return '{% else %}';\n    }\n    if (tag.syntax) {\n        return tag.syntax;\n    }\n    else if (isBlockTag(tag.name)) {\n        return `{% ${tag.name}$1 %}\\n  $2\\n{% end${tag.name} %}`;\n    }\n    else {\n        return `{% ${tag.name}$1 %}`;\n    }\n}\n/**\n * If the tag is on a new line, then we can use the snippet with newline.\n * If there's more content on that line, then we inline the snippet in one line.\n */\nfunction shouldInline(textDocument, params, node, isInLiquidLiquidTag) {\n    if (isInLiquidLiquidTag)\n        return false;\n    const endPosition = textDocument.positionAt(node.blockStartPosition.start);\n    const startPosition = vscode_languageserver_1.Position.create(endPosition.line, 0);\n    const textBeforeTag = textDocument.getText(vscode_languageserver_1.Range.create(startPosition, endPosition));\n    return textBeforeTag.trim() !== '';\n}\n/**\n * We mirror the whitespace stripping of the start tag.\n * {% if -%} => {% if -%}{%- endif %}\n */\nfunction withCorrectWhitespaceStrippingCharacters(snippet, whitespaceStart, whitespaceEnd) {\n    var _a, _b;\n    let starti = 0;\n    let endi = 0;\n    let countOfEndTags = (_b = (_a = snippet.match(/%\\}/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n    snippet = snippet\n        .replace(/\\{%/g, () => {\n        if (starti++ === 0) {\n            // mirror outside stripping\n            return '{%' + whitespaceStart;\n        }\n        else {\n            // mirror inside stripping\n            return '{%' + whitespaceEnd;\n        }\n    })\n        .replace(/%\\}/g, () => {\n        if (countOfEndTags > 1 && endi++ === countOfEndTags - 1) {\n            // mirror outside stripping\n            return whitespaceStart + '%}';\n        }\n        else {\n            // mirror inside stripping\n            return whitespaceEnd + '%}';\n        }\n    });\n    return snippet;\n}\nfunction findEndOfBlockStart(context, node, isInLiquidLiquidTag) {\n    const doc = context.document.textDocument;\n    const source = context.document.source;\n    const start = node.position.start;\n    if (isInLiquidLiquidTag) {\n        return doc.positionAt(source.indexOf('\\n', start));\n    }\n    const end = source.indexOf('%}', start);\n    const endOpen = source.indexOf('{%', start + 2);\n    const isThere = end !== -1 && (endOpen === -1 || end < endOpen);\n    if (isThere) {\n        // %} => + 2\n        return doc.positionAt(end + 2);\n    }\n    else {\n        // return cursor position.\n        return context.position;\n    }\n}\nfunction existingMarkup(params, endOfBlockStart) {\n    const { document } = params;\n    const { source, textDocument } = document;\n    return source\n        .slice(textDocument.offsetAt(params.position), textDocument.offsetAt(endOfBlockStart))\n        .replace(/-?%\\}/, '');\n}\n// We're trying to infer if we should trim the whitespace to the right given what the user has already written\n// {%  if|        => ''\n// {%- if|        => '-'\n// {%- if|  %}    => ''\n// {%- if| -%}    => '-'\n// {%  if| -%}    => '-'\n// {% liquid\n//       if|      => ''\n// %}\nfunction inferWhitespaceEnd(textDocument, endOfBlockStart, params, whitespaceStart, source, isInLiquidLiquidTag) {\n    if (isInLiquidLiquidTag) {\n        return '';\n    }\n    else if (textDocument.offsetAt(endOfBlockStart) === textDocument.offsetAt(params.position)) {\n        return whitespaceStart; // if the %} wasn't auto inserted, copy whatever was there on the other side\n    }\n    else if (source.charAt(textDocument.offsetAt(endOfBlockStart) - 3) === '-') {\n        return '-';\n    }\n    else {\n        return '';\n    }\n}\nfunction isLiquidLiquidTag(parent) {\n    return parent.type === liquid_html_parser_1.NodeTypes.LiquidTag && parent.name === liquid_html_parser_1.NamedTags.liquid;\n}\nfunction isBlockTag(name) {\n    return liquid_html_parser_1.BLOCKS.includes(name);\n}\n//# sourceMappingURL=LiquidTagsCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectAttributeCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst TypeSystem_1 = require(\"../../TypeSystem\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nconst ArrayCoreProperties = ['size', 'first', 'last'];\nconst StringCoreProperties = ['size'];\nclass ObjectAttributeCompletionProvider {\n    constructor(typeSystem, getThemeSettingsSchema) {\n        this.typeSystem = typeSystem;\n        this.getThemeSettingsSchema = getThemeSettingsSchema;\n    }\n    async completions(params) {\n        var _a;\n        if (!params.completionContext)\n            return [];\n        const { partialAst, node } = params.completionContext;\n        if (!node || node.type !== liquid_html_parser_1.NodeTypes.VariableLookup) {\n            return [];\n        }\n        if (node.lookups.length === 0) {\n            // We only do lookups in this one\n            return [];\n        }\n        const lastLookup = node.lookups.at(-1);\n        if (lastLookup.type !== liquid_html_parser_1.NodeTypes.String) {\n            // We don't complete numbers, or variable lookups\n            return [];\n        }\n        const partial = lastLookup.value.replace(params_1.CURSOR, '');\n        // Fake a VariableLookup up to the last one.\n        const parentLookup = { ...node };\n        parentLookup.lookups = [...parentLookup.lookups];\n        parentLookup.lookups.pop();\n        const parentType = await this.typeSystem.inferType(parentLookup, partialAst, params.textDocument.uri);\n        if ((0, TypeSystem_1.isArrayType)(parentType)) {\n            return completionItems(ArrayCoreProperties.map((name) => ({ name })), partial);\n        }\n        else if (parentType === 'string') {\n            return completionItems(StringCoreProperties.map((name) => ({ name })), partial);\n        }\n        const objectMap = await this.typeSystem.objectMap(params.textDocument.uri, partialAst);\n        const parentTypeProperties = ((_a = objectMap[parentType]) === null || _a === void 0 ? void 0 : _a.properties) || [];\n        return completionItems(parentTypeProperties, partial);\n    }\n}\nexports.ObjectAttributeCompletionProvider = ObjectAttributeCompletionProvider;\nfunction completionItems(options, partial) {\n    return options\n        .filter(({ name }) => name.startsWith(partial))\n        .sort(common_1.sortByName)\n        .map(toPropertyCompletionItem);\n}\nfunction toPropertyCompletionItem(object) {\n    return (0, common_1.createCompletionItem)(object, { kind: vscode_languageserver_1.CompletionItemKind.Variable });\n}\n//# sourceMappingURL=ObjectAttributeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst params_1 = require(\"../params\");\nconst common_1 = require(\"./common\");\nclass ObjectCompletionProvider {\n    constructor(typeSystem) {\n        this.typeSystem = typeSystem;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { partialAst, node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node || node.type !== liquid_html_parser_1.NodeTypes.VariableLookup) {\n            return [];\n        }\n        if (!node.name || node.lookups.length > 0) {\n            // We only do top level in this one.\n            return [];\n        }\n        // ContentFor and Render uses VariableLookup to support completion of NamedParams.\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.ContentForMarkup ||\n            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.RenderMarkup) {\n            return [];\n        }\n        const partial = node.name.replace(params_1.CURSOR, '');\n        const options = await this.typeSystem.availableVariables(partialAst, partial, node, params.textDocument.uri);\n        return options.map(({ entry, type }) => (0, common_1.createCompletionItem)(entry, { kind: vscode_languageserver_1.CompletionItemKind.Variable }, 'object', type));\n    }\n}\nexports.ObjectCompletionProvider = ObjectCompletionProvider;\n//# sourceMappingURL=ObjectCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nclass RenderSnippetCompletionProvider {\n    constructor(getSnippetNamesForURI = async () => []) {\n        this.getSnippetNamesForURI = getSnippetNamesForURI;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node ||\n            !parentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.String ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.RenderMarkup) {\n            return [];\n        }\n        const options = await this.getSnippetNamesForURI(params.textDocument.uri);\n        const partial = node.value;\n        return options\n            .filter((option) => option.startsWith(partial))\n            .map((option) => ({\n            label: option,\n            kind: vscode_languageserver_1.CompletionItemKind.Snippet,\n            documentation: {\n                kind: 'markdown',\n                value: `snippets/${option}.liquid`,\n            },\n        }));\n    }\n}\nexports.RenderSnippetCompletionProvider = RenderSnippetCompletionProvider;\n//# sourceMappingURL=RenderSnippetCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetParameterCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst params_1 = require(\"../params\");\nconst liquidDoc_1 = require(\"../../utils/liquidDoc\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nclass RenderSnippetParameterCompletionProvider {\n    constructor(getSnippetDefinitionForURI) {\n        this.getSnippetDefinitionForURI = getSnippetDefinitionForURI;\n    }\n    async completions(params) {\n        var _a, _b;\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        if (!node ||\n            !parentNode ||\n            node.type !== liquid_html_parser_1.NodeTypes.VariableLookup ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.RenderMarkup ||\n            parentNode.snippet.type !== 'String') {\n            return [];\n        }\n        const userInputStr = ((_a = node.name) === null || _a === void 0 ? void 0 : _a.replace(params_1.CURSOR, '')) || '';\n        const snippetDefinition = await this.getSnippetDefinitionForURI(params.textDocument.uri, parentNode.snippet.value);\n        const liquidDocParams = (_b = snippetDefinition === null || snippetDefinition === void 0 ? void 0 : snippetDefinition.liquidDoc) === null || _b === void 0 ? void 0 : _b.parameters;\n        if (!liquidDocParams) {\n            return [];\n        }\n        let offset = node.name === params_1.CURSOR ? 1 : 0;\n        let start = params.document.textDocument.positionAt(node.position.start);\n        let end = params.document.textDocument.positionAt(node.position.end - offset);\n        // We need to find out existing params in the render tag so we don't offer it again for completion\n        const existingRenderParams = parentNode.args\n            .filter((arg) => arg.type === liquid_html_parser_1.NodeTypes.NamedArgument)\n            .map((arg) => arg.name);\n        return liquidDocParams\n            .filter((liquidDocParam) => !existingRenderParams.includes(liquidDocParam.name))\n            .filter((liquidDocParam) => liquidDocParam.name.startsWith(userInputStr))\n            .map((liquidDocParam) => {\n            const paramDefaultValue = (0, theme_check_common_1.getDefaultValueForType)(liquidDocParam.type);\n            const paramValueTemplate = paramDefaultValue === \"''\" ? `'$1'$0` : `\\${1:${paramDefaultValue}}$0`;\n            return {\n                label: liquidDocParam.name,\n                kind: vscode_languageserver_1.CompletionItemKind.Property,\n                documentation: {\n                    kind: vscode_languageserver_1.MarkupKind.Markdown,\n                    value: (0, liquidDoc_1.formatLiquidDocParameter)(liquidDocParam, true),\n                },\n                textEdit: vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(start, end), `${liquidDocParam.name}: ${paramValueTemplate}`),\n                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,\n            };\n        });\n    }\n}\nexports.RenderSnippetParameterCompletionProvider = RenderSnippetParameterCompletionProvider;\n//# sourceMappingURL=RenderSnippetParameterCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TranslationCompletionProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst translations_1 = require(\"../../translations\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nclass TranslationCompletionProvider {\n    constructor(documentManager, getTranslationsForURI) {\n        this.documentManager = documentManager;\n        this.getTranslationsForURI = getTranslationsForURI;\n    }\n    async completions(params) {\n        if (!params.completionContext)\n            return [];\n        const { node, ancestors } = params.completionContext;\n        const parentNode = ancestors.at(-1);\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!node ||\n            node.type !== liquid_html_parser_1.NodeTypes.String ||\n            !parentNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.LiquidVariable ||\n            !document) {\n            return [];\n        }\n        const ast = document.ast;\n        const textDocument = document.textDocument;\n        const translations = await this.getTranslationsForURI(params.textDocument.uri);\n        const partial = node.value;\n        // We only want to show standard translations to complete if the translation\n        // is prefixed by shopify. Otherwise it's too noisy.\n        const options = (0, translations_1.translationOptions)(translations).filter((option) => { var _a; return !((_a = option.path[0]) === null || _a === void 0 ? void 0 : _a.startsWith('shopify')) || partial.startsWith('shopify'); });\n        const [_currentNode, realAncestors] = ast instanceof Error\n            ? [null, []]\n            : (0, theme_check_common_1.findCurrentNode)(ast, textDocument.offsetAt(params.position));\n        // That part feels kind of gross, let me explain...\n        // When we complete translations, we also want to append the `| t` after the\n        // string, but we should only ever do that if the variable didn't _already_ have that.\n        // But since our completion engine works on incomplete code, we need to temporarily\n        // fetch the real node to do the optional | t completion.\n        const realParentNode = realAncestors.at(-1);\n        let shouldAppendTranslateFilter = (realParentNode === null || realParentNode === void 0 ? void 0 : realParentNode.type) === liquid_html_parser_1.NodeTypes.LiquidVariable && (realParentNode === null || realParentNode === void 0 ? void 0 : realParentNode.filters.length) === 0;\n        const quote = node.single ? \"'\" : '\"';\n        let postFix = quote + ' | t';\n        let replaceRange;\n        if (shouldAppendTranslateFilter) {\n            postFix = quote + ' | t';\n            replaceRange = {\n                start: textDocument.positionAt(node.position.start + 1),\n                end: textDocument.positionAt(node.position.end), // including quote\n            };\n        }\n        else {\n            postFix = '';\n            replaceRange = {\n                start: textDocument.positionAt(node.position.start + 1),\n                end: textDocument.positionAt(node.position.end - 1), // excluding quote\n            };\n        }\n        const insertTextStartIndex = partial.lastIndexOf('.') + 1;\n        return options.map(({ path, translation }) => {\n            var _a;\n            const params = (0, translations_1.extractParams)(typeof translation === 'string' ? translation : (_a = Object.values(translation)[0]) !== null && _a !== void 0 ? _a : '');\n            const parameters = (0, translations_1.paramsString)(params);\n            return {\n                label: quote + path.join('.') + quote + ' | t',\n                insertText: path.join('.').slice(insertTextStartIndex),\n                kind: vscode_languageserver_1.CompletionItemKind.Field,\n                textEdit: vscode_languageserver_1.TextEdit.replace(replaceRange, path.join('.') + postFix + (shouldAppendTranslateFilter ? parameters : '')),\n                documentation: {\n                    kind: 'markdown',\n                    value: (0, translations_1.renderTranslation)(translation),\n                },\n            };\n        });\n    }\n}\nexports.TranslationCompletionProvider = TranslationCompletionProvider;\n//# sourceMappingURL=TranslationCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createCompletionItem = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst docset_1 = require(\"../../../docset\");\n// ASCII tokens that make a string appear lower in the list.\n//\n// It's setup so that we can show array filters before \"global\" filters,\n// and similarly array deprecated filters before \"global\" deprecated\n// filters.\nvar SortTokens;\n(function (SortTokens) {\n    SortTokens[\"normal\"] = \"\";\n    SortTokens[\"deprioritized\"] = \"{\";\n    SortTokens[\"deprecated\"] = \"|\";\n    SortTokens[\"deprecatedAndDeprioritized\"] = \"}\";\n})(SortTokens || (SortTokens = {}));\nfunction createCompletionItem(entry, extraProperties = {}, docsetEntryType, entryType) {\n    // prettier-ignore\n    const sortToken = entry.deprecated\n        ? entry.deprioritized\n            ? SortTokens.deprecatedAndDeprioritized\n            : SortTokens.deprecated\n        : entry.deprioritized\n            ? SortTokens.deprioritized\n            : SortTokens.normal;\n    return {\n        label: entry.name,\n        sortText: `${sortToken}${entry.name}`,\n        ...documentationProperties(entry, docsetEntryType, entryType),\n        ...deprecatedProperties(entry),\n        ...extraProperties,\n    };\n}\nexports.createCompletionItem = createCompletionItem;\nfunction documentationProperties(entry, docsetEntryType, entryType) {\n    const value = (0, docset_1.render)(entry, entryType, docsetEntryType);\n    return {\n        documentation: {\n            kind: 'markdown',\n            value,\n        },\n    };\n}\nfunction deprecatedProperties(entry) {\n    if (!entry.deprecated)\n        return {};\n    const tags = [vscode_languageserver_1.CompletionItemTag.Deprecated];\n    return {\n        tags,\n    };\n}\n//# sourceMappingURL=CompletionItemProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortByName = exports.createCompletionItem = void 0;\nvar CompletionItemProperties_1 = require(\"./CompletionItemProperties\");\nObject.defineProperty(exports, \"createCompletionItem\", { enumerable: true, get: function () { return CompletionItemProperties_1.createCompletionItem; } });\nfunction sortByName({ name: nameA }, { name: nameB }) {\n    if (nameA < nameB) {\n        return -1;\n    }\n    if (nameA > nameB) {\n        return 1;\n    }\n    // names must be equal\n    return 0;\n}\nexports.sortByName = sortByName;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_COMPLETION_OPTIONS = void 0;\n/**\n * These definitions are not currently available in the generated Liquid Docs\n * so we're hardcoding them here in the interim.\n */\nexports.DEFAULT_COMPLETION_OPTIONS = {\n    type: \"The type (name) of an existing theme block in your themes /blocks folder. Only applicable when `content_type` is 'block'.\",\n    id: \"A unique identifier and literal string within the section or block that contains the static blocks. Only applicable when `content_type` is 'block'.\",\n    closest: 'A path that provides a way to access the closest resource of a given type.',\n};\n//# sourceMappingURL=contentForParameterCompletionOptions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetCompletionProvider = exports.TranslationCompletionProvider = exports.ObjectCompletionProvider = exports.ObjectAttributeCompletionProvider = exports.LiquidTagsCompletionProvider = exports.FilterNamedParameterCompletionProvider = exports.FilterCompletionProvider = exports.HtmlAttributeValueCompletionProvider = exports.HtmlAttributeCompletionProvider = exports.HtmlTagCompletionProvider = exports.ContentForParameterCompletionProvider = exports.ContentForBlockTypeCompletionProvider = exports.ContentForCompletionProvider = void 0;\nvar ContentForCompletionProvider_1 = require(\"./ContentForCompletionProvider\");\nObject.defineProperty(exports, \"ContentForCompletionProvider\", { enumerable: true, get: function () { return ContentForCompletionProvider_1.ContentForCompletionProvider; } });\nvar ContentForBlockTypeCompletionProvider_1 = require(\"./ContentForBlockTypeCompletionProvider\");\nObject.defineProperty(exports, \"ContentForBlockTypeCompletionProvider\", { enumerable: true, get: function () { return ContentForBlockTypeCompletionProvider_1.ContentForBlockTypeCompletionProvider; } });\nvar ContentForParameterCompletionProvider_1 = require(\"./ContentForParameterCompletionProvider\");\nObject.defineProperty(exports, \"ContentForParameterCompletionProvider\", { enumerable: true, get: function () { return ContentForParameterCompletionProvider_1.ContentForParameterCompletionProvider; } });\nvar HtmlTagCompletionProvider_1 = require(\"./HtmlTagCompletionProvider\");\nObject.defineProperty(exports, \"HtmlTagCompletionProvider\", { enumerable: true, get: function () { return HtmlTagCompletionProvider_1.HtmlTagCompletionProvider; } });\nvar HtmlAttributeCompletionProvider_1 = require(\"./HtmlAttributeCompletionProvider\");\nObject.defineProperty(exports, \"HtmlAttributeCompletionProvider\", { enumerable: true, get: function () { return HtmlAttributeCompletionProvider_1.HtmlAttributeCompletionProvider; } });\nvar HtmlAttributeValueCompletionProvider_1 = require(\"./HtmlAttributeValueCompletionProvider\");\nObject.defineProperty(exports, \"HtmlAttributeValueCompletionProvider\", { enumerable: true, get: function () { return HtmlAttributeValueCompletionProvider_1.HtmlAttributeValueCompletionProvider; } });\nvar FilterCompletionProvider_1 = require(\"./FilterCompletionProvider\");\nObject.defineProperty(exports, \"FilterCompletionProvider\", { enumerable: true, get: function () { return FilterCompletionProvider_1.FilterCompletionProvider; } });\nvar FilterNamedParameterCompletionProvider_1 = require(\"./FilterNamedParameterCompletionProvider\");\nObject.defineProperty(exports, \"FilterNamedParameterCompletionProvider\", { enumerable: true, get: function () { return FilterNamedParameterCompletionProvider_1.FilterNamedParameterCompletionProvider; } });\nvar LiquidTagsCompletionProvider_1 = require(\"./LiquidTagsCompletionProvider\");\nObject.defineProperty(exports, \"LiquidTagsCompletionProvider\", { enumerable: true, get: function () { return LiquidTagsCompletionProvider_1.LiquidTagsCompletionProvider; } });\nvar ObjectAttributeCompletionProvider_1 = require(\"./ObjectAttributeCompletionProvider\");\nObject.defineProperty(exports, \"ObjectAttributeCompletionProvider\", { enumerable: true, get: function () { return ObjectAttributeCompletionProvider_1.ObjectAttributeCompletionProvider; } });\nvar ObjectCompletionProvider_1 = require(\"./ObjectCompletionProvider\");\nObject.defineProperty(exports, \"ObjectCompletionProvider\", { enumerable: true, get: function () { return ObjectCompletionProvider_1.ObjectCompletionProvider; } });\nvar TranslationCompletionProvider_1 = require(\"./TranslationCompletionProvider\");\nObject.defineProperty(exports, \"TranslationCompletionProvider\", { enumerable: true, get: function () { return TranslationCompletionProvider_1.TranslationCompletionProvider; } });\nvar RenderSnippetCompletionProvider_1 = require(\"./RenderSnippetCompletionProvider\");\nObject.defineProperty(exports, \"RenderSnippetCompletionProvider\", { enumerable: true, get: function () { return RenderSnippetCompletionProvider_1.RenderSnippetCompletionProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticsManager = void 0;\nconst offenseToDiagnostic_1 = require(\"./offenseToDiagnostic\");\nclass DiagnosticsManager {\n    constructor(connection) {\n        this.connection = connection;\n        this.diagnostics = new Map();\n    }\n    get(uri) {\n        return this.diagnostics.get(uri);\n    }\n    set(uri, version, offenses) {\n        const anomalies = offenses.map((offense, index) => ({\n            offense,\n            diagnostic: (0, offenseToDiagnostic_1.offenseToDiagnostic)(offense),\n            id: index,\n        }));\n        this.diagnostics.set(uri, {\n            uri,\n            version,\n            anomalies,\n        });\n        this.connection.sendDiagnostics({\n            uri,\n            version,\n            diagnostics: anomalies.map((a) => a.diagnostic),\n        });\n    }\n    clear(uri) {\n        this.diagnostics.delete(uri);\n        this.connection.sendDiagnostics({\n            uri,\n            version: undefined,\n            diagnostics: [],\n        });\n    }\n}\nexports.DiagnosticsManager = DiagnosticsManager;\n//# sourceMappingURL=DiagnosticsManager.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeRunChecks = exports.DiagnosticsManager = void 0;\nvar DiagnosticsManager_1 = require(\"./DiagnosticsManager\");\nObject.defineProperty(exports, \"DiagnosticsManager\", { enumerable: true, get: function () { return DiagnosticsManager_1.DiagnosticsManager; } });\nvar runChecks_1 = require(\"./runChecks\");\nObject.defineProperty(exports, \"makeRunChecks\", { enumerable: true, get: function () { return runChecks_1.makeRunChecks; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.offenseToDiagnostic = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst checkToDocsUrl = theme_check_common_1.allChecks.reduce((acc, checkDescription) => {\n    const url = checkDescription.meta.docs.url;\n    const code = checkDescription.meta.code;\n    if (url !== undefined) {\n        acc[code] = url;\n    }\n    return acc;\n}, {});\nfunction offenseToDiagnostic(offense) {\n    const diagnostic = vscode_languageserver_1.Diagnostic.create(diagnosticRange(offense), offense.message, diagnosticSeverity(offense), offense.check, 'theme-check');\n    const url = checkToDocsUrl[offense.check];\n    if (url) {\n        diagnostic.codeDescription = { href: url };\n    }\n    return diagnostic;\n}\nexports.offenseToDiagnostic = offenseToDiagnostic;\nfunction diagnosticRange({ start, end }) {\n    return {\n        start: {\n            line: start.line,\n            character: start.character,\n        },\n        end: {\n            line: end.line,\n            character: end.character,\n        },\n    };\n}\nfunction diagnosticSeverity(offense) {\n    switch (offense.severity) {\n        case theme_check_common_1.Severity.INFO: {\n            return vscode_languageserver_1.DiagnosticSeverity.Information;\n        }\n        case theme_check_common_1.Severity.WARNING: {\n            return vscode_languageserver_1.DiagnosticSeverity.Warning;\n        }\n        case theme_check_common_1.Severity.ERROR: {\n            return vscode_languageserver_1.DiagnosticSeverity.Error;\n        }\n        default: {\n            return (0, theme_check_common_1.assertNever)(offense.severity);\n        }\n    }\n}\n//# sourceMappingURL=offenseToDiagnostic.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeRunChecks = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nfunction makeRunChecks(documentManager, diagnosticsManager, { fs, loadConfig, themeDocset, jsonValidationSet, getMetafieldDefinitions, }) {\n    return async function runChecks(triggerURIs) {\n        // This function takes an array of triggerURIs so that we can correctly\n        // recheck on file renames that came from out of bounds in a\n        // workspaces.\n        //\n        // e.g. if a user renames\n        //  theme1/snippets/a.liquid to\n        //  theme1/snippets/b.liquid\n        //\n        // then we recheck theme1\n        const fileExists = (0, theme_check_common_1.makeFileExists)(fs);\n        const rootURIs = await Promise.all(triggerURIs.map((uri) => (0, theme_check_common_1.findRoot)(uri, fileExists)));\n        const deduplicatedRootURIs = new Set(rootURIs);\n        await Promise.all([...deduplicatedRootURIs].map(runChecksForRoot));\n        return;\n        async function runChecksForRoot(configFileRootUri) {\n            const config = await loadConfig(configFileRootUri, fs);\n            const theme = documentManager.theme(config.rootUri);\n            const offenses = await (0, theme_check_common_1.check)(theme, config, {\n                fs,\n                themeDocset,\n                jsonValidationSet,\n                getMetafieldDefinitions,\n                // TODO should do something for app blocks?\n                async getBlockSchema(name) {\n                    // We won't preload here. If it's available, we'll give it. Otherwise expect nothing.\n                    const uri = theme_check_common_1.path.join(config.rootUri, 'blocks', `${name}.liquid`);\n                    const doc = documentManager.get(uri);\n                    if ((doc === null || doc === void 0 ? void 0 : doc.type) !== theme_check_common_1.SourceCodeType.LiquidHtml)\n                        return undefined;\n                    const schema = await doc.getSchema();\n                    return schema;\n                },\n                async getSectionSchema(name) {\n                    // We won't preload here. If it's available, we'll give it. Otherwise expect nothing.\n                    const uri = theme_check_common_1.path.join(config.rootUri, 'sections', `${name}.liquid`);\n                    const doc = documentManager.get(uri);\n                    if ((doc === null || doc === void 0 ? void 0 : doc.type) !== theme_check_common_1.SourceCodeType.LiquidHtml)\n                        return undefined;\n                    const schema = await doc.getSchema();\n                    return schema;\n                },\n            });\n            // We iterate over the theme files (as opposed to offenses) because if\n            // there were offenses before, we need to send an empty array to clear\n            // them.\n            for (const sourceCode of theme) {\n                const sourceCodeOffenses = offenses.filter((offense) => offense.uri === sourceCode.uri);\n                diagnosticsManager.set(sourceCode.uri, sourceCode.version, sourceCodeOffenses);\n            }\n        }\n    };\n}\nexports.makeRunChecks = makeRunChecks;\n//# sourceMappingURL=runChecks.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlData = void 0;\nconst htmlData = __importStar(require(\"@vscode/web-custom-data/data/browsers.html-data.json\"));\nexports.HtmlData = htmlData;\n//# sourceMappingURL=HtmlDocset.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderHtmlEntry = exports.render = void 0;\nconst TypeSystem_1 = require(\"../TypeSystem\");\nconst HORIZONTAL_SEPARATOR = '\\n\\n---\\n\\n';\nfunction render(entry, returnType, docsetEntryType) {\n    return [title(entry, returnType), docsetEntryBody(entry, returnType, docsetEntryType)]\n        .filter(Boolean)\n        .join('\\n');\n}\nexports.render = render;\nfunction renderHtmlEntry(entry, parentEntry) {\n    return [title(entry, 'untyped'), htmlEntryBody(entry, parentEntry)].join('\\n');\n}\nexports.renderHtmlEntry = renderHtmlEntry;\nfunction title(entry, returnType) {\n    returnType = returnType !== null && returnType !== void 0 ? returnType : (0, TypeSystem_1.docsetEntryReturnType)(entry, 'untyped');\n    if ((0, TypeSystem_1.isArrayType)(returnType)) {\n        return `### ${entry.name}: \\`${returnType.valueType}[]\\``;\n    }\n    else if (returnType !== 'untyped') {\n        return `### ${entry.name}: \\`${returnType}\\``;\n    }\n    return `### ${entry.name}`;\n}\nfunction sanitize(s) {\n    return s === null || s === void 0 ? void 0 : s.replace(/(^|\\n+)&gt;/g, ' ').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/\\]\\(\\//g, '](https://shopify.dev/').trim();\n}\nfunction docsetEntryBody(entry, returnType, docsetEntryType) {\n    return [\n        syntax(entry),\n        entry.deprecation_reason,\n        entry.summary,\n        entry.description,\n        shopifyDevReference(entry, returnType, docsetEntryType),\n    ]\n        .map(sanitize)\n        .filter(Boolean)\n        .join(HORIZONTAL_SEPARATOR);\n}\nfunction htmlEntryBody(entry, parentEntry) {\n    return [description(entry), references(entry), references(parentEntry)]\n        .filter(Boolean)\n        .join(HORIZONTAL_SEPARATOR);\n}\nfunction syntax(entry) {\n    if (!('syntax' in entry) || !entry.syntax) {\n        return undefined;\n    }\n    // TagEntry entries already have liquid tags as a part of the syntax\n    // explanation so we can return them directly.\n    if (entry.syntax.startsWith('{%')) {\n        return `\\`\\`\\`liquid\\n${entry.syntax}\\n\\`\\`\\``;\n    }\n    // Wrap the syntax in liquid tags to ensure we get proper syntax highlighting\n    // if it's available.\n    return `\\`\\`\\`liquid\\n{{ ${entry.syntax} }}\\n\\`\\`\\``;\n}\nfunction description(entry) {\n    if (!entry.description || typeof entry.description === 'string') {\n        return entry.description;\n    }\n    return entry.description.value;\n}\nconst shopifyDevRoot = `https://shopify.dev/docs/api/liquid`;\nfunction shopifyDevReference(entry, returnType, docsetEntryType) {\n    switch (docsetEntryType) {\n        case 'tag': {\n            if (entry.name === 'else' && 'category' in entry) {\n                return `[Shopify Reference](${shopifyDevRoot}/tags/${entry.category}-${entry.name})`;\n            }\n            else if ('category' in entry) {\n                return `[Shopify Reference](${shopifyDevRoot}/tags/${entry.name})`;\n            }\n            else {\n                return undefined;\n            }\n        }\n        case 'object': {\n            if (!returnType) {\n                return `[Shopify Reference](${shopifyDevRoot}/objects/${entry.name})`;\n            }\n            else if ((0, TypeSystem_1.isArrayType)(returnType)) {\n                return `[Shopify Reference](${shopifyDevRoot}/objects/${returnType.valueType})`;\n            }\n            else if ('access' in entry) {\n                return `[Shopify Reference](${shopifyDevRoot}/objects/${returnType})`;\n            }\n            else {\n                return undefined;\n            }\n        }\n        case 'filter': {\n            if ('category' in entry) {\n                return `[Shopify Reference](${shopifyDevRoot}/filters/${entry.name})`;\n            }\n            else {\n                return undefined;\n            }\n        }\n        default: {\n            return undefined;\n        }\n    }\n}\nfunction references(entry) {\n    if (!entry || !('references' in entry) || !entry.references || entry.references.length === 0) {\n        return undefined;\n    }\n    if (entry.references.length === 1) {\n        const [ref] = entry.references;\n        return `[${ref.name}](${ref.url})`;\n    }\n    return [`#### Learn more`, entry.references.map((ref) => `- [${ref.name}](${ref.url})`)].join('\\n\\n');\n}\n//# sourceMappingURL=MarkdownRenderer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderHtmlEntry = exports.render = void 0;\nvar MarkdownRenderer_1 = require(\"./MarkdownRenderer\");\nObject.defineProperty(exports, \"render\", { enumerable: true, get: function () { return MarkdownRenderer_1.render; } });\nObject.defineProperty(exports, \"renderHtmlEntry\", { enumerable: true, get: function () { return MarkdownRenderer_1.renderHtmlEntry; } });\n__exportStar(require(\"./HtmlDocset\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentHighlightsProvider = exports.PREVENT_DEFAULT = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nconst providers_1 = require(\"./providers\");\n/**\n * The default behaviour for documentHighlights is to highlight every occurence\n * of the word under the cursor. We want to prevent that since it doesn't really\n * make sense in our context. We don't want to highlight every occurence of\n * `assign` when you put your cursor over it.\n */\nexports.PREVENT_DEFAULT = [];\n/**\n * Informs the client to highlight ranges in a document.\n *\n * This is a pretty abstract concept, but you could use it to highlight all\n * instances of a variable in a template, to highlight the matching\n * opening/closing liquid tags, html tags, etc.\n */\nclass DocumentHighlightsProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n        this.providers = [\n            new providers_1.HtmlTagNameDocumentHighlightsProvider(documentManager),\n            new providers_1.LiquidBlockTagDocumentHighlightsProvider(documentManager),\n        ];\n    }\n    async documentHighlights(params) {\n        var _a;\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!document || document.type !== theme_check_common_1.SourceCodeType.LiquidHtml || document.ast instanceof Error) {\n            return exports.PREVENT_DEFAULT;\n        }\n        const [currentNode, ancestors] = (0, theme_check_common_2.findCurrentNode)(document.ast, document.textDocument.offsetAt(params.position));\n        const promises = this.providers.map((p) => p.documentHighlights(currentNode, ancestors, params).catch(() => null));\n        const results = await Promise.all(promises);\n        return (_a = results.find(Boolean)) !== null && _a !== void 0 ? _a : exports.PREVENT_DEFAULT;\n    }\n}\nexports.DocumentHighlightsProvider = DocumentHighlightsProvider;\n//# sourceMappingURL=DocumentHighlightsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagNameDocumentHighlightsProvider = void 0;\nconst htmlTagNames_1 = require(\"../../utils/htmlTagNames\");\nclass HtmlTagNameDocumentHighlightsProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async documentHighlights(node, ancestors, params) {\n        var _a;\n        const textDocument = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!textDocument)\n            return null;\n        const ranges = (0, htmlTagNames_1.getHtmlElementNameRanges)(node, ancestors, params, textDocument);\n        if (!ranges)\n            return null;\n        return ranges.map((range) => ({ range }));\n    }\n}\nexports.HtmlTagNameDocumentHighlightsProvider = HtmlTagNameDocumentHighlightsProvider;\n//# sourceMappingURL=HtmlTagNameDocumentHighlightsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidBlockTagDocumentHighlightsProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nclass LiquidBlockTagDocumentHighlightsProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async documentHighlights(node, ancestors, params) {\n        var _a;\n        const textDocument = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!textDocument)\n            return null;\n        if (isLiquidBranch(node)) {\n            node = ancestors.at(-1);\n        }\n        if (!isLiquidBlock(node) || !node.blockEndPosition) {\n            return null;\n        }\n        const nameOffset = node.source.indexOf(node.name, node.blockStartPosition.start);\n        const endblockNameOffset = node.source.indexOf('end' + node.name, node.blockEndPosition.start);\n        const ranges = [\n            vscode_languageserver_1.Range.create(textDocument.positionAt(nameOffset), textDocument.positionAt(nameOffset + node.name.length)),\n            vscode_languageserver_1.Range.create(textDocument.positionAt(endblockNameOffset), \n            // \"end\" is 3 characters, end$name is 3 + node.name.length.\n            textDocument.positionAt(endblockNameOffset + 3 + node.name.length)),\n        ];\n        // highlighting the elsif/else branches as well\n        if (isLiquidTag(node) && node.children && node.children.every(isLiquidBranch)) {\n            for (const branch of node.children.filter((x) => x.name !== null)) {\n                const branchNameOffset = node.source.indexOf(branch.name, branch.blockStartPosition.start);\n                ranges.push(vscode_languageserver_1.Range.create(textDocument.positionAt(branchNameOffset), textDocument.positionAt(branchNameOffset + branch.name.length)));\n            }\n        }\n        return ranges.map((range) => ({ range }));\n    }\n}\nexports.LiquidBlockTagDocumentHighlightsProvider = LiquidBlockTagDocumentHighlightsProvider;\nfunction isLiquidBranch(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidBranch;\n}\nfunction isLiquidBlock(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidTag || node.type === liquid_html_parser_1.NodeTypes.LiquidRawTag;\n}\nfunction isLiquidTag(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidTag;\n}\n//# sourceMappingURL=LiquidBlockTagDocumentHighlightsProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidBlockTagDocumentHighlightsProvider = exports.HtmlTagNameDocumentHighlightsProvider = void 0;\nvar HtmlTagNameDocumentHighlightsProvider_1 = require(\"./HtmlTagNameDocumentHighlightsProvider\");\nObject.defineProperty(exports, \"HtmlTagNameDocumentHighlightsProvider\", { enumerable: true, get: function () { return HtmlTagNameDocumentHighlightsProvider_1.HtmlTagNameDocumentHighlightsProvider; } });\nvar LiquidBlockTagDocumentHighlightsProvider_1 = require(\"./LiquidBlockTagDocumentHighlightsProvider\");\nObject.defineProperty(exports, \"LiquidBlockTagDocumentHighlightsProvider\", { enumerable: true, get: function () { return LiquidBlockTagDocumentHighlightsProvider_1.LiquidBlockTagDocumentHighlightsProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentLinksProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst vscode_uri_1 = require(\"vscode-uri\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nclass DocumentLinksProvider {\n    constructor(documentManager, findThemeRootURI) {\n        this.documentManager = documentManager;\n        this.findThemeRootURI = findThemeRootURI;\n    }\n    async documentLinks(uriString) {\n        const sourceCode = this.documentManager.get(uriString);\n        if (!sourceCode ||\n            sourceCode.type !== theme_check_common_1.SourceCodeType.LiquidHtml ||\n            sourceCode.ast instanceof Error) {\n            return [];\n        }\n        const rootUri = await this.findThemeRootURI(uriString);\n        const visitor = documentLinksVisitor(sourceCode.textDocument, vscode_uri_1.URI.parse(rootUri));\n        return (0, theme_check_common_2.visit)(sourceCode.ast, visitor);\n    }\n}\nexports.DocumentLinksProvider = DocumentLinksProvider;\nfunction documentLinksVisitor(textDocument, root) {\n    return {\n        LiquidTag(node) {\n            // {% render 'snippet' %}\n            // {% include 'snippet' %}\n            if ((node.name === 'render' || node.name === 'include') &&\n                typeof node.markup !== 'string' &&\n                isLiquidString(node.markup.snippet)) {\n                const snippet = node.markup.snippet;\n                return vscode_languageserver_1.DocumentLink.create(range(textDocument, snippet), vscode_uri_1.Utils.resolvePath(root, 'snippets', snippet.value + '.liquid').toString());\n            }\n            // {% section 'section' %}\n            if (node.name === 'section' &&\n                typeof node.markup !== 'string' &&\n                isLiquidString(node.markup)) {\n                const sectionName = node.markup;\n                return vscode_languageserver_1.DocumentLink.create(range(textDocument, sectionName), vscode_uri_1.Utils.resolvePath(root, 'sections', sectionName.value + '.liquid').toString());\n            }\n            // {% content_for 'block', type: 'block_name' %}\n            if (node.name === liquid_html_parser_1.NamedTags.content_for && typeof node.markup !== 'string') {\n                const typeArg = node.markup.args.find((arg) => arg.name === 'type');\n                if (typeArg && typeArg.value.type === 'String') {\n                    return vscode_languageserver_1.DocumentLink.create(range(textDocument, typeArg.value), vscode_uri_1.Utils.resolvePath(root, 'blocks', typeArg.value.value + '.liquid').toString());\n                }\n            }\n        },\n        // {{ 'theme.js' | asset_url }}\n        LiquidVariable(node) {\n            if (node.filters.length === 0 || node.filters[0].name !== 'asset_url') {\n                return;\n            }\n            if (!isLiquidString(node.expression)) {\n                return;\n            }\n            const expression = node.expression;\n            return vscode_languageserver_1.DocumentLink.create(range(textDocument, node.expression), vscode_uri_1.Utils.resolvePath(root, 'assets', expression.value).toString());\n        },\n    };\n}\nfunction range(textDocument, node) {\n    const start = textDocument.positionAt(node.position.start + 1);\n    const end = textDocument.positionAt(node.position.end - 1);\n    return vscode_languageserver_1.Range.create(start, end);\n}\nfunction isLiquidString(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.String;\n}\n//# sourceMappingURL=DocumentLinksProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentLinksProvider = void 0;\nvar DocumentLinksProvider_1 = require(\"./DocumentLinksProvider\");\nObject.defineProperty(exports, \"DocumentLinksProvider\", { enumerable: true, get: function () { return DocumentLinksProvider_1.DocumentLinksProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentManager = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_textdocument_1 = require(\"vscode-languageserver-textdocument\");\nconst progress_1 = require(\"../progress\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nclass DocumentManager {\n    constructor(fs, connection, clientCapabilities, getModeForUri, isValidSchema) {\n        this.fs = fs;\n        this.connection = connection;\n        this.clientCapabilities = clientCapabilities;\n        this.getModeForUri = getModeForUri;\n        this.isValidSchema = isValidSchema;\n        /**\n         * The preload method is used to pre-load and pre-parse all the files in the\n         * theme. It is smart and only will load files that are not already in the\n         * DocumentManager.\n         *\n         * Files that are loaded from the AbstractFileSystem will have a version of `undefined`.\n         */\n        this.preload = (0, theme_check_common_1.memoize)(async (rootUri) => {\n            if (!this.fs)\n                throw new Error('Cannot call preload without a FileSystem');\n            const { fs, connection, clientCapabilities } = this;\n            const progress = progress_1.Progress.create(connection, clientCapabilities, `preload#${rootUri}`);\n            progress.start('Initializing Liquid LSP');\n            // We'll only load the files that aren't already in the store. No need to\n            // parse a file we already parsed.\n            const filesToLoad = await (0, theme_check_common_1.recursiveReadDirectory)(this.fs, rootUri, ([uri]) => /\\.(liquid|json)$/.test(uri) && !this.sourceCodes.has(uri));\n            progress.report(10, 'Preloading files');\n            let [i, n] = [0, filesToLoad.length];\n            await Promise.all(filesToLoad.map(async (file) => {\n                // This is what is important, we are loading the file from the file system\n                // And setting their initial version to `undefined` to mean \"on disk\".\n                this.set(file, await fs.readFile(file), undefined);\n                // This is just doing progress reporting\n                if (++i % 10 === 0) {\n                    const message = `Preloading files [${i}/${n}]`;\n                    progress.report((0, progress_1.percent)(i, n, 10), message);\n                }\n            }));\n            progress.end('Completed');\n        }, (rootUri) => rootUri);\n        this.sourceCodes = new Map();\n        this.recentlyRenamed = new Set();\n    }\n    open(uri, source, version) {\n        return this.set(uri, source, version);\n    }\n    change(uri, source, version) {\n        return this.set(uri, source, version);\n    }\n    async changeFromDisk(uri) {\n        if (!this.fs)\n            throw new Error('Cannot call changeFromDisk without a FileSystem');\n        this.change(uri, await this.fs.readFile(uri), undefined);\n    }\n    close(uri) {\n        const sourceCode = this.sourceCodes.get(uri);\n        if (!sourceCode)\n            return;\n        return this.set(uri, sourceCode.source, undefined);\n    }\n    delete(uri) {\n        return this.sourceCodes.delete(uri);\n    }\n    rename(oldUri, newUri) {\n        this.trackRename(oldUri, newUri);\n        const sourceCode = this.sourceCodes.get(oldUri);\n        if (!sourceCode)\n            return;\n        this.sourceCodes.delete(oldUri);\n        this.set(newUri, sourceCode.source, sourceCode.version);\n    }\n    theme(root, includeFilesFromDisk = false) {\n        return [...this.sourceCodes.values()]\n            .filter((sourceCode) => sourceCode.uri.startsWith(root))\n            .filter((sourceCode) => includeFilesFromDisk || sourceCode.version !== undefined);\n    }\n    get openDocuments() {\n        return [...this.sourceCodes.values()].filter((sourceCode) => sourceCode.version !== undefined);\n    }\n    get(uri) {\n        return this.sourceCodes.get(theme_check_common_1.path.normalize(uri));\n    }\n    has(uri) {\n        return this.sourceCodes.has(theme_check_common_1.path.normalize(uri));\n    }\n    /** Used to prevent cache busting twice for the same operation */\n    hasRecentRename(uri) {\n        return this.recentlyRenamed.has(uri);\n    }\n    clearRecentRename(uri) {\n        this.recentlyRenamed.delete(uri);\n    }\n    set(uri, source, version) {\n        uri = theme_check_common_1.path.normalize(uri);\n        // We only support json and liquid files.\n        if (!/\\.(json|liquid)$/.test(uri) || /\\.(s?css|js).liquid$/.test(uri)) {\n            return;\n        }\n        this.sourceCodes.set(uri, this.augmentedSourceCode(uri, source, version));\n    }\n    augmentedSourceCode(uri, source, version) {\n        var _a;\n        const sourceCode = (0, theme_check_common_1.toSourceCode)(uri, source, version);\n        const textDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, sourceCode.type, (_a = sourceCode.version) !== null && _a !== void 0 ? _a : 0, // create doesn't let us put undefined here.\n        sourceCode.source);\n        switch (sourceCode.type) {\n            case theme_check_common_1.SourceCodeType.JSON:\n                return {\n                    ...sourceCode,\n                    textDocument,\n                };\n            case theme_check_common_1.SourceCodeType.LiquidHtml:\n                return {\n                    ...sourceCode,\n                    textDocument,\n                    /** Lazy and only computed once per file version */\n                    getSchema: (0, theme_check_common_1.memo)(async () => {\n                        if (!this.getModeForUri || !this.isValidSchema)\n                            return undefined;\n                        const mode = await this.getModeForUri(uri);\n                        return (0, theme_check_common_1.toSchema)(mode, uri, sourceCode, this.isValidSchema, false);\n                    }),\n                    /** Lazy and only computed once per file version */\n                    getLiquidDoc: (0, theme_check_common_1.memo)(async (snippetName) => {\n                        if ((0, theme_check_common_1.isError)(sourceCode.ast))\n                            return undefined;\n                        return (0, theme_check_common_2.getSnippetDefinition)(sourceCode.ast, snippetName);\n                    }),\n                };\n            default:\n                return (0, theme_check_common_1.assertNever)(sourceCode);\n        }\n    }\n    /**\n     * The workspace/onDidRenameFile notification is sent when a file is renamed in the workspace (via a user gesture)\n     * The workspace/onDidChangeWatchedFiles notification is sent when a file is renamed on disk (via a file system event)\n     *\n     * The order is not guaranteed, but it seems to be true that onDidRenameFile happens before onDidChangeWatchedFiles.\n     *\n     * In the off-chance that the order is reversed, we'll have the sleep timer to clean up the state.\n     */\n    trackRename(oldUri, newUri) {\n        this.recentlyRenamed.add(oldUri);\n        this.recentlyRenamed.add(newUri);\n        sleep(2000).then(() => {\n            this.clearRecentRename(oldUri);\n            this.clearRecentRename(newUri);\n        });\n    }\n}\nexports.DocumentManager = DocumentManager;\n//# sourceMappingURL=DocumentManager.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentManager = void 0;\nvar DocumentManager_1 = require(\"./DocumentManager\");\nObject.defineProperty(exports, \"DocumentManager\", { enumerable: true, get: function () { return DocumentManager_1.DocumentManager; } });\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isJsonSourceCode = exports.isLiquidSourceCode = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst isLiquidSourceCode = (file) => file.type === theme_check_common_1.SourceCodeType.LiquidHtml;\nexports.isLiquidSourceCode = isLiquidSourceCode;\nconst isJsonSourceCode = (file) => file.type === theme_check_common_1.SourceCodeType.JSON;\nexports.isJsonSourceCode = isJsonSourceCode;\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OnTypeFormattingProvider = void 0;\nconst BracketsAutoclosingOnTypeFormattingProvider_1 = require(\"./providers/BracketsAutoclosingOnTypeFormattingProvider\");\nconst HtmlElementAutoclosingOnTypeFormattingProvider_1 = require(\"./providers/HtmlElementAutoclosingOnTypeFormattingProvider\");\nclass OnTypeFormattingProvider {\n    constructor(documentManager, setCursorPosition = async () => { }) {\n        this.documentManager = documentManager;\n        this.setCursorPosition = setCursorPosition;\n        this.providers = [\n            new BracketsAutoclosingOnTypeFormattingProvider_1.BracketsAutoclosingOnTypeFormattingProvider(),\n            new HtmlElementAutoclosingOnTypeFormattingProvider_1.HtmlElementAutoclosingOnTypeFormattingProvider(setCursorPosition),\n        ];\n    }\n    async onTypeFormatting(params) {\n        var _a;\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!document)\n            return null;\n        const results = this.providers.map((provider) => provider.onTypeFormatting(document, params));\n        return (_a = results.find((result) => result !== null)) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports.OnTypeFormattingProvider = OnTypeFormattingProvider;\n//# sourceMappingURL=OnTypeFormattingProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OnTypeFormattingProvider = void 0;\nvar OnTypeFormattingProvider_1 = require(\"./OnTypeFormattingProvider\");\nObject.defineProperty(exports, \"OnTypeFormattingProvider\", { enumerable: true, get: function () { return OnTypeFormattingProvider_1.OnTypeFormattingProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BracketsAutoclosingOnTypeFormattingProvider = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nclass BracketsAutoclosingOnTypeFormattingProvider {\n    /**\n     * This very complex piece of code here exists to provide a good autoclosing UX.\n     *\n     * The story is kind of long so here goes...\n     *\n     * What we want:\n     * 1. Basic autoclosing of {{, {% with the corresponding pair (and spaces)\n     *   - user types: {{\n     *   - user sees: {{ | }} (with cursor position at |)\n     * 2. Autoclosing of {{- with -}}, {%- with -%}\n     *   - user types: {{-\n     *   - user sees: {{- | -}} (with cursor at |)\n     * 3. User adds whitespace stripping on one side of the braces of an existing tag\n     *   - user types: - at | in `{{| drop }}`\n     *   - user sees: {{- drop }}\n     *\n     * Why we can't do it with autoclosingPairs:\n     *   - VS Code's settings accepts autoclosingPairs and autocloseBefore\n     *     - autoclosingPairs is a set of pairs that should be autoclosed (e.g. ['{%', '%}'])\n     *     - autocloseBefore is a character set of 'allowed next characters' that would cause a closing pair\n     *   - If we put a space (' ') the autoclosingPairs set, then (3) from above becomes funky:\n     *     - assume autoclosingPairs = {|}, {{|}}, {{ | }}\n     *     - user types: a space at | in `{{| drop }}`\n     *     - user sees: {{   }}drop }}\n     *   - This happens because the space is an autocloseBefore character, it sees a space after the cursor\n     *     so it closes '{{ ' with ' }}' at the cursor position, resulting in '{{  }}drop }}'\n     *   - Something similar happens if we include the `-` in the autoclosing pairs\n     *   - This is annoying!\n     *\n     * So our solution is the following:\n     * 1. We change the pairs to include the closing space (this way our cursor remains where we want it to be)\n     *    - {{| }}\n     *    - {%| %}\n     * 2. We add this OnTypeFormattingProvider that does the following \"fixes\":\n     *    - {{| }}   into {{ | }}\n     *    - {{ -| }} into {{- | -}}\n     *    - {%| %}   into {% | %}\n     *    - {% -| %} into {%- | -%}\n     *\n     * This lets us avoid the unnecessary close and accomplish 1, 2 and 3 :)\n     *\n     * Fallback for editor.onTypeFormatting: false is to let the user type the `-` on both sides manually\n     */\n    onTypeFormatting(document, params) {\n        const textDocument = document.textDocument;\n        const ch = params.ch;\n        // position is position of cursor so 1 ahead of char\n        const { line, character } = params.position;\n        // This is an early return to avoid doing currentLine.at(-1);\n        if ((ch === ' ' && character <= 2) || character <= 1)\n            return null;\n        const currentLineRange = vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(line, 0), vscode_languageserver_protocol_1.Position.create(line + 1, 0));\n        const currentLine = textDocument.getText(currentLineRange);\n        const charIdx = ch === ' ' ? character - 2 : character - 1;\n        const char = currentLine.at(charIdx);\n        switch (char) {\n            // here we fix {{| }} with {{ | }}\n            // here we fix {%| %} with {% | %}\n            case '{':\n            case '%': {\n                const chars = currentLine.slice(charIdx - 1, charIdx + 4);\n                if (chars === '{{ }}' || chars === '{% %}') {\n                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(line, charIdx + 1), ' ')];\n                }\n            }\n            // here we fix {{ -| }} to {{- | -}}\n            // here we fix {% -| }} to {%- | -%}\n            case '-': {\n                // remember 0-index means 4th char\n                if (charIdx < 3)\n                    return null;\n                const chars = currentLine.slice(charIdx - 3, charIdx + 4);\n                if (chars === '{{ - }}' || chars === '{% - %}') {\n                    // Here we're being clever and doing the {{- -}} if the first character\n                    // you type is a `-`, leaving your cursor in the middle :)\n                    return [\n                        // Start with\n                        //   {{ - }}\n                        //     ^ start replace\n                        //       ^ end replace (excluded)\n                        // Replace with '- ', get\n                        //   {{- }}\n                        vscode_languageserver_protocol_1.TextEdit.replace(vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(line, charIdx - 1), vscode_languageserver_protocol_1.Position.create(line, charIdx + 1)), '- '),\n                        // Start with\n                        //   {{ - }}\n                        //      ^ char\n                        //        ^ insertion point\n                        // Insert ' ' , get\n                        //   {{ - -}}\n                        // Both together and you get {{- -}} with your cursor in the middle\n                        vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(line, charIdx + 2), '-'),\n                    ];\n                }\n            }\n        }\n        return null;\n    }\n}\nexports.BracketsAutoclosingOnTypeFormattingProvider = BracketsAutoclosingOnTypeFormattingProvider;\n//# sourceMappingURL=BracketsAutoclosingOnTypeFormattingProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlElementAutoclosingOnTypeFormattingProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst defer = (fn) => setTimeout(fn, 10);\n/**\n * This class is responsible for closing dangling HTML elements.\n *\n * Say user types <script>, then we'd want `</script>` to be inserted.\n *\n * Thing is we want to do that only if the `</script>` isn't already present in the file.\n * If the user goes to edit `<script>` and types `>`, we don't want to insert `</script>` again.\n *\n * The \"trick\" we use here is to only add the `</script>` part if the\n * document.ast is an instance of LiquidHTMLASTParsingError and that the\n * unclosed element is of the correct name.\n *\n * @example:\n * ```html\n *   <div id=\"main\">\n *     <div id=\"inner\">|\n *   </div>\n * ```\n * - The user just finished typing `<div id=\"inner\">` inside the div#main.\n * - This parses as though the div#inner is closed and div#main isn't.\n * - That's OK.\n * - This makes a LiquidHTMLASTParsingError with unclosed div (the div#main).\n * - Since\n *     - the cursor is at the end of a div, and\n *     - the unclosed element is a div,\n *   Then we can insert one automatically after the cursor and fix the AST.\n *\n * ```html\n *  <div id=\"main\">\n *    <div id=\"inner\">|</div>\n *  </div>\n * ```\n */\nclass HtmlElementAutoclosingOnTypeFormattingProvider {\n    constructor(setCursorPosition) {\n        this.setCursorPosition = setCursorPosition;\n    }\n    onTypeFormatting(document, params) {\n        const textDocument = document.textDocument;\n        const ch = params.ch;\n        // position is position of cursor so 1 ahead of char\n        const { line, character } = params.position;\n        switch (ch) {\n            // here we fix `>` with `</$unclosed>`\n            case '>': {\n                const ast = document.ast;\n                if (ast instanceof liquid_html_parser_1.LiquidHTMLASTParsingError &&\n                    ast.unclosed &&\n                    ast.unclosed.type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n                    (ast.unclosed.blockStartPosition.end === textDocument.offsetAt(params.position) ||\n                        shouldClose(ast.unclosed, nodeAtCursor(textDocument, params.position)))) {\n                    defer(() => this.setCursorPosition(textDocument, params.position));\n                    return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(line, character), `</${ast.unclosed.name}>`)];\n                }\n                else if (!(ast instanceof Error)) {\n                    // Even though we accept dangling <div>s inside {% if condition %}, we prefer to auto-insert the </div>\n                    const [node] = (0, theme_check_common_1.findCurrentNode)(ast, textDocument.offsetAt(params.position));\n                    if (isDanglingHtmlElement(node)) {\n                        defer(() => this.setCursorPosition(textDocument, params.position));\n                        return [vscode_languageserver_protocol_1.TextEdit.insert(vscode_languageserver_protocol_1.Position.create(line, character), `</${(0, liquid_html_parser_1.getName)(node)}>`)];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n}\nexports.HtmlElementAutoclosingOnTypeFormattingProvider = HtmlElementAutoclosingOnTypeFormattingProvider;\nfunction nodeAtCursor(textDocument, position) {\n    var _a;\n    const text = textDocument.getText(vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), position));\n    try {\n        const ast = (0, liquid_html_parser_1.toLiquidHtmlAST)(text, {\n            allowUnclosedDocumentNode: true,\n            mode: 'tolerant',\n        });\n        const [node, ancestors] = (0, theme_check_common_1.findCurrentNode)(ast, textDocument.offsetAt(position));\n        if (((_a = ancestors.at(-1)) === null || _a === void 0 ? void 0 : _a.type) === liquid_html_parser_1.NodeTypes.HtmlElement)\n            return ancestors.at(-1);\n        if (node.type === liquid_html_parser_1.NodeTypes.LiquidBranch)\n            return ancestors.at(-1);\n        return node;\n    }\n    catch {\n        return null;\n    }\n}\nfunction shouldClose(unclosed, node) {\n    if (node === null || !('blockStartPosition' in node))\n        return false;\n    return ([liquid_html_parser_1.NodeTypes.HtmlElement, liquid_html_parser_1.NodeTypes.LiquidTag, liquid_html_parser_1.NodeTypes.HtmlRawNode].includes(unclosed.type) &&\n        (0, liquid_html_parser_1.getName)(node) === unclosed.name);\n}\nfunction isDanglingHtmlElement(node) {\n    return (node !== null &&\n        node.type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n        node.blockEndPosition.start === node.blockEndPosition.end);\n}\n//# sourceMappingURL=HtmlElementAutoclosingOnTypeFormattingProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HoverProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst TypeSystem_1 = require(\"../TypeSystem\");\nconst providers_1 = require(\"./providers\");\nconst HtmlAttributeValueHoverProvider_1 = require(\"./providers/HtmlAttributeValueHoverProvider\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nconst LiquidDocTagHoverProvider_1 = require(\"./providers/LiquidDocTagHoverProvider\");\nclass HoverProvider {\n    constructor(documentManager, themeDocset, getMetafieldDefinitions, getTranslationsForURI = async () => ({}), getSettingsSchemaForURI = async () => [], getSnippetDefinitionForURI = async (_uri, snippetName) => ({\n        name: snippetName,\n    })) {\n        this.documentManager = documentManager;\n        this.themeDocset = themeDocset;\n        this.getMetafieldDefinitions = getMetafieldDefinitions;\n        this.getTranslationsForURI = getTranslationsForURI;\n        this.getSettingsSchemaForURI = getSettingsSchemaForURI;\n        this.getSnippetDefinitionForURI = getSnippetDefinitionForURI;\n        this.providers = [];\n        const typeSystem = new TypeSystem_1.TypeSystem(themeDocset, getSettingsSchemaForURI, getMetafieldDefinitions);\n        this.providers = [\n            new providers_1.LiquidTagHoverProvider(themeDocset),\n            new providers_1.LiquidFilterHoverProvider(themeDocset),\n            new providers_1.LiquidObjectHoverProvider(typeSystem),\n            new providers_1.LiquidObjectAttributeHoverProvider(typeSystem),\n            new providers_1.HtmlTagHoverProvider(),\n            new providers_1.HtmlAttributeHoverProvider(),\n            new HtmlAttributeValueHoverProvider_1.HtmlAttributeValueHoverProvider(),\n            new providers_1.TranslationHoverProvider(getTranslationsForURI, documentManager),\n            new providers_1.RenderSnippetHoverProvider(getSnippetDefinitionForURI),\n            new providers_1.RenderSnippetParameterHoverProvider(getSnippetDefinitionForURI),\n            new LiquidDocTagHoverProvider_1.LiquidDocTagHoverProvider(),\n        ];\n    }\n    async hover(params) {\n        var _a;\n        const uri = params.textDocument.uri;\n        const document = this.documentManager.get(uri);\n        // Supports only Liquid resources\n        if ((document === null || document === void 0 ? void 0 : document.type) !== theme_check_common_1.SourceCodeType.LiquidHtml || document.ast instanceof Error) {\n            return null;\n        }\n        const [currentNode, ancestors] = (0, theme_check_common_2.findCurrentNode)(document.ast, document.textDocument.offsetAt(params.position));\n        const promises = this.providers.map((p) => p.hover(currentNode, ancestors, params));\n        const results = await Promise.all(promises);\n        return (_a = results.find(Boolean)) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports.HoverProvider = HoverProvider;\n//# sourceMappingURL=HoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HoverProvider = void 0;\nvar HoverProvider_1 = require(\"./HoverProvider\");\nObject.defineProperty(exports, \"HoverProvider\", { enumerable: true, get: function () { return HoverProvider_1.HoverProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlAttributeHoverProvider = void 0;\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nclass HtmlAttributeHoverProvider {\n    async hover(currentNode, ancestors) {\n        var _a;\n        const attributeNode = ancestors.at(-1);\n        const tagNode = (0, utils_1.findLast)(ancestors, utils_1.isNamedHtmlElementNode);\n        if (!attributeNode ||\n            !tagNode ||\n            !(0, utils_1.isTextNode)(currentNode) ||\n            !(0, utils_1.isHtmlAttribute)(attributeNode) ||\n            !attributeNode.name.includes(currentNode) ||\n            attributeNode.name.length > 1 ||\n            !(0, utils_1.isNamedHtmlElementNode)(tagNode)) {\n            return null;\n        }\n        const name = currentNode.value;\n        const tagName = (0, utils_1.getCompoundName)(tagNode);\n        const tagEntry = docset_1.HtmlData.tags.find((tag) => tag.name === tagName);\n        const tagEntryAttributes = (tagEntry === null || tagEntry === void 0 ? void 0 : tagEntry.attributes) || [];\n        const attribute = (_a = docset_1.HtmlData.globalAttributes.find((attr) => attr.name === name)) !== null && _a !== void 0 ? _a : tagEntryAttributes.find((attr) => attr.name === name);\n        if (!attribute) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.renderHtmlEntry)(attribute, 'references' in attribute ? undefined : tagEntry),\n            },\n        };\n    }\n}\nexports.HtmlAttributeHoverProvider = HtmlAttributeHoverProvider;\n//# sourceMappingURL=HtmlAttributeHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlAttributeValueHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nclass HtmlAttributeValueHoverProvider {\n    async hover(currentNode, ancestors) {\n        var _a;\n        const attributeNode = (0, utils_1.findLast)(ancestors, utils_1.isHtmlAttribute);\n        const tagNode = (0, utils_1.findLast)(ancestors, utils_1.isNamedHtmlElementNode);\n        if (!(0, utils_1.isTextNode)(currentNode) ||\n            !attributeNode ||\n            !tagNode ||\n            !(0, utils_1.isHtmlAttribute)(attributeNode) ||\n            !(0, utils_1.isNamedHtmlElementNode)(tagNode) ||\n            attributeNode.type === liquid_html_parser_1.NodeTypes.AttrEmpty ||\n            attributeNode.value.length !== 1 ||\n            !attributeNode.value.includes(currentNode)) {\n            return null;\n        }\n        const valueName = currentNode.value;\n        const attrName = (0, utils_1.getCompoundName)(attributeNode);\n        const tagName = (0, utils_1.getCompoundName)(tagNode);\n        const tagEntry = docset_1.HtmlData.tags.find((tag) => tag.name === tagName);\n        const attribute = (_a = docset_1.HtmlData.globalAttributes.find((attr) => attr.name === attrName)) !== null && _a !== void 0 ? _a : tagEntry === null || tagEntry === void 0 ? void 0 : tagEntry.attributes.find((attr) => attr.name === attrName);\n        const valueSetName = attribute === null || attribute === void 0 ? void 0 : attribute.valueSet;\n        const valueSetEntry = docset_1.HtmlData.valueSets.find((valueSet) => valueSet.name === valueSetName);\n        const valueEntry = valueSetEntry === null || valueSetEntry === void 0 ? void 0 : valueSetEntry.values.find((value) => value.name === valueName);\n        if (!valueEntry) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.renderHtmlEntry)(valueEntry, (attribute === null || attribute === void 0 ? void 0 : attribute.references) ? attribute : tagEntry),\n            },\n        };\n    }\n}\nexports.HtmlAttributeValueHoverProvider = HtmlAttributeValueHoverProvider;\n//# sourceMappingURL=HtmlAttributeValueHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagHoverProvider = void 0;\nconst docset_1 = require(\"../../docset\");\nconst utils_1 = require(\"../../utils\");\nclass HtmlTagHoverProvider {\n    async hover(currentNode, ancestors) {\n        let name;\n        const parentNode = ancestors.at(-1);\n        if ((0, utils_1.isNamedHtmlElementNode)(currentNode) && typeof currentNode.name === 'string') {\n            name = currentNode.name;\n        }\n        else if ((0, utils_1.isTextNode)(currentNode) &&\n            parentNode &&\n            (0, utils_1.isNamedHtmlElementNode)(parentNode) &&\n            typeof parentNode.name !== 'string' &&\n            parentNode.name.includes(currentNode) &&\n            parentNode.name.length === 1) {\n            name = currentNode.value;\n        }\n        if (!name) {\n            return null;\n        }\n        const entry = docset_1.HtmlData.tags.find((tag) => tag.name === name);\n        if (!entry) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.renderHtmlEntry)(entry),\n            },\n        };\n    }\n}\nexports.HtmlTagHoverProvider = HtmlTagHoverProvider;\n//# sourceMappingURL=HtmlTagHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidDocTagHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst liquidDoc_1 = require(\"../../utils/liquidDoc\");\nclass LiquidDocTagHoverProvider {\n    constructor() { }\n    async hover(currentNode, ancestors) {\n        const parentNode = ancestors.at(-1);\n        let docTagNode;\n        // We could be hovering on the liquidDoc tag itself\n        if (currentNode.type === liquid_html_parser_1.NodeTypes.LiquidDocParamNode ||\n            currentNode.type === liquid_html_parser_1.NodeTypes.LiquidDocDescriptionNode ||\n            currentNode.type === liquid_html_parser_1.NodeTypes.LiquidDocExampleNode) {\n            docTagNode = currentNode;\n        }\n        // or we could be hovering on the liquidDoc tag's text\n        if (((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.LiquidDocParamNode ||\n            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.LiquidDocDescriptionNode ||\n            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === liquid_html_parser_1.NodeTypes.LiquidDocExampleNode) &&\n            currentNode.type === liquid_html_parser_1.NodeTypes.TextNode) {\n            docTagNode = parentNode;\n        }\n        if (!docTagNode) {\n            return null;\n        }\n        const docTagData = liquidDoc_1.SUPPORTED_LIQUID_DOC_TAG_HANDLES[docTagNode.name];\n        if (!docTagData) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: vscode_languageserver_1.MarkupKind.Markdown,\n                value: (0, liquidDoc_1.formatLiquidDocTagHandle)(docTagNode.name, docTagData.description, docTagData.example),\n            },\n        };\n    }\n}\nexports.LiquidDocTagHoverProvider = LiquidDocTagHoverProvider;\n//# sourceMappingURL=LiquidDocTagHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidFilterHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst docset_1 = require(\"../../docset\");\nclass LiquidFilterHoverProvider {\n    constructor(themeDocset) {\n        this.themeDocset = themeDocset;\n    }\n    async hover(currentNode) {\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.LiquidFilter) {\n            return null;\n        }\n        const name = currentNode.name;\n        const entries = await this.themeDocset.filters();\n        const entry = entries.find((entry) => entry.name === name);\n        if (!entry) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.render)(entry, undefined, 'filter'),\n            },\n        };\n    }\n}\nexports.LiquidFilterHoverProvider = LiquidFilterHoverProvider;\n//# sourceMappingURL=LiquidFilterHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidObjectAttributeHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst TypeSystem_1 = require(\"../../TypeSystem\");\nconst docset_1 = require(\"../../docset\");\nclass LiquidObjectAttributeHoverProvider {\n    constructor(typeSystem) {\n        this.typeSystem = typeSystem;\n    }\n    async hover(currentNode, ancestors, params) {\n        var _a;\n        const parentNode = ancestors.at(-1);\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.String ||\n            !parentNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.VariableLookup ||\n            !parentNode.lookups.includes(currentNode)) {\n            return null;\n        }\n        const lookupIndex = parentNode.lookups.findIndex((lookup) => lookup === currentNode);\n        const node = {\n            ...parentNode,\n            lookups: parentNode.lookups.slice(0, lookupIndex),\n        };\n        const parentType = await this.typeSystem.inferType(node, ancestors[0], params.textDocument.uri);\n        if ((0, TypeSystem_1.isArrayType)(parentType)) {\n            return null;\n        }\n        const objectMap = await this.typeSystem.objectMap(params.textDocument.uri, ancestors[0]);\n        const parentEntry = objectMap[parentType];\n        if (!parentEntry) {\n            return null;\n        }\n        const parentTypeProperties = ((_a = objectMap[parentType]) === null || _a === void 0 ? void 0 : _a.properties) || [];\n        const entry = parentTypeProperties.find((p) => p.name === currentNode.value);\n        if (!entry) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.render)(entry),\n            },\n        };\n    }\n}\nexports.LiquidObjectAttributeHoverProvider = LiquidObjectAttributeHoverProvider;\n//# sourceMappingURL=LiquidObjectAttributeHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidObjectHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst TypeSystem_1 = require(\"../../TypeSystem\");\nconst docset_1 = require(\"../../docset\");\nclass LiquidObjectHoverProvider {\n    constructor(typeSystem) {\n        this.typeSystem = typeSystem;\n    }\n    async hover(currentNode, ancestors, params) {\n        var _a;\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.VariableLookup &&\n            currentNode.type !== liquid_html_parser_1.NodeTypes.AssignMarkup) {\n            return null;\n        }\n        if (!currentNode.name) {\n            return null;\n        }\n        let node = currentNode;\n        if (node.type === liquid_html_parser_1.NodeTypes.VariableLookup) {\n            node = {\n                ...currentNode,\n                lookups: [],\n            };\n        }\n        const type = await this.typeSystem.inferType(node, ancestors[0], params.textDocument.uri);\n        const objectMap = await this.typeSystem.objectMap(params.textDocument.uri, ancestors[0]);\n        const entry = objectMap[(0, TypeSystem_1.isArrayType)(type) ? type.valueType : type];\n        if (type === 'untyped') {\n            return null;\n        }\n        if (!entry) {\n            const entryByName = (_a = objectMap[currentNode.name]) !== null && _a !== void 0 ? _a : {};\n            return {\n                contents: {\n                    kind: 'markdown',\n                    value: (0, docset_1.render)({\n                        ...entryByName,\n                        name: currentNode.name,\n                    }, type, 'object'),\n                },\n            };\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.render)({ ...entry, name: currentNode.name }, type, 'object'),\n            },\n        };\n    }\n}\nexports.LiquidObjectHoverProvider = LiquidObjectHoverProvider;\n//# sourceMappingURL=LiquidObjectHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidTagHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst docset_1 = require(\"../../docset\");\nclass LiquidTagHoverProvider {\n    constructor(themeDocset) {\n        this.themeDocset = themeDocset;\n    }\n    async hover(currentNode) {\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.LiquidTag &&\n            currentNode.type !== liquid_html_parser_1.NodeTypes.LiquidRawTag &&\n            currentNode.type !== liquid_html_parser_1.NodeTypes.LiquidBranch) {\n            return null;\n        }\n        const name = currentNode.name;\n        const entries = await this.themeDocset.tags();\n        const entry = entries.find((entry) => entry.name === name);\n        if (!entry) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, docset_1.render)(entry, undefined, 'tag'),\n            },\n        };\n    }\n}\nexports.LiquidTagHoverProvider = LiquidTagHoverProvider;\n//# sourceMappingURL=LiquidTagHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst liquidDoc_1 = require(\"../../utils/liquidDoc\");\nclass RenderSnippetHoverProvider {\n    constructor(getSnippetDefinitionForURI) {\n        this.getSnippetDefinitionForURI = getSnippetDefinitionForURI;\n    }\n    async hover(currentNode, ancestors, params) {\n        var _a, _b, _c;\n        const parentNode = ancestors.at(-1);\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.String ||\n            !parentNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.RenderMarkup) {\n            return null;\n        }\n        const snippetName = currentNode.value;\n        const snippetDefinition = await this.getSnippetDefinitionForURI(params.textDocument.uri, snippetName);\n        if (!snippetDefinition) {\n            return null;\n        }\n        const liquidDoc = snippetDefinition.liquidDoc;\n        if (!liquidDoc) {\n            return {\n                contents: {\n                    kind: 'markdown',\n                    value: `### ${snippetDefinition.name}`,\n                },\n            };\n        }\n        const parts = [`### ${snippetDefinition.name}`];\n        if ((_a = liquidDoc.parameters) === null || _a === void 0 ? void 0 : _a.length) {\n            const parameters = this.buildParameters(liquidDoc.parameters);\n            parts.push('', '**Parameters:**', parameters);\n        }\n        if ((_b = liquidDoc.examples) === null || _b === void 0 ? void 0 : _b.length) {\n            const examples = (_c = liquidDoc.examples) === null || _c === void 0 ? void 0 : _c.map(({ content }) => `\\`\\`\\`liquid${content}\\`\\`\\``).join('\\n');\n            parts.push('', '**Examples:**', examples);\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: parts.join('\\n'),\n            },\n        };\n    }\n    buildParameters(parameters) {\n        return parameters.map((param) => (0, liquidDoc_1.formatLiquidDocParameter)(param)).join('\\n');\n    }\n}\nexports.RenderSnippetHoverProvider = RenderSnippetHoverProvider;\n//# sourceMappingURL=RenderSnippetHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetParameterHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst liquidDoc_1 = require(\"../../utils/liquidDoc\");\nclass RenderSnippetParameterHoverProvider {\n    constructor(getSnippetDefinitionForURI) {\n        this.getSnippetDefinitionForURI = getSnippetDefinitionForURI;\n    }\n    async hover(currentNode, ancestors, params) {\n        var _a, _b;\n        const parentNode = ancestors.at(-1);\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.NamedArgument ||\n            !parentNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.RenderMarkup ||\n            parentNode.snippet.type !== liquid_html_parser_1.NodeTypes.String) {\n            return null;\n        }\n        const snippetName = parentNode.snippet.value;\n        const snippetDefinition = await this.getSnippetDefinitionForURI(params.textDocument.uri, snippetName);\n        if (!((_b = (_a = snippetDefinition === null || snippetDefinition === void 0 ? void 0 : snippetDefinition.liquidDoc) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.length)) {\n            return null;\n        }\n        const paramName = currentNode.name;\n        const hoveredParameter = snippetDefinition.liquidDoc.parameters.find((parameter) => parameter.name === paramName);\n        if (!hoveredParameter) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, liquidDoc_1.formatLiquidDocParameter)(hoveredParameter, true),\n            },\n        };\n    }\n}\nexports.RenderSnippetParameterHoverProvider = RenderSnippetParameterHoverProvider;\n//# sourceMappingURL=RenderSnippetParameterHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TranslationHoverProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst translations_1 = require(\"../../translations\");\nclass TranslationHoverProvider {\n    constructor(getTranslationsForUri, documentManager) {\n        this.getTranslationsForUri = getTranslationsForUri;\n        this.documentManager = documentManager;\n    }\n    async hover(currentNode, ancestors, params) {\n        var _a;\n        const parentNode = ancestors.at(-1);\n        if (currentNode.type !== liquid_html_parser_1.NodeTypes.String ||\n            !parentNode ||\n            parentNode.type !== liquid_html_parser_1.NodeTypes.LiquidVariable) {\n            return null;\n        }\n        if (!parentNode.filters[0] || !['t', 'translate'].includes(parentNode.filters[0].name)) {\n            return null;\n        }\n        const translations = await this.getTranslationsForUri(params.textDocument.uri);\n        const translation = (0, translations_1.translationValue)(currentNode.value, translations);\n        const document = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!translation || !document) {\n            return null;\n        }\n        return {\n            contents: {\n                kind: 'markdown',\n                value: (0, translations_1.renderTranslation)(translation),\n            },\n            range: {\n                start: document.positionAt(currentNode.position.start),\n                end: document.positionAt(currentNode.position.end),\n            },\n        };\n    }\n}\nexports.TranslationHoverProvider = TranslationHoverProvider;\n//# sourceMappingURL=TranslationHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderSnippetParameterHoverProvider = exports.RenderSnippetHoverProvider = exports.TranslationHoverProvider = exports.HtmlAttributeValueHoverProvider = exports.HtmlAttributeHoverProvider = exports.HtmlTagHoverProvider = exports.LiquidObjectAttributeHoverProvider = exports.LiquidObjectHoverProvider = exports.LiquidFilterHoverProvider = exports.LiquidTagHoverProvider = void 0;\nvar LiquidTagHoverProvider_1 = require(\"./LiquidTagHoverProvider\");\nObject.defineProperty(exports, \"LiquidTagHoverProvider\", { enumerable: true, get: function () { return LiquidTagHoverProvider_1.LiquidTagHoverProvider; } });\nvar LiquidFilterHoverProvider_1 = require(\"./LiquidFilterHoverProvider\");\nObject.defineProperty(exports, \"LiquidFilterHoverProvider\", { enumerable: true, get: function () { return LiquidFilterHoverProvider_1.LiquidFilterHoverProvider; } });\nvar LiquidObjectHoverProvider_1 = require(\"./LiquidObjectHoverProvider\");\nObject.defineProperty(exports, \"LiquidObjectHoverProvider\", { enumerable: true, get: function () { return LiquidObjectHoverProvider_1.LiquidObjectHoverProvider; } });\nvar LiquidObjectAttributeHoverProvider_1 = require(\"./LiquidObjectAttributeHoverProvider\");\nObject.defineProperty(exports, \"LiquidObjectAttributeHoverProvider\", { enumerable: true, get: function () { return LiquidObjectAttributeHoverProvider_1.LiquidObjectAttributeHoverProvider; } });\nvar HtmlTagHoverProvider_1 = require(\"./HtmlTagHoverProvider\");\nObject.defineProperty(exports, \"HtmlTagHoverProvider\", { enumerable: true, get: function () { return HtmlTagHoverProvider_1.HtmlTagHoverProvider; } });\nvar HtmlAttributeHoverProvider_1 = require(\"./HtmlAttributeHoverProvider\");\nObject.defineProperty(exports, \"HtmlAttributeHoverProvider\", { enumerable: true, get: function () { return HtmlAttributeHoverProvider_1.HtmlAttributeHoverProvider; } });\nvar HtmlAttributeValueHoverProvider_1 = require(\"./HtmlAttributeValueHoverProvider\");\nObject.defineProperty(exports, \"HtmlAttributeValueHoverProvider\", { enumerable: true, get: function () { return HtmlAttributeValueHoverProvider_1.HtmlAttributeValueHoverProvider; } });\nvar TranslationHoverProvider_1 = require(\"./TranslationHoverProvider\");\nObject.defineProperty(exports, \"TranslationHoverProvider\", { enumerable: true, get: function () { return TranslationHoverProvider_1.TranslationHoverProvider; } });\nvar RenderSnippetHoverProvider_1 = require(\"./RenderSnippetHoverProvider\");\nObject.defineProperty(exports, \"RenderSnippetHoverProvider\", { enumerable: true, get: function () { return RenderSnippetHoverProvider_1.RenderSnippetHoverProvider; } });\nvar RenderSnippetParameterHoverProvider_1 = require(\"./RenderSnippetParameterHoverProvider\");\nObject.defineProperty(exports, \"RenderSnippetParameterHoverProvider\", { enumerable: true, get: function () { return RenderSnippetParameterHoverProvider_1.RenderSnippetParameterHoverProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileType = exports.allChecks = exports.recommendedChecks = exports.startServer = exports.parseJSON = exports.memo = exports.debounce = exports.visit = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nObject.defineProperty(exports, \"allChecks\", { enumerable: true, get: function () { return theme_check_common_1.allChecks; } });\nObject.defineProperty(exports, \"recommendedChecks\", { enumerable: true, get: function () { return theme_check_common_1.recommended; } });\nObject.defineProperty(exports, \"FileType\", { enumerable: true, get: function () { return theme_check_common_1.FileType; } });\n__exportStar(require(\"./types\"), exports);\nvar theme_check_common_2 = require(\"@shopify/theme-check-common\");\nObject.defineProperty(exports, \"visit\", { enumerable: true, get: function () { return theme_check_common_2.visit; } });\nvar utils_1 = require(\"./utils\");\nObject.defineProperty(exports, \"debounce\", { enumerable: true, get: function () { return utils_1.debounce; } });\nObject.defineProperty(exports, \"memo\", { enumerable: true, get: function () { return utils_1.memo; } });\nObject.defineProperty(exports, \"parseJSON\", { enumerable: true, get: function () { return utils_1.parseJSON; } });\nvar server_1 = require(\"./server\");\nObject.defineProperty(exports, \"startServer\", { enumerable: true, get: function () { return server_1.startServer; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONContributions = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst BlockTypeCompletionProvider_1 = require(\"./completions/providers/BlockTypeCompletionProvider\");\nconst ReferencedBlockTypeCompletionProvider_1 = require(\"./completions/providers/ReferencedBlockTypeCompletionProvider\");\nconst SchemaTranslationCompletionProvider_1 = require(\"./completions/providers/SchemaTranslationCompletionProvider\");\nconst SchemaTranslationHoverProvider_1 = require(\"./hover/providers/SchemaTranslationHoverProvider\");\nconst TranslationPathHoverProvider_1 = require(\"./hover/providers/TranslationPathHoverProvider\");\nconst utils_1 = require(\"./utils\");\nconst SettingsPropertyCompletionProvider_1 = require(\"./completions/providers/SettingsPropertyCompletionProvider\");\nconst SettingsHoverProvider_1 = require(\"./hover/providers/SettingsHoverProvider\");\nconst BlockSettingsPropertyCompletionProvider_1 = require(\"./completions/providers/BlockSettingsPropertyCompletionProvider\");\nconst BlockSettingsHoverProvider_1 = require(\"./hover/providers/BlockSettingsHoverProvider\");\n/** The getInfoContribution API will only fallback if we return undefined synchronously */\nconst SKIP_CONTRIBUTION = undefined;\n/**\n * I'm not a fan of how json-languageservice does its feature contributions. It's too different\n * from everything else we do in here.\n *\n * Instead, we'll have this little adapter that makes the completions and hover providers feel\n * a bit more familiar.\n */\nclass JSONContributions {\n    constructor(documentManager, getDefaultSchemaTranslations, getThemeBlockNames, getThemeBlockSchema) {\n        this.documentManager = documentManager;\n        this.hoverProviders = [\n            new TranslationPathHoverProvider_1.TranslationPathHoverProvider(),\n            new SchemaTranslationHoverProvider_1.SchemaTranslationHoverProvider(getDefaultSchemaTranslations),\n            new SettingsHoverProvider_1.SettingsHoverProvider(getDefaultSchemaTranslations),\n            new BlockSettingsHoverProvider_1.BlockSettingsHoverProvider(getDefaultSchemaTranslations, getThemeBlockSchema),\n        ];\n        this.completionProviders = [\n            new SchemaTranslationCompletionProvider_1.SchemaTranslationsCompletionProvider(getDefaultSchemaTranslations),\n            new BlockTypeCompletionProvider_1.BlockTypeCompletionProvider(getThemeBlockNames),\n            new ReferencedBlockTypeCompletionProvider_1.ReferencedBlockTypeCompletionProvider(getThemeBlockNames, getThemeBlockSchema),\n            new BlockSettingsPropertyCompletionProvider_1.BlockSettingsPropertyCompletionProvider(getDefaultSchemaTranslations, getThemeBlockSchema),\n            new SettingsPropertyCompletionProvider_1.SettingsPropertyCompletionProvider(getDefaultSchemaTranslations),\n        ];\n    }\n    getInfoContribution(uri, location) {\n        const doc = this.documentManager.get(uri);\n        if (!doc)\n            return SKIP_CONTRIBUTION;\n        const context = this.getContext(doc);\n        const provider = this.hoverProviders.find((p) => p.canHover(context, location));\n        if (!provider)\n            return SKIP_CONTRIBUTION;\n        return provider.hover(context, location);\n    }\n    async collectPropertyCompletions(uri, location, \n    // Don't know what those three are for.\n    _currentWord, _addValue, _isLast, result) {\n        const doc = this.documentManager.get(uri);\n        if (!doc || doc.ast instanceof Error)\n            return;\n        const items = await Promise.all(this.completionProviders\n            .filter((provider) => provider.completeProperty)\n            .map((provider) => provider.completeProperty(this.getContext(doc), location)));\n        for (const item of items.flat()) {\n            result.add(item);\n        }\n    }\n    async collectValueCompletions(uri, location, propertyKey, result) {\n        const doc = this.documentManager.get(uri);\n        if (!doc || doc.ast instanceof Error)\n            return;\n        const items = await Promise.all(this.completionProviders\n            .filter((provider) => provider.completeValue)\n            .map((provider) => provider.completeValue(this.getContext(doc), location.concat(propertyKey))));\n        for (const item of items.flat()) {\n            result.add(item);\n        }\n    }\n    /** I'm not sure we want to do anything with that... but TS requires us to have it */\n    async collectDefaultCompletions(_uri, _result) { }\n    getContext(doc) {\n        const context = {\n            doc,\n        };\n        if (doc.type === theme_check_common_1.SourceCodeType.LiquidHtml && !(doc.ast instanceof Error)) {\n            const schema = (0, utils_1.findSchemaNode)(doc.ast);\n            if (!schema)\n                return SKIP_CONTRIBUTION;\n            const jsonString = schema === null || schema === void 0 ? void 0 : schema.source.slice(schema.blockStartPosition.end, schema.blockEndPosition.start);\n            context.schema = schema;\n            context.parsed = (0, theme_check_common_1.parseJSON)(jsonString);\n        }\n        return context;\n    }\n}\nexports.JSONContributions = JSONContributions;\n//# sourceMappingURL=JSONContributions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONLanguageService = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_json_languageservice_1 = require(\"vscode-json-languageservice\");\nconst vscode_languageserver_textdocument_1 = require(\"vscode-languageserver-textdocument\");\nconst JSONContributions_1 = require(\"./JSONContributions\");\nclass JSONLanguageService {\n    constructor(documentManager, jsonValidationSet, getDefaultSchemaTranslations, getModeForURI, getThemeBlockNames, getThemeBlockSchema) {\n        this.documentManager = documentManager;\n        this.jsonValidationSet = jsonValidationSet;\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n        this.getModeForURI = getModeForURI;\n        this.getThemeBlockNames = getThemeBlockNames;\n        this.getThemeBlockSchema = getThemeBlockSchema;\n        this.isValidSchema = async (uri, jsonString) => {\n            const mode = await this.getModeForURI(uri);\n            const service = this.services[mode];\n            if (!service)\n                return false;\n            return (0, theme_check_common_1.isValid)(service, uri, jsonString);\n        };\n        this.services = Object.fromEntries(theme_check_common_1.Modes.map((mode) => [mode, null]));\n        this.schemas = {};\n    }\n    async setup(clientCapabilities) {\n        await Promise.all(theme_check_common_1.Modes.map(async (mode) => {\n            const schemas = await this.jsonValidationSet.schemas(mode);\n            for (const schema of schemas) {\n                this.schemas[schema.uri] = schema;\n            }\n            if (!schemas.length)\n                return;\n            const service = (0, vscode_json_languageservice_1.getLanguageService)({\n                clientCapabilities,\n                // Map URIs to schemas without making network requests. Removes the\n                // network dependency.\n                schemaRequestService: this.getSchemaForURI.bind(this),\n                // This is how we make sure that our \"$ref\": \"./inputSettings.json\" in\n                // our JSON schemas resolve correctly.\n                workspaceContext: {\n                    resolveRelativePath: (relativePath, resource) => {\n                        const url = new URL(relativePath, resource);\n                        return url.toString();\n                    },\n                },\n                contributions: [\n                    new JSONContributions_1.JSONContributions(this.documentManager, this.getDefaultSchemaTranslations, this.getThemeBlockNames, this.getThemeBlockSchema),\n                ],\n            });\n            service.configure({\n                // This is what we use to map file names to JSON schemas. Without\n                // this, we'd need folks to use the `$schema` field in their JSON\n                // blobs. That ain't fun nor is going to happen.\n                schemas: schemas.map((schemaDefinition) => ({\n                    uri: schemaDefinition.uri,\n                    fileMatch: schemaDefinition.fileMatch,\n                })),\n            });\n            this.services[mode] = service;\n        }));\n    }\n    async completions(params) {\n        const mode = await this.getModeForURI(params.textDocument.uri);\n        const service = this.services[mode];\n        if (!service)\n            return null;\n        const documents = this.getDocuments(params, service);\n        if (!documents)\n            return null;\n        const [jsonTextDocument, jsonDocument] = documents;\n        return service.doComplete(jsonTextDocument, params.position, jsonDocument);\n    }\n    async hover(params) {\n        const mode = await this.getModeForURI(params.textDocument.uri);\n        const service = this.services[mode];\n        if (!service)\n            return null;\n        const documents = this.getDocuments(params, service);\n        if (!documents)\n            return null;\n        const [jsonTextDocument, jsonDocument] = documents;\n        return service.doHover(jsonTextDocument, params.position, jsonDocument);\n    }\n    getDocuments(params, service) {\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!document)\n            return null;\n        switch (document.type) {\n            case theme_check_common_1.SourceCodeType.JSON: {\n                const jsonTextDocument = document.textDocument;\n                const jsonDocument = service.parseJSONDocument(jsonTextDocument);\n                return [jsonTextDocument, jsonDocument];\n            }\n            case theme_check_common_1.SourceCodeType.LiquidHtml: {\n                if (document.ast instanceof Error)\n                    return null;\n                const textDocument = document.textDocument;\n                const offset = textDocument.offsetAt(params.position);\n                const [_, ancestors] = (0, theme_check_common_1.findCurrentNode)(document.ast, offset);\n                const schema = ancestors.find((node) => node.type === liquid_html_parser_1.NodeTypes.LiquidRawTag && node.name === 'schema');\n                if (!schema)\n                    return null;\n                const schemaLineNumber = textDocument.positionAt(schema.blockStartPosition.end).line;\n                // Hacking away \"same line numbers\" here by prefixing the file with newlines\n                // This way params.position will be at the same line number in this fake jsonTextDocument\n                // Which means that the completions will be at the same line number in the Liquid document\n                const jsonString = Array(schemaLineNumber).fill('\\n').join('') +\n                    schema.source.slice(schema.blockStartPosition.end, schema.blockEndPosition.start);\n                const jsonTextDocument = vscode_languageserver_textdocument_1.TextDocument.create(textDocument.uri, 'json', textDocument.version, jsonString);\n                const jsonDocument = service.parseJSONDocument(jsonTextDocument);\n                return [jsonTextDocument, jsonDocument];\n            }\n        }\n    }\n    async getSchemaForURI(uri) {\n        var _a;\n        const schema = (_a = this.schemas[uri]) === null || _a === void 0 ? void 0 : _a.schema;\n        if (!schema)\n            return `Could not get schema for '${uri}'`;\n        return schema;\n    }\n}\nexports.JSONLanguageService = JSONLanguageService;\n//# sourceMappingURL=JSONLanguageService.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isJSONRequestContext = exports.isLiquidRequestContext = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nfunction isLiquidRequestContext(context) {\n    const { doc, schema, parsed } = context;\n    return (doc.type === theme_check_common_1.SourceCodeType.LiquidHtml && !!schema && !(0, theme_check_common_1.isError)(doc.ast) && !(0, theme_check_common_1.isError)(parsed));\n}\nexports.isLiquidRequestContext = isLiquidRequestContext;\nfunction isJSONRequestContext(context) {\n    const { doc } = context;\n    return doc.type === theme_check_common_1.SourceCodeType.JSON && !(0, theme_check_common_1.isError)(doc.ast);\n}\nexports.isJSONRequestContext = isJSONRequestContext;\n//# sourceMappingURL=RequestContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockSettingsPropertyCompletionProvider = void 0;\nconst utils_1 = require(\"../../utils\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst BlockTypeCompletionProvider_1 = require(\"./BlockTypeCompletionProvider\");\nconst schemaSettings_1 = require(\"./helpers/schemaSettings\");\n/**\n * The BlockSettingsPropertyCompletionProvider offers value completions of the\n * `presets.[].(recursive blocks.[]).settings` keys and `defaults.blocks.[].settings` keys inside\n * `{% schema %}` tags.\n *\n * @example\n * {% schema %}\n * {\n *   \"presets\": [\n *     {\n *       \"blocks\": [\n *         {\n *           \"type\": \"block-type\",\n *           \"settings\": {\n *             \"\"\n *           }\n *         },\n *       ]\n *     },\n *   ],\n *   \"default\": {\n *     \"blocks\": [\n *       {\n *         \"type\": \"block-type\",\n *         \"settings\": {\n *           \"\"\n *         }\n *       },\n *     ]\n *   }\n * }\n * {% endschema %}\n */\nclass BlockSettingsPropertyCompletionProvider {\n    constructor(getDefaultSchemaTranslations, getThemeBlockSchema) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n        this.getThemeBlockSchema = getThemeBlockSchema;\n    }\n    async completeProperty(context, path) {\n        var _a, _b;\n        const { doc } = context;\n        if (doc.type !== theme_check_common_1.SourceCodeType.LiquidHtml)\n            return [];\n        // section files can have schemas with `presets` and `default`\n        // block files can have schemas with `presets` only\n        if (!((0, utils_1.isSectionFile)(doc.uri) &&\n            (isPresetsBlocksSettingsPath(path) || isDefaultBlocksSettingsPath(path))) &&\n            !((0, utils_1.isBlockFile)(doc.uri) && isPresetsBlocksSettingsPath(path))) {\n            return [];\n        }\n        if ((0, utils_1.isSectionFile)(doc.uri) && !isDefaultBlocksSettingsPath(path)) {\n        }\n        const schema = await doc.getSchema();\n        if (!schema || !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(schema) || (0, theme_check_common_1.isError)(schema.parsed)) {\n            return [];\n        }\n        const blockType = (0, theme_check_common_1.deepGet)(schema.parsed, [...path.slice(0, -1), 'type']);\n        if (!blockType) {\n            return [];\n        }\n        const blockOriginSchema = await this.getThemeBlockSchema(doc.uri, blockType);\n        if (!blockOriginSchema ||\n            (0, theme_check_common_1.isError)(blockOriginSchema.parsed) ||\n            !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(blockOriginSchema)) {\n            return [];\n        }\n        if (!((_a = blockOriginSchema.parsed) === null || _a === void 0 ? void 0 : _a.settings) || !Array.isArray((_b = blockOriginSchema.parsed) === null || _b === void 0 ? void 0 : _b.settings)) {\n            return [];\n        }\n        const translations = await this.getDefaultSchemaTranslations(doc.textDocument.uri);\n        return (0, schemaSettings_1.schemaSettingsPropertyCompletionItems)(blockOriginSchema.parsed, translations);\n    }\n}\nexports.BlockSettingsPropertyCompletionProvider = BlockSettingsPropertyCompletionProvider;\n// `blocks` can be nested within other `blocks`\n// We need to ensure the last leg of the path is { \"blocks\": [{ \"settings\": { \"\" } }] }\nfunction isPresetsBlocksSettingsPath(path) {\n    return path.at(0) === 'presets' && path.at(-3) === 'blocks' && path.at(-1) === 'settings';\n}\n// `blocks` inside `default` can't be nested within other `blocks`\nfunction isDefaultBlocksSettingsPath(path) {\n    return path.at(0) === 'default' && path.at(1) === 'blocks' && path.at(3) === 'settings';\n}\n//# sourceMappingURL=BlockSettingsPropertyCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSectionOrBlockSchema = exports.isLocalBlockDefinition = exports.hasLocalBlockDefinitions = exports.isBlockTypePath = exports.isPresetBlockPath = exports.isBlockDefinitionPath = exports.createBlockNameCompletionItems = exports.BlockTypeCompletionProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\n/**\n * The BlockTypeCompletionProvider offers value completions of the\n * `blocks.[].type` property inside section and theme block `{% schema %}` tags.\n *\n * @example\n * {% schema %}\n * {\n *   \"blocks\": [\n *     { \"type\": \"\" },\n *   ]\n * }\n * {% endschema %}\n */\nclass BlockTypeCompletionProvider {\n    constructor(getThemeBlockNames) {\n        this.getThemeBlockNames = getThemeBlockNames;\n    }\n    async completeValue(context, path) {\n        if (!(0, utils_1.isSectionOrBlockFile)(context.doc.uri) ||\n            !(0, RequestContext_1.isLiquidRequestContext)(context) ||\n            !isBlockDefinitionPath(path)) {\n            return [];\n        }\n        const { doc } = context;\n        const schema = await doc.getSchema();\n        // Can't complete if we can't parse the schema\n        if (!schema || (0, theme_check_common_1.isError)(schema.parsed) || !isSectionOrBlockSchema(schema)) {\n            return [];\n        }\n        // Local blocks have their type defined in the schema, there's nothing to complete\n        if (hasLocalBlockDefinitions(schema))\n            return [];\n        const blockNames = await this.getThemeBlockNames(doc.uri, true);\n        return createBlockNameCompletionItems(blockNames);\n    }\n}\nexports.BlockTypeCompletionProvider = BlockTypeCompletionProvider;\nfunction createBlockNameCompletionItems(blockNames) {\n    return blockNames.map((name) => ({\n        kind: vscode_languageserver_protocol_1.CompletionItemKind.Value,\n        label: `\"${name}\"`,\n        insertText: `\"${name}\"`,\n    }));\n}\nexports.createBlockNameCompletionItems = createBlockNameCompletionItems;\nfunction isBlockDefinitionPath(path) {\n    return path.at(0) === 'blocks';\n}\nexports.isBlockDefinitionPath = isBlockDefinitionPath;\nfunction isPresetBlockPath(path) {\n    return path.at(0) === 'presets';\n}\nexports.isPresetBlockPath = isPresetBlockPath;\nfunction isBlockTypePath(path) {\n    // We have these cases to support:\n    // - top level blocks.[].type\n    // - presets.[](recursive .blocks.[].type)\n    // - presets.[](recursive .blocks.{}.type)\n    const topLevel = path.at(0);\n    if (topLevel !== 'blocks' && topLevel !== 'presets')\n        return false;\n    if (path.length < 4)\n        return false; // minimum path length\n    const [shouldBeBlocks, _idOrIndex, shouldBeType] = path.slice(-3);\n    return shouldBeBlocks === 'blocks' && shouldBeType === 'type';\n}\nexports.isBlockTypePath = isBlockTypePath;\nfunction hasLocalBlockDefinitions(schema) {\n    if (schema.type !== theme_check_common_1.ThemeSchemaType.Section || (0, theme_check_common_1.isError)(schema.parsed))\n        return false;\n    const blocks = (0, theme_check_common_1.deepGet)(schema.parsed, ['blocks']);\n    if (!blocks || !Array.isArray(blocks))\n        return false;\n    return blocks.some((block) => block && block.name !== undefined);\n}\nexports.hasLocalBlockDefinitions = hasLocalBlockDefinitions;\nfunction isLocalBlockDefinition(schema, blockTypePath) {\n    if (schema.type !== theme_check_common_1.ThemeSchemaType.Section)\n        return false;\n    const blockNamePath = [...blockTypePath.slice(0, -1), 'name'];\n    const name = (0, theme_check_common_1.deepGet)(schema.parsed, blockNamePath);\n    return name !== undefined;\n}\nexports.isLocalBlockDefinition = isLocalBlockDefinition;\nconst SectionOrBlockSchemaTypes = [theme_check_common_1.ThemeSchemaType.Section, theme_check_common_1.ThemeSchemaType.Block];\nfunction isSectionOrBlockSchema(schema) {\n    return SectionOrBlockSchemaTypes.includes(schema.type);\n}\nexports.isSectionOrBlockSchema = isSectionOrBlockSchema;\n//# sourceMappingURL=BlockTypeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReferencedBlockTypeCompletionProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nconst BlockTypeCompletionProvider_1 = require(\"./BlockTypeCompletionProvider\");\n/**\n * The ReferencedBlockTypeCompletionProvider offers value completions of the\n * `presets.[](recursive .blocks.[]).type` value and `default.blocks.[].type` value inside\n * section and theme block `{% schema %}` tags.\n *\n * @example\n * {% schema %}\n * {\n *   \"presets\": [\n *     {\n *       \"blocks\": [\n *         { \"type\": \"\" },\n *       ]\n *     },\n *   ],\n *   \"default\": {\n *     \"blocks\": [\n *       { \"type\": \"\" },\n *     ]\n *   }\n * }\n * {% endschema %}\n */\nclass ReferencedBlockTypeCompletionProvider {\n    constructor(getThemeBlockNames, getThemeBlockSchema) {\n        this.getThemeBlockNames = getThemeBlockNames;\n        this.getThemeBlockSchema = getThemeBlockSchema;\n    }\n    async completeValue(context, path) {\n        if (!(0, utils_1.isSectionOrBlockFile)(context.doc.uri) ||\n            !(0, RequestContext_1.isLiquidRequestContext)(context) ||\n            !isBlockTypePath(path)) {\n            return [];\n        }\n        const { doc } = context;\n        const schema = await doc.getSchema();\n        if (!schema || (0, theme_check_common_1.isError)(schema.parsed) || !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(schema)) {\n            return [];\n        }\n        let parsedBlockSchema = schema.parsed;\n        if (isNestedBlockPath(path)) {\n            const parentBlockName = getParentBlockName(schema.parsed, path);\n            if (!parentBlockName) {\n                return [];\n            }\n            const parentBlockSchema = await this.getThemeBlockSchema(doc.uri, parentBlockName);\n            if (!parentBlockSchema ||\n                (0, theme_check_common_1.isError)(parentBlockSchema.parsed) ||\n                !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(parentBlockSchema)) {\n                return [];\n            }\n            parsedBlockSchema = parentBlockSchema.parsed;\n        }\n        const blocks = parsedBlockSchema.blocks || [];\n        const blockGroups = {\n            themeBlocks: false,\n            specificBlockNames: [],\n        };\n        blocks.forEach((block) => {\n            if (block.type === '@theme') {\n                blockGroups.themeBlocks = true;\n            }\n            else if (!block.type.startsWith('@')) {\n                blockGroups.specificBlockNames.push(block.type);\n            }\n        });\n        let blockNames = blockGroups.specificBlockNames;\n        if (blockGroups.themeBlocks) {\n            blockNames.push(...(await this.getThemeBlockNames(doc.uri, false)));\n        }\n        return (0, BlockTypeCompletionProvider_1.createBlockNameCompletionItems)(blockNames);\n    }\n}\nexports.ReferencedBlockTypeCompletionProvider = ReferencedBlockTypeCompletionProvider;\n// `blocks` can be nested within other `blocks`\n// We need to ensure the last leg of the path is { \"blocks\": [{ \"type\": \"\" }] }\nfunction isBlockTypePath(path) {\n    return ((path.at(0) === 'presets' || path.at(0) === 'default') &&\n        path.at(-3) === 'blocks' &&\n        path.at(-1) === 'type');\n}\nfunction isNestedBlockPath(path) {\n    return path.at(-5) === 'blocks' && path.at(-3) === 'blocks' && path.at(-1) === 'type';\n}\nfunction getParentBlockName(parsedSchema, path) {\n    return (0, theme_check_common_1.deepGet)(parsedSchema, [...path.slice(0, -3), 'type']);\n}\n//# sourceMappingURL=ReferencedBlockTypeCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaTranslationsCompletionProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_json_languageservice_1 = require(\"vscode-json-languageservice\");\nconst translations_1 = require(\"../../../translations\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nclass SchemaTranslationsCompletionProvider {\n    constructor(getDefaultSchemaTranslations) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n    }\n    async completeValue(context, path) {\n        var _a;\n        if (!(0, utils_1.isSectionOrBlockFile)(context.doc.uri) || !(0, RequestContext_1.isLiquidRequestContext)(context)) {\n            return [];\n        }\n        const { doc, parsed } = context;\n        const label = (0, theme_check_common_1.deepGet)(parsed, path);\n        if (!label || typeof label !== 'string' || !label.startsWith('t:')) {\n            return [];\n        }\n        const partial = (_a = /^t:(.*)/.exec(label)) === null || _a === void 0 ? void 0 : _a[1];\n        if (partial === undefined)\n            return [];\n        const translations = await this.getDefaultSchemaTranslations(doc.uri);\n        // We'll let the frontend do the filtering. But we'll only include shopify\n        // translations if the shopify prefix is present\n        const options = (0, translations_1.translationOptions)(translations);\n        return options.map((option) => {\n            const tLabel = `t:${option.path.join('.')}`;\n            return {\n                label: tLabel,\n                kind: vscode_json_languageservice_1.CompletionItemKind.Value,\n                filterText: `\"${tLabel}\"`,\n                insertText: `\"${tLabel}\"`,\n                insertTextFormat: 1,\n                documentation: {\n                    kind: 'markdown',\n                    value: (0, translations_1.renderTranslation)(option.translation),\n                },\n            };\n        });\n    }\n}\nexports.SchemaTranslationsCompletionProvider = SchemaTranslationsCompletionProvider;\n//# sourceMappingURL=SchemaTranslationCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsPropertyCompletionProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst utils_1 = require(\"../../utils\");\nconst BlockTypeCompletionProvider_1 = require(\"./BlockTypeCompletionProvider\");\nconst schemaSettings_1 = require(\"./helpers/schemaSettings\");\n/**\n * The SettingsPropertyCompletionProvider offers property completions for:\n * - `presets.[].settings.[]` objects inside `{% schema %}` tag in sections and blocks\n * - `default.settings` object inside `{% schema %}` tag in sections\n *\n * @example\n * {% schema %}\n * {\n *   \"presets\": [\n *     {\n *       \"settings\": [\n *         { \"\" },\n *       ]\n *     },\n *   ],\n *   \"default\": {\n *     \"settings\": {\n *       \"\"\n *     }\n *   }\n * }\n * {% endschema %}\n */\nclass SettingsPropertyCompletionProvider {\n    constructor(getDefaultSchemaTranslations) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n    }\n    async completeProperty(context, path) {\n        const { doc } = context;\n        if (doc.type !== theme_check_common_1.SourceCodeType.LiquidHtml)\n            return [];\n        // section files can have schemas with `presets` and `default`\n        // block files can have schemas with `presets` only\n        if (!((0, utils_1.isSectionFile)(doc.uri) && (isPresetSettingsPath(path) || isDefaultSettingsPath(path))) &&\n            !((0, utils_1.isBlockFile)(doc.uri) && isPresetSettingsPath(path))) {\n            return [];\n        }\n        const schema = await doc.getSchema();\n        if (!schema || !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(schema) || (0, theme_check_common_1.isError)(schema.parsed)) {\n            return [];\n        }\n        const parsedSchema = schema.parsed;\n        if (!(parsedSchema === null || parsedSchema === void 0 ? void 0 : parsedSchema.settings) || !Array.isArray(parsedSchema.settings)) {\n            return [];\n        }\n        const translations = await this.getDefaultSchemaTranslations(doc.textDocument.uri);\n        return (0, schemaSettings_1.schemaSettingsPropertyCompletionItems)(parsedSchema, translations);\n    }\n}\nexports.SettingsPropertyCompletionProvider = SettingsPropertyCompletionProvider;\nfunction isPresetSettingsPath(path) {\n    return path.length === 3 && path.at(0) === 'presets' && path.at(2) === 'settings';\n}\nfunction isDefaultSettingsPath(path) {\n    return path.length === 2 && path.at(0) === 'default' && path.at(1) === 'settings';\n}\n//# sourceMappingURL=SettingsPropertyCompletionProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.schemaSettingsPropertyCompletionItems = void 0;\nconst vscode_json_languageservice_1 = require(\"vscode-json-languageservice\");\nconst translations_1 = require(\"../../../../translations\");\nfunction schemaSettingsPropertyCompletionItems(parsedSchema, translations) {\n    return parsedSchema.settings\n        .filter((setting) => setting.id)\n        .map((setting) => {\n        let docValue = '';\n        if (setting.label) {\n            if (setting.label.startsWith('t:')) {\n                const translation = (0, translations_1.translationValue)(setting.label.substring(2), translations);\n                if (translation) {\n                    docValue = (0, translations_1.renderTranslation)(translation);\n                }\n            }\n            else {\n                docValue = setting.label;\n            }\n        }\n        const completionText = setting.id ? `\"${setting.id}\"` : '';\n        return {\n            kind: vscode_json_languageservice_1.CompletionItemKind.Property,\n            label: completionText,\n            insertText: completionText,\n            documentation: {\n                kind: vscode_json_languageservice_1.MarkupKind.Markdown,\n                value: docValue,\n            },\n        };\n    });\n}\nexports.schemaSettingsPropertyCompletionItems = schemaSettingsPropertyCompletionItems;\n//# sourceMappingURL=schemaSettings.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockSettingsHoverProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst translations_1 = require(\"../../../translations\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nconst BlockTypeCompletionProvider_1 = require(\"../../completions/providers/BlockTypeCompletionProvider\");\nclass BlockSettingsHoverProvider {\n    constructor(getDefaultSchemaTranslations, getThemeBlockSchema) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n        this.getThemeBlockSchema = getThemeBlockSchema;\n    }\n    canHover(context, path) {\n        return ((0, utils_1.isSectionOrBlockFile)(context.doc.uri) &&\n            (0, RequestContext_1.isLiquidRequestContext)(context) &&\n            path.length !== 0 &&\n            isBlocksSettingsPath(path));\n    }\n    async hover(context, path) {\n        var _a;\n        if (!this.canHover(context, path))\n            return [];\n        const { doc } = context;\n        const schema = await doc.getSchema();\n        if (!isValidSchema(schema))\n            return [];\n        const blockType = (0, theme_check_common_1.deepGet)(schema.parsed, [...path.slice(0, -2), 'type']);\n        if (!blockType)\n            return [];\n        const themeBlockSchema = await this.getThemeBlockSchema(doc.uri, blockType);\n        if (!isValidSchema(themeBlockSchema))\n            return [];\n        if (!hasValidSchemaSettings(themeBlockSchema))\n            return [];\n        const label = (_a = themeBlockSchema.parsed.settings.find((setting) => (setting === null || setting === void 0 ? void 0 : setting.id) === path.at(-1))) === null || _a === void 0 ? void 0 : _a.label;\n        if (!label)\n            return [];\n        if (!label.startsWith('t:')) {\n            return [label];\n        }\n        return this.getDefaultSchemaTranslations(doc.uri).then((translations) => {\n            const path = label.substring(2);\n            const value = (0, translations_1.translationValue)(path, translations);\n            if (!value)\n                return undefined;\n            return [(0, translations_1.renderTranslation)(value)];\n        });\n    }\n}\nexports.BlockSettingsHoverProvider = BlockSettingsHoverProvider;\nfunction isBlocksSettingsPath(path) {\n    return ((path.at(0) === 'presets' || path.at(0) === 'default') &&\n        path.at(-4) === 'blocks' &&\n        path.at(-2) === 'settings' &&\n        path.at(-1) !== undefined &&\n        typeof path.at(-1) === 'string');\n}\nfunction isValidSchema(schema) {\n    return !!schema && !(0, theme_check_common_1.isError)(schema.parsed) && (0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(schema);\n}\nfunction hasValidSchemaSettings(schema) {\n    var _a;\n    return ((_a = schema.parsed) === null || _a === void 0 ? void 0 : _a.settings) !== undefined && Array.isArray(schema.parsed.settings);\n}\n//# sourceMappingURL=BlockSettingsHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SchemaTranslationHoverProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst translations_1 = require(\"../../../translations\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nclass SchemaTranslationHoverProvider {\n    constructor(getDefaultSchemaTranslations) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n    }\n    canHover(context, path) {\n        const label = (0, theme_check_common_1.deepGet)(context.parsed, path);\n        return ((0, utils_1.isSectionOrBlockFile)(context.doc.uri) &&\n            (0, RequestContext_1.isLiquidRequestContext)(context) &&\n            path.length !== 0 &&\n            label &&\n            typeof label === 'string' &&\n            label.startsWith('t:'));\n    }\n    async hover(context, path) {\n        if (!this.canHover(context, path))\n            return [];\n        // Can assert is a string because of `canHover` check above\n        const label = (0, theme_check_common_1.deepGet)(context.parsed, path);\n        return this.getDefaultSchemaTranslations(context.doc.uri).then((translations) => {\n            const path = label.slice(2); // remove `t:`\n            const value = (0, translations_1.translationValue)(path, translations);\n            if (!value)\n                return undefined;\n            return [(0, translations_1.renderTranslation)(value)];\n        });\n    }\n}\nexports.SchemaTranslationHoverProvider = SchemaTranslationHoverProvider;\n//# sourceMappingURL=SchemaTranslationHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SettingsHoverProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst translations_1 = require(\"../../../translations\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nconst BlockTypeCompletionProvider_1 = require(\"../../completions/providers/BlockTypeCompletionProvider\");\nclass SettingsHoverProvider {\n    constructor(getDefaultSchemaTranslations) {\n        this.getDefaultSchemaTranslations = getDefaultSchemaTranslations;\n    }\n    canHover(context, path) {\n        return ((0, utils_1.isSectionOrBlockFile)(context.doc.uri) &&\n            (0, RequestContext_1.isLiquidRequestContext)(context) &&\n            path.length !== 0 &&\n            (isPresetsSettingsPath(path) || isDefaultSettingsPath(path)));\n    }\n    async hover(context, path) {\n        if (!this.canHover(context, path))\n            return [];\n        const { doc } = context;\n        const label = await getSettingsLabel(doc, path.at(-1));\n        if (!label)\n            return [];\n        if (!label.startsWith('t:')) {\n            return [label];\n        }\n        return this.getDefaultSchemaTranslations(doc.uri).then((translations) => {\n            const path = label.substring(2);\n            const value = (0, translations_1.translationValue)(path, translations);\n            if (!value)\n                return undefined;\n            return [(0, translations_1.renderTranslation)(value)];\n        });\n    }\n}\nexports.SettingsHoverProvider = SettingsHoverProvider;\nfunction isPresetsSettingsPath(path) {\n    return (path.at(0) === 'presets' &&\n        path.at(2) === 'settings' &&\n        path.at(3) !== undefined &&\n        typeof path.at(3) === 'string');\n}\nfunction isDefaultSettingsPath(path) {\n    return (path.at(0) === 'default' &&\n        path.at(1) === 'settings' &&\n        path.at(2) !== undefined &&\n        typeof path.at(2) === 'string');\n}\nasync function getSettingsLabel(doc, label) {\n    var _a;\n    const schema = await doc.getSchema();\n    if (!schema ||\n        !(0, BlockTypeCompletionProvider_1.isSectionOrBlockSchema)(schema) ||\n        (0, theme_check_common_1.isError)(schema.parsed) ||\n        schema.parsed.settings === undefined ||\n        !Array.isArray(schema.parsed.settings)) {\n        return;\n    }\n    return (_a = schema.parsed.settings.find((setting) => (setting === null || setting === void 0 ? void 0 : setting.id) === label)) === null || _a === void 0 ? void 0 : _a.label;\n}\n//# sourceMappingURL=SettingsHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contextualizedLabel = exports.TranslationPathHoverProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst translations_1 = require(\"../../../translations\");\nconst RequestContext_1 = require(\"../../RequestContext\");\nconst utils_1 = require(\"../../utils\");\nclass TranslationPathHoverProvider {\n    constructor() {\n        this.filePatterns = [/^.*\\/locales\\/[^\\/]*\\.json$/];\n    }\n    canHover(context, path) {\n        return ((0, utils_1.fileMatch)(context.doc.uri, this.filePatterns) &&\n            path.length > 0 &&\n            (0, RequestContext_1.isJSONRequestContext)(context));\n    }\n    async hover(context, path) {\n        // Redundant use for type assertion\n        if (!this.canHover(context, path))\n            return [];\n        const { doc } = context;\n        const ast = doc.ast;\n        const node = (0, theme_check_common_1.nodeAtPath)(ast, path);\n        switch (true) {\n            // Because the JSON language service doesn't support composition of hover info,\n            // We have to hardcode the docs for the translation file schema here.\n            case ['zero', 'one', 'two', 'few', 'many', 'other'].includes(path.at(-1)): {\n                if (!node || node.type !== 'Literal' || typeof node.value !== 'string') {\n                    return [`Pluralized translations should have a string value`];\n                }\n                return [contextualizedLabel(doc.uri, path.slice(0, -1), node.value)];\n            }\n            case path.at(-1).toString().endsWith('_html'): {\n                if (!node || node.type !== 'Literal' || typeof node.value !== 'string') {\n                    return [`Translations ending in '_html' should have a string value`];\n                }\n                return [\n                    contextualizedLabel(doc.uri, path, node.value),\n                    `The '_html' suffix prevents the HTML content from being escaped.`,\n                ];\n            }\n            default: {\n                if (!node || node.type !== 'Literal' || typeof node.value !== 'string') {\n                    return [`Translation group: ${path.join('.')}`];\n                }\n                return [contextualizedLabel(doc.uri, path, node.value)];\n            }\n        }\n    }\n}\nexports.TranslationPathHoverProvider = TranslationPathHoverProvider;\nfunction contextualizedLabel(uri, str, value) {\n    if (uri.includes('.schema')) {\n        return marked(`\"t:${str.join('.')}\"`, 'json');\n    }\n    else {\n        const params = (0, translations_1.extractParams)(value);\n        return marked(`{{ '${str.join('.')}' | t${(0, translations_1.paramsString)(params)} }}`, 'liquid');\n    }\n}\nexports.contextualizedLabel = contextualizedLabel;\nfunction marked(value, language = 'liquid') {\n    return { language, value };\n}\n//# sourceMappingURL=TranslationPathHoverProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findSchemaNode = exports.isSectionOrBlockFile = exports.isBlockFile = exports.isSectionFile = exports.fileMatch = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nfunction fileMatch(uri, patterns) {\n    return patterns.some((pattern) => pattern.test(uri));\n}\nexports.fileMatch = fileMatch;\nfunction isSectionFile(uri) {\n    return /\\/sections\\/[^/]*\\.liquid$/.test(uri);\n}\nexports.isSectionFile = isSectionFile;\nfunction isBlockFile(uri) {\n    return /\\/blocks\\/[^/]*\\.liquid$/.test(uri);\n}\nexports.isBlockFile = isBlockFile;\nfunction isSectionOrBlockFile(uri) {\n    return isSectionFile(uri) || isBlockFile(uri);\n}\nexports.isSectionOrBlockFile = isSectionOrBlockFile;\nfunction findSchemaNode(ast) {\n    const nodes = (0, theme_check_common_1.visit)(ast, {\n        LiquidRawTag(node) {\n            if (node.name === 'schema') {\n                return node;\n            }\n        },\n    });\n    return nodes[0];\n}\nexports.findSchemaNode = findSchemaNode;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangesProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nconst providers_1 = require(\"./providers\");\nclass LinkedEditingRangesProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n        this.providers = [\n            new providers_1.HtmlTagNameLinkedRangesProvider(documentManager),\n            new providers_1.EmptyHtmlTagLinkedRangesProvider(documentManager),\n        ];\n    }\n    async linkedEditingRanges(params) {\n        var _a;\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!document || document.type !== theme_check_common_1.SourceCodeType.LiquidHtml) {\n            return null;\n        }\n        let currentNode = null;\n        let ancestors = null;\n        if (!(document.ast instanceof Error)) {\n            [currentNode, ancestors] = (0, theme_check_common_2.findCurrentNode)(document.ast, document.textDocument.offsetAt(params.position));\n        }\n        const promises = this.providers.map((p) => p.linkedEditingRanges(currentNode, ancestors, params).catch(() => null));\n        const results = await Promise.all(promises);\n        return (_a = results.find(Boolean)) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports.LinkedEditingRangesProvider = LinkedEditingRangesProvider;\n//# sourceMappingURL=LinkedEditingRangesProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EmptyHtmlTagLinkedRangesProvider = void 0;\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst wordPattern_1 = require(\"../wordPattern\");\nclass EmptyHtmlTagLinkedRangesProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async linkedEditingRanges(node, ancestors, { textDocument: { uri }, position }) {\n        // We're strictly checking for <></> and cursor in either branch, that's a parse error\n        // ... but it's fine because <></> is rather easy to find.\n        if (node !== null || ancestors !== null)\n            return null;\n        const document = this.documentManager.get(uri);\n        const textDocument = document === null || document === void 0 ? void 0 : document.textDocument;\n        if (!document || !textDocument)\n            return null;\n        const openRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, position.character - 1), vscode_languageserver_1.Position.create(position.line, position.character + 1));\n        if (!['<>', '< '].includes(textDocument.getText(openRange)))\n            return null;\n        const closeOffset = document.source.indexOf('</>', textDocument.offsetAt(position));\n        if (closeOffset === -1)\n            return null;\n        const afterSlashOffset = closeOffset + 2;\n        const afterSlashPosition = textDocument.positionAt(afterSlashOffset);\n        return {\n            ranges: [\n                vscode_languageserver_1.Range.create(position, position),\n                vscode_languageserver_1.Range.create(afterSlashPosition, afterSlashPosition),\n            ],\n            wordPattern: wordPattern_1.htmlElementNameWordPattern,\n        };\n    }\n}\nexports.EmptyHtmlTagLinkedRangesProvider = EmptyHtmlTagLinkedRangesProvider;\n//# sourceMappingURL=EmptyHtmlTagLinkedRangesProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagNameLinkedRangesProvider = void 0;\nconst htmlTagNames_1 = require(\"../../utils/htmlTagNames\");\nconst wordPattern_1 = require(\"../wordPattern\");\nclass HtmlTagNameLinkedRangesProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async linkedEditingRanges(node, ancestors, params) {\n        var _a;\n        if (!node || !ancestors)\n            return null;\n        const textDocument = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!textDocument)\n            return null;\n        const ranges = (0, htmlTagNames_1.getHtmlElementNameRanges)(node, ancestors, params, textDocument);\n        if (!ranges)\n            return null;\n        return {\n            ranges,\n            wordPattern: wordPattern_1.htmlElementNameWordPattern,\n        };\n    }\n}\nexports.HtmlTagNameLinkedRangesProvider = HtmlTagNameLinkedRangesProvider;\n//# sourceMappingURL=HtmlTagNameLinkedRangesProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagNameLinkedRangesProvider = exports.EmptyHtmlTagLinkedRangesProvider = void 0;\nvar EmptyHtmlTagLinkedRangesProvider_1 = require(\"./EmptyHtmlTagLinkedRangesProvider\");\nObject.defineProperty(exports, \"EmptyHtmlTagLinkedRangesProvider\", { enumerable: true, get: function () { return EmptyHtmlTagLinkedRangesProvider_1.EmptyHtmlTagLinkedRangesProvider; } });\nvar HtmlTagNameLinkedRangesProvider_1 = require(\"./HtmlTagNameLinkedRangesProvider\");\nObject.defineProperty(exports, \"HtmlTagNameLinkedRangesProvider\", { enumerable: true, get: function () { return HtmlTagNameLinkedRangesProvider_1.HtmlTagNameLinkedRangesProvider; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.htmlElementNameWordPattern = void 0;\nconst nameCharStart = '[a-zA-Z]';\nconst nameChar = '[a-zA-Z0-9-]';\nexports.htmlElementNameWordPattern = `${nameCharStart}${nameChar}*`;\n//# sourceMappingURL=wordPattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.percent = exports.Progress = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\n/**\n * A short hand for handling progress reporting to the language client.\n *\n * It handles all the LSP protocol details for you.\n *\n * @example\n * const progress = Progress.create(connection, capabilities, progressToken);\n * await progress.start('Starting progress');\n * await progress.report(50, 'Halfway there');\n * await progress.end('Finished');\n */\nclass Progress {\n    constructor(connection, progressToken) {\n        this.connection = connection;\n        this.progressToken = progressToken;\n    }\n    static create(connection, capabilities, progressToken) {\n        if (!connection || !capabilities || !capabilities.hasProgressSupport) {\n            // If you don't have a connection, we give you a mock that doesn't do anything.\n            return {\n                start: async () => { },\n                report: async () => { },\n                end: async () => { },\n            };\n        }\n        return new Progress(connection, progressToken);\n    }\n    async start(title) {\n        await this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, {\n            token: this.progressToken,\n        });\n        await this.connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this.progressToken, {\n            kind: 'begin',\n            title,\n        });\n    }\n    async report(percentage, message) {\n        await this.connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this.progressToken, {\n            kind: 'report',\n            message,\n            percentage,\n        });\n    }\n    async end(message) {\n        await this.connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this.progressToken, {\n            kind: 'end',\n            message,\n        });\n    }\n}\nexports.Progress = Progress;\n/**\n * Given a current/total and an offset, report the percent complete\n * @param current - number of items processed from total\n * @param total   - total number of items\n * @param offset  - offset % to start at\n *\n * @example\n * const offset = 50 // Start at 50%\n * const current = 0\n * const total = 100 // files or whatever\n * percent(0, total, offset)   // 50 %\n * percent(50, total, offset)  // 75 %\n * percent(100, total, offset) // 100 %\n */\nfunction percent(current, total, offset = 0) {\n    return Math.round(offset + (current / total) * (100 - offset));\n}\nexports.percent = percent;\n//# sourceMappingURL=progress.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenameProvider = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst theme_check_common_2 = require(\"@shopify/theme-check-common\");\nconst HtmlTagNameRenameProvider_1 = require(\"./providers/HtmlTagNameRenameProvider\");\nconst LiquidVariableRenameProvider_1 = require(\"./providers/LiquidVariableRenameProvider\");\n/**\n * RenameProvider is responsible for providing rename support for the theme language server.\n *\n * Rename is a pretty abstract concept, it can be renaming a tag name, a variable, a class name, etc.\n */\nclass RenameProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n        this.providers = [\n            new HtmlTagNameRenameProvider_1.HtmlTagNameRenameProvider(documentManager),\n            new LiquidVariableRenameProvider_1.LiquidVariableRenameProvider(documentManager),\n        ];\n    }\n    /** Prepare is for telling if you can rename this thing or not, and what text to rename */\n    async prepare(params) {\n        var _a;\n        const [currentNode, ancestors] = this.nodes(params);\n        if (currentNode === null || ancestors === null) {\n            return null;\n        }\n        const promises = this.providers.map((provider) => provider\n            .prepare(currentNode, ancestors, params)\n            .catch(() => null));\n        const results = await Promise.all(promises);\n        return (_a = results.find(Boolean)) !== null && _a !== void 0 ? _a : null;\n    }\n    /** Rename is for actually renaming something */\n    async rename(params) {\n        var _a;\n        const [currentNode, ancestors] = this.nodes(params);\n        if (currentNode === null || ancestors === null) {\n            return null;\n        }\n        const promises = this.providers.map((provider) => provider\n            .rename(currentNode, ancestors, params)\n            .catch(() => null));\n        const results = await Promise.all(promises);\n        return (_a = results.find(Boolean)) !== null && _a !== void 0 ? _a : null;\n    }\n    /** a helper for getting the node under the cursor and its ancestry */\n    nodes(params) {\n        const document = this.documentManager.get(params.textDocument.uri);\n        if (!document || document.type !== theme_check_common_1.SourceCodeType.LiquidHtml) {\n            return [null, null];\n        }\n        if (!(document.ast instanceof Error)) {\n            return (0, theme_check_common_2.findCurrentNode)(document.ast, document.textDocument.offsetAt(params.position));\n        }\n        return [null, null];\n    }\n}\nexports.RenameProvider = RenameProvider;\n//# sourceMappingURL=RenameProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlTagNameRenameProvider = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst htmlTagNames_1 = require(\"../../utils/htmlTagNames\");\nclass HtmlTagNameRenameProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async prepare(node, ancestors, params) {\n        var _a;\n        const textDocument = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!textDocument || !node || !ancestors)\n            return null;\n        const ranges = (0, htmlTagNames_1.getHtmlElementNameRanges)(node, ancestors, params, textDocument);\n        if (!ranges || !ranges[0])\n            return null;\n        return {\n            range: ranges[0],\n            placeholder: textDocument.getText(ranges[0]),\n        };\n    }\n    async rename(node, ancestors, params) {\n        var _a;\n        const textDocument = (_a = this.documentManager.get(params.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.textDocument;\n        if (!textDocument || !node || !ancestors)\n            return null;\n        const ranges = (0, htmlTagNames_1.getHtmlElementNameRanges)(node, ancestors, params, textDocument);\n        if (!ranges)\n            return null;\n        const textDocumentEdit = vscode_languageserver_protocol_1.TextDocumentEdit.create({ uri: textDocument.uri, version: textDocument.version }, toTextEdits(ranges, params.newName));\n        return {\n            documentChanges: [textDocumentEdit],\n        };\n    }\n}\nexports.HtmlTagNameRenameProvider = HtmlTagNameRenameProvider;\nfunction toTextEdits(ranges, newText) {\n    return ranges.map((range) => vscode_languageserver_protocol_1.TextEdit.replace(range, newText));\n}\n//# sourceMappingURL=HtmlTagNameRenameProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiquidVariableRenameProvider = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nclass LiquidVariableRenameProvider {\n    constructor(documentManager) {\n        this.documentManager = documentManager;\n    }\n    async prepare(node, ancestors, params) {\n        const document = this.documentManager.get(params.textDocument.uri);\n        const textDocument = document === null || document === void 0 ? void 0 : document.textDocument;\n        if (!textDocument || !node || !ancestors)\n            return null;\n        if (!supportedTags(node))\n            return null;\n        const oldName = variableName(node);\n        const offsetOfVariableNameEnd = node.position.start + oldName.length;\n        // The cursor could be past the end of the variable name\n        if (textDocument.offsetAt(params.position) > offsetOfVariableNameEnd)\n            return null;\n        return {\n            range: vscode_languageserver_1.Range.create(textDocument.positionAt(node.position.start), textDocument.positionAt(offsetOfVariableNameEnd)),\n            placeholder: oldName,\n        };\n    }\n    async rename(node, ancestors, params) {\n        const document = this.documentManager.get(params.textDocument.uri);\n        const textDocument = document === null || document === void 0 ? void 0 : document.textDocument;\n        if (!textDocument || !node || !ancestors)\n            return null;\n        if (document.ast instanceof Error)\n            return null;\n        if (!supportedTags(node))\n            return null;\n        const oldName = variableName(node);\n        const scope = variableNameBlockScope(oldName, ancestors);\n        const replaceRange = textReplaceRange(oldName, textDocument, scope);\n        const ranges = (0, theme_check_common_1.visit)(document.ast, {\n            VariableLookup: replaceRange,\n            AssignMarkup: replaceRange,\n            ForMarkup: replaceRange,\n        });\n        const textDocumentEdit = vscode_languageserver_protocol_1.TextDocumentEdit.create({ uri: textDocument.uri, version: textDocument.version }, ranges.map((range) => vscode_languageserver_protocol_1.TextEdit.replace(range, params.newName)));\n        return {\n            documentChanges: [textDocumentEdit],\n        };\n    }\n}\nexports.LiquidVariableRenameProvider = LiquidVariableRenameProvider;\nfunction supportedTags(node) {\n    return (node.type === liquid_html_parser_1.NodeTypes.AssignMarkup ||\n        node.type === liquid_html_parser_1.NodeTypes.VariableLookup ||\n        node.type === liquid_html_parser_1.NodeTypes.ForMarkup);\n}\nfunction variableName(node) {\n    var _a, _b;\n    switch (node.type) {\n        case liquid_html_parser_1.NodeTypes.VariableLookup:\n        case liquid_html_parser_1.NodeTypes.AssignMarkup:\n            return (_a = node.name) !== null && _a !== void 0 ? _a : '';\n        case liquid_html_parser_1.NodeTypes.ForMarkup:\n            return (_b = node.variableName) !== null && _b !== void 0 ? _b : '';\n        default:\n            return '';\n    }\n}\n/*\n * Find the scope where the variable name is used. Looks at defined in `tablerow` and `for` tags.\n */\nfunction variableNameBlockScope(variableName, ancestors) {\n    let scopedAncestor;\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const ancestor = ancestors[i];\n        if (ancestor.type === liquid_html_parser_1.NodeTypes.LiquidTag &&\n            (ancestor.name === liquid_html_parser_1.NamedTags.tablerow || ancestor.name === liquid_html_parser_1.NamedTags.for) &&\n            typeof ancestor.markup !== 'string' &&\n            ancestor.markup.variableName === variableName) {\n            scopedAncestor = ancestor;\n            break;\n        }\n    }\n    if (!scopedAncestor || !scopedAncestor.blockEndPosition)\n        return;\n    return {\n        start: scopedAncestor.blockStartPosition.start,\n        end: scopedAncestor.blockEndPosition.end,\n    };\n}\nfunction textReplaceRange(oldName, textDocument, selectedVariableScope) {\n    return (node, ancestors) => {\n        if (variableName(node) !== oldName)\n            return;\n        const ancestorScope = variableNameBlockScope(oldName, ancestors);\n        if ((ancestorScope === null || ancestorScope === void 0 ? void 0 : ancestorScope.start) !== (selectedVariableScope === null || selectedVariableScope === void 0 ? void 0 : selectedVariableScope.start) ||\n            (ancestorScope === null || ancestorScope === void 0 ? void 0 : ancestorScope.end) !== (selectedVariableScope === null || selectedVariableScope === void 0 ? void 0 : selectedVariableScope.end)) {\n            return;\n        }\n        return vscode_languageserver_1.Range.create(textDocument.positionAt(node.position.start), textDocument.positionAt(node.position.start + oldName.length));\n    };\n}\n//# sourceMappingURL=LiquidVariableRenameProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenameHandler = void 0;\nconst AssetRenameHandler_1 = require(\"./handlers/AssetRenameHandler\");\nconst BlockRenameHandler_1 = require(\"./handlers/BlockRenameHandler\");\nconst SnippetRenameHandler_1 = require(\"./handlers/SnippetRenameHandler\");\nconst SectionRenameHandler_1 = require(\"./handlers/SectionRenameHandler\");\n/**\n * The RenameHandler is responsible for handling workspace/didRenameFiles notifications.\n *\n * Stuff we'll handle:\n * - When a snippet is renamed, then we'll change all the render calls\n * - When an asset is renamed, then we'll change the asset_url calls\n * - etc.\n */\nclass RenameHandler {\n    constructor(connection, capabilities, documentManager, findThemeRootURI) {\n        this.handlers = [\n            new SnippetRenameHandler_1.SnippetRenameHandler(documentManager, connection, capabilities, findThemeRootURI),\n            new AssetRenameHandler_1.AssetRenameHandler(documentManager, connection, capabilities, findThemeRootURI),\n            new BlockRenameHandler_1.BlockRenameHandler(documentManager, connection, capabilities, findThemeRootURI),\n            new SectionRenameHandler_1.SectionRenameHandler(documentManager, connection, capabilities, findThemeRootURI),\n        ];\n    }\n    async onDidRenameFiles(params) {\n        try {\n            const promises = this.handlers.map((handler) => handler.onDidRenameFiles(params));\n            await Promise.all(promises);\n        }\n        catch (error) {\n            console.error(error);\n            return;\n        }\n    }\n}\nexports.RenameHandler = RenameHandler;\n//# sourceMappingURL=RenameHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetRenameHandler = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst documents_1 = require(\"../../documents\");\nconst uri_1 = require(\"../../utils/uri\");\n/**\n * The AssetRenameHandler will handle asset renames.\n *\n * We'll change all the `| asset_url` that reference the old asset:\n *   {{ 'oldName.js' | asset_url }} -> {{ 'newName.js' | asset_url }}\n *\n * We'll do that for `.(css|js).liquid` files as well\n *\n * We'll do this by visiting all the liquid files in the theme and looking for\n * string | asset_url Variable nodes that reference the old asset. We'll then create a\n * WorkspaceEdit that changes the references to the new asset.\n */\nclass AssetRenameHandler {\n    constructor(documentManager, connection, capabilities, findThemeRootURI) {\n        this.documentManager = documentManager;\n        this.connection = connection;\n        this.capabilities = capabilities;\n        this.findThemeRootURI = findThemeRootURI;\n    }\n    async onDidRenameFiles(params) {\n        var _a;\n        if (!this.capabilities.hasApplyEditSupport)\n            return;\n        const relevantRenames = params.files.filter((file) => (0, uri_1.isAsset)(file.oldUri) && (0, uri_1.isAsset)(file.newUri));\n        // Only preload if you have something to do (folder renames are not supported)\n        if (relevantRenames.length !== 1)\n            return;\n        const rename = relevantRenames[0];\n        const rootUri = await this.findThemeRootURI(theme_check_common_1.path.dirname(params.files[0].oldUri));\n        await this.documentManager.preload(rootUri);\n        const theme = this.documentManager.theme(rootUri, true);\n        const liquidSourceCodes = theme.filter(documents_1.isLiquidSourceCode);\n        const oldAssetName = (0, uri_1.assetName)(rename.oldUri);\n        const newAssetName = (0, uri_1.assetName)(rename.newUri);\n        const editLabel = `Rename asset '${oldAssetName}' to '${newAssetName}'`;\n        const annotationId = 'renameAsset';\n        const workspaceEdit = {\n            documentChanges: [],\n            changeAnnotations: {\n                [annotationId]: {\n                    label: editLabel,\n                    needsConfirmation: false,\n                },\n            },\n        };\n        for (const sourceCode of liquidSourceCodes) {\n            if (sourceCode.ast instanceof Error)\n                continue;\n            const textDocument = sourceCode.textDocument;\n            const edits = (0, theme_check_common_1.visit)(sourceCode.ast, {\n                LiquidVariable(node) {\n                    if (node.filters.length === 0)\n                        return;\n                    if (node.expression.type !== liquid_html_parser_1.NodeTypes.String)\n                        return;\n                    if (node.filters[0].name !== 'asset_url')\n                        return;\n                    const assetName = node.expression.value;\n                    if (assetName !== oldAssetName)\n                        return;\n                    return {\n                        newText: newAssetName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(node.expression.position.start + 1), // +1 to skip the opening quote\n                        textDocument.positionAt(node.expression.position.end - 1)),\n                    };\n                },\n            });\n            if (edits.length === 0)\n                continue;\n            workspaceEdit.documentChanges.push({\n                textDocument: {\n                    uri: textDocument.uri,\n                    version: (_a = sourceCode.version) !== null && _a !== void 0 ? _a : null /* null means file from disk in this API */,\n                },\n                annotationId,\n                edits,\n            });\n        }\n        if (workspaceEdit.documentChanges.length === 0) {\n            console.error('Nothing to do!');\n            return;\n        }\n        await this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, {\n            label: editLabel,\n            edit: workspaceEdit,\n        });\n    }\n}\nexports.AssetRenameHandler = AssetRenameHandler;\n//# sourceMappingURL=AssetRenameHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockRenameHandler = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst documents_1 = require(\"../../documents\");\nconst uri_1 = require(\"../../utils/uri\");\nconst utils_1 = require(\"./utils\");\nconst annotationId = 'renameBlock';\n/**\n * The BlockRenameHandler will handle block renames.\n *\n * Whenever a block gets renamed, a lot of things need to happen:\n *   1. References in files with a {% schema %} must be changed\n *   2. References in template files must be changed\n *   3. References in section groups must be changed\n *   4. References in {% content_for \"block\", type: \"oldName\" %} must be changed\n *\n * Things we're not doing:\n *   5. If isPublic(oldName) && isPrivate(newName) && \"schema.blocks\" accepts \"@theme\",\n *      Then the block should be added to the \"blocks\" array\n *\n *    Reasoning: this is more noisy than useful. a now-private block\n *      could be used by a preset, template or section group. Doing a\n *      toil-free rename would require visiting all preset, templates and\n *      section groups to see if a parent that uses the new block name\n *      was supporting \"@theme\" blocks. It's a lot. It's O(S*(S+T+SG)) where\n *      S is the number of sections, T is the number of templates and SG is the\n *      number of section groups. It's not worth it.\n *\n *      This stuff is complicated enough as it is .\n */\nclass BlockRenameHandler {\n    constructor(documentManager, connection, capabilities, findThemeRootURI) {\n        this.documentManager = documentManager;\n        this.connection = connection;\n        this.capabilities = capabilities;\n        this.findThemeRootURI = findThemeRootURI;\n    }\n    async onDidRenameFiles(params) {\n        if (!this.capabilities.hasApplyEditSupport)\n            return;\n        const relevantRenames = params.files.filter((file) => (0, uri_1.isBlock)(file.oldUri) && (0, uri_1.isBlock)(file.newUri));\n        // Only preload if you have something to do (folder renames not supported yet).\n        if (relevantRenames.length !== 1)\n            return;\n        const rename = relevantRenames[0];\n        const rootUri = await this.findThemeRootURI(theme_check_common_1.path.dirname(params.files[0].oldUri));\n        await this.documentManager.preload(rootUri);\n        const theme = this.documentManager.theme(rootUri, true);\n        const liquidFiles = theme.filter(documents_1.isLiquidSourceCode);\n        const sectionsAndBlocks = liquidFiles.filter((file) => (0, uri_1.isBlock)(file.uri) || (0, uri_1.isSection)(file.uri));\n        const templates = theme.filter(documents_1.isJsonSourceCode).filter((file) => (0, uri_1.isTemplate)(file.uri));\n        const sectionGroups = theme.filter(documents_1.isJsonSourceCode).filter((file) => (0, uri_1.isSectionGroup)(file.uri));\n        const oldBlockName = (0, uri_1.blockName)(rename.oldUri);\n        const newBlockName = (0, uri_1.blockName)(rename.newUri);\n        const editLabel = `Rename block '${oldBlockName}' to '${newBlockName}'`;\n        const workspaceEdit = {\n            documentChanges: [],\n            changeAnnotations: {\n                [annotationId]: {\n                    label: editLabel,\n                    needsConfirmation: false,\n                },\n            },\n        };\n        // We need to keep track of sections that have local blocks, because we\n        // shouldn't rename those. Only uses of \"@theme\" or specifically named blocks\n        // should be renamed when the blocks/*.liquid file is renamed.\n        const sectionsWithLocalBlocks = new Set();\n        const sectionAndBlocksChanges = await Promise.all(sectionsAndBlocks.map(this.getSchemaChanges(sectionsWithLocalBlocks, oldBlockName, newBlockName)));\n        // All the templates/*.json files need to be updated with the new block name\n        // when the old block name wasn't a local block.\n        const [templateChanges, sectionGroupChanges, contentForChanges] = await Promise.all([\n            Promise.all(templates.map(this.getTemplateChanges(oldBlockName, newBlockName, sectionsWithLocalBlocks))),\n            Promise.all(sectionGroups.map(this.getSectionGroupChanges(oldBlockName, newBlockName, sectionsWithLocalBlocks))),\n            Promise.all(liquidFiles.map(this.getContentForChanges(oldBlockName, newBlockName))),\n        ]);\n        for (const docChange of [\n            ...sectionAndBlocksChanges,\n            ...templateChanges,\n            ...sectionGroupChanges,\n        ]) {\n            if (docChange !== null) {\n                workspaceEdit.documentChanges.push(docChange);\n            }\n        }\n        // Because contentForChanges could make a change to an existing document, we need\n        // to group the edits together by document. Or else we might have index\n        // drifting issues.\n        for (const docChange of contentForChanges) {\n            if (docChange !== null) {\n                const existingDocChange = workspaceEdit.documentChanges.find((dc) => dc.textDocument.uri === (docChange === null || docChange === void 0 ? void 0 : docChange.textDocument.uri));\n                if (existingDocChange) {\n                    existingDocChange.edits.push(...docChange.edits);\n                }\n                else {\n                    workspaceEdit.documentChanges.push(docChange);\n                }\n            }\n        }\n        if (workspaceEdit.documentChanges.length === 0) {\n            console.error('Nothing to do!');\n            return;\n        }\n        await this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, {\n            label: editLabel,\n            edit: workspaceEdit,\n        });\n    }\n    getSchemaChanges(sectionsWithLocalBlocks, oldBlockName, newBlockName) {\n        return async (sourceCode) => {\n            if (sourceCode.ast instanceof Error)\n                return null;\n            const textDocument = sourceCode.textDocument;\n            const schema = await sourceCode.getSchema();\n            if (!(0, theme_check_common_1.isBlockSchema)(schema) && !(0, theme_check_common_1.isSectionSchema)(schema))\n                return null;\n            if ((0, theme_check_common_1.isError)(schema.validSchema) || (0, theme_check_common_1.isError)(schema.ast))\n                return null;\n            const { validSchema, ast, offset } = schema;\n            const edits = [];\n            if (validSchema.blocks) {\n                for (let i = 0; i < validSchema.blocks.length; i++) {\n                    const blockDef = validSchema.blocks[i];\n                    if (isLocalBlock(blockDef)) {\n                        // If the section has a local blocks, we shouldn't rename\n                        // anything in this file.\n                        if ((0, theme_check_common_1.isSectionSchema)(schema)) {\n                            sectionsWithLocalBlocks.add(schema.name);\n                        }\n                        return null;\n                    }\n                    if (blockDef.type !== oldBlockName)\n                        continue;\n                    const node = (0, theme_check_common_1.nodeAtPath)(ast, ['blocks', i, 'type']);\n                    edits.push({\n                        annotationId,\n                        newText: newBlockName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(offset + node.loc.start.offset + 1), textDocument.positionAt(offset + node.loc.end.offset - 1)),\n                    });\n                }\n            }\n            const presetEdits = (presetBlock, path) => {\n                if (!presetBlock || !('blocks' in presetBlock))\n                    return [];\n                if (Array.isArray(presetBlock.blocks)) {\n                    return presetBlock.blocks.flatMap((block, index) => {\n                        const edits = presetEdits(block, [...path, 'blocks', index]);\n                        if (block.type === oldBlockName) {\n                            const node = (0, theme_check_common_1.nodeAtPath)(ast, [...path, 'blocks', index, 'type']);\n                            edits.push({\n                                annotationId,\n                                newText: newBlockName,\n                                range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(offset + node.loc.start.offset + 1), textDocument.positionAt(offset + node.loc.end.offset - 1)),\n                            });\n                        }\n                        return edits;\n                    });\n                }\n                else if (typeof presetBlock.blocks === 'object') {\n                    return Object.entries(presetBlock.blocks).flatMap(([key, block]) => {\n                        const edits = presetEdits(block, [...path, 'blocks', key]);\n                        if (block.type === oldBlockName) {\n                            const node = (0, theme_check_common_1.nodeAtPath)(ast, [...path, 'blocks', key, 'type']);\n                            edits.push({\n                                annotationId,\n                                newText: newBlockName,\n                                range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(offset + node.loc.start.offset + 1), textDocument.positionAt(offset + node.loc.end.offset - 1)),\n                            });\n                        }\n                        return edits;\n                    });\n                }\n                else {\n                    return [];\n                }\n            };\n            if (validSchema.presets) {\n                edits.push(...validSchema.presets.flatMap((preset, i) => presetEdits(preset, ['presets', i])));\n            }\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n    getTemplateChanges(oldBlockName, newBlockName, sectionsWithLocalBlocks) {\n        return async (sourceCode) => {\n            // assuming that the JSON is valid...\n            const { textDocument, ast, source } = sourceCode;\n            const parsed = (0, theme_check_common_1.parseJSON)(source);\n            if (!parsed || (0, theme_check_common_1.isError)(parsed) || (0, theme_check_common_1.isError)(ast))\n                return null;\n            const getBlocksEdits = getBlocksEditsFactory(oldBlockName, newBlockName, textDocument, ast);\n            const edits = !(0, utils_1.isValidTemplate)(parsed)\n                ? []\n                : Object.entries(parsed.sections).flatMap(([key, section]) => {\n                    if ('blocks' in section &&\n                        !!section.blocks &&\n                        !sectionsWithLocalBlocks.has(section.type) // don't rename local blocks\n                    ) {\n                        return getBlocksEdits(section.blocks, ['sections', key, 'blocks']);\n                    }\n                    else {\n                        return [];\n                    }\n                });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n    getSectionGroupChanges(oldBlockName, newBlockName, sectionsWithLocalBlocks) {\n        return async (sourceCode) => {\n            const { textDocument, ast, source } = sourceCode;\n            const parsed = (0, theme_check_common_1.parseJSON)(source);\n            if (!parsed || (0, theme_check_common_1.isError)(parsed) || (0, theme_check_common_1.isError)(ast))\n                return null;\n            const getBlocksEdits = getBlocksEditsFactory(oldBlockName, newBlockName, textDocument, ast);\n            const edits = !(0, utils_1.isValidSectionGroup)(parsed)\n                ? []\n                : Object.entries(parsed.sections).flatMap(([key, section]) => {\n                    if ('blocks' in section &&\n                        !!section.blocks &&\n                        !sectionsWithLocalBlocks.has(section.type) // don't rename local blocks\n                    ) {\n                        return getBlocksEdits(section.blocks, ['sections', key, 'blocks']);\n                    }\n                    else {\n                        return [];\n                    }\n                });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n    getContentForChanges(oldBlockName, newBlockName) {\n        return async (sourceCode) => {\n            const { textDocument, ast } = sourceCode;\n            if ((0, theme_check_common_1.isError)(ast))\n                return null;\n            const edits = (0, theme_check_common_1.visit)(ast, {\n                LiquidTag(node) {\n                    if (node.name !== 'content_for')\n                        return;\n                    if (typeof node.markup === 'string')\n                        return;\n                    if (node.markup.contentForType.value !== 'block')\n                        return;\n                    const typeNode = node.markup.args.find((arg) => arg.name === 'type');\n                    if (!typeNode ||\n                        typeNode.value.type !== liquid_html_parser_1.NodeTypes.String ||\n                        typeNode.value.value !== oldBlockName) {\n                        return;\n                    }\n                    return {\n                        annotationId,\n                        newText: newBlockName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(typeNode.value.position.start + 1), textDocument.positionAt(typeNode.value.position.end - 1)),\n                    };\n                },\n            });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n}\nexports.BlockRenameHandler = BlockRenameHandler;\nfunction isLocalBlock(blockDef) {\n    return 'name' in blockDef && typeof blockDef.name === 'string';\n}\nfunction getBlocksEditsFactory(oldBlockName, newBlockName, textDocument, ast) {\n    return function getBlocksEdits(blocks, path) {\n        if (!blocks)\n            return [];\n        return Object.entries(blocks).flatMap(([key, block]) => {\n            const edits = getBlocksEdits(block.blocks, [...path, key, 'blocks']);\n            if (block.type === oldBlockName) {\n                const node = (0, theme_check_common_1.nodeAtPath)(ast, [...path, key, 'type']);\n                edits.push({\n                    annotationId,\n                    newText: newBlockName,\n                    range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(node.loc.start.offset + 1), textDocument.positionAt(node.loc.end.offset - 1)),\n                });\n            }\n            return edits;\n        });\n    };\n}\nfunction documentChanges(sourceCode, edits) {\n    var _a;\n    return {\n        textDocument: {\n            uri: sourceCode.uri,\n            version: (_a = sourceCode.version) !== null && _a !== void 0 ? _a : null /* null means file from disk in this API */,\n        },\n        edits,\n    };\n}\n//# sourceMappingURL=BlockRenameHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SectionRenameHandler = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst documents_1 = require(\"../../documents\");\nconst uri_1 = require(\"../../utils/uri\");\nconst utils_1 = require(\"./utils\");\nconst annotationId = 'renameSection';\n/**\n * The SectionRenameHandler will handle section renames\n *\n * Whenever a section gets renamed, a lot of things need to happen:\n *   2. References in template files must be changed\n *   3. References in section groups must be changed\n *   4. References like {% section \"oldName\" %} must be changed\n */\nclass SectionRenameHandler {\n    constructor(documentManager, connection, capabilities, findThemeRootURI) {\n        this.documentManager = documentManager;\n        this.connection = connection;\n        this.capabilities = capabilities;\n        this.findThemeRootURI = findThemeRootURI;\n    }\n    async onDidRenameFiles(params) {\n        if (!this.capabilities.hasApplyEditSupport)\n            return;\n        const relevantRenames = params.files.filter((file) => (0, uri_1.isSection)(file.oldUri) && (0, uri_1.isSection)(file.newUri));\n        // Only preload if you have something to do (folder renames not supported yet).\n        if (relevantRenames.length !== 1)\n            return;\n        const rename = relevantRenames[0];\n        const rootUri = await this.findThemeRootURI(theme_check_common_1.path.dirname(params.files[0].oldUri));\n        await this.documentManager.preload(rootUri);\n        const theme = this.documentManager.theme(rootUri, true);\n        const liquidFiles = theme.filter(documents_1.isLiquidSourceCode);\n        const templates = theme.filter(documents_1.isJsonSourceCode).filter((file) => (0, uri_1.isTemplate)(file.uri));\n        const sectionGroups = theme.filter(documents_1.isJsonSourceCode).filter((file) => (0, uri_1.isSectionGroup)(file.uri));\n        const oldSectionName = (0, uri_1.sectionName)(rename.oldUri);\n        const newSectionName = (0, uri_1.sectionName)(rename.newUri);\n        const editLabel = `Rename section '${oldSectionName}' to '${newSectionName}'`;\n        const workspaceEdit = {\n            documentChanges: [],\n            changeAnnotations: {\n                [annotationId]: {\n                    label: editLabel,\n                    needsConfirmation: false,\n                },\n            },\n        };\n        // All the templates/*.json files need to be updated with the new block name\n        // when the old block name wasn't a local block.\n        const [templateChanges, sectionGroupChanges, sectionTagChanges] = await Promise.all([\n            Promise.all(templates.map(this.getTemplateChanges(oldSectionName, newSectionName))),\n            Promise.all(sectionGroups.map(this.getSectionGroupChanges(oldSectionName, newSectionName))),\n            Promise.all(liquidFiles.map(this.getSectionTagChanges(oldSectionName, newSectionName))),\n        ]);\n        for (const docChange of [...templateChanges, ...sectionGroupChanges]) {\n            if (docChange !== null) {\n                workspaceEdit.documentChanges.push(docChange);\n            }\n        }\n        // Because section tag changes could make a change to an existing document,\n        // we need to group the edits together by document. Or else we might have\n        // index drifting issues.\n        for (const docChange of sectionTagChanges) {\n            if (docChange !== null) {\n                const existingDocChange = workspaceEdit.documentChanges.find((dc) => dc.textDocument.uri === (docChange === null || docChange === void 0 ? void 0 : docChange.textDocument.uri));\n                if (existingDocChange) {\n                    existingDocChange.edits.push(...docChange.edits);\n                }\n                else {\n                    workspaceEdit.documentChanges.push(docChange);\n                }\n            }\n        }\n        if (workspaceEdit.documentChanges.length === 0) {\n            console.error('Nothing to do!');\n            return;\n        }\n        await this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, {\n            label: editLabel,\n            edit: workspaceEdit,\n        });\n    }\n    getTemplateChanges(oldSectionName, newSectionName) {\n        return async (sourceCode) => {\n            const { textDocument, ast, source } = sourceCode;\n            const parsed = (0, theme_check_common_1.parseJSON)(source);\n            if (!parsed || (0, theme_check_common_1.isError)(parsed) || (0, theme_check_common_1.isError)(ast))\n                return null;\n            const edits = !(0, utils_1.isValidTemplate)(parsed)\n                ? []\n                : Object.entries(parsed.sections)\n                    .filter(([_key, section]) => section.type === oldSectionName)\n                    .map(([key]) => {\n                    const node = (0, theme_check_common_1.nodeAtPath)(ast, ['sections', key, 'type']);\n                    return {\n                        annotationId,\n                        newText: newSectionName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(node.loc.start.offset + 1), textDocument.positionAt(node.loc.end.offset - 1)),\n                    };\n                });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n    // Awfully similar except for the isValidSectionGroup check and the types of the objects.\n    // Feels like a coincidence that the types are so similar. I'm not sure this should be DRY'd up.\n    getSectionGroupChanges(oldSectionName, newSectionName) {\n        return async (sourceCode) => {\n            const { textDocument, ast, source } = sourceCode;\n            const parsed = (0, theme_check_common_1.parseJSON)(source);\n            if (!parsed || (0, theme_check_common_1.isError)(parsed) || (0, theme_check_common_1.isError)(ast))\n                return null;\n            const edits = !(0, utils_1.isValidSectionGroup)(parsed)\n                ? []\n                : Object.entries(parsed.sections)\n                    .filter(([_key, section]) => section.type === oldSectionName)\n                    .map(([key]) => {\n                    const node = (0, theme_check_common_1.nodeAtPath)(ast, ['sections', key, 'type']);\n                    return {\n                        annotationId,\n                        newText: newSectionName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(node.loc.start.offset + 1), textDocument.positionAt(node.loc.end.offset - 1)),\n                    };\n                });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n    getSectionTagChanges(oldSectionName, newSectionName) {\n        return async (sourceCode) => {\n            const { textDocument, ast } = sourceCode;\n            if ((0, theme_check_common_1.isError)(ast))\n                return null;\n            const edits = (0, theme_check_common_1.visit)(ast, {\n                LiquidTag(node) {\n                    if (node.name !== 'section')\n                        return;\n                    if (typeof node.markup === 'string')\n                        return;\n                    // Note the type assertion to the LHS of the expression.\n                    // The type assertions above are enough for this to be true.\n                    // But I'm making the explicit annotation here to make it clear.\n                    const typeNode = node.markup;\n                    if (typeNode.value !== oldSectionName)\n                        return;\n                    return {\n                        annotationId,\n                        newText: newSectionName,\n                        range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(typeNode.position.start + 1), textDocument.positionAt(typeNode.position.end - 1)),\n                    };\n                },\n            });\n            if (edits.length === 0)\n                return null;\n            return documentChanges(sourceCode, edits);\n        };\n    }\n}\nexports.SectionRenameHandler = SectionRenameHandler;\nfunction documentChanges(sourceCode, edits) {\n    var _a;\n    return {\n        textDocument: {\n            uri: sourceCode.uri,\n            version: (_a = sourceCode.version) !== null && _a !== void 0 ? _a : null /* null means file from disk in this API */,\n        },\n        edits,\n    };\n}\n//# sourceMappingURL=SectionRenameHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SnippetRenameHandler = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst documents_1 = require(\"../../documents\");\nconst uri_1 = require(\"../../utils/uri\");\n/**\n * The SnippetRenameHandler will handle snippet renames.\n *\n * We'll change all the render and include tags that reference the old snippet\n * to reference the new snippet.\n *\n *   {% render 'oldName' %} -> {% render 'newName' %}\n *\n * We'll do this by visiting all the liquid files in the theme and looking for\n * render and include tags that reference the old snippet. We'll then create a\n * WorkspaceEdit that changes the references to the new snippet.\n */\nclass SnippetRenameHandler {\n    constructor(documentManager, connection, capabilities, findThemeRootURI) {\n        this.documentManager = documentManager;\n        this.connection = connection;\n        this.capabilities = capabilities;\n        this.findThemeRootURI = findThemeRootURI;\n    }\n    async onDidRenameFiles(params) {\n        var _a;\n        if (!this.capabilities.hasApplyEditSupport)\n            return;\n        const relevantRenames = params.files.filter((file) => (0, uri_1.isSnippet)(file.oldUri) && (0, uri_1.isSnippet)(file.newUri));\n        // Only preload if you have something to do (folder renames are not supported)\n        if (relevantRenames.length !== 1)\n            return;\n        const rename = relevantRenames[0];\n        const rootUri = await this.findThemeRootURI(theme_check_common_1.path.dirname(params.files[0].oldUri));\n        await this.documentManager.preload(rootUri);\n        const theme = this.documentManager.theme(rootUri, true);\n        const liquidSourceCodes = theme.filter(documents_1.isLiquidSourceCode);\n        const oldSnippetName = (0, uri_1.snippetName)(rename.oldUri);\n        const newSnippetName = (0, uri_1.snippetName)(rename.newUri);\n        const editLabel = `Rename snippet '${oldSnippetName}' to '${newSnippetName}'`;\n        const annotationId = 'renameSnippet';\n        const workspaceEdit = {\n            documentChanges: [],\n            changeAnnotations: {\n                [annotationId]: {\n                    label: editLabel,\n                    needsConfirmation: false,\n                },\n            },\n        };\n        for (const sourceCode of liquidSourceCodes) {\n            if (sourceCode.ast instanceof Error)\n                continue;\n            const textDocument = sourceCode.textDocument;\n            const edits = (0, theme_check_common_1.visit)(sourceCode.ast, {\n                LiquidTag(node) {\n                    if (node.name !== liquid_html_parser_1.NamedTags.render && node.name !== liquid_html_parser_1.NamedTags.include) {\n                        return;\n                    }\n                    if (typeof node.markup === 'string') {\n                        return;\n                    }\n                    const snippet = node.markup.snippet;\n                    if (snippet.type === liquid_html_parser_1.NodeTypes.String && snippet.value === oldSnippetName) {\n                        return {\n                            newText: `${newSnippetName}`,\n                            range: vscode_languageserver_protocol_1.Range.create(textDocument.positionAt(snippet.position.start + 1), // +1 to skip the opening quote\n                            textDocument.positionAt(snippet.position.end - 1)),\n                        };\n                    }\n                },\n            });\n            if (edits.length === 0)\n                continue;\n            workspaceEdit.documentChanges.push({\n                textDocument: {\n                    uri: textDocument.uri,\n                    version: (_a = sourceCode.version) !== null && _a !== void 0 ? _a : null /* null means file from disk in this API */,\n                },\n                annotationId,\n                edits,\n            });\n        }\n        if (workspaceEdit.documentChanges.length === 0) {\n            console.error('Nothing to do!');\n            return;\n        }\n        await this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, {\n            label: editLabel,\n            edit: workspaceEdit,\n        });\n    }\n}\nexports.SnippetRenameHandler = SnippetRenameHandler;\n//# sourceMappingURL=SnippetRenameHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidSectionGroup = exports.isValidTemplate = void 0;\n// this is very very optimistic...\nfunction isValidTemplate(parsed) {\n    return (typeof parsed === 'object' &&\n        parsed !== null &&\n        'sections' in parsed &&\n        'order' in parsed &&\n        Array.isArray(parsed.order));\n}\nexports.isValidTemplate = isValidTemplate;\nfunction isValidSectionGroup(parsed) {\n    return (typeof parsed === 'object' &&\n        parsed !== null &&\n        'sections' in parsed &&\n        'order' in parsed &&\n        Array.isArray(parsed.order));\n}\nexports.isValidSectionGroup = isValidSectionGroup;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CachedFileSystem = void 0;\nclass CachedFileSystem {\n    constructor(fs) {\n        this.readFile = cachedByUri(fs.readFile.bind(fs));\n        this.readDirectory = cachedByUri(fs.readDirectory.bind(fs));\n        this.stat = cachedByUri(fs.stat.bind(fs));\n    }\n}\nexports.CachedFileSystem = CachedFileSystem;\nfunction cachedByUri(fn) {\n    const cache = new Map();\n    function cached(uri) {\n        if (!cache.has(uri)) {\n            // I'm intentionally leaving this comment here for debugging purposes :)\n            // console.error('cache miss', fn.name, uri);\n            cache.set(uri, fn(uri));\n        }\n        return cache.get(uri);\n    }\n    cached.invalidate = (uri) => {\n        // I'm intentionally leaving this comment here for debugging purposes :)\n        // console.error('cache invalidate', fn.name, uri);\n        cache.delete(uri);\n    };\n    return cached;\n}\n//# sourceMappingURL=CachedFileSystem.js.map","\"use strict\";\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Configuration = exports.ConfigurationKeys = exports.PRELOAD_ON_BOOT = exports.CHECK_ON_CHANGE = exports.CHECK_ON_SAVE = exports.CHECK_ON_OPEN = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nexports.CHECK_ON_OPEN = 'themeCheck.checkOnOpen';\nexports.CHECK_ON_SAVE = 'themeCheck.checkOnSave';\nexports.CHECK_ON_CHANGE = 'themeCheck.checkOnChange';\nexports.PRELOAD_ON_BOOT = 'themeCheck.preloadOnBoot';\nexports.ConfigurationKeys = [\n    exports.CHECK_ON_OPEN,\n    exports.CHECK_ON_SAVE,\n    exports.CHECK_ON_CHANGE,\n    exports.PRELOAD_ON_BOOT,\n];\nclass Configuration {\n    constructor(connection, capabilities) {\n        this.connection = connection;\n        this.capabilities = capabilities;\n        this[_a] = true;\n        this[_b] = true;\n        this[_c] = true;\n        this[_d] = true;\n        this.fetchConfiguration = (0, theme_check_common_1.memo)(async () => {\n            if (!this.capabilities.hasWorkspaceConfigurationSupport)\n                return;\n            const configs = await this.connection.workspace.getConfiguration(exports.ConfigurationKeys.map((key) => ({ section: key })));\n            for (let i = 0; i < exports.ConfigurationKeys.length; i++) {\n                const key = exports.ConfigurationKeys[i];\n                if (configs[i] !== null) {\n                    this[key] = configs[i];\n                }\n            }\n        });\n        this.registerDidChangeCapability = (0, theme_check_common_1.memo)(async () => {\n            if (!this.capabilities.hasDidChangeConfigurationDynamicRegistrationSupport)\n                return;\n            return this.connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type);\n        });\n        this.registerDidChangeWatchedFilesNotification = async (options) => {\n            if (!this.capabilities.hasDidChangeWatchedFilesDynamicRegistrationSupport)\n                return;\n            return this.connection.client.register(vscode_languageserver_1.DidChangeWatchedFilesNotification.type, options);\n        };\n        this.connection = connection;\n        this.capabilities = capabilities;\n    }\n    setup() {\n        this[exports.CHECK_ON_OPEN] = this.capabilities.initializationOption(exports.CHECK_ON_OPEN, true);\n        this[exports.CHECK_ON_SAVE] = this.capabilities.initializationOption(exports.CHECK_ON_SAVE, true);\n        this[exports.CHECK_ON_CHANGE] = this.capabilities.initializationOption(exports.CHECK_ON_CHANGE, true);\n        this[exports.PRELOAD_ON_BOOT] = this.capabilities.initializationOption(exports.PRELOAD_ON_BOOT, true);\n    }\n    async shouldCheckOnOpen() {\n        await this.fetchConfiguration();\n        return this[exports.CHECK_ON_OPEN];\n    }\n    async shouldCheckOnSave() {\n        await this.fetchConfiguration();\n        return this[exports.CHECK_ON_SAVE];\n    }\n    async shouldCheckOnChange() {\n        await this.fetchConfiguration();\n        return this[exports.CHECK_ON_CHANGE];\n    }\n    async shouldPreloadOnBoot() {\n        await this.fetchConfiguration();\n        return this[exports.PRELOAD_ON_BOOT];\n    }\n    clearCache() {\n        this.fetchConfiguration.clearCache();\n    }\n}\nexports.Configuration = Configuration;\n_a = exports.CHECK_ON_OPEN, _b = exports.CHECK_ON_SAVE, _c = exports.CHECK_ON_CHANGE, _d = exports.PRELOAD_ON_BOOT;\n//# sourceMappingURL=Configuration.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.startServer = void 0;\nvar startServer_1 = require(\"./startServer\");\nObject.defineProperty(exports, \"startServer\", { enumerable: true, get: function () { return startServer_1.startServer; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.safe = void 0;\n/**\n * This function wraps a function that might throw an error and handles it by\n * returning the default value instead.\n *\n * There are cases, such as fs.readDirectory, that might throw an error if the\n * directory doesn't exist. Since there _is_ a difference between a directory that\n * doesn't exist and a directory that is empty, we don't want to change the API\n * of fs.readDirectory either.\n *\n * In such cases, we can use this helper to wrap the function and gracefully handle\n * the error by returning a default value instead.\n *\n * @param fn\n * @param defaultReturnValue\n *\n * @example\n * const getThemeBlockNames = safe(async function () { ... }, []);\n */\nconst safe = (fn, defaultReturnValue) => {\n    return async function safeFn(...args) {\n        try {\n            return await fn(...args);\n        }\n        catch (error) {\n            return defaultReturnValue;\n        }\n    };\n};\nexports.safe = safe;\n//# sourceMappingURL=safe.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.startServer = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst ClientCapabilities_1 = require(\"../ClientCapabilities\");\nconst codeActions_1 = require(\"../codeActions\");\nconst commands_1 = require(\"../commands\");\nconst completions_1 = require(\"../completions\");\nconst diagnostics_1 = require(\"../diagnostics\");\nconst DocumentHighlightsProvider_1 = require(\"../documentHighlights/DocumentHighlightsProvider\");\nconst documentLinks_1 = require(\"../documentLinks\");\nconst documents_1 = require(\"../documents\");\nconst formatting_1 = require(\"../formatting\");\nconst hover_1 = require(\"../hover\");\nconst JSONLanguageService_1 = require(\"../json/JSONLanguageService\");\nconst LinkedEditingRangesProvider_1 = require(\"../linkedEditingRanges/LinkedEditingRangesProvider\");\nconst RenameProvider_1 = require(\"../rename/RenameProvider\");\nconst RenameHandler_1 = require(\"../renamed/RenameHandler\");\nconst utils_1 = require(\"../utils\");\nconst uri_1 = require(\"../utils/uri\");\nconst version_1 = require(\"../version\");\nconst CachedFileSystem_1 = require(\"./CachedFileSystem\");\nconst Configuration_1 = require(\"./Configuration\");\nconst safe_1 = require(\"./safe\");\nconst defaultLogger = () => { };\n/**\n * The `git:` VFS does not support the `fs.readDirectory` call and makes most things break.\n * `git` URIs are the ones you'd encounter when doing a git diff in VS Code. They're not\n * real files, they're just a way to represent changes in a git repository. As such, I don't\n * think we want to sync those in our document manager or try to offer document links, etc.\n *\n * A middleware would be nice but it'd be a bit of a pain to implement.\n */\nconst hasUnsupportedDocument = (params) => {\n    return ('textDocument' in params &&\n        'uri' in params.textDocument &&\n        typeof params.textDocument.uri === 'string' &&\n        params.textDocument.uri.startsWith('git:'));\n};\n/**\n * This code runs in node and the browser, it can't talk to the file system\n * or make requests. Stuff like that should be injected.\n *\n * In browser, theme-check-js wants these things:\n *   - fileExists(path)\n *   - defaultTranslations\n *\n * Which means we gotta provide 'em from here too!\n */\nfunction startServer(connection, { fs: injectedFs, loadConfig, log = defaultLogger, jsonValidationSet, themeDocset: remoteThemeDocset, fetchMetafieldDefinitionsForURI, }) {\n    const fs = new CachedFileSystem_1.CachedFileSystem(injectedFs);\n    const fileExists = (0, theme_check_common_1.makeFileExists)(fs);\n    const clientCapabilities = new ClientCapabilities_1.ClientCapabilities();\n    const configuration = new Configuration_1.Configuration(connection, clientCapabilities);\n    const documentManager = new documents_1.DocumentManager(fs, connection, clientCapabilities, getModeForURI, isValidSchema);\n    const diagnosticsManager = new diagnostics_1.DiagnosticsManager(connection);\n    const documentLinksProvider = new documentLinks_1.DocumentLinksProvider(documentManager, findThemeRootURI);\n    const codeActionsProvider = new codeActions_1.CodeActionsProvider(documentManager, diagnosticsManager);\n    const onTypeFormattingProvider = new formatting_1.OnTypeFormattingProvider(documentManager, async function setCursorPosition(textDocument, position) {\n        if (!clientCapabilities.hasShowDocumentSupport)\n            return;\n        connection.sendRequest(vscode_languageserver_1.ShowDocumentRequest.type, {\n            uri: textDocument.uri,\n            takeFocus: true,\n            selection: {\n                start: position,\n                end: position,\n            },\n        });\n    });\n    const linkedEditingRangesProvider = new LinkedEditingRangesProvider_1.LinkedEditingRangesProvider(documentManager);\n    const documentHighlightProvider = new DocumentHighlightsProvider_1.DocumentHighlightsProvider(documentManager);\n    const renameProvider = new RenameProvider_1.RenameProvider(documentManager);\n    const renameHandler = new RenameHandler_1.RenameHandler(connection, clientCapabilities, documentManager, findThemeRootURI);\n    async function findThemeRootURI(uri) {\n        const rootUri = await (0, theme_check_common_1.findRoot)(uri, fileExists);\n        const config = await loadConfig(rootUri, fs);\n        return config.rootUri;\n    }\n    const getMetafieldDefinitionsForRootUri = (0, theme_check_common_1.memoize)((0, theme_check_common_1.makeGetMetafieldDefinitions)(fs), (rootUri) => rootUri);\n    const getMetafieldDefinitions = async (uri) => {\n        const rootUri = await findThemeRootURI(uri);\n        return getMetafieldDefinitionsForRootUri(rootUri);\n    };\n    // These are augmented here so that the caching is maintained over different runs.\n    const themeDocset = new theme_check_common_1.AugmentedThemeDocset(remoteThemeDocset);\n    const runChecks = (0, utils_1.debounce)((0, diagnostics_1.makeRunChecks)(documentManager, diagnosticsManager, {\n        fs,\n        loadConfig,\n        themeDocset,\n        jsonValidationSet,\n        getMetafieldDefinitions,\n    }), 100);\n    const getTranslationsForURI = async (uri) => {\n        const rootURI = await findThemeRootURI(uri);\n        const theme = documentManager.theme(rootURI);\n        const getDefaultTranslations = (0, theme_check_common_1.makeGetDefaultTranslations)(fs, theme, rootURI);\n        const [defaultTranslations, shopifyTranslations] = await Promise.all([\n            getDefaultTranslations(),\n            themeDocset.systemTranslations(),\n        ]);\n        return { ...shopifyTranslations, ...defaultTranslations };\n    };\n    const getSchemaTranslationsForURI = async (uri) => {\n        const rootURI = await findThemeRootURI(uri);\n        const theme = documentManager.theme(rootURI);\n        const getDefaultSchemaTranslations = (0, theme_check_common_1.makeGetDefaultSchemaTranslations)(fs, theme, rootURI);\n        return getDefaultSchemaTranslations();\n    };\n    const getSnippetDefinitionForURI = async (uri, snippetName) => {\n        const rootUri = await findThemeRootURI(uri);\n        const snippetURI = theme_check_common_1.path.join(rootUri, 'snippets', `${snippetName}.liquid`);\n        const snippet = documentManager.get(snippetURI);\n        if (!snippet || snippet.type !== theme_check_common_1.SourceCodeType.LiquidHtml || (0, theme_check_common_1.isError)(snippet.ast)) {\n            return undefined;\n        }\n        return snippet.getLiquidDoc(snippetName);\n    };\n    const snippetFilter = ([uri]) => /\\.liquid$/.test(uri) && /snippets/.test(uri);\n    const getSnippetNamesForURI = (0, safe_1.safe)(async (uri) => {\n        const rootUri = await findThemeRootURI(uri);\n        const snippetUris = await (0, theme_check_common_1.recursiveReadDirectory)(fs, rootUri, snippetFilter);\n        return snippetUris.map(uri_1.snippetName);\n    }, []);\n    const getThemeSettingsSchemaForURI = (0, safe_1.safe)(async (uri) => {\n        const rootUri = await findThemeRootURI(uri);\n        const settingsSchemaUri = theme_check_common_1.path.join(rootUri, 'config', 'settings_schema.json');\n        const contents = await fs.readFile(settingsSchemaUri);\n        const json = (0, theme_check_common_1.parseJSON)(contents);\n        if ((0, theme_check_common_1.isError)(json) || !Array.isArray(json)) {\n            throw new Error('Settings JSON file not in correct format');\n        }\n        return json;\n    }, []);\n    async function getModeForURI(uri) {\n        const rootUri = await (0, theme_check_common_1.findRoot)(uri, fileExists);\n        const config = await loadConfig(rootUri, fs);\n        return config.context;\n    }\n    const getThemeBlockNames = (0, safe_1.safe)(async (uri, includePrivate) => {\n        const rootUri = await findThemeRootURI(uri);\n        const blocks = await fs.readDirectory(theme_check_common_1.path.join(rootUri, 'blocks'));\n        const blockNames = blocks.map(([uri]) => theme_check_common_1.path.basename(uri, '.liquid'));\n        if (includePrivate) {\n            return blockNames;\n        }\n        return blockNames.filter((blockName) => !blockName.startsWith('_'));\n    }, []);\n    async function getThemeBlockSchema(uri, name) {\n        const rootUri = await findThemeRootURI(uri);\n        const blockUri = theme_check_common_1.path.join(rootUri, 'blocks', `${name}.liquid`);\n        const doc = documentManager.get(blockUri);\n        if (!doc || doc.type !== theme_check_common_1.SourceCodeType.LiquidHtml) {\n            return;\n        }\n        return doc.getSchema();\n    }\n    // Defined as a function to solve a circular dependency (doc manager & json\n    // lang service both need each other)\n    async function isValidSchema(uri, jsonString) {\n        return jsonLanguageService.isValidSchema(uri, jsonString);\n    }\n    const jsonLanguageService = new JSONLanguageService_1.JSONLanguageService(documentManager, jsonValidationSet, getSchemaTranslationsForURI, getModeForURI, getThemeBlockNames, getThemeBlockSchema);\n    const completionsProvider = new completions_1.CompletionsProvider({\n        documentManager,\n        themeDocset,\n        getTranslationsForURI,\n        getSnippetNamesForURI,\n        getThemeSettingsSchemaForURI,\n        log,\n        getThemeBlockNames,\n        getMetafieldDefinitions,\n        getSnippetDefinitionForURI,\n    });\n    const hoverProvider = new hover_1.HoverProvider(documentManager, themeDocset, getMetafieldDefinitions, getTranslationsForURI, getThemeSettingsSchemaForURI, getSnippetDefinitionForURI);\n    const executeCommandProvider = new commands_1.ExecuteCommandProvider(documentManager, diagnosticsManager, clientCapabilities, runChecks, connection);\n    const fetchMetafieldDefinitionsForWorkspaceFolders = async (folders) => {\n        if (!fetchMetafieldDefinitionsForURI)\n            return;\n        for (let folder of folders) {\n            const mode = await getModeForURI(folder.uri);\n            if (mode === 'theme') {\n                fetchMetafieldDefinitionsForURI(folder.uri);\n            }\n        }\n    };\n    connection.onInitialize((params) => {\n        clientCapabilities.setup(params.capabilities, params.initializationOptions);\n        jsonLanguageService.setup(params.capabilities);\n        configuration.setup();\n        const fileOperationRegistrationOptions = {\n            filters: [\n                {\n                    pattern: {\n                        glob: '**/*.{liquid,json}',\n                    },\n                },\n                {\n                    pattern: {\n                        glob: '**/assets/*',\n                    },\n                },\n            ],\n        };\n        const result = {\n            capabilities: {\n                textDocumentSync: {\n                    change: vscode_languageserver_1.TextDocumentSyncKind.Full,\n                    save: true,\n                    openClose: true,\n                },\n                codeActionProvider: {\n                    codeActionKinds: [...codeActions_1.CodeActionKinds],\n                },\n                completionProvider: {\n                    triggerCharacters: ['.', '{{ ', '{% ', '<', '/', '[', '\"', \"'\", ':'],\n                },\n                documentOnTypeFormattingProvider: {\n                    firstTriggerCharacter: ' ',\n                    moreTriggerCharacter: ['{', '%', '-', '>'],\n                },\n                documentLinkProvider: {\n                    resolveProvider: false,\n                    workDoneProgress: false,\n                },\n                documentHighlightProvider: true,\n                linkedEditingRangeProvider: true,\n                renameProvider: {\n                    prepareProvider: true,\n                },\n                executeCommandProvider: {\n                    commands: [...commands_1.Commands],\n                },\n                hoverProvider: {\n                    workDoneProgress: false,\n                },\n                workspace: {\n                    workspaceFolders: {\n                        supported: true,\n                        changeNotifications: true,\n                    },\n                    fileOperations: {\n                        didRename: fileOperationRegistrationOptions,\n                    },\n                },\n            },\n            serverInfo: {\n                name: 'theme-language-server',\n                version: version_1.VERSION,\n            },\n        };\n        return result;\n    });\n    connection.onInitialized(() => {\n        log(`[SERVER] Let's roll!`);\n        configuration.fetchConfiguration();\n        configuration.registerDidChangeCapability();\n        configuration.registerDidChangeWatchedFilesNotification({\n            watchers: [\n                {\n                    globPattern: '**/.shopify/*',\n                },\n                {\n                    globPattern: '**/*.liquid',\n                },\n                {\n                    globPattern: '**/{locales,sections,templates,customers}/*.json',\n                },\n                {\n                    globPattern: '**/config/settings_{data,schema}.json',\n                },\n            ],\n        });\n        if (clientCapabilities.hasWorkspaceFoldersSupport) {\n            connection.workspace.getWorkspaceFolders().then(async (folders) => {\n                if (!folders)\n                    return;\n                fetchMetafieldDefinitionsForWorkspaceFolders(folders);\n            });\n            connection.workspace.onDidChangeWorkspaceFolders(async (params) => {\n                fetchMetafieldDefinitionsForWorkspaceFolders(params.added);\n            });\n        }\n    });\n    connection.onDidChangeConfiguration((_params) => {\n        configuration.clearCache();\n    });\n    connection.onDidOpenTextDocument(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return;\n        const { uri, text, version } = params.textDocument;\n        documentManager.open(uri, text, version);\n        if (await configuration.shouldCheckOnOpen()) {\n            runChecks([uri]);\n        }\n        // The objective at the time of writing this is to make {Asset,Snippet}Rename\n        // fast when you eventually need it.\n        //\n        // I'm choosing the textDocument/didOpen notification as a hook because\n        // I'm not sure we have a better solution than this. Yes we have the\n        // initialize request with the workspace folders, but you might have opened\n        // an app folder. The root of a theme app extension would probably be\n        // at ${workspaceRoot}/extensions/${appExtensionName}. It'd be hard to\n        // figure out from the initialize request params.\n        //\n        // If we open a file that we know is liquid, then we can kind of guarantee\n        // we'll find a theme root and we'll preload that.\n        if (await configuration.shouldPreloadOnBoot()) {\n            const rootUri = await findThemeRootURI(uri);\n            documentManager.preload(rootUri);\n        }\n    });\n    connection.onDidChangeTextDocument(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return;\n        const { uri, version } = params.textDocument;\n        documentManager.change(uri, params.contentChanges[0].text, version);\n        if (await configuration.shouldCheckOnChange()) {\n            runChecks([uri]);\n        }\n        else {\n            // The diagnostics may be stale! Clear em!\n            diagnosticsManager.clear(params.textDocument.uri);\n        }\n    });\n    connection.onDidSaveTextDocument(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return;\n        const { uri } = params.textDocument;\n        if (await configuration.shouldCheckOnSave()) {\n            runChecks([uri]);\n        }\n    });\n    connection.onDidCloseTextDocument((params) => {\n        if (hasUnsupportedDocument(params))\n            return;\n        const { uri } = params.textDocument;\n        documentManager.close(uri);\n        diagnosticsManager.clear(uri);\n    });\n    connection.onDocumentLinks(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return [];\n        return documentLinksProvider.documentLinks(params.textDocument.uri);\n    });\n    connection.onCodeAction(async (params) => {\n        return codeActionsProvider.codeActions(params);\n    });\n    connection.onExecuteCommand(async (params) => {\n        await executeCommandProvider.execute(params);\n    });\n    connection.onCompletion(async (params) => {\n        var _a;\n        if (hasUnsupportedDocument(params))\n            return [];\n        return ((_a = (await jsonLanguageService.completions(params))) !== null && _a !== void 0 ? _a : (await completionsProvider.completions(params)));\n    });\n    connection.onHover(async (params) => {\n        var _a;\n        if (hasUnsupportedDocument(params))\n            return null;\n        return (_a = (await jsonLanguageService.hover(params))) !== null && _a !== void 0 ? _a : (await hoverProvider.hover(params));\n    });\n    connection.onDocumentOnTypeFormatting(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return null;\n        return onTypeFormattingProvider.onTypeFormatting(params);\n    });\n    connection.onDocumentHighlight(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return [];\n        return documentHighlightProvider.documentHighlights(params);\n    });\n    connection.onPrepareRename(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return null;\n        return renameProvider.prepare(params);\n    });\n    connection.onRenameRequest(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return null;\n        return renameProvider.rename(params);\n    });\n    connection.languages.onLinkedEditingRange(async (params) => {\n        if (hasUnsupportedDocument(params))\n            return null;\n        return linkedEditingRangesProvider.linkedEditingRanges(params);\n    });\n    connection.workspace.onDidRenameFiles(async (params) => {\n        const triggerUris = params.files.map((fileRename) => fileRename.newUri);\n        // Behold the cache invalidation monster\n        for (const { oldUri, newUri } of params.files) {\n            // When a file is renamed, we paste the content of the old file into the\n            // new file in the document manager. We don't need to invalidate preload\n            // because that's the only thing that changed.\n            documentManager.rename(oldUri, newUri);\n            // When a file is renamed, readDirectory to the parent folder is invalidated.\n            fs.readDirectory.invalidate(theme_check_common_1.path.dirname(oldUri));\n            fs.readDirectory.invalidate(theme_check_common_1.path.dirname(newUri));\n            // When a file is renamed, readFile and stat for both the old and new URIs are invalidated.\n            fs.readFile.invalidate(oldUri);\n            fs.readFile.invalidate(newUri);\n            fs.stat.invalidate(oldUri);\n            fs.stat.invalidate(newUri);\n        }\n        // We should complete refactors before running theme check\n        await renameHandler.onDidRenameFiles(params);\n        // MissingAssets/MissingSnippet should be rerun when a file is deleted\n        // since the file rename might cause an error.\n        runChecks.force(triggerUris);\n    });\n    /**\n     * onDidChangeWatchedFiles is triggered by file operations (in or out of the editor).\n     *\n     * For in-editor changes, happens redundantly with\n     *   - onDidCreateFiles\n     *   - onDidRenameFiles\n     *   - onDidDeleteFiles\n     *   - onDidSaveTextDocument\n     *\n     * Not redundant for operations that happen outside of the editor\n     *   - git pull, checkout, reset, stash pop, etc.\n     *   - shopify theme metafields pull\n     *   - etc.\n     *\n     * It always runs and onDid* will never fire without a corresponding onDidChangeWatchedFiles.\n     *\n     * This is why the bulk of the cache invalidation logic is in this handler.\n     */\n    connection.onDidChangeWatchedFiles(async (params) => {\n        var _a;\n        if (params.changes.length === 0)\n            return;\n        const triggerUris = params.changes.map((change) => change.uri);\n        const updates = [];\n        for (const change of params.changes) {\n            // Rename cache invalidation is handled by onDidRenameFiles\n            if (documentManager.hasRecentRename(change.uri)) {\n                documentManager.clearRecentRename(change.uri);\n                continue;\n            }\n            switch (change.type) {\n                case vscode_languageserver_1.FileChangeType.Created:\n                    // A created file invalidates readDirectory, readFile and stat\n                    fs.readDirectory.invalidate(theme_check_common_1.path.dirname(change.uri));\n                    fs.readFile.invalidate(change.uri);\n                    fs.stat.invalidate(change.uri);\n                    // If a file is created under out feet, we update its contents.\n                    updates.push(documentManager.changeFromDisk(change.uri));\n                    break;\n                case vscode_languageserver_1.FileChangeType.Changed:\n                    // A changed file invalidates readFile and stat (but not readDirectory)\n                    fs.readFile.invalidate(change.uri);\n                    fs.stat.invalidate(change.uri);\n                    // If the file is not open, we update its contents in the doc manager\n                    // If it is open, then we don't need to update it because the document manager\n                    // will have the version from the editor.\n                    if (((_a = documentManager.get(change.uri)) === null || _a === void 0 ? void 0 : _a.version) === undefined) {\n                        updates.push(documentManager.changeFromDisk(change.uri));\n                    }\n                    break;\n                case vscode_languageserver_1.FileChangeType.Deleted:\n                    // A deleted file invalides readDirectory, readFile, and stat\n                    fs.readDirectory.invalidate(theme_check_common_1.path.dirname(change.uri));\n                    fs.readFile.invalidate(change.uri);\n                    fs.stat.invalidate(change.uri);\n                    // If a file is deleted, it's removed from the document manager\n                    documentManager.delete(change.uri);\n                    break;\n            }\n            if (change.uri.endsWith('metafields.json')) {\n                updates.push(findThemeRootURI(change.uri).then((rootUri) => getMetafieldDefinitionsForRootUri.invalidate(rootUri)));\n            }\n        }\n        await Promise.all(updates);\n        // MissingAssets/MissingSnippet should be rerun when a file is deleted\n        // since an error might be introduced (and vice versa).\n        runChecks.force(triggerUris);\n    });\n    connection.listen();\n}\nexports.startServer = startServer;\n//# sourceMappingURL=startServer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isInputSetting = exports.isSettingsCategory = void 0;\nfunction isSettingsCategory(x) {\n    return 'settings' in x;\n}\nexports.isSettingsCategory = isSettingsCategory;\nfunction isInputSetting(x) {\n    return 'id' in x && 'type' in x && 'label' in x;\n}\nexports.isInputSetting = isInputSetting;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.paramsString = exports.extractParams = exports.translationOptions = exports.toOptions = exports.isPluralizedTranslation = exports.translationValue = exports.renderTranslation = exports.renderKey = exports.PluralizedTranslationKeys = void 0;\nexports.PluralizedTranslationKeys = ['one', 'few', 'many', 'two', 'zero', 'other'];\nfunction renderKey(translation, key) {\n    if (translation[key]) {\n        return `\\`${key}:\\` ${translation[key]}`;\n    }\n}\nexports.renderKey = renderKey;\nfunction renderTranslation(translation) {\n    if (typeof translation === 'string')\n        return translation;\n    return [\n        renderKey(translation, 'zero'),\n        renderKey(translation, 'one'),\n        renderKey(translation, 'two'),\n        renderKey(translation, 'few'),\n        renderKey(translation, 'many'),\n        renderKey(translation, 'other'),\n    ]\n        .filter(Boolean)\n        .join('\\n\\n---\\n\\n');\n}\nexports.renderTranslation = renderTranslation;\nfunction translationValue(path, translations) {\n    const parts = path.split('.');\n    let current = translations;\n    for (const key of parts) {\n        if (!current || typeof current === 'string') {\n            return undefined;\n        }\n        current = current[key];\n    }\n    return current;\n}\nexports.translationValue = translationValue;\nfunction isPluralizedTranslation(translations) {\n    return Object.keys(translations).every((key) => exports.PluralizedTranslationKeys.includes(key));\n}\nexports.isPluralizedTranslation = isPluralizedTranslation;\nfunction toOptions(prefix, translations) {\n    return Object.entries(translations).flatMap(([path, translation]) => {\n        if (typeof translation === 'string' || isPluralizedTranslation(translation)) {\n            return [{ path: prefix.concat(path), translation }];\n        }\n        else {\n            return toOptions(prefix.concat(path), translation);\n        }\n    });\n}\nexports.toOptions = toOptions;\nfunction translationOptions(translations) {\n    return toOptions([], translations);\n}\nexports.translationOptions = translationOptions;\nfunction extractParams(value) {\n    const regex = /\\{\\{([^}]+?)\\}\\}/g;\n    const results = [];\n    let current;\n    while ((current = regex.exec(value)) !== null) {\n        results.push(current[1].trim());\n    }\n    return results;\n}\nexports.extractParams = extractParams;\nfunction paramsString(params) {\n    if (params.length === 0)\n        return '';\n    return `: ` + params.map((param) => `${param}: ${param}`).join(', ');\n}\nexports.paramsString = paramsString;\n//# sourceMappingURL=translations.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findLast = void 0;\n// Array.prototype.findLast is only available in es2023. Which feels too new?\nfunction findLast(array, pred) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        if (pred(array[i]))\n            return array[i];\n    }\n}\nexports.findLast = findLast;\n//# sourceMappingURL=array.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.debounce = void 0;\n/**\n * debounce(fn, ms)\n *\n * A debounced function only executes once after a timer has expired. Repeated\n * call to the debounced function before its timer has expired result in a delayed\n * execution of the function.\n *\n * This is useful in cases where you have an \"expensive\" function that you only want\n * to execute after the user is idle for a little bit.\n *\n * e.g. Run theme check after the user has stopped typing for at least 100ms.\n *\n * The debounced function has the same type signature as its argument.\n *\n * The input function must return void (or else you might \"bomb\" when you resolve).\n *\n * @param fn a function that should be debounced\n * @param ms milliseconds after last function call for it to execute\n * @returns a function that will execute on the trailing edge of a timer with the last argument it was called with\n */\nfunction debounce(fn, ms) {\n    let timeoutId = null;\n    let force = false; // force use a certain set of arguments in the next call\n    const debouncedFn = (...args) => {\n        if (timeoutId !== null && force)\n            return;\n        if (timeoutId !== null)\n            clearTimeout(timeoutId);\n        timeoutId = setTimeout(async () => {\n            await Promise.resolve(fn(...args));\n            timeoutId = null;\n            force = false;\n        }, ms);\n    };\n    debouncedFn.force = (...args) => {\n        debouncedFn(...args);\n        force = true;\n    };\n    return debouncedFn;\n}\nexports.debounce = debounce;\n//# sourceMappingURL=debounce.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isDanglingOpenHtmlElement = exports.getHtmlElementNameRanges = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst isCovered_1 = require(\"./isCovered\");\nfunction getHtmlElementNameRanges(node, ancestors, params, textDocument) {\n    let htmlElementNode = null;\n    // Try parent node as HTML Element\n    // <name> case\n    const parentNode = ancestors.at(-1);\n    if (parentNode &&\n        parentNode.type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n        parentNode.name.length > 0 &&\n        (0, isCovered_1.isCovered)(textDocument.offsetAt(params.position), {\n            start: parentNode.name[0].position.start,\n            end: parentNode.name.at(-1).position.end,\n        })) {\n        htmlElementNode = parentNode;\n    }\n    // </name> case\n    if (node.type === liquid_html_parser_1.NodeTypes.HtmlElement &&\n        node.name.length > 0 &&\n        (0, isCovered_1.isCovered)(textDocument.offsetAt(params.position), node.blockEndPosition)) {\n        htmlElementNode = node;\n    }\n    if (!htmlElementNode || isDanglingOpenHtmlElement(htmlElementNode))\n        return null;\n    const nameNodes = htmlElementNode.name;\n    const firstNode = nameNodes.at(0);\n    const lastNode = nameNodes.at(-1);\n    const startRange = vscode_languageserver_1.Range.create(textDocument.positionAt(firstNode.position.start), textDocument.positionAt(lastNode.position.end));\n    const endRange = vscode_languageserver_1.Range.create(\n    // </ means offset 2 characters\n    textDocument.positionAt(htmlElementNode.blockEndPosition.start + 2), textDocument.positionAt(htmlElementNode.blockEndPosition.end - 1));\n    return [startRange, endRange];\n}\nexports.getHtmlElementNameRanges = getHtmlElementNameRanges;\nfunction isDanglingOpenHtmlElement(node) {\n    return (node.type === liquid_html_parser_1.NodeTypes.HtmlElement && node.blockEndPosition.start === node.blockEndPosition.end);\n}\nexports.isDanglingOpenHtmlElement = isDanglingOpenHtmlElement;\n//# sourceMappingURL=htmlTagNames.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJSON = exports.memoize = exports.memo = void 0;\nvar theme_check_common_1 = require(\"@shopify/theme-check-common\");\nObject.defineProperty(exports, \"memo\", { enumerable: true, get: function () { return theme_check_common_1.memo; } });\nObject.defineProperty(exports, \"memoize\", { enumerable: true, get: function () { return theme_check_common_1.memoize; } });\nObject.defineProperty(exports, \"parseJSON\", { enumerable: true, get: function () { return theme_check_common_1.parseJSON; } });\n__exportStar(require(\"./debounce\"), exports);\n__exportStar(require(\"./array\"), exports);\n__exportStar(require(\"./node\"), exports);\n__exportStar(require(\"./isCovered\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCovered = void 0;\nfunction isCovered(offset, range) {\n    return range.start <= offset && offset <= range.end;\n}\nexports.isCovered = isCovered;\n//# sourceMappingURL=isCovered.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SUPPORTED_LIQUID_DOC_TAG_HANDLES = exports.formatLiquidDocTagHandle = exports.formatLiquidDocParameter = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nfunction formatLiquidDocParameter({ name, type, description, required }, heading = false) {\n    const nameStr = required ? `\\`${name}\\`` : `\\`${name}\\` (Optional)`;\n    const typeStr = type ? `: ${type}` : '';\n    if (heading) {\n        const descStr = description ? `\\n\\n${description}` : '';\n        return `### ${nameStr}${typeStr}${descStr}`;\n    }\n    const descStr = description ? ` - ${description}` : '';\n    return `- ${nameStr}${typeStr}${descStr}`;\n}\nexports.formatLiquidDocParameter = formatLiquidDocParameter;\nfunction formatLiquidDocTagHandle(label, description, example) {\n    return `### @${label}\\n\\n${description}\\n\\n` + `**Example**\\n\\n\\`\\`\\`liquid\\n${example}\\n\\`\\`\\``;\n}\nexports.formatLiquidDocTagHandle = formatLiquidDocTagHandle;\nexports.SUPPORTED_LIQUID_DOC_TAG_HANDLES = {\n    [theme_check_common_1.SupportedDocTagTypes.Param]: {\n        description: 'Provides information about a parameter for the snippet.\\n' +\n            `- The type of parameter is optional and can be ${Object.values(theme_check_common_1.SupportedParamTypes)\n                .map((type) => `\\`${type}\\``)\n                .join(', ')}\\n` +\n            '- An optional parameter is denoted by square brackets around the parameter name\\n' +\n            '- The description is optional Markdown text',\n        example: '{% doc %}\\n' +\n            \"  @param {string} name - The person's name\\n\" +\n            \"  @param {number} [fav_num] - The person's favorite number\\n\" +\n            '{% enddoc %}\\n',\n        template: `param {$1} $2 - $0`,\n    },\n    [theme_check_common_1.SupportedDocTagTypes.Example]: {\n        description: 'Provides an example on how to use the snippet.',\n        example: '{% doc %}\\n' + '  @example {% render \"snippet-name\", arg1: \"value\" %}\\n' + '{% enddoc %}\\n',\n        template: `example\\n$0`,\n    },\n    [theme_check_common_1.SupportedDocTagTypes.Description]: {\n        description: 'Provides information on what the snippet does.',\n        example: '{% doc %}\\n' + '  @description This snippet renders a product image.\\n' + '{% enddoc %}\\n',\n        template: `description $0`,\n    },\n};\n//# sourceMappingURL=liquidDoc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isLiquidVariableOutput = exports.isNamedLiquidTag = exports.isHtmlAttribute = exports.getCompoundName = exports.isNamedHtmlElementNode = exports.isAttrEmpty = exports.isTextNode = exports.HtmlAttributeTypes = exports.HtmlElementTypes = void 0;\nconst liquid_html_parser_1 = require(\"@shopify/liquid-html-parser\");\nexports.HtmlElementTypes = [\n    liquid_html_parser_1.NodeTypes.HtmlElement,\n    liquid_html_parser_1.NodeTypes.HtmlDanglingMarkerClose,\n    liquid_html_parser_1.NodeTypes.HtmlSelfClosingElement,\n    liquid_html_parser_1.NodeTypes.HtmlVoidElement,\n    liquid_html_parser_1.NodeTypes.HtmlRawNode,\n];\nexports.HtmlAttributeTypes = [\n    liquid_html_parser_1.NodeTypes.AttrUnquoted,\n    liquid_html_parser_1.NodeTypes.AttrDoubleQuoted,\n    liquid_html_parser_1.NodeTypes.AttrSingleQuoted,\n    liquid_html_parser_1.NodeTypes.AttrEmpty,\n];\nfunction isTextNode(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.TextNode;\n}\nexports.isTextNode = isTextNode;\nfunction isAttrEmpty(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.AttrEmpty;\n}\nexports.isAttrEmpty = isAttrEmpty;\nfunction isNamedHtmlElementNode(node) {\n    return exports.HtmlElementTypes.includes(node.type);\n}\nexports.isNamedHtmlElementNode = isNamedHtmlElementNode;\nfunction getCompoundName(node) {\n    if (typeof node.name === 'string')\n        return node.name;\n    const names = node.name;\n    if (names.length === 0 || names.length > 1 || !isTextNode(names[0])) {\n        return 'unknown';\n    }\n    return names[0].value;\n}\nexports.getCompoundName = getCompoundName;\nfunction isHtmlAttribute(node) {\n    return exports.HtmlAttributeTypes.some((type) => node.type === type);\n}\nexports.isHtmlAttribute = isHtmlAttribute;\nfunction isNamedLiquidTag(node, name) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidTag && node.name === name && typeof node.markup !== 'string';\n}\nexports.isNamedLiquidTag = isNamedLiquidTag;\nfunction isLiquidVariableOutput(node) {\n    return node.type === liquid_html_parser_1.NodeTypes.LiquidVariableOutput && typeof node.markup !== 'string';\n}\nexports.isLiquidVariableOutput = isLiquidVariableOutput;\n//# sourceMappingURL=node.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTemplate = exports.templateName = exports.isSectionGroup = exports.sectionGroupName = exports.isSection = exports.sectionName = exports.isBlock = exports.blockName = exports.isAsset = exports.assetName = exports.isSnippet = exports.snippetName = void 0;\nconst theme_check_common_1 = require(\"@shopify/theme-check-common\");\nconst snippetName = (uri) => theme_check_common_1.path.basename(uri, '.liquid');\nexports.snippetName = snippetName;\nconst isSnippet = (uri) => /\\bsnippets(\\\\|\\/)[^\\\\\\/]*\\.liquid/.test(uri);\nexports.isSnippet = isSnippet;\n// asset urls have their `.liquid`` removed (if present) and require the other extension */\nconst assetName = (uri) => theme_check_common_1.path.basename(uri, '.liquid');\nexports.assetName = assetName;\nconst isAsset = (uri) => /\\bassets(\\\\|\\/)[^\\\\\\/]/.test(uri);\nexports.isAsset = isAsset;\nconst blockName = (uri) => theme_check_common_1.path.basename(uri, '.liquid');\nexports.blockName = blockName;\nconst isBlock = (uri) => /\\bblocks(\\\\|\\/)[^\\\\\\/]/.test(uri);\nexports.isBlock = isBlock;\nconst sectionName = (uri) => theme_check_common_1.path.basename(uri, '.liquid');\nexports.sectionName = sectionName;\nconst isSection = (uri) => /\\bsections(\\\\|\\/)[^\\\\\\/]/.test(uri) && /.liquid$/.test(uri);\nexports.isSection = isSection;\nconst sectionGroupName = (uri) => theme_check_common_1.path.basename(uri, '.json');\nexports.sectionGroupName = sectionGroupName;\nconst isSectionGroup = (uri) => /\\bsections(\\\\|\\/)[^\\\\\\/]/.test(uri) && /.json$/.test(uri);\nexports.isSectionGroup = isSectionGroup;\nconst templateName = (uri) => theme_check_common_1.path.basename(uri, '.json');\nexports.templateName = templateName;\nconst isTemplate = (uri) => /\\btemplates(\\\\|\\/)[^\\\\\\/]/.test(uri);\nexports.isTemplate = isTemplate;\n//# sourceMappingURL=uri.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VERSION = void 0;\nconst package_json_1 = __importDefault(require(\"../package.json\"));\nexports.VERSION = package_json_1.default.version;\n//# sourceMappingURL=version.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\nexports.assertValidPattern = assertValidPattern;\n//# sourceMappingURL=assert-valid-pattern.js.map","\"use strict\";\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n//# sourceMappingURL=ast.js.map","\"use strict\";\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n//# sourceMappingURL=brace-expressions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n//# sourceMappingURL=escape.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched)\n                    continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        return fastTest ? Object.assign(re, { test: fastTest }) : re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", { enumerable: true, get: function () { return ast_js_2.AST; } });\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return escape_js_2.escape; } });\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", { enumerable: true, get: function () { return unescape_js_2.unescape; } });\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n//# sourceMappingURL=unescape.js.map","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (let change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            let startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        let ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        let ch = text.charCodeAt(i);\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { findRoot, makeFileExists } from '@shopify/theme-check-common';\nimport {\n  Dependencies,\n  getConnection,\n  recommendedChecks,\n  startServer,\n} from '@shopify/theme-language-server-browser';\nimport { VsCodeFileSystem } from '../common/VsCodeFileSystem';\n\n/**\n * These are replaced at build time by the contents of\n * @shopify/theme-check-docs-updater's DocsManager\n */\ndeclare global {\n  export const WEBPACK_TAGS: any[];\n  export const WEBPACK_FILTERS: any[];\n  export const WEBPACK_OBJECTS: any[];\n  export const WEBPACK_SYSTEM_TRANSLATIONS: any;\n  export const WEBPACK_SCHEMAS: any;\n}\n\nconst tags = WEBPACK_TAGS;\nconst filters = WEBPACK_FILTERS;\nconst objects = WEBPACK_OBJECTS;\nconst systemTranslations = WEBPACK_SYSTEM_TRANSLATIONS;\nconst schemas = WEBPACK_SCHEMAS;\n\nconst worker = self as any as Worker;\nconst connection = getConnection(worker);\nconst fileSystem = new VsCodeFileSystem(connection, {});\nconst dependencies: Dependencies = {\n  fs: fileSystem,\n  log: console.info.bind(console),\n  loadConfig: async (uri, fs) => {\n    const fileExists = makeFileExists(fs);\n    const rootUri = await findRoot(uri, fileExists);\n    return {\n      context: 'theme',\n      settings: {},\n      checks: recommendedChecks,\n      rootUri,\n    };\n  },\n  themeDocset: {\n    filters: async () => filters,\n    objects: async () => objects,\n    tags: async () => tags,\n    systemTranslations: async () => systemTranslations,\n  },\n  jsonValidationSet: {\n    schemas: async () => schemas,\n  },\n};\n\nstartServer(worker, dependencies, connection);\n"],"names":[],"sourceRoot":""}